from .context import Context
from redis import StrictRedis

from typing import (
    Any, Callable, Dict, Iterable, Iterator, List, Optional, Sequence, Text,
    Type, TypeVar, Tuple, Union)

TYPE_MODEL = TypeVar('TYPE_MODEL', bound = 'Model')

class Client:
    def context(
        self,
        namespace: Optional[str],
        global_cache: Optional[RedisCache]
    ) -> Context: ...

# Model Stubs
class Model(type):
    key: Key = ...
    _key: Key = ...
    _values: Dict[Text, Any] = ...
    _properties: Dict[Text, Any] = ...
    def __init__(*args: Any, **kwds: Any) -> None: ...
    def populate(self, **constructor_options: Any) -> None: ...
    def to_dict(
        self, exclude: Optional[List[Text]] = None) -> Dict[Text, Any]: ...
    @classmethod
    def query(cls, *args: Any, **kwds: Any) -> Query: ...
    def put(self, **ctx_options: Any) -> None: ...
    @classmethod
    def get_by_id(
        cls: Type[TYPE_MODEL], id: Text, **ctx_options: Any) -> TYPE_MODEL:...
    def _pre_put_hook(self) -> None: ...


def get_context(**kwds: Any) -> Context: ...
def get_multi(
    keys: List[Key], **ctx_options: Any) -> List[Optional[TYPE_MODEL]]: ...
def put_multi(
    entities: (List[TYPE_MODEL]), **ctx_options: Any) -> List[Text]: ...
def delete_multi(keys: List[Key], **ctx_options: Any) -> List[None]: ...


# Property Stubs
class Property(object):
    def __init__(
        self, name: Optional[Text] = ..., indexed: Optional[bool] = ...,
        repeated: Optional[bool] = ..., required: Optional[bool] = ...,
        default: Optional[Any] = ...,
        choices: Union[List[Any], Tuple[Any, ...], None] = ...,
        validator: Optional[Callable[..., Any]] = ...,
        verbose_name: Optional[Text] = ...
    ) -> None: ...
    def __eq__(self, value: Any) -> bool: ...
    def __ne__(self, value: Any) -> bool: ...
    def __lt__(self, value: Any) -> bool: ...
    def __le__(self, value: Any) -> bool: ...
    def __gt__(self, value: Any) -> bool: ...
    def __ge__(self, value: Any) -> bool: ...
    IN: Any = ...
    def __neg__(self) -> Any: ...
    def __pos__(self) -> Any: ...
    def __get__(self, entity: Any, unused_cls: Optional[Any] = ...) -> Any: ...
    def __set__(self, entity: Any, value: Any) -> None: ...
    def __delete__(self, entity: Any) -> None: ...

class BooleanProperty(Property): ...

class DateTimeProperty(Property):
    def __init__(
        self, name: Optional[Text] = ..., auto_now: bool = ...,
        auto_now_add: bool = ..., **kwds: Any
    ) -> None: ...

class DateProperty(DateTimeProperty): ...

class ComputedProperty(Property): ...

class IntegerProperty(Property): ...

class FloatProperty(Property): ...

class JsonProperty(Property):
    def __init__(
        self, name: Optional[Text] = ..., compressed: bool = ...,
        json_type: Optional[Any] = ..., **kwds: Any
    ) -> None: ...

class UserProperty(Property):
    def __init__(
        self, name: Optional[Text] = ..., auto_current_user: bool = ...,
        auto_current_user_add: bool = ..., **kwds: Any
    ) -> None: ...

class TextProperty(Property): ...

class StringProperty(TextProperty): ...

# Query Stubs
class Node: ...

class ConjunctionNode(Node): ...

class DisjunctionNode(Node): ...

AND = ConjunctionNode
OR = DisjunctionNode

class Query:
    def __init__(
        self, kind: Optional[Any] = ..., ancestor: Optional[Any] = ...,
        filters: Optional[Any] = ..., orders: Optional[Any] = ...,
        app: Optional[Any] = ..., namespace: Optional[Any] = ...,
        default_options: Optional[Any] = ..., projection: Optional[Any] = ...,
        group_by: Optional[Any] = ...
    ) -> None: ...
    @property
    def projection(self) -> Union[Tuple[Text], List[Text]]: ...
    def filter(self, *args: Any) -> Query: ...
    def order(self, *args: Any) -> Query: ...
    def __iter__(self) -> Iterator[Any]: ...
    def fetch(
        self, limit: Optional[int] = ..., **q_options: Any
    ) -> Sequence[Union[Model, Key]]: ...
    def get(self, **q_options: Any) -> Optional[Union[Model, Key]]: ...
    def count(self, limit: Optional[int] = ..., **q_options: Any) -> int: ...
    def fetch_page(
        self, page_size: int, **q_options: Any
    ) -> Tuple[Sequence[Union[Model, Key]], Cursor, bool]: ...

class Cursor:
    def __init__(
        self, urlsafe: Optional[str]
    ) -> None: ...
    def urlsafe(self) -> bytes: ...

# Key Stubs
class Key:
    def __new__(cls, *_args: Any, **kwargs: Any) -> Key: ...
    def namespace(self) -> Optional[Text]: ...
    def app(self) -> Optional[Text]: ...
    def id(self) -> Text: ...
    def flat(self) -> Optional[Iterable[Union[Text, int]]]: ...
    def kind(self) -> Optional[Text]: ...
    def get(self, **ctx_options: Any) -> Optional[Model]: ...
    def delete(self, **ctx_options: Any) -> None: ...

class RedisCache:
    def __init__(self, redis_instance: StrictRedis[str]): ...

# Transaction Options Stubs
class TransactionOptions(object):
    NESTED = 1  # join=False
    MANDATORY = 2  # join=True
    ALLOWED = 3  # join=True
    INDEPENDENT = 4  # join=False
