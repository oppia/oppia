/*!
 * angular-translate - v2.11.0 - 2016-03-20
 * 
 * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT
 */
!function(a,b){"function"==typeof define&&define.amd?
// AMD. Register as an anonymous module unless amdModuleId is set
define(["messageformat"],function(a){return b(a)}):"object"==typeof exports?
// Node. Does not work with strict CommonJS, but
// only CommonJS-like environments that support module.exports,
// like Node.
module.exports=b(require("messageformat")):b(MessageFormat)}(this,function(a){function b(b,c,d){"use strict";var e={},f=c.get(d),
// instantiate with default locale (which is 'en')
g=new a("en"),h="messageformat";
// create cache if it doesn't exist already
/**
   * @ngdoc function
   * @name pascalprecht.translate.$translateMessageFormatInterpolation#setLocale
   * @methodOf pascalprecht.translate.$translateMessageFormatInterpolation
   *
   * @description
   * Sets current locale (this is currently not use in this interpolation).
   *
   * @param {string} locale Language key or locale.
   */
/**
   * @ngdoc function
   * @name pascalprecht.translate.$translateMessageFormatInterpolation#getInterpolationIdentifier
   * @methodOf pascalprecht.translate.$translateMessageFormatInterpolation
   *
   * @description
   * Returns an identifier for this interpolation service.
   *
   * @returns {string} $identifier
   */
/**
   * @deprecated will be removed in 3.0
   * @see {@link pascalprecht.translate.$translateSanitization}
   */
/**
   * @ngdoc function
   * @name pascalprecht.translate.$translateMessageFormatInterpolation#interpolate
   * @methodOf pascalprecht.translate.$translateMessageFormatInterpolation
   *
   * @description
   * Interpolates given string against given interpolate params using MessageFormat.js.
   *
   * @returns {string} interpolated string.
   */
return f||(f=c(d)),f.put("en",g),e.setLocale=function(b){g=f.get(b),g||(g=new a(b),f.put(b,g))},e.getInterpolationIdentifier=function(){return h},e.useSanitizeValueStrategy=function(a){return b.useStrategy(a),this},e.interpolate=function(a,c){c=c||{},c=b.sanitize(c,"params");var d=f.get("mf:"+a);
// if given string wasn't compiled yet, we do so now and never have to do it again
if(!d){
// Ensure explicit type if possible
// MessageFormat checks the actual type (i.e. for amount based conditions)
for(var e in c)if(c.hasOwnProperty(e)){
// ensure number
var h=parseInt(c[e],10);angular.isNumber(h)&&""+h===c[e]&&(c[e]=h)}d=g.compile(a),f.put("mf:"+a,d)}var i=d(c);return b.sanitize(i,"text")},e}return b.$inject=["$translateSanitization","$cacheFactory","TRANSLATE_MF_INTERPOLATION_CACHE"],angular.module("pascalprecht.translate").constant("TRANSLATE_MF_INTERPOLATION_CACHE","$translateMessageFormatInterpolation").factory("$translateMessageFormatInterpolation",b),b.displayName="$translateMessageFormatInterpolation","pascalprecht.translate"});