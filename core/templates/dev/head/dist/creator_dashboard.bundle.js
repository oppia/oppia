/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"creator_dashboard": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.scripts.ts","vendors~about~admin~collection_editor~collection_player~community_dashboard~contact~creator_dashboar~7856c05a","vendors~admin~collection_editor~collection_player~creator_dashboard~exploration_editor~exploration_p~7f8bcc67","vendors~admin~collection_editor~creator_dashboard~exploration_editor~exploration_player~practice_ses~988cfeb1","vendors~creator_dashboard~exploration_editor~exploration_player~practice_session~review_test~skill_e~61b3d15e","about~admin~collection_editor~collection_player~community_dashboard~contact~creator_dashboard~donate~e06a4a17","admin~creator_dashboard~exploration_editor~exploration_player~moderator~practice_session~review_test~b9580ed0","admin~creator_dashboard~exploration_editor~exploration_player~moderator~practice_session~review_test~d3595155","collection_player~creator_dashboard~learner_dashboard~library~profile~story_viewer"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./core/templates/dev/head/base_components/BaseContentDirective.ts":
/*!*************************************************************************!*\
  !*** ./core/templates/dev/head/base_components/BaseContentDirective.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Base Transclusion Component.
 */
__webpack_require__(/*! base_components/WarningLoaderDirective.ts */ "./core/templates/dev/head/base_components/WarningLoaderDirective.ts");
__webpack_require__(/*! pages/OppiaFooterDirective.ts */ "./core/templates/dev/head/pages/OppiaFooterDirective.ts");
__webpack_require__(/*! domain/sidebar/SidebarStatusService.ts */ "./core/templates/dev/head/domain/sidebar/SidebarStatusService.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
__webpack_require__(/*! services/stateful/BackgroundMaskService.ts */ "./core/templates/dev/head/services/stateful/BackgroundMaskService.ts");
angular.module('oppia').directive('baseContent', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            transclude: {
                breadcrumb: '?navbarBreadcrumb',
                content: 'content',
                footer: '?pageFooter',
                navOptions: '?navOptions',
            },
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/base_components/base_content_directive.html'),
            controllerAs: '$ctrl',
            controller: ['$rootScope', 'BackgroundMaskService',
                'SidebarStatusService', 'UrlService', 'SITE_FEEDBACK_FORM_URL',
                function ($rootScope, BackgroundMaskService, SidebarStatusService, UrlService, SITE_FEEDBACK_FORM_URL) {
                    var ctrl = this;
                    ctrl.iframed = UrlService.isIframed();
                    ctrl.siteFeedbackFormUrl = SITE_FEEDBACK_FORM_URL;
                    ctrl.isSidebarShown = SidebarStatusService.isSidebarShown;
                    ctrl.closeSidebarOnSwipe = SidebarStatusService.closeSidebar;
                    ctrl.isBackgroundMaskActive = BackgroundMaskService.isMaskActive;
                    ctrl.DEV_MODE = $rootScope.DEV_MODE;
                    ctrl.skipToMainContent = function () {
                        var mainContentElement = document.getElementById('oppia-main-content');
                        if (!mainContentElement) {
                            throw Error('Variable mainContentElement is undefined.');
                        }
                        mainContentElement.tabIndex = -1;
                        mainContentElement.scrollIntoView();
                        mainContentElement.focus();
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/base_components/WarningLoaderDirective.ts":
/*!***************************************************************************!*\
  !*** ./core/templates/dev/head/base_components/WarningLoaderDirective.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for warning_loader.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/AlertsService.ts */ "./core/templates/dev/head/services/AlertsService.ts");
angular.module('oppia').directive('warningLoader', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/base_components/warning_loader_directive.html'),
            controllerAs: '$ctrl',
            controller: ['AlertsService',
                function (AlertsService) {
                    var ctrl = this;
                    ctrl.AlertsService = AlertsService;
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/button-directives/exploration-embed-button.service.ts":
/*!**************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/button-directives/exploration-embed-button.service.ts ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Service for the 'embed exploration' modal.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/SiteAnalyticsService.ts */ "./core/templates/dev/head/services/SiteAnalyticsService.ts");
angular.module('oppia').factory('ExplorationEmbedButtonService', [
    '$uibModal', 'SiteAnalyticsService', 'UrlInterpolationService',
    function ($uibModal, SiteAnalyticsService, UrlInterpolationService) {
        return {
            showModal: function (explorationId) {
                $uibModal.open({
                    backdrop: true,
                    templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/components/button-directives/' +
                        'exploration-embed-button.directive.html'),
                    resolve: {
                        explorationId: function () {
                            return explorationId;
                        }
                    },
                    controller: [
                        '$scope', '$uibModalInstance', '$window', 'explorationId',
                        function ($scope, $uibModalInstance, $window, explorationId) {
                            $scope.explorationId = explorationId;
                            $scope.serverName = ($window.location.protocol + '//' + $window.location.host);
                            $scope.close = function () {
                                $uibModalInstance.dismiss('close');
                            };
                            $scope.selectText = function (evt) {
                                var codeDiv = evt.currentTarget;
                                var range = document.createRange();
                                range.setStartBefore(codeDiv.firstChild);
                                range.setEndAfter(codeDiv.lastChild);
                                var selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                            };
                        }
                    ]
                });
                SiteAnalyticsService.registerOpenEmbedInfoEvent(explorationId);
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/common-layout-directives/common-elements/background-banner.directive.ts":
/*!********************************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/common-layout-directives/common-elements/background-banner.directive.ts ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the background banner.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
angular.module('oppia').directive('backgroundBanner', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/components/common-layout-directives/common-elements/' +
                'background-banner.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                function () {
                    var ctrl = this;
                    var possibleBannerFilenames = [
                        'bannerA.svg', 'bannerB.svg', 'bannerC.svg', 'bannerD.svg'
                    ];
                    var bannerImageFilename = possibleBannerFilenames[Math.floor(Math.random() * possibleBannerFilenames.length)];
                    ctrl.bannerImageFileUrl = UrlInterpolationService.getStaticImageUrl('/background/' + bannerImageFilename);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/common-layout-directives/common-elements/sharing-links.directive.ts":
/*!****************************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/common-layout-directives/common-elements/sharing-links.directive.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Social Sharing Links.
 */
__webpack_require__(/*! components/button-directives/exploration-embed-button.service.ts */ "./core/templates/dev/head/components/button-directives/exploration-embed-button.service.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/SiteAnalyticsService.ts */ "./core/templates/dev/head/services/SiteAnalyticsService.ts");
angular.module('oppia').directive('sharingLinks', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                layoutType: '@',
                layoutAlignType: '@',
                shareType: '@',
                getExplorationId: '&explorationId',
                getCollectionId: '&collectionId'
            },
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/components/common-layout-directives/common-elements/' +
                'sharing-links.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$window', 'HtmlEscaperService',
                'ExplorationEmbedButtonService', 'SiteAnalyticsService',
                'DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR',
                function ($window, HtmlEscaperService, ExplorationEmbedButtonService, SiteAnalyticsService, DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR) {
                    var ctrl = this;
                    ctrl.registerShareEvent = null;
                    if (ctrl.shareType === 'exploration') {
                        ctrl.explorationId = ctrl.getExplorationId();
                        ctrl.activityType = 'explore';
                        ctrl.activityId = ctrl.explorationId;
                        ctrl.registerShareEvent = (SiteAnalyticsService.registerShareExplorationEvent);
                        ctrl.showEmbedExplorationModal = (ExplorationEmbedButtonService.showModal);
                    }
                    else if (ctrl.shareType === 'collection') {
                        ctrl.collectionId = ctrl.getCollectionId();
                        ctrl.activityType = 'collection';
                        ctrl.activityId = ctrl.collectionId;
                        ctrl.registerShareEvent = (SiteAnalyticsService.registerShareCollectionEvent);
                    }
                    else {
                        throw Error('SharingLinks directive can only be used either in the' +
                            'collection player or the exploration player');
                    }
                    ctrl.serverName = ($window.location.protocol + '//' + $window.location.host);
                    ctrl.escapedTwitterText = (HtmlEscaperService.unescapedStrToEscapedStr(DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR));
                    ctrl.classroomUrl = UrlInterpolationService.getStaticImageUrl('/general/classroom.png');
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/forms/custom-forms-directives/image-uploader.directive.ts":
/*!******************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/forms/custom-forms-directives/image-uploader.directive.ts ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for uploading images.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/IdGenerationService.ts */ "./core/templates/dev/head/services/IdGenerationService.ts");
angular.module('oppia').directive('imageUploader', [
    'IdGenerationService', 'UrlInterpolationService',
    function (IdGenerationService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {
                height: '@',
                onFileChanged: '=',
                errorMessage: '@',
                width: '@'
            },
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/components/forms/custom-forms-directives/' +
                'image-uploader.directive.html'),
            link: function (scope, elt) {
                var onDragEnd = function (e) {
                    e.preventDefault();
                    $('.image-uploader-drop-area').removeClass('image-uploader-is-active');
                };
                var validateUploadedFile = function (file, filename) {
                    if (!file || !file.size || !file.type.match('image.*')) {
                        return 'This file is not recognized as an image.';
                    }
                    if (!file.type.match('image.jpeg') &&
                        !file.type.match('image.gif') &&
                        !file.type.match('image.jpg') &&
                        !file.type.match('image.png')) {
                        return 'This image format is not supported.';
                    }
                    if ((file.type.match(/jp(e?)g$/) && !file.name.match(/\.jp(e?)g$/)) ||
                        (file.type.match(/gif$/) && !file.name.match(/\.gif$/)) ||
                        (file.type.match(/png$/) && !file.name.match(/\.png$/))) {
                        return 'This image format does not match the filename extension.';
                    }
                    var ONE_MB_IN_BYTES = 1048576;
                    if (file.size > ONE_MB_IN_BYTES) {
                        var currentSize = (file.size / ONE_MB_IN_BYTES).toFixed(1) + ' MB';
                        return 'The maximum allowed file size is 1 MB' +
                            ' (' + currentSize + ' given).';
                    }
                    return null;
                };
                $(elt).bind('drop', function (e) {
                    onDragEnd(e);
                    var file = e.originalEvent.dataTransfer.files[0];
                    scope.errorMessage = validateUploadedFile(file, file.name);
                    if (!scope.errorMessage) {
                        // Only fire this event if validations pass.
                        scope.onFileChanged(file, file.name);
                    }
                    scope.$apply();
                });
                $(elt).bind('dragover', function (e) {
                    e.preventDefault();
                    $('.image-uploader-drop-area').addClass('image-uploader-is-active');
                });
                $(elt).bind('dragleave', onDragEnd);
                // If the user accidentally drops an image outside of the image-uploader
                // we want to prevent the browser from applying normal drag-and-drop
                // logic, which is to load the image in the browser tab.
                $(window).bind('dragover', function (e) {
                    e.preventDefault();
                });
                $(window).bind('drop', function (e) {
                    e.preventDefault();
                });
                // We generate a random class name to distinguish this input from
                // others in the DOM.
                scope.fileInputClassName = ('image-uploader-file-input' + IdGenerationService.generateNewId());
                angular.element(document).on('change', '.' + scope.fileInputClassName, function (evt) {
                    var file = evt.currentTarget.files[0];
                    var filename = evt.target.value.split(/(\\|\/)/g).pop();
                    scope.errorMessage = validateUploadedFile(file, filename);
                    if (!scope.errorMessage) {
                        // Only fire this event if validations pass.
                        scope.onFileChanged(file, filename);
                    }
                    scope.$apply();
                });
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-editor.service.ts":
/*!******************************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-editor.service.ts ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview A service that maintains a record of the objects exclusive to
 * a state.
 */
var cloneDeep_1 = __importDefault(__webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"));
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var solution_validity_service_1 = __webpack_require__(/*! pages/exploration-editor-page/editor-tab/services/solution-validity.service */ "./core/templates/dev/head/pages/exploration-editor-page/editor-tab/services/solution-validity.service.ts");
/* eslint-enable max-len */
var StateEditorService = /** @class */ (function () {
    function StateEditorService(solutionValidityService) {
        this.solutionValidityService = solutionValidityService;
        this.activeStateName = null;
        this.stateNames = [];
        this.correctnessFeedbackEnabled = null;
        this.inQuestionMode = null;
        // Currently, the only place where this is used in the state editor
        // is in solution verification. So, once the interaction is set in this
        // service, the given solutions would be automatically verified for the set
        // interaction.
        // TODO(#7165): Replace 'any' with the exact type. This has been kept as
        // 'any' because the return type is a interaction domain object which can be
        // typed once InteractionObjectFactory is upgraded.
        this.interaction = null;
        this.misconceptionsBySkill = {};
        this.explorationIsWhitelisted = false;
        this.solicitAnswerDetails = null;
    }
    StateEditorService.prototype.getActiveStateName = function () {
        return this.activeStateName;
    };
    StateEditorService.prototype.setActiveStateName = function (newActiveStateName) {
        if (newActiveStateName === '' || newActiveStateName === null) {
            console.error('Invalid active state name: ' + newActiveStateName);
            return;
        }
        this.activeStateName = newActiveStateName;
    };
    StateEditorService.prototype.isExplorationWhitelisted = function () {
        return this.explorationIsWhitelisted;
    };
    StateEditorService.prototype.updateExplorationWhitelistedStatus = function (value) {
        this.explorationIsWhitelisted = value;
    };
    StateEditorService.prototype.setMisconceptionsBySkill = function (newMisconceptionsBySkill) {
        this.misconceptionsBySkill = newMisconceptionsBySkill;
    };
    StateEditorService.prototype.getMisconceptionsBySkill = function () {
        return this.misconceptionsBySkill;
    };
    StateEditorService.prototype.setInteraction = function (newInteraction) {
        this.interaction = newInteraction;
    };
    StateEditorService.prototype.setInteractionId = function (newId) {
        this.interaction.setId(newId);
    };
    StateEditorService.prototype.setInteractionAnswerGroups = function (newAnswerGroups) {
        this.interaction.setAnswerGroups(newAnswerGroups);
    };
    StateEditorService.prototype.setInteractionDefaultOutcome = function (newOutcome) {
        this.interaction.setDefaultOutcome(newOutcome);
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'newArgs' is a dict with underscore_cased keys which
    // give tslint errors against underscore_casing in favor of camelCasing.
    StateEditorService.prototype.setInteractionCustomizationArgs = function (newArgs) {
        this.interaction.setCustomizationArgs(newArgs);
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'solution' is a solution domain object which can be typed
    // once SolutionObjectFactory is upgraded.
    StateEditorService.prototype.setInteractionSolution = function (solution) {
        this.interaction.setSolution(solution);
    };
    StateEditorService.prototype.setInteractionHints = function (hints) {
        this.interaction.setHints(hints);
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because the return type is a interaction domain object which can be
    // typed once InteractionObjectFactory is upgraded.
    StateEditorService.prototype.getInteraction = function () {
        return cloneDeep_1.default(this.interaction);
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with underscore_cased keys
    // which give tslint errors against underscore_casing in favor of camelCasing.
    StateEditorService.prototype.getAnswerChoices = function (interactionId, customizationArgs) {
        if (!interactionId) {
            return null;
        }
        // Special cases for multiple choice input and image click input.
        if (interactionId === 'MultipleChoiceInput') {
            return customizationArgs.choices.value.map(function (val, ind) {
                return {
                    val: ind,
                    label: val
                };
            });
        }
        else if (interactionId === 'ImageClickInput') {
            var _answerChoices = [];
            var imageWithRegions = customizationArgs.imageAndRegions.value;
            for (var j = 0; j < imageWithRegions.labeledRegions.length; j++) {
                _answerChoices.push({
                    val: imageWithRegions.labeledRegions[j].label,
                    label: imageWithRegions.labeledRegions[j].label
                });
            }
            return _answerChoices;
        }
        else if (interactionId === 'ItemSelectionInput' ||
            interactionId === 'DragAndDropSortInput') {
            return customizationArgs.choices.value.map(function (val) {
                return {
                    val: val,
                    label: val
                };
            });
        }
        else {
            return null;
        }
    };
    StateEditorService.prototype.setInQuestionMode = function (newModeValue) {
        this.inQuestionMode = newModeValue;
    };
    StateEditorService.prototype.isInQuestionMode = function () {
        return this.inQuestionMode;
    };
    StateEditorService.prototype.setCorrectnessFeedbackEnabled = function (newCorrectnessFeedbackEnabled) {
        this.correctnessFeedbackEnabled = newCorrectnessFeedbackEnabled;
    };
    StateEditorService.prototype.getCorrectnessFeedbackEnabled = function () {
        return this.correctnessFeedbackEnabled;
    };
    StateEditorService.prototype.setSolicitAnswerDetails = function (newSolicitAnswerDetails) {
        this.solicitAnswerDetails = newSolicitAnswerDetails;
    };
    StateEditorService.prototype.getSolicitAnswerDetails = function () {
        return this.solicitAnswerDetails;
    };
    StateEditorService.prototype.setStateNames = function (newStateNames) {
        this.stateNames = newStateNames;
    };
    StateEditorService.prototype.getStateNames = function () {
        return this.stateNames;
    };
    StateEditorService.prototype.isCurrentSolutionValid = function () {
        return this.solutionValidityService.isSolutionValid(this.activeStateName);
    };
    StateEditorService.prototype.deleteCurrentSolutionValidity = function () {
        this.solutionValidityService.deleteSolutionValidity(this.activeStateName);
    };
    var _a;
    StateEditorService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof solution_validity_service_1.SolutionValidityService !== "undefined" && solution_validity_service_1.SolutionValidityService) === "function" ? _a : Object])
    ], StateEditorService);
    return StateEditorService;
}());
exports.StateEditorService = StateEditorService;
angular.module('oppia').factory('StateEditorService', static_1.downgradeInjectable(StateEditorService));


/***/ }),

/***/ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-interaction-id.service.ts":
/*!**************************************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-interaction-id.service.ts ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview A data service that stores the current interaction id.
 */
// TODO(sll): Add validation.
angular.module('oppia').factory('StateInteractionIdService', [
    'StatePropertyService', function (StatePropertyService) {
        var child = Object.create(StatePropertyService);
        child.setterMethodKey = 'saveInteractionId';
        return child;
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-property.service.ts":
/*!********************************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-property.service.ts ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Standalone services for the general state editor page.
 */
__webpack_require__(/*! services/AlertsService.ts */ "./core/templates/dev/head/services/AlertsService.ts");
angular.module('oppia').factory('StatePropertyService', [
    'AlertsService',
    function (AlertsService) {
        // Public base API for data services corresponding to state properties
        // (interaction id, content, etc.)
        // WARNING: This should be initialized only in the context of the state
        // editor, and every time the state is loaded, so that proper behavior is
        // maintained if e.g. the state is renamed.
        return {
            init: function (stateName, value) {
                if (this.setterMethodKey === null) {
                    throw 'State property setter method key cannot be null.';
                }
                // The name of the state.
                this.stateName = stateName;
                // The current value of the property (which may not have been saved to
                // the frontend yet). In general, this will be bound directly to the UI.
                this.displayed = angular.copy(value);
                // The previous (saved-in-the-frontend) value of the property. Here,
                // 'saved' means that this is the latest value of the property as
                // determined by the frontend change list.
                this.savedMemento = angular.copy(value);
            },
            // Returns whether the current value has changed from the memento.
            hasChanged: function () {
                return !angular.equals(this.savedMemento, this.displayed);
            },
            // The name of the setter method in ExplorationStatesService for this
            // property. THIS MUST BE SPECIFIED BY SUBCLASSES.
            setterMethodKey: null,
            // Transforms the given value into a normalized form. THIS CAN BE
            // OVERRIDDEN BY SUBCLASSES. The default behavior is to do nothing.
            _normalize: function (value) {
                return value;
            },
            // Validates the given value and returns a boolean stating whether it
            // is valid or not. THIS CAN BE OVERRIDDEN BY SUBCLASSES. The default
            // behavior is to always return true.
            _isValid: function (value) {
                return true;
            },
            // Updates the memento to the displayed value.
            saveDisplayedValue: function () {
                if (this.setterMethodKey === null) {
                    throw 'State property setter method key cannot be null.';
                }
                this.displayed = this._normalize(this.displayed);
                if (!this._isValid(this.displayed) || !this.hasChanged()) {
                    this.restoreFromMemento();
                    return;
                }
                if (angular.equals(this.displayed, this.savedMemento)) {
                    return;
                }
                AlertsService.clearWarnings();
                this.savedMemento = angular.copy(this.displayed);
            },
            // Reverts the displayed value to the saved memento.
            restoreFromMemento: function () {
                this.displayed = angular.copy(this.savedMemento);
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ajs.ts":
/*!**************************************************************************************************!*\
  !*** ./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ajs.ts ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for summary tile for collections.
 */
// TODO(#7092): Delete this file once migration is complete and these AngularJS
// equivalents of the Angular constants are no longer needed.
var collection_summary_tile_constants_1 = __webpack_require__(/*! components/summary-tile/collection-summary-tile.constants */ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ts");
angular.module('oppia').constant('COLLECTION_VIEWER_URL', collection_summary_tile_constants_1.CollectionSummaryTileConstants.COLLECTION_VIEWER_URL);
angular.module('oppia').constant('COLLECTION_EDITOR_URL', collection_summary_tile_constants_1.CollectionSummaryTileConstants.COLLECTION_EDITOR_URL);


/***/ }),

/***/ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ts":
/*!**********************************************************************************************!*\
  !*** ./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ts ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for summary tile for collections.
 */
var CollectionSummaryTileConstants = /** @class */ (function () {
    function CollectionSummaryTileConstants() {
    }
    CollectionSummaryTileConstants.COLLECTION_VIEWER_URL = '/collection/<collection_id>';
    CollectionSummaryTileConstants.COLLECTION_EDITOR_URL = '/collection_editor/create/<collection_id>';
    return CollectionSummaryTileConstants;
}());
exports.CollectionSummaryTileConstants = CollectionSummaryTileConstants;


/***/ }),

/***/ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.directive.ts":
/*!**********************************************************************************************!*\
  !*** ./core/templates/dev/head/components/summary-tile/collection-summary-tile.directive.ts ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Summary tile for collections.
 */
__webpack_require__(/*! domain/learner_dashboard/LearnerDashboardIconsDirective.ts */ "./core/templates/dev/head/domain/learner_dashboard/LearnerDashboardIconsDirective.ts");
__webpack_require__(/*! filters/string-utility-filters/truncate-and-capitalize.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-and-capitalize.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/DateTimeFormatService.ts */ "./core/templates/dev/head/services/DateTimeFormatService.ts");
__webpack_require__(/*! services/UserService.ts */ "./core/templates/dev/head/services/UserService.ts");
__webpack_require__(/*! components/summary-tile/collection-summary-tile.constants.ajs.ts */ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ajs.ts");
angular.module('oppia').directive('collectionSummaryTile', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getCollectionId: '&collectionId',
                getCollectionTitle: '&collectionTitle',
                getObjective: '&objective',
                getNodeCount: '&nodeCount',
                getLastUpdatedMsec: '&lastUpdatedMsec',
                getThumbnailIconUrl: '&thumbnailIconUrl',
                getThumbnailBgColor: '&thumbnailBgColor',
                isLinkedToEditorPage: '=?isLinkedToEditorPage',
                getCategory: '&category',
                isPlaylistTile: '&isPlaylistTile',
                showLearnerDashboardIconsIfPossible: ('&showLearnerDashboardIconsIfPossible'),
                isContainerNarrow: '&containerIsNarrow',
                isOwnedByCurrentUser: '&activityIsOwnedByCurrentUser',
            },
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/components/summary-tile/collection-summary-tile.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                'DateTimeFormatService', 'UserService',
                'ACTIVITY_TYPE_COLLECTION', 'COLLECTION_VIEWER_URL',
                'COLLECTION_EDITOR_URL', function (DateTimeFormatService, UserService, ACTIVITY_TYPE_COLLECTION, COLLECTION_VIEWER_URL, COLLECTION_EDITOR_URL) {
                    var ctrl = this;
                    ctrl.userIsLoggedIn = null;
                    UserService.getUserInfoAsync().then(function (userInfo) {
                        ctrl.userIsLoggedIn = userInfo.isLoggedIn();
                    });
                    ctrl.DEFAULT_EMPTY_TITLE = 'Untitled';
                    ctrl.ACTIVITY_TYPE_COLLECTION = ACTIVITY_TYPE_COLLECTION;
                    ctrl.getLastUpdatedDatetime = function () {
                        return DateTimeFormatService.getLocaleAbbreviatedDatetimeString(ctrl.getLastUpdatedMsec());
                    };
                    ctrl.getCollectionLink = function () {
                        var targetUrl = (ctrl.isLinkedToEditorPage ?
                            COLLECTION_EDITOR_URL : COLLECTION_VIEWER_URL);
                        return UrlInterpolationService.interpolateUrl(targetUrl, {
                            collection_id: ctrl.getCollectionId()
                        });
                    };
                    ctrl.getCompleteThumbnailIconUrl = function () {
                        return UrlInterpolationService.getStaticImageUrl(ctrl.getThumbnailIconUrl());
                    };
                    ctrl.getStaticImageUrl = function (url) {
                        return UrlInterpolationService.getStaticImageUrl(url);
                    };
                    ctrl.setHoverState = function (hoverState) {
                        ctrl.collectionIsCurrentlyHoveredOver = hoverState;
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/domain/classifier/PredictionResultObjectFactory.ts":
/*!************************************************************************************!*\
  !*** ./core/templates/dev/head/domain/classifier/PredictionResultObjectFactory.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Factory for creating new frontend instances of Prediction
 *     result domain objects.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var PredictionResult = /** @class */ (function () {
    function PredictionResult(label, confidence) {
        this.predictionLabel = label;
        this.predictionConfidence = confidence;
    }
    PredictionResult.prototype.getLabel = function () {
        return this.predictionLabel;
    };
    PredictionResult.prototype.getConfidence = function () {
        return this.predictionConfidence;
    };
    return PredictionResult;
}());
exports.PredictionResult = PredictionResult;
var PredictionResultObjectFactory = /** @class */ (function () {
    function PredictionResultObjectFactory() {
    }
    PredictionResultObjectFactory.prototype.createNew = function (label, confidence) {
        return new PredictionResult(label, confidence);
    };
    PredictionResultObjectFactory = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], PredictionResultObjectFactory);
    return PredictionResultObjectFactory;
}());
exports.PredictionResultObjectFactory = PredictionResultObjectFactory;
angular.module('oppia').factory('PredictionResultObjectFactory', static_1.downgradeInjectable(PredictionResultObjectFactory));


/***/ }),

/***/ "./core/templates/dev/head/domain/collection/ReadOnlyCollectionBackendApiService.ts":
/*!******************************************************************************************!*\
  !*** ./core/templates/dev/head/domain/collection/ReadOnlyCollectionBackendApiService.ts ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Service to retrieve read only information
 * about collections from the backend.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
// TODO(bhenning): For preview mode, this service should be replaced by a
// separate CollectionDataService implementation which returns a local copy of
// the collection instead. This file should not be included on the page in that
// scenario.
angular.module('oppia').factory('ReadOnlyCollectionBackendApiService', [
    '$http', '$q', 'UrlInterpolationService',
    'COLLECTION_DATA_URL_TEMPLATE',
    function ($http, $q, UrlInterpolationService, COLLECTION_DATA_URL_TEMPLATE) {
        // Maps previously loaded collections to their IDs.
        var _collectionCache = [];
        var _collectionDetailsCache = [];
        var _fetchCollection = function (collectionId, successCallback, errorCallback) {
            var collectionDataUrl = UrlInterpolationService.interpolateUrl(COLLECTION_DATA_URL_TEMPLATE, {
                collection_id: collectionId
            });
            $http.get(collectionDataUrl).then(function (response) {
                var collection = angular.copy(response.data.collection);
                _cacheCollectionDetails(response.data);
                if (successCallback) {
                    successCallback(collection);
                }
            }, function (errorResponse) {
                if (errorCallback) {
                    errorCallback(errorResponse.data);
                }
            });
        };
        var _cacheCollectionDetails = function (details) {
            _collectionDetailsCache[details.collection.id] = {
                canEdit: details.can_edit,
                title: details.collection.title,
            };
        };
        var _isCached = function (collectionId) {
            return _collectionCache.hasOwnProperty(collectionId);
        };
        return {
            /**
             * Retrieves a collection from the backend given a collection ID. This
             * returns a promise object that allows a success and rejection callbacks
             * to be registered. If the collection is successfully loaded and a
             * success callback function is provided to the promise object, the
             * success callback is called with the collection passed in as a
             * parameter. If something goes wrong while trying to fetch the
             * collection, the rejection callback is called instead, if present. The
             * rejection callback function is passed the error that occurred and the
             * collection ID.
             */
            fetchCollection: function (collectionId) {
                return $q(function (resolve, reject) {
                    _fetchCollection(collectionId, resolve, reject);
                });
            },
            /**
             * Behaves in the exact same way as fetchCollection (including callback
             * behavior and returning a promise object), except this function will
             * attempt to see whether the given collection has already been loaded. If
             * it has not yet been loaded, it will fetch the collection from the
             * backend. If it successfully retrieves the collection from the backend,
             * it will store it in the cache to avoid requests from the backend in
             * further function calls.
             */
            loadCollection: function (collectionId) {
                return $q(function (resolve, reject) {
                    if (_isCached(collectionId)) {
                        if (resolve) {
                            resolve(angular.copy(_collectionCache[collectionId]));
                        }
                    }
                    else {
                        _fetchCollection(collectionId, function (collection) {
                            // Save the fetched collection to avoid future fetches.
                            _collectionCache[collectionId] = collection;
                            if (resolve) {
                                resolve(angular.copy(collection));
                            }
                        }, reject);
                    }
                });
            },
            getCollectionDetails: function (collectionId) {
                if (_collectionDetailsCache[collectionId]) {
                    return _collectionDetailsCache[collectionId];
                }
                else {
                    throw Error('collection has not been fetched');
                }
            },
            /**
             * Returns whether the given collection is stored within the local data
             * cache or if it needs to be retrieved from the backend upon a laod.
             */
            isCached: function (collectionId) {
                return _isCached(collectionId);
            },
            /**
             * Replaces the current collection in the cache given by the specified
             * collection ID with a new collection object.
             */
            cacheCollection: function (collectionId, collection) {
                _collectionCache[collectionId] = angular.copy(collection);
            },
            /**
             * Clears the local collection data cache, forcing all future loads to
             * re-request the previously loaded collections from the backend.
             */
            clearCollectionCache: function () {
                _collectionCache = [];
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/domain/creator_dashboard/CreatorDashboardBackendApiService.ts":
/*!***********************************************************************************************!*\
  !*** ./core/templates/dev/head/domain/creator_dashboard/CreatorDashboardBackendApiService.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Service to retrieve information of creator dashboard from the
 * backend.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var http_1 = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var CreatorDashboardBackendApiService = /** @class */ (function () {
    function CreatorDashboardBackendApiService(http) {
        this.http = http;
    }
    CreatorDashboardBackendApiService.prototype._fetchDashboardData = function () {
        // HttpClient returns an Observable, the toPromise converts it into a
        // Promise.
        return this.http.get('/creatordashboardhandler/data').toPromise();
    };
    CreatorDashboardBackendApiService.prototype.fetchDashboardData = function () {
        return this._fetchDashboardData();
    };
    var _a;
    CreatorDashboardBackendApiService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof http_1.HttpClient !== "undefined" && http_1.HttpClient) === "function" ? _a : Object])
    ], CreatorDashboardBackendApiService);
    return CreatorDashboardBackendApiService;
}());
exports.CreatorDashboardBackendApiService = CreatorDashboardBackendApiService;
angular.module('oppia').factory('CreatorDashboardBackendApiService', static_1.downgradeInjectable(CreatorDashboardBackendApiService));


/***/ }),

/***/ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts":
/*!*************************************************************************!*\
  !*** ./core/templates/dev/head/domain/objects/FractionObjectFactory.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Factory for creating instances of Fraction
 * domain objects.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var objects_domain_constants_1 = __webpack_require__(/*! domain/objects/objects-domain.constants */ "./core/templates/dev/head/domain/objects/objects-domain.constants.ts");
var Fraction = /** @class */ (function () {
    function Fraction(isNegative, wholeNumber, numerator, denominator) {
        this.isNegative = isNegative;
        this.wholeNumber = wholeNumber;
        this.numerator = numerator;
        this.denominator = denominator;
    }
    Fraction.prototype.toString = function () {
        var fractionString = '';
        if (this.numerator !== 0) {
            fractionString += this.numerator + '/' + this.denominator;
        }
        if (this.wholeNumber !== 0) {
            fractionString = this.wholeNumber + ' ' + fractionString;
            // If the fractional part was empty then there will be a trailing
            // whitespace.
            fractionString = fractionString.trim();
        }
        if (this.isNegative && fractionString !== '') {
            fractionString = '-' + fractionString;
        }
        return fractionString === '' ? '0' : fractionString;
    };
    Fraction.prototype.toDict = function () {
        return {
            isNegative: this.isNegative,
            wholeNumber: this.wholeNumber,
            numerator: this.numerator,
            denominator: this.denominator
        };
    };
    Fraction.prototype.toFloat = function () {
        var totalParts = (this.wholeNumber * this.denominator) + this.numerator;
        var floatVal = (totalParts / this.denominator);
        return this.isNegative ? -floatVal : floatVal;
    };
    Fraction.prototype.getIntegerPart = function () {
        return this.isNegative ? -this.wholeNumber : this.wholeNumber;
    };
    Fraction.prototype.convertToSimplestForm = function () {
        var gcd = function (x, y) {
            return y === 0 ? x : gcd(y, x % y);
        };
        var g = gcd(this.numerator, this.denominator);
        var numerator = this.numerator / g;
        var denominator = this.denominator / g;
        return new Fraction(this.isNegative, this.wholeNumber, numerator, denominator);
    };
    Fraction.prototype.hasNonzeroIntegerPart = function () {
        return this.wholeNumber !== 0;
    };
    Fraction.prototype.isImproperFraction = function () {
        return this.denominator <= this.numerator;
    };
    return Fraction;
}());
exports.Fraction = Fraction;
var FractionObjectFactory = /** @class */ (function () {
    function FractionObjectFactory() {
    }
    FractionObjectFactory.prototype.fromRawInputString = function (rawInput) {
        var INVALID_CHARS_REGEX = /[^\d\s\/-]/g;
        if (INVALID_CHARS_REGEX.test(rawInput)) {
            throw new Error(objects_domain_constants_1.ObjectsDomainConstants.FRACTION_PARSING_ERRORS.INVALID_CHARS);
        }
        var FRACTION_REGEX = /^\s*-?\s*((\d*\s*\d+\s*\/\s*\d+)|\d+)\s*$/;
        if (!FRACTION_REGEX.test(rawInput)) {
            throw new Error(objects_domain_constants_1.ObjectsDomainConstants.FRACTION_PARSING_ERRORS.INVALID_FORMAT);
        }
        var isNegative = false;
        var wholeNumber = 0;
        var numerator = 0;
        var denominator = 1;
        rawInput = rawInput.trim();
        if (rawInput.charAt(0) === '-') {
            isNegative = true;
            // Remove the negative char from the string.
            rawInput = rawInput.substring(1);
        }
        // Filter result from split to remove empty strings.
        var numbers = rawInput.split(/\/|\s/g).filter(function (token) {
            // The empty string will evaluate to false.
            return Boolean(token);
        });
        if (numbers.length === 1) {
            wholeNumber = parseInt(numbers[0]);
        }
        else if (numbers.length === 2) {
            numerator = parseInt(numbers[0]);
            denominator = parseInt(numbers[1]);
        }
        else {
            // numbers.length == 3
            wholeNumber = parseInt(numbers[0]);
            numerator = parseInt(numbers[1]);
            denominator = parseInt(numbers[2]);
        }
        if (denominator === 0) {
            throw new Error(objects_domain_constants_1.ObjectsDomainConstants.FRACTION_PARSING_ERRORS.DIVISION_BY_ZERO);
        }
        return new Fraction(isNegative, wholeNumber, numerator, denominator);
    };
    FractionObjectFactory.prototype.fromDict = function (fractionDict) {
        return new Fraction(fractionDict.isNegative, fractionDict.wholeNumber, fractionDict.numerator, fractionDict.denominator);
    };
    FractionObjectFactory = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], FractionObjectFactory);
    return FractionObjectFactory;
}());
exports.FractionObjectFactory = FractionObjectFactory;
angular.module('oppia').factory('FractionObjectFactory', static_1.downgradeInjectable(FractionObjectFactory));


/***/ }),

/***/ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts":
/*!********************************************************************************!*\
  !*** ./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Factory for creating instances of NumberWithUnits
 * domain objects.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! domain/objects/UnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/UnitsObjectFactory.ts");
__webpack_require__(/*! domain/objects/objects-domain.constants.ajs.ts */ "./core/templates/dev/head/domain/objects/objects-domain.constants.ajs.ts");
/* Guidelines for adding new custom currency units in Number with Units
  interaction:

  Simply add currency unit to the dict of CURRENCY_UNITS constant and it will
  be automatically added to the allowed custom units. Following are the keys
  to be defined within the unit dict:
    name:  The name of the custom currency unit.
    aliases: Other allowed canonical forms of the currency unit.
    front_units: A list of all the currency symbols that are added to the front
      (like- $, Rs, ). Keep it an empty list if no symbol is needed.
    base_unit: Define the unit in terms of base unit only if the defined custom
      unit is a sub unit else assign it 'null' value.*/
angular.module('oppia').factory('NumberWithUnitsObjectFactory', [
    'FractionObjectFactory', 'UnitsObjectFactory', 'CURRENCY_UNITS',
    'NUMBER_WITH_UNITS_PARSING_ERRORS', function (FractionObjectFactory, UnitsObjectFactory, CURRENCY_UNITS, NUMBER_WITH_UNITS_PARSING_ERRORS) {
        var NumberWithUnits = function (type, real, fractionObj, unitsObj) {
            this.type = type;
            this.real = real;
            this.fraction = fractionObj;
            this.units = unitsObj.units;
        };
        NumberWithUnits.prototype.toString = function () {
            var numberWithUnitsString = '';
            var unitsString = UnitsObjectFactory.fromList(this.units).toString();
            if (unitsString.includes('$')) {
                unitsString = unitsString.replace('$', '');
                numberWithUnitsString += '$' + ' ';
            }
            if (unitsString.includes('Rs')) {
                unitsString = unitsString.replace('Rs', '');
                numberWithUnitsString += 'Rs' + ' ';
            }
            if (unitsString.includes('')) {
                unitsString = unitsString.replace('', '');
                numberWithUnitsString += '' + ' ';
            }
            if (this.type === 'real') {
                numberWithUnitsString += this.real + ' ';
            }
            else if (this.type === 'fraction') {
                numberWithUnitsString += this.fraction.toString() + ' ';
            }
            numberWithUnitsString += unitsString.trim();
            numberWithUnitsString = numberWithUnitsString.trim();
            return numberWithUnitsString;
        };
        NumberWithUnits.prototype.toMathjsCompatibleString = function () {
            var numberWithUnitsString = '';
            var unitsString = UnitsObjectFactory.fromList(this.units).toString();
            unitsString = UnitsObjectFactory.toMathjsCompatibleString(unitsString);
            if (this.type === 'real') {
                numberWithUnitsString += this.real + ' ';
            }
            else if (this.type === 'fraction') {
                numberWithUnitsString += this.fraction.toString() + ' ';
            }
            numberWithUnitsString += unitsString.trim();
            numberWithUnitsString = numberWithUnitsString.trim();
            return numberWithUnitsString;
        };
        NumberWithUnits.prototype.toDict = function () {
            return {
                type: this.type,
                real: this.real,
                fraction: this.fraction.toDict(),
                units: this.units
            };
        };
        // TODO(ankita240796): Remove the bracket notation once Angular2 gets in.
        /* eslint-disable dot-notation */
        NumberWithUnits['createCurrencyUnits'] = function () {
            /* eslint-enable dot-notation */
            try {
                UnitsObjectFactory.createCurrencyUnits();
            }
            catch (parsingError) { }
        };
        // TODO(ankita240796): Remove the bracket notation once Angular2 gets in.
        /* eslint-disable dot-notation */
        NumberWithUnits['fromRawInputString'] = function (rawInput) {
            /* eslint-enable dot-notation */
            rawInput = rawInput.trim();
            var type = '';
            var real = 0.0;
            // Default fraction value.
            var fractionObj = FractionObjectFactory.fromRawInputString('0/1');
            var units = '';
            var value = '';
            var unitObj = [];
            // Allow validation only when rawInput is not null or an empty string.
            if (rawInput !== '' && rawInput !== null) {
                // Start with digit when there is no currency unit.
                if (rawInput.match(/^\d/)) {
                    var ind = rawInput.indexOf(rawInput.match(/[a-z($]/i));
                    if (ind === -1) {
                        // There is value with no units.
                        value = rawInput;
                        units = '';
                    }
                    else {
                        value = rawInput.substr(0, ind).trim();
                        units = rawInput.substr(ind).trim();
                    }
                    var keys = Object.keys(CURRENCY_UNITS);
                    for (var i = 0; i < keys.length; i++) {
                        for (var j = 0; j < CURRENCY_UNITS[keys[i]].front_units.length; j++) {
                            if (units.indexOf(CURRENCY_UNITS[keys[i]].front_units[j]) !== -1) {
                                throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_CURRENCY_FORMAT);
                            }
                        }
                    }
                }
                else {
                    var startsWithCorrectCurrencyUnit = false;
                    var keys = Object.keys(CURRENCY_UNITS);
                    for (var i = 0; i < keys.length; i++) {
                        for (var j = 0; j < CURRENCY_UNITS[keys[i]].front_units.length; j++) {
                            if (rawInput.startsWith(CURRENCY_UNITS[keys[i]].front_units[j])) {
                                startsWithCorrectCurrencyUnit = true;
                                break;
                            }
                        }
                    }
                    if (startsWithCorrectCurrencyUnit === false) {
                        throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_CURRENCY);
                    }
                    var ind = rawInput.indexOf(rawInput.match(/[0-9]/));
                    if (ind === -1) {
                        throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_CURRENCY);
                    }
                    units = rawInput.substr(0, ind).trim();
                    startsWithCorrectCurrencyUnit = false;
                    for (var i = 0; i < keys.length; i++) {
                        for (var j = 0; j < CURRENCY_UNITS[keys[i]].front_units.length; j++) {
                            if (units === CURRENCY_UNITS[keys[i]].front_units[j].trim()) {
                                startsWithCorrectCurrencyUnit = true;
                                break;
                            }
                        }
                    }
                    if (startsWithCorrectCurrencyUnit === false) {
                        throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_CURRENCY);
                    }
                    units = units + ' ';
                    var ind2 = rawInput.indexOf(rawInput.substr(ind).match(/[a-z(]/i));
                    if (ind2 !== -1) {
                        value = rawInput.substr(ind, ind2 - ind).trim();
                        units += rawInput.substr(ind2).trim();
                    }
                    else {
                        value = rawInput.substr(ind).trim();
                        units = units.trim();
                    }
                }
                // Checking invalid characters in value.
                if (value.match(/[a-z]/i) || value.match(/[*^$()#@]/)) {
                    throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_VALUE);
                }
                if (value.includes('/')) {
                    type = 'fraction';
                    fractionObj = FractionObjectFactory.fromRawInputString(value);
                }
                else {
                    type = 'real';
                    real = parseFloat(value);
                }
                if (units !== '') {
                    // Checking invalid characters in units.
                    if (units.match(/[^0-9a-z/* ^()$-]/i)) {
                        throw new Error(NUMBER_WITH_UNITS_PARSING_ERRORS.INVALID_UNIT_CHARS);
                    }
                }
            }
            var unitsObj = UnitsObjectFactory.fromRawInputString(units);
            return new NumberWithUnits(type, real, fractionObj, unitsObj);
        };
        // TODO(ankita240796): Remove the bracket notation once Angular2 gets in.
        /* eslint-disable dot-notation */
        NumberWithUnits['fromDict'] = function (numberWithUnitsDict) {
            /* eslint-enable dot-notation */
            return new NumberWithUnits(numberWithUnitsDict.type, numberWithUnitsDict.real, FractionObjectFactory.fromDict(numberWithUnitsDict.fraction), UnitsObjectFactory.fromList(numberWithUnitsDict.units));
        };
        return NumberWithUnits;
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/domain/objects/UnitsObjectFactory.ts":
/*!**********************************************************************!*\
  !*** ./core/templates/dev/head/domain/objects/UnitsObjectFactory.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
// TODO(#7403): Convert this to partial imports.
var mathjs_1 = __importDefault(__webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js"));
var objects_domain_constants_1 = __webpack_require__(/*! domain/objects/objects-domain.constants */ "./core/templates/dev/head/domain/objects/objects-domain.constants.ts");
var Units = /** @class */ (function () {
    function Units(unitsList) {
        this.units = unitsList;
    }
    Units.prototype.toDict = function () {
        return {
            units: this.units
        };
    };
    Units.prototype.toString = function () {
        var unit = '';
        for (var i = 0; i < this.units.length; i++) {
            var d = this.units[i];
            if (d.exponent === 1) {
                unit += d.unit + ' ';
            }
            else {
                unit += d.unit + '^' + d.exponent.toString() + ' ';
            }
        }
        return unit.trim();
    };
    return Units;
}());
exports.Units = Units;
var UnitsObjectFactory = /** @class */ (function () {
    function UnitsObjectFactory() {
    }
    UnitsObjectFactory.prototype.isunit = function (unit) {
        return !('/*() '.includes(unit));
    };
    UnitsObjectFactory.prototype.stringToLexical = function (units) {
        units += '#';
        var unitList = [];
        var unit = '';
        for (var i = 0; i < units.length; i++) {
            if ('*/()# '.includes(units[i]) && unit !== 'per') {
                if (unit.length > 0) {
                    if ((unitList.length > 0) && this.isunit(unitList.slice(-1).pop())) {
                        unitList.push('*');
                    }
                    unitList.push(unit);
                    unit = '';
                }
                if (!('# '.includes(units[i]))) {
                    unitList.push(units[i]);
                }
            }
            else if (units[i] === ' ' && unit === 'per') {
                unitList.push('/');
                unit = '';
            }
            else {
                unit += units[i];
            }
        }
        return unitList;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because the return type is a list with varying element types. An
    // exact type needs to be found for it.
    UnitsObjectFactory.prototype.unitWithMultiplier = function (unitList) {
        var multiplier = 1;
        var unitsWithMultiplier = [];
        var parenthesisStack = [];
        for (var ind = 0; ind < unitList.length; ind++) {
            if (unitList[ind] === '/') {
                multiplier = -multiplier;
            }
            else if (unitList[ind] === '(') {
                if (unitList[ind - 1] === '/') {
                    // If previous element was division then we need to inverse
                    // multiplier when we find its corresponsing closing parenthesis.
                    // Second element of pushed element is used for this purpose.
                    parenthesisStack.push(['(', -1]);
                }
                else {
                    // If previous element was not division then we don't need to
                    // invert the multiplier.
                    parenthesisStack.push(['(', 1]);
                }
            }
            else if (unitList[ind] === ')') {
                var elem = parenthesisStack.pop();
                multiplier = parseInt(elem[1]) * multiplier;
            }
            else if (this.isunit(unitList[ind])) {
                unitsWithMultiplier.push([unitList[ind], multiplier]);
                // If previous element was division then we need to invert
                // multiplier.
                if (unitList[ind - 1] === '/') {
                    multiplier = -multiplier;
                }
            }
        }
        return unitsWithMultiplier;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'unitDict' is a dict with varying element types. An
    // exact type needs to be found for it, Once that is found the return type
    // can also be typed.
    UnitsObjectFactory.prototype.convertUnitDictToList = function (unitDict) {
        var unitList = [];
        for (var key in unitDict) {
            unitList.push({ unit: key, exponent: unitDict[key] });
        }
        return unitList;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'unitsWithMultiplier' is a dict with varying element types.
    // An exact type needs to be found for it, Once that is found the return type
    // can also be typed.
    UnitsObjectFactory.prototype.unitToList = function (unitsWithMultiplier) {
        var unitDict = {};
        for (var i = 0; i < unitsWithMultiplier.length; i++) {
            var unit = unitsWithMultiplier[i][0];
            var multiplier = unitsWithMultiplier[i][1];
            var ind = unit.indexOf('^');
            var s = null;
            var power = null;
            if (ind > -1) {
                s = unit.substr(0, ind);
                power = parseInt(unit.substr(ind + 1));
            }
            else {
                s = unit;
                power = 1;
            }
            if (!(s in unitDict)) {
                unitDict[s] = 0;
            }
            unitDict[s] += multiplier * power;
        }
        return this.convertUnitDictToList(unitDict);
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'units' is a list with varying element types. An exact
    // type needs to be found for it.
    UnitsObjectFactory.prototype.fromList = function (unitsList) {
        return new Units(unitsList);
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because the return type is to be determined once 'unitToList' has
    // determined return type.
    UnitsObjectFactory.prototype.fromStringToList = function (unitsString) {
        return this.unitToList(this.unitWithMultiplier(this.stringToLexical(unitsString)));
    };
    UnitsObjectFactory.prototype.createCurrencyUnits = function () {
        var keys = Object.keys(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS);
        for (var i = 0; i < keys.length; i++) {
            if (objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].base_unit === null) {
                // Base unit (like: rupees, dollar etc.).
                mathjs_1.default.createUnit(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].name, {
                    aliases: objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].aliases
                });
            }
            else {
                // Sub unit (like: paise, cents etc.).
                mathjs_1.default.createUnit(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].name, {
                    definition: objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].base_unit,
                    aliases: objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].aliases
                });
            }
        }
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'units' is a list with varying element types. An exact
    // type needs to be found for it.
    UnitsObjectFactory.prototype.toMathjsCompatibleString = function (units) {
        // Makes the units compatible with the math.js allowed format.
        units = units.replace(/per/g, '/');
        // Special symbols need to be replaced as math.js doesn't support custom
        // units starting with special symbols. Also, it doesn't allow units
        // followed by a number as in the case of currency units.
        var keys = Object.keys(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS);
        for (var i = 0; i < keys.length; i++) {
            for (var j = 0; j < objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].front_units.length; j++) {
                if (units.includes(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].front_units[j])) {
                    units = units.replace(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].front_units[j], '');
                    units = objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].name + units;
                }
            }
            for (var j = 0; j < objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].aliases.length; j++) {
                if (units.includes(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].aliases[j])) {
                    units = units.replace(objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].aliases[j], objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS[keys[i]].name);
                }
            }
        }
        return units.trim();
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'units' is a list with varying element types. An exact
    // type needs to be found for it.
    UnitsObjectFactory.prototype.fromRawInputString = function (units) {
        try {
            this.createCurrencyUnits();
        }
        catch (parsingError) { }
        var compatibleUnits = this.toMathjsCompatibleString(units);
        if (compatibleUnits !== '') {
            try {
                mathjs_1.default.unit(compatibleUnits);
            }
            catch (err) {
                throw new Error(err);
            }
        }
        return new Units(this.fromStringToList(units));
    };
    UnitsObjectFactory = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], UnitsObjectFactory);
    return UnitsObjectFactory;
}());
exports.UnitsObjectFactory = UnitsObjectFactory;
angular.module('oppia').factory('UnitsObjectFactory', static_1.downgradeInjectable(UnitsObjectFactory));


/***/ }),

/***/ "./core/templates/dev/head/domain/objects/objects-domain.constants.ajs.ts":
/*!********************************************************************************!*\
  !*** ./core/templates/dev/head/domain/objects/objects-domain.constants.ajs.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for objects domain.
 */
// TODO(#7092): Delete this file once migration is complete and these AngularJS
// equivalents of the Angular constants are no longer needed.
var objects_domain_constants_1 = __webpack_require__(/*! domain/objects/objects-domain.constants */ "./core/templates/dev/head/domain/objects/objects-domain.constants.ts");
angular.module('oppia').constant('FRACTION_PARSING_ERRORS', objects_domain_constants_1.ObjectsDomainConstants.FRACTION_PARSING_ERRORS);
angular.module('oppia').constant('NUMBER_WITH_UNITS_PARSING_ERRORS', objects_domain_constants_1.ObjectsDomainConstants.NUMBER_WITH_UNITS_PARSING_ERRORS);
angular.module('oppia').constant('CURRENCY_UNITS', objects_domain_constants_1.ObjectsDomainConstants.CURRENCY_UNITS);


/***/ }),

/***/ "./core/templates/dev/head/domain/suggestion/SuggestionObjectFactory.ts":
/*!******************************************************************************!*\
  !*** ./core/templates/dev/head/domain/suggestion/SuggestionObjectFactory.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Factory for creating new frontend instances of suggestion
   domain objects.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var Suggestion = /** @class */ (function () {
    function Suggestion(suggestionType, suggestionId, targetType, targetId, status, authorName, stateName, newValue, oldValue, lastUpdated) {
        this.suggestionType = suggestionType;
        this.suggestionId = suggestionId;
        this.targetType = targetType;
        this.targetId = targetId;
        this.status = status;
        this.authorName = authorName;
        this.stateName = stateName;
        this.newValue = newValue;
        this.oldValue = oldValue;
        this.lastUpdated = lastUpdated;
    }
    Suggestion.prototype.getThreadId = function () {
        return this.suggestionId;
    };
    return Suggestion;
}());
exports.Suggestion = Suggestion;
var SuggestionObjectFactory = /** @class */ (function () {
    function SuggestionObjectFactory() {
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'suggestionBackendDict' is a dict with underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    SuggestionObjectFactory.prototype.createFromBackendDict = function (suggestionBackendDict) {
        return new Suggestion(suggestionBackendDict.suggestion_type, suggestionBackendDict.suggestion_id, suggestionBackendDict.target_type, suggestionBackendDict.target_id, suggestionBackendDict.status, suggestionBackendDict.author_name, suggestionBackendDict.change.state_name, suggestionBackendDict.change.new_value, suggestionBackendDict.change.old_value, suggestionBackendDict.last_updated);
    };
    SuggestionObjectFactory = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], SuggestionObjectFactory);
    return SuggestionObjectFactory;
}());
exports.SuggestionObjectFactory = SuggestionObjectFactory;
angular.module('oppia').factory('SuggestionObjectFactory', static_1.downgradeInjectable(SuggestionObjectFactory));


/***/ }),

/***/ "./core/templates/dev/head/domain/suggestion/SuggestionThreadObjectFactory.ts":
/*!************************************************************************************!*\
  !*** ./core/templates/dev/head/domain/suggestion/SuggestionThreadObjectFactory.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Factory for creating new frontend instances of suggestion
   thread domain objects.
 */
__webpack_require__(/*! domain/suggestion/SuggestionObjectFactory.ts */ "./core/templates/dev/head/domain/suggestion/SuggestionObjectFactory.ts");
angular.module('oppia').factory('SuggestionThreadObjectFactory', [
    'SuggestionObjectFactory', function (SuggestionObjectFactory) {
        var SuggestionThread = function (status, subject, summary, originalAuthorName, lastUpdated, messageCount, threadId, suggestion) {
            this.status = status;
            this.subject = subject;
            this.summary = summary;
            this.originalAuthorName = originalAuthorName;
            this.lastUpdated = lastUpdated;
            this.messageCount = messageCount;
            this.threadId = threadId;
            this.suggestion = suggestion;
            this.messages = [];
        };
        // TODO(ankita240796): Remove the bracket notation once Angular2 gets in.
        /* eslint-disable dot-notation */
        SuggestionThread['createFromBackendDicts'] = function (
        /* eslint-enable dot-notation */
        suggestionThreadBackendDict, suggestionBackendDict) {
            var suggestion;
            if (suggestionBackendDict.suggestion_type ===
                'edit_exploration_state_content') {
                suggestion = SuggestionObjectFactory.createFromBackendDict(suggestionBackendDict);
            }
            return new SuggestionThread(suggestionThreadBackendDict.status, suggestionThreadBackendDict.subject, suggestionThreadBackendDict.summary, suggestionThreadBackendDict.original_author_username, suggestionThreadBackendDict.last_updated, suggestionThreadBackendDict.message_count, suggestionThreadBackendDict.thread_id, suggestion);
        };
        SuggestionThread.prototype.setMessages = function (messages) {
            this.messages = messages;
        };
        SuggestionThread.prototype.isSuggestionHandled = function () {
            return this.suggestion.status !== 'review';
        };
        SuggestionThread.prototype.getSuggestionStateName = function () {
            return this.suggestion.stateName;
        };
        SuggestionThread.prototype.getSuggestionStatus = function () {
            return this.suggestion.status;
        };
        SuggestionThread.prototype.getReplacementHtmlFromSuggestion = function () {
            return this.suggestion.newValue.html;
        };
        SuggestionThread.prototype.isSuggestionThread = function () {
            return true;
        };
        SuggestionThread.prototype.getSuggestion = function () {
            return this.suggestion;
        };
        return SuggestionThread;
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/filters/remove-duplicates-in-array.filter.ts":
/*!******************************************************************************!*\
  !*** ./core/templates/dev/head/filters/remove-duplicates-in-array.filter.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview RemoveDuplicatesInArray filter for Oppia.
 */
angular.module('oppia').filter('removeDuplicatesInArray', [function () {
        return function (input) {
            if (!input.filter) {
                throw Error('Bad input for removeDuplicatesInArray: ' + JSON.stringify(input));
            }
            return input.filter(function (val, pos) {
                return input.indexOf(val) === pos;
            });
        };
    }]);


/***/ }),

/***/ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace-punctuation-and-case.filter.ts":
/*!********************************************************************************************************************!*\
  !*** ./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace-punctuation-and-case.filter.ts ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview NormalizeWhitespacePunctuationAndCase filter for Oppia.
 */
// Filter that takes a string, trims and normalizes spaces within each
// line, and removes blank lines. Note that any spaces whose removal does not
// result in two alphanumeric "words" being joined together are also removed,
// so "hello ? " becomes "hello?".
angular.module('oppia').filter('normalizeWhitespacePunctuationAndCase', [
    function () {
        return function (input) {
            if (typeof input === 'string' || input instanceof String) {
                var isAlphanumeric = function (character) {
                    return 'qwertyuiopasdfghjklzxcvbnm0123456789'.indexOf(character.toLowerCase()) !== -1;
                };
                input = input.trim();
                var inputLines = input.split('\n');
                var resultLines = [];
                for (var i = 0; i < inputLines.length; i++) {
                    var result = '';
                    var inputLine = inputLines[i].trim().replace(/\s{2,}/g, ' ');
                    for (var j = 0; j < inputLine.length; j++) {
                        var currentChar = inputLine.charAt(j).toLowerCase();
                        if (currentChar === ' ') {
                            if (j > 0 && j < inputLine.length - 1 &&
                                isAlphanumeric(inputLine.charAt(j - 1)) &&
                                isAlphanumeric(inputLine.charAt(j + 1))) {
                                result += currentChar;
                            }
                        }
                        else {
                            result += currentChar;
                        }
                    }
                    if (result) {
                        resultLines.push(result);
                    }
                }
                return resultLines.join('\n');
            }
            else {
                return input;
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace.filter.ts":
/*!***********************************************************************************************!*\
  !*** ./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace.filter.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview NormalizeWhitespace filter for Oppia.
 */
__webpack_require__(/*! services/UtilsService.ts */ "./core/templates/dev/head/services/UtilsService.ts");
// Filter that removes whitespace from the beginning and end of a string, and
// replaces interior whitespace with a single space character.
angular.module('oppia').filter('normalizeWhitespace', [
    'UtilsService', function (UtilsService) {
        return function (input) {
            if (UtilsService.isString(input)) {
                // Remove whitespace from the beginning and end of the string, and
                // replace interior whitespace with a single space character.
                input = input.trim();
                input = input.replace(/\s{2,}/g, ' ');
                return input;
            }
            else {
                return input;
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts":
/*!*************************************************************************************************!*\
  !*** ./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview TruncateAtFirstLine filter for Oppia.
 */
angular.module('oppia').filter('truncateAtFirstLine', [function () {
        return function (input) {
            if (!input) {
                return input;
            }
            var pattern = /(\r\n|[\n\v\f\r\x85\u2028\u2029])/g;
            // Normalize line endings then split using the normalized delimiter.
            var lines = input.replace(pattern, '\n').split('\n');
            var firstNonemptyLineIndex = -1;
            var otherNonemptyLinesExist = false;
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].length > 0) {
                    if (firstNonemptyLineIndex === -1) {
                        firstNonemptyLineIndex = i;
                    }
                    else {
                        otherNonemptyLinesExist = true;
                        break;
                    }
                }
            }
            var suffix = otherNonemptyLinesExist ? '...' : '';
            return (firstNonemptyLineIndex !== -1 ?
                lines[firstNonemptyLineIndex] + suffix : '');
        };
    }]);


/***/ }),

/***/ "./core/templates/dev/head/pages/OppiaFooterDirective.ts":
/*!***************************************************************!*\
  !*** ./core/templates/dev/head/pages/OppiaFooterDirective.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the footer.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
angular.module('oppia').directive('oppiaFooter', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/pages/oppia_footer_directive.html'),
            controllerAs: '$ctrl',
            controller: [
                function () { }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ajs.ts":
/*!******************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ajs.ts ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for the creator dashboard.
 */
// TODO(#7092): Delete this file once migration is complete and these AngularJS
// equivalents of the Angular constants are no longer needed.
var creator_dashboard_page_constants_1 = __webpack_require__(/*! pages/creator-dashboard-page/creator-dashboard-page.constants */ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ts");
angular.module('oppia').constant('EXPLORATION_DROPDOWN_STATS', creator_dashboard_page_constants_1.CreatorDashboardConstants.EXPLORATION_DROPDOWN_STATS);
angular.module('oppia').constant('EXPLORATIONS_SORT_BY_KEYS', creator_dashboard_page_constants_1.CreatorDashboardConstants.EXPLORATIONS_SORT_BY_KEYS);
angular.module('oppia').constant('HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS', creator_dashboard_page_constants_1.CreatorDashboardConstants.HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS);
angular.module('oppia').constant('SUBSCRIPTION_SORT_BY_KEYS', creator_dashboard_page_constants_1.CreatorDashboardConstants.SUBSCRIPTION_SORT_BY_KEYS);
angular.module('oppia').constant('HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS', creator_dashboard_page_constants_1.CreatorDashboardConstants.HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS);


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ts":
/*!**************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ts ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for the creator dashboard.
 */
var CreatorDashboardConstants = /** @class */ (function () {
    function CreatorDashboardConstants() {
    }
    CreatorDashboardConstants.EXPLORATION_DROPDOWN_STATS = {
        OPEN_FEEDBACK: 'open_feedback'
    };
    CreatorDashboardConstants.EXPLORATIONS_SORT_BY_KEYS = {
        TITLE: 'title',
        RATING: 'ratings',
        NUM_VIEWS: 'num_views',
        OPEN_FEEDBACK: 'num_open_threads',
        LAST_UPDATED: 'last_updated_msec'
    };
    CreatorDashboardConstants.HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS = {
        TITLE: 'I18N_DASHBOARD_EXPLORATIONS_SORT_BY_TITLE',
        RATING: 'I18N_DASHBOARD_EXPLORATIONS_SORT_BY_AVERAGE_RATING',
        NUM_VIEWS: 'I18N_DASHBOARD_EXPLORATIONS_SORT_BY_TOTAL_PLAYS',
        OPEN_FEEDBACK: 'I18N_DASHBOARD_EXPLORATIONS_SORT_BY_OPEN_FEEDBACK',
        LAST_UPDATED: 'I18N_DASHBOARD_EXPLORATIONS_SORT_BY_LAST_UPDATED'
    };
    CreatorDashboardConstants.SUBSCRIPTION_SORT_BY_KEYS = {
        USERNAME: 'subscriber_username',
        IMPACT: 'subscriber_impact'
    };
    CreatorDashboardConstants.HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS = {
        USERNAME: 'Username',
        IMPACT: 'Impact'
    };
    return CreatorDashboardConstants;
}());
exports.CreatorDashboardConstants = CreatorDashboardConstants;


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.controller.ts":
/*!***************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.controller.ts ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the creator dashboard.
 */
__webpack_require__(/*! base_components/BaseContentDirective.ts */ "./core/templates/dev/head/base_components/BaseContentDirective.ts");
__webpack_require__(/*! components/common-layout-directives/common-elements/sharing-links.directive.ts */ "./core/templates/dev/head/components/common-layout-directives/common-elements/sharing-links.directive.ts");
__webpack_require__(/*! components/common-layout-directives/common-elements/background-banner.directive.ts */ "./core/templates/dev/head/components/common-layout-directives/common-elements/background-banner.directive.ts");
__webpack_require__(/*! components/summary-tile/collection-summary-tile.directive.ts */ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.directive.ts");
__webpack_require__(/*! pages/exploration-editor-page/feedback-tab/thread-table/thread-table.directive.ts */ "./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/thread-table/thread-table.directive.ts");
__webpack_require__(/*! interactions/interactionsRequires.ts */ "./extensions/interactions/interactionsRequires.ts");
__webpack_require__(/*! objects/objectComponentsRequires.ts */ "./extensions/objects/objectComponentsRequires.ts");
__webpack_require__(/*! components/entity-creation-services/exploration-creation.service.ts */ "./core/templates/dev/head/components/entity-creation-services/exploration-creation.service.ts");
__webpack_require__(/*! components/ratings/rating-computation/rating-computation.service.ts */ "./core/templates/dev/head/components/ratings/rating-computation/rating-computation.service.ts");
__webpack_require__(/*! domain/creator_dashboard/CreatorDashboardBackendApiService.ts */ "./core/templates/dev/head/domain/creator_dashboard/CreatorDashboardBackendApiService.ts");
__webpack_require__(/*! domain/suggestion/SuggestionObjectFactory.ts */ "./core/templates/dev/head/domain/suggestion/SuggestionObjectFactory.ts");
__webpack_require__(/*! domain/suggestion/SuggestionThreadObjectFactory.ts */ "./core/templates/dev/head/domain/suggestion/SuggestionThreadObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/creator-dashboard-page/suggestion-modal-for-creator-view/suggestion-modal-for-creator-view.service.ts */ "./core/templates/dev/head/pages/creator-dashboard-page/suggestion-modal-for-creator-view/suggestion-modal-for-creator-view.service.ts");
__webpack_require__(/*! pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts */ "./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts");
__webpack_require__(/*! services/AlertsService.ts */ "./core/templates/dev/head/services/AlertsService.ts");
__webpack_require__(/*! services/DateTimeFormatService.ts */ "./core/templates/dev/head/services/DateTimeFormatService.ts");
__webpack_require__(/*! services/UserService.ts */ "./core/templates/dev/head/services/UserService.ts");
__webpack_require__(/*! pages/creator-dashboard-page/creator-dashboard-page.constants.ajs.ts */ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ajs.ts");
angular.module('oppia').directive('creatorDashboardPage', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/pages/creator-dashboard-page/creator-dashboard-page.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$http', '$log', '$q', '$rootScope', '$window',
                'AlertsService', 'CreatorDashboardBackendApiService',
                'DateTimeFormatService',
                'ExplorationCreationService', 'RatingComputationService',
                'SuggestionModalForCreatorDashboardService', 'SuggestionObjectFactory',
                'SuggestionThreadObjectFactory', 'ThreadStatusDisplayService',
                'UrlInterpolationService', 'UserService',
                'ALLOWED_CREATOR_DASHBOARD_DISPLAY_PREFS',
                'DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR', 'EXPLORATIONS_SORT_BY_KEYS',
                'EXPLORATION_DROPDOWN_STATS', 'FATAL_ERROR_CODES',
                'HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS',
                'HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS',
                'SUBSCRIPTION_SORT_BY_KEYS',
                function ($http, $log, $q, $rootScope, $window, AlertsService, CreatorDashboardBackendApiService, DateTimeFormatService, ExplorationCreationService, RatingComputationService, SuggestionModalForCreatorDashboardService, SuggestionObjectFactory, SuggestionThreadObjectFactory, ThreadStatusDisplayService, UrlInterpolationService, UserService, ALLOWED_CREATOR_DASHBOARD_DISPLAY_PREFS, DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR, EXPLORATIONS_SORT_BY_KEYS, EXPLORATION_DROPDOWN_STATS, FATAL_ERROR_CODES, HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS, HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS, SUBSCRIPTION_SORT_BY_KEYS) {
                    var ctrl = this;
                    var EXP_PUBLISH_TEXTS = {
                        defaultText: ('This exploration is private. Publish it to receive statistics.'),
                        smText: 'Publish the exploration to receive statistics.'
                    };
                    var userDashboardDisplayPreference = ALLOWED_CREATOR_DASHBOARD_DISPLAY_PREFS.CARD;
                    ctrl.DEFAULT_EMPTY_TITLE = 'Untitled';
                    ctrl.EXPLORATION_DROPDOWN_STATS = EXPLORATION_DROPDOWN_STATS;
                    ctrl.EXPLORATIONS_SORT_BY_KEYS = EXPLORATIONS_SORT_BY_KEYS;
                    ctrl.HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS = (HUMAN_READABLE_EXPLORATIONS_SORT_BY_KEYS);
                    ctrl.SUBSCRIPTION_SORT_BY_KEYS = SUBSCRIPTION_SORT_BY_KEYS;
                    ctrl.HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS = (HUMAN_READABLE_SUBSCRIPTION_SORT_BY_KEYS);
                    ctrl.DEFAULT_TWITTER_SHARE_MESSAGE_DASHBOARD = (DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR);
                    ctrl.canCreateCollections = null;
                    $rootScope.loadingMessage = 'Loading';
                    var userInfoPromise = UserService.getUserInfoAsync();
                    userInfoPromise.then(function (userInfo) {
                        ctrl.canCreateCollections = userInfo.canCreateCollections();
                    });
                    var dashboardDataPromise = (CreatorDashboardBackendApiService.fetchDashboardData());
                    dashboardDataPromise.then(function (response) {
                        // The following condition is required for Karma testing. The
                        // Angular HttpClient returns an Observable which when converted
                        // to a promise does not have the 'data' key but the AngularJS
                        // mocks of services using HttpClient use $http which return
                        // promise and the content is contained in the 'data' key.
                        // Therefore the following condition checks for presence of
                        // 'response.data' which would be the case in AngularJS testing
                        // but assigns 'response' if the former is not present which is
                        // the case with HttpClient.
                        var responseData = response.data ? response.data : response;
                        ctrl.currentSortType = EXPLORATIONS_SORT_BY_KEYS.OPEN_FEEDBACK;
                        ctrl.currentSubscribersSortType =
                            SUBSCRIPTION_SORT_BY_KEYS.USERNAME;
                        ctrl.isCurrentSortDescending = true;
                        ctrl.isCurrentSubscriptionSortDescending = true;
                        ctrl.explorationsList = responseData.explorations_list;
                        ctrl.collectionsList = responseData.collections_list;
                        ctrl.subscribersList = responseData.subscribers_list;
                        ctrl.dashboardStats = responseData.dashboard_stats;
                        ctrl.lastWeekStats = responseData.last_week_stats;
                        ctrl.myExplorationsView = responseData.display_preference;
                        var numberOfCreatedSuggestions = (responseData.threads_for_created_suggestions_list.length);
                        var numberOfSuggestionsToReview = (responseData.threads_for_suggestions_to_review_list.length);
                        ctrl.mySuggestionsList = [];
                        for (var i = 0; i < numberOfCreatedSuggestions; i++) {
                            if (responseData.created_suggestions_list.length !==
                                numberOfCreatedSuggestions) {
                                $log.error('Number of suggestions does not match number of ' +
                                    'suggestion threads');
                            }
                            for (var j = 0; j < numberOfCreatedSuggestions; j++) {
                                var suggestion = SuggestionObjectFactory
                                    .createFromBackendDict(responseData.created_suggestions_list[j]);
                                var threadDict = (responseData.threads_for_created_suggestions_list[i]);
                                if (threadDict.thread_id === suggestion.getThreadId()) {
                                    var suggestionThread = (SuggestionThreadObjectFactory.createFromBackendDicts(threadDict, responseData.created_suggestions_list[j]));
                                    ctrl.mySuggestionsList.push(suggestionThread);
                                }
                            }
                        }
                        ctrl.suggestionsToReviewList = [];
                        for (var i = 0; i < numberOfSuggestionsToReview; i++) {
                            if (responseData.suggestions_to_review_list.length !==
                                numberOfSuggestionsToReview) {
                                $log.error('Number of suggestions does not match number of ' +
                                    'suggestion threads');
                            }
                            for (var j = 0; j < numberOfSuggestionsToReview; j++) {
                                var suggestion = SuggestionObjectFactory
                                    .createFromBackendDict(responseData.suggestions_to_review_list[j]);
                                var threadDict = (responseData.threads_for_suggestions_to_review_list[i]);
                                if (threadDict.thread_id === suggestion.getThreadId()) {
                                    var suggestionThread = (SuggestionThreadObjectFactory.createFromBackendDicts(threadDict, responseData.suggestions_to_review_list[j]));
                                    ctrl.suggestionsToReviewList.push(suggestionThread);
                                }
                            }
                        }
                        if (ctrl.dashboardStats && ctrl.lastWeekStats) {
                            ctrl.relativeChangeInTotalPlays = (ctrl.dashboardStats.total_plays - (ctrl.lastWeekStats.total_plays));
                        }
                        if (ctrl.explorationsList.length === 0 &&
                            ctrl.collectionsList.length > 0) {
                            ctrl.activeTab = 'myCollections';
                        }
                        else if (ctrl.explorationsList.length === 0 && (ctrl.mySuggestionsList.length > 0 ||
                            ctrl.suggestionsToReviewList.length > 0)) {
                            ctrl.activeTab = 'suggestions';
                        }
                        else {
                            ctrl.activeTab = 'myExplorations';
                        }
                    }, function (errorResponse) {
                        if (FATAL_ERROR_CODES.indexOf(errorResponse.status) !== -1) {
                            AlertsService.addWarning('Failed to get dashboard data');
                        }
                    });
                    $q.all([userInfoPromise, dashboardDataPromise]).then(function () {
                        $rootScope.loadingMessage = '';
                    });
                    ctrl.getAverageRating = RatingComputationService
                        .computeAverageRating;
                    ctrl.createNewExploration = (ExplorationCreationService.createNewExploration);
                    ctrl.getLocaleAbbreviatedDatetimeString = (DateTimeFormatService.getLocaleAbbreviatedDatetimeString);
                    ctrl.getHumanReadableStatus = (ThreadStatusDisplayService.getHumanReadableStatus);
                    ctrl.emptyDashboardImgUrl = UrlInterpolationService
                        .getStaticImageUrl('/general/empty_dashboard.svg');
                    ctrl.canReviewActiveThread = null;
                    ctrl.setActiveTab = function (newActiveTabName) {
                        ctrl.activeTab = newActiveTabName;
                    };
                    ctrl.getExplorationUrl = function (explorationId) {
                        return '/create/' + explorationId;
                    };
                    ctrl.getCollectionUrl = function (collectionId) {
                        return '/collection_editor/create/' + collectionId;
                    };
                    ctrl.setMyExplorationsView = function (newViewType) {
                        $http.post('/creatordashboardhandler/data', {
                            display_preference: newViewType,
                        }).then(function () {
                            ctrl.myExplorationsView = newViewType;
                        });
                        userDashboardDisplayPreference = newViewType;
                    };
                    ctrl.checkMobileView = function () {
                        return ($window.innerWidth < 500);
                    };
                    ctrl.showUsernamePopover = function (subscriberUsername) {
                        // The popover on the subscription card is only shown if the length
                        // of the subscriber username is greater than 10 and the user hovers
                        // over the truncated username.
                        if (subscriberUsername.length > 10) {
                            return 'mouseenter';
                        }
                        else {
                            return 'none';
                        }
                    };
                    ctrl.updatesGivenScreenWidth = function () {
                        if (ctrl.checkMobileView()) {
                            // For mobile users, the view of the creators
                            // exploration list is shown only in
                            // the card view and can't be switched to list view.
                            ctrl.myExplorationsView = (ALLOWED_CREATOR_DASHBOARD_DISPLAY_PREFS.CARD);
                            ctrl.publishText = EXP_PUBLISH_TEXTS.smText;
                        }
                        else {
                            // For computer users or users operating in larger screen size
                            // the creator exploration list will come back to its previously
                            // selected view (card or list) when resized from mobile view
                            ctrl.myExplorationsView = userDashboardDisplayPreference;
                            ctrl.publishText = EXP_PUBLISH_TEXTS.defaultText;
                        }
                    };
                    ctrl.updatesGivenScreenWidth();
                    angular.element($window).bind('resize', function () {
                        ctrl.updatesGivenScreenWidth();
                    });
                    ctrl.setExplorationsSortingOptions = function (sortType) {
                        if (sortType === ctrl.currentSortType) {
                            ctrl.isCurrentSortDescending = !ctrl.isCurrentSortDescending;
                        }
                        else {
                            ctrl.currentSortType = sortType;
                        }
                    };
                    ctrl.setSubscriptionSortingOptions = function (sortType) {
                        if (sortType === ctrl.currentSubscribersSortType) {
                            ctrl.isCurrentSubscriptionSortDescending = (!ctrl.isCurrentSubscriptionSortDescending);
                        }
                        else {
                            ctrl.currentSubscribersSortType = sortType;
                        }
                    };
                    ctrl.sortSubscriptionFunction = function (entity) {
                        // This function is passed as a custom comparator function to
                        // `orderBy`, so that special cases can be handled while sorting
                        // subscriptions.
                        var value = entity[ctrl.currentSubscribersSortType];
                        if (ctrl.currentSubscribersSortType ===
                            SUBSCRIPTION_SORT_BY_KEYS.IMPACT) {
                            value = (value || 0);
                        }
                        return value;
                    };
                    var _fetchMessages = function (threadId) {
                        $http.get('/threadhandler/' + threadId).then(function (response) {
                            var allThreads = ctrl.mySuggestionsList.concat(ctrl.suggestionsToReviewList);
                            for (var i = 0; i < allThreads.length; i++) {
                                if (allThreads[i].threadId === threadId) {
                                    allThreads[i].setMessages(response.data.messages);
                                    break;
                                }
                            }
                        });
                    };
                    ctrl.clearActiveThread = function () {
                        ctrl.activeThread = null;
                    };
                    ctrl.setActiveThread = function (threadId) {
                        _fetchMessages(threadId);
                        for (var i = 0; i < ctrl.mySuggestionsList.length; i++) {
                            if (ctrl.mySuggestionsList[i].threadId === threadId) {
                                ctrl.activeThread = ctrl.mySuggestionsList[i];
                                ctrl.canReviewActiveThread = false;
                                break;
                            }
                        }
                        if (!ctrl.activeThread) {
                            for (var i = 0; i < ctrl.suggestionsToReviewList.length; i++) {
                                if (ctrl.suggestionsToReviewList[i].threadId === threadId) {
                                    ctrl.activeThread = ctrl.suggestionsToReviewList[i];
                                    ctrl.canReviewActiveThread = true;
                                    break;
                                }
                            }
                        }
                    };
                    ctrl.showSuggestionModal = function () {
                        SuggestionModalForCreatorDashboardService.showSuggestionModal(ctrl.activeThread.suggestion.suggestionType, {
                            activeThread: ctrl.activeThread,
                            suggestionsToReviewList: ctrl.suggestionsToReviewList,
                            clearActiveThread: ctrl.clearActiveThread,
                            canReviewActiveThread: ctrl.canReviewActiveThread
                        });
                    };
                    ctrl.sortByFunction = function (entity) {
                        // This function is passed as a custom comparator function to
                        // `orderBy`, so that special cases can be handled while sorting
                        // explorations.
                        var value = entity[ctrl.currentSortType];
                        if (entity.status === 'private') {
                            if (ctrl.currentSortType === EXPLORATIONS_SORT_BY_KEYS.TITLE) {
                                value = (value || ctrl.DEFAULT_EMPTY_TITLE);
                            }
                            else if (ctrl.currentSortType !==
                                EXPLORATIONS_SORT_BY_KEYS.LAST_UPDATED) {
                                value = 0;
                            }
                        }
                        else if (ctrl.currentSortType === EXPLORATIONS_SORT_BY_KEYS.RATING) {
                            var averageRating = ctrl.getAverageRating(value);
                            value = (averageRating || 0);
                        }
                        return value;
                    };
                    ctrl.getCompleteThumbnailIconUrl = function (iconUrl) {
                        return UrlInterpolationService.getStaticImageUrl(iconUrl);
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.module.ts":
/*!***********************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.module.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Module for the collection player page.
 */
__webpack_require__(/*! core-js/es7/reflect */ "./node_modules/core-js/es7/reflect.js");
__webpack_require__(/*! zone.js */ "./node_modules/zone.js/dist/zone.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var platform_browser_1 = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm5/platform-browser.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var http_1 = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
// This component is needed to force-bootstrap Angular at the beginning of the
// app.
var ServiceBootstrapComponent = /** @class */ (function () {
    function ServiceBootstrapComponent() {
    }
    ServiceBootstrapComponent = __decorate([
        core_1.Component({
            selector: 'service-bootstrap',
            template: ''
        })
    ], ServiceBootstrapComponent);
    return ServiceBootstrapComponent;
}());
exports.ServiceBootstrapComponent = ServiceBootstrapComponent;
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var classifiers_extension_constants_1 = __webpack_require__(/*! classifiers/classifiers-extension.constants */ "./extensions/classifiers/classifiers-extension.constants.ts");
var collection_summary_tile_constants_1 = __webpack_require__(/*! components/summary-tile/collection-summary-tile.constants */ "./core/templates/dev/head/components/summary-tile/collection-summary-tile.constants.ts");
var interactions_extension_constants_1 = __webpack_require__(/*! interactions/interactions-extension.constants */ "./extensions/interactions/interactions-extension.constants.ts");
var objects_domain_constants_1 = __webpack_require__(/*! domain/objects/objects-domain.constants */ "./core/templates/dev/head/domain/objects/objects-domain.constants.ts");
var services_constants_1 = __webpack_require__(/*! services/services.constants */ "./core/templates/dev/head/services/services.constants.ts");
var creator_dashboard_page_constants_1 = __webpack_require__(/*! pages/creator-dashboard-page/creator-dashboard-page.constants */ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.constants.ts");
var CreatorDashboardPageModule = /** @class */ (function () {
    function CreatorDashboardPageModule() {
    }
    // Empty placeholder method to satisfy the `Compiler`.
    CreatorDashboardPageModule.prototype.ngDoBootstrap = function () { };
    CreatorDashboardPageModule = __decorate([
        core_1.NgModule({
            imports: [
                platform_browser_1.BrowserModule,
                http_1.HttpClientModule
            ],
            declarations: [
                ServiceBootstrapComponent
            ],
            entryComponents: [
                ServiceBootstrapComponent
            ],
            providers: [
                app_constants_1.AppConstants,
                classifiers_extension_constants_1.ClassifiersExtensionConstants,
                collection_summary_tile_constants_1.CollectionSummaryTileConstants,
                interactions_extension_constants_1.InteractionsExtensionsConstants,
                objects_domain_constants_1.ObjectsDomainConstants,
                services_constants_1.ServicesConstants,
                creator_dashboard_page_constants_1.CreatorDashboardConstants
            ]
        })
    ], CreatorDashboardPageModule);
    return CreatorDashboardPageModule;
}());
var platform_browser_dynamic_1 = __webpack_require__(/*! @angular/platform-browser-dynamic */ "./node_modules/@angular/platform-browser-dynamic/fesm5/platform-browser-dynamic.js");
var static_2 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var bootstrapFn = function (extraProviders) {
    var platformRef = platform_browser_dynamic_1.platformBrowserDynamic(extraProviders);
    return platformRef.bootstrapModule(CreatorDashboardPageModule);
};
var downgradedModule = static_2.downgradeModule(bootstrapFn);
angular.module('oppia', [
    'dndLists', 'headroom', 'infinite-scroll', 'ngAnimate',
    'ngAudio', 'ngCookies', 'ngImgCrop', 'ngJoyRide', 'ngMaterial',
    'ngResource', 'ngSanitize', 'ngTouch', 'pascalprecht.translate',
    'toastr', 'ui.bootstrap', 'ui.sortable', 'ui.tree', 'ui.validate',
    downgradedModule
])
    // This directive is the downgraded version of the Angular component to
    // bootstrap the Angular 8.
    .directive('serviceBootstrap', static_1.downgradeComponent({
    component: ServiceBootstrapComponent
}));


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.scripts.ts":
/*!************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.scripts.ts ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive scripts for the creator dashboard.
 */
// The module needs to be loaded before everything else since it defines the
// main module the elements are attached to.
__webpack_require__(/*! pages/creator-dashboard-page/creator-dashboard-page.module.ts */ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.module.ts");
__webpack_require__(/*! App.ts */ "./core/templates/dev/head/App.ts");
__webpack_require__(/*! pages/creator-dashboard-page/creator-dashboard-page.controller.ts */ "./core/templates/dev/head/pages/creator-dashboard-page/creator-dashboard-page.controller.ts");


/***/ }),

/***/ "./core/templates/dev/head/pages/creator-dashboard-page/suggestion-modal-for-creator-view/suggestion-modal-for-creator-view.service.ts":
/*!*********************************************************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/creator-dashboard-page/suggestion-modal-for-creator-view/suggestion-modal-for-creator-view.service.ts ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Service to display suggestion modal in creator view.
 */
__webpack_require__(/*! components/ck-editor-helpers/ck-editor-4-rte.directive.ts */ "./core/templates/dev/head/components/ck-editor-helpers/ck-editor-4-rte.directive.ts");
__webpack_require__(/*! components/ck-editor-helpers/ck-editor-4-widgets.initializer.ts */ "./core/templates/dev/head/components/ck-editor-helpers/ck-editor-4-widgets.initializer.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/SuggestionModalService.ts */ "./core/templates/dev/head/services/SuggestionModalService.ts");
angular.module('oppia').factory('SuggestionModalForCreatorDashboardService', [
    '$http', '$log',
    '$uibModal', 'UrlInterpolationService',
    function ($http, $log, $uibModal, UrlInterpolationService) {
        var _templateUrl = UrlInterpolationService.getDirectiveTemplateUrl('/pages/creator-dashboard-page/suggestion-modal-for-creator-view/' +
            'suggestion-modal-for-creator-view.directive.html');
        var _showEditStateContentSuggestionModal = function (activeThread, suggestionsToReviewList, clearActiveThread, canReviewActiveThread) {
            $uibModal.open({
                templateUrl: _templateUrl,
                backdrop: true,
                size: 'lg',
                resolve: {
                    suggestionIsHandled: function () {
                        return activeThread.isSuggestionHandled();
                    },
                    suggestionStatus: function () {
                        return activeThread.getSuggestionStatus();
                    },
                    description: function () {
                        return activeThread.description;
                    },
                    oldContent: function () {
                        return activeThread.suggestion.oldValue;
                    },
                    newContent: function () {
                        return activeThread.suggestion.newValue;
                    },
                    canReviewActiveThread: function () {
                        return canReviewActiveThread;
                    },
                    stateName: function () {
                        return activeThread.suggestion.stateName;
                    },
                    suggestionType: function () {
                        return activeThread.suggestion.suggestionType;
                    }
                },
                controller: [
                    '$log', '$scope', '$uibModalInstance', 'SuggestionModalService',
                    'canReviewActiveThread', 'description', 'newContent', 'oldContent',
                    'stateName', 'suggestionIsHandled', 'suggestionStatus',
                    'suggestionType',
                    function ($log, $scope, $uibModalInstance, SuggestionModalService, canReviewActiveThread, description, newContent, oldContent, stateName, suggestionIsHandled, suggestionStatus, suggestionType) {
                        $scope.isNotHandled = !suggestionIsHandled;
                        $scope.canReject = $scope.isNotHandled;
                        $scope.canAccept = $scope.isNotHandled;
                        if (!$scope.isNotHandled) {
                            if (suggestionStatus === (SuggestionModalService.SUGGESTION_ACCEPTED)) {
                                $scope.errorMessage = SuggestionModalService
                                    .SUGGESTION_ACCEPTED_MSG;
                                $scope.isSuggestionRejected = false;
                            }
                            else {
                                $scope.errorMessage = SuggestionModalService
                                    .SUGGESTION_REJECTED_MSG;
                                $scope.isSuggestionRejected = true;
                            }
                        }
                        else {
                            $scope.errorMessage = '';
                        }
                        $scope.oldContent = oldContent;
                        $scope.newContent = newContent;
                        $scope.stateName = stateName;
                        $scope.suggestionType = suggestionType;
                        $scope.commitMessage = description;
                        $scope.reviewMessage = null;
                        $scope.summaryMessage = null;
                        $scope.canReviewActiveThread = canReviewActiveThread;
                        // ng-model needs to bind to a property of an object on
                        // the scope (the property cannot sit directly on the scope)
                        // Reference https://stackoverflow.com/q/12618342
                        $scope.suggestionData = { newSuggestionHtml: newContent.html };
                        $scope.suggestionEditorIsShown = false;
                        $scope.acceptSuggestion = function () {
                            SuggestionModalService.acceptSuggestion($uibModalInstance, {
                                action: SuggestionModalService.ACTION_ACCEPT_SUGGESTION,
                                commitMessage: $scope.commitMessage,
                                reviewMessage: $scope.reviewMessage,
                            });
                        };
                        $scope.rejectSuggestion = function () {
                            SuggestionModalService.rejectSuggestion($uibModalInstance, {
                                action: SuggestionModalService.ACTION_REJECT_SUGGESTION,
                                commitMessage: null,
                                reviewMessage: $scope.reviewMessage
                            });
                        };
                        $scope.editSuggestion = function () {
                            $scope.suggestionEditorIsShown = true;
                        };
                        $scope.cancel = function () {
                            SuggestionModalService.cancelSuggestion($uibModalInstance);
                        };
                        $scope.isEditButtonShown = function () {
                            return (!$scope.isNotHandled && $scope.isSuggestionRejected &&
                                !$scope.suggestionEditorIsShown);
                        };
                        $scope.isResubmitButtonShown = function () {
                            return (!$scope.isNotHandled && $scope.isSuggestionRejected &&
                                $scope.suggestionEditorIsShown);
                        };
                        $scope.isResubmitButtonDisabled = function () {
                            return !($scope.summaryMessage &&
                                ($scope.suggestionData.newSuggestionHtml.trim() !==
                                    newContent.html.trim()));
                        };
                        $scope.cancelEditMode = function () {
                            $scope.suggestionEditorIsShown = false;
                        };
                        $scope.resubmitChanges = function () {
                            $uibModalInstance.close({
                                action: SuggestionModalService.ACTION_RESUBMIT_SUGGESTION,
                                newSuggestionHtml: $scope.suggestionData.newSuggestionHtml,
                                summaryMessage: $scope.summaryMessage,
                                stateName: $scope.stateName,
                                suggestionType: $scope.suggestionType,
                                oldContent: $scope.oldContent
                            });
                        };
                    }
                ]
            }).result.then(function (result) {
                var RESUBMIT_SUGGESTION_URL_TEMPLATE = ('/suggestionactionhandler/resubmit/<suggestion_id>');
                var HANDLE_SUGGESTION_URL_TEMPLATE = ('/suggestionactionhandler/<target_type>/<target_id>/<suggestion_id>');
                var url = null;
                var data = null;
                if (result.action === 'resubmit' &&
                    result.suggestionType === 'edit_exploration_state_content') {
                    url = UrlInterpolationService.interpolateUrl(RESUBMIT_SUGGESTION_URL_TEMPLATE, {
                        suggestion_id: activeThread.suggestion.suggestionId
                    });
                    data = {
                        action: result.action,
                        summary_message: result.summaryMessage,
                        change: {
                            cmd: 'edit_state_property',
                            property_name: 'content',
                            state_name: result.stateName,
                            old_value: result.oldContent,
                            new_value: {
                                html: result.newSuggestionHtml
                            }
                        }
                    };
                }
                else {
                    url = UrlInterpolationService.interpolateUrl(HANDLE_SUGGESTION_URL_TEMPLATE, {
                        target_type: activeThread.suggestion.targetType,
                        target_id: activeThread.suggestion.targetId,
                        suggestion_id: activeThread.suggestion.suggestionId
                    });
                    data = {
                        action: result.action,
                        commit_message: result.commitMessage,
                        review_message: result.reviewMessage
                    };
                }
                $http.put(url, data).then(function () {
                    for (var i = 0; i < suggestionsToReviewList.length; i++) {
                        if (suggestionsToReviewList[i] === activeThread) {
                            suggestionsToReviewList.splice(i, 1);
                            break;
                        }
                    }
                    clearActiveThread();
                }, function () {
                    $log.error('Error resolving suggestion');
                });
            });
        };
        return {
            showSuggestionModal: function (suggestionType, extraParams) {
                if (suggestionType === 'edit_exploration_state_content') {
                    _showEditStateContentSuggestionModal(extraParams.activeThread, extraParams.suggestionsToReviewList, extraParams.clearActiveThread, extraParams.canReviewActiveThread);
                }
            }
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/pages/exploration-editor-page/editor-tab/services/solution-validity.service.ts":
/*!****************************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/exploration-editor-page/editor-tab/services/solution-validity.service.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Service for keeping track of solution validity.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var SolutionValidityService = /** @class */ (function () {
    function SolutionValidityService() {
        this.solutionValidities = {};
    }
    SolutionValidityService.prototype.init = function (stateNames) {
        var _this = this;
        stateNames.forEach(function (stateName) {
            _this.solutionValidities[stateName] = true;
        });
    };
    SolutionValidityService.prototype.deleteSolutionValidity = function (stateName) {
        delete this.solutionValidities[stateName];
    };
    SolutionValidityService.prototype.onRenameState = function (newStateName, oldStateName) {
        this.solutionValidities[newStateName] =
            this.solutionValidities[oldStateName];
        this.deleteSolutionValidity(oldStateName);
    };
    SolutionValidityService.prototype.updateValidity = function (stateName, solutionIsValid) {
        this.solutionValidities[stateName] = solutionIsValid;
    };
    SolutionValidityService.prototype.isSolutionValid = function (stateName) {
        if (this.solutionValidities.hasOwnProperty(stateName)) {
            return this.solutionValidities[stateName];
        }
    };
    SolutionValidityService.prototype.getAllValidities = function () {
        return this.solutionValidities;
    };
    SolutionValidityService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], SolutionValidityService);
    return SolutionValidityService;
}());
exports.SolutionValidityService = SolutionValidityService;
angular.module('oppia').factory('SolutionValidityService', static_1.downgradeInjectable(SolutionValidityService));


/***/ }),

/***/ "./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts":
/*!**********************************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Service that provides information about how to display the
 * status label for a thread in the feedback tab of the exploration editor.
 */
var cloneDeep_1 = __importDefault(__webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"));
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var ThreadStatusDisplayService = /** @class */ (function () {
    function ThreadStatusDisplayService() {
        this.STATUS_CHOICES = cloneDeep_1.default(ThreadStatusDisplayService_1._STATUS_CHOICES);
    }
    ThreadStatusDisplayService_1 = ThreadStatusDisplayService;
    ThreadStatusDisplayService.prototype.getLabelClass = function (status) {
        if (status === 'open') {
            return 'label label-info';
        }
        else if (status === 'compliment') {
            return 'label label-success';
        }
        else {
            return 'label label-default';
        }
    };
    ThreadStatusDisplayService.prototype.getHumanReadableStatus = function (status) {
        for (var i = 0; i < ThreadStatusDisplayService_1._STATUS_CHOICES.length; i++) {
            if (ThreadStatusDisplayService_1._STATUS_CHOICES[i].id === status) {
                return ThreadStatusDisplayService_1._STATUS_CHOICES[i].text;
            }
        }
        return '';
    };
    var ThreadStatusDisplayService_1;
    ThreadStatusDisplayService._STATUS_CHOICES = [{
            id: 'open',
            text: 'Open'
        }, {
            id: 'fixed',
            text: 'Fixed'
        }, {
            id: 'ignored',
            text: 'Ignored'
        }, {
            id: 'compliment',
            text: 'Compliment'
        }, {
            id: 'not_actionable',
            text: 'Not Actionable'
        }];
    ThreadStatusDisplayService = ThreadStatusDisplayService_1 = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], ThreadStatusDisplayService);
    return ThreadStatusDisplayService;
}());
exports.ThreadStatusDisplayService = ThreadStatusDisplayService;
angular.module('oppia').factory('ThreadStatusDisplayService', static_1.downgradeInjectable(ThreadStatusDisplayService));


/***/ }),

/***/ "./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/thread-table/thread-table.directive.ts":
/*!*******************************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/thread-table/thread-table.directive.ts ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for displaying the list of threads in the feedback
 * tab of the exploration editor.
 */
__webpack_require__(/*! filters/string-utility-filters/truncate.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts */ "./core/templates/dev/head/pages/exploration-editor-page/feedback-tab/services/thread-status-display.service.ts");
__webpack_require__(/*! services/DateTimeFormatService.ts */ "./core/templates/dev/head/services/DateTimeFormatService.ts");
angular.module('oppia').directive('threadTable', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {
                onClickRow: '=',
                getThreads: '&threads'
            },
            templateUrl: UrlInterpolationService.getDirectiveTemplateUrl('/pages/exploration-editor-page/feedback-tab/thread-table/' +
                'thread-table.directive.html'),
            controller: [
                '$scope', 'ThreadStatusDisplayService', 'DateTimeFormatService',
                function ($scope, ThreadStatusDisplayService, DateTimeFormatService) {
                    $scope.getLabelClass = ThreadStatusDisplayService.getLabelClass;
                    $scope.getHumanReadableStatus = (ThreadStatusDisplayService.getHumanReadableStatus);
                    $scope.getLocaleAbbreviatedDatetimeString = (DateTimeFormatService.getLocaleAbbreviatedDatetimeString);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts":
/*!*******************************************************************************************************!*\
  !*** ./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Facilitates communication between the current interaction
 * and the progress nav. The former holds data about the learner's answer,
 * while the latter contains the actual "Submit" button which triggers the
 * answer submission process.
 */
__webpack_require__(/*! components/state-editor/state-editor-properties-services/state-editor.service.ts */ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-editor.service.ts");
__webpack_require__(/*! components/state-editor/state-editor-properties-services/state-interaction-id.service.ts */ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-interaction-id.service.ts");
__webpack_require__(/*! components/state-editor/state-editor-properties-services/state-property.service.ts */ "./core/templates/dev/head/components/state-editor/state-editor-properties-services/state-property.service.ts");
__webpack_require__(/*! services/ContextService.ts */ "./core/templates/dev/head/services/ContextService.ts");
angular.module('oppia').factory('CurrentInteractionService', [
    'ContextService', 'StateEditorService', 'StateInteractionIdService', function (ContextService, StateEditorService, StateInteractionIdService) {
        var _submitAnswerFn = null;
        var _onSubmitFn = null;
        var _validityCheckFn = null;
        var _presubmitHooks = [];
        return {
            setOnSubmitFn: function (onSubmit) {
                /**
                 * The ConversationSkinDirective should register its onSubmit
                 * callback here.
                 *
                 * @param {function(answer, interactionRulesService)} onSubmit
                 */
                _onSubmitFn = onSubmit;
            },
            registerCurrentInteraction: function (submitAnswerFn, validityCheckFn) {
                /**
                 * Each interaction directive should call registerCurrentInteraction
                 * when the interaction directive is first created.
                 *
                 * @param {function|null} submitAnswerFn - Should grab the learner's
                 *   answer and pass it to onSubmit. The interaction can pass in
                 *   null if it does not use the progress nav's submit button
                 *   (ex: MultipleChoiceInput).
                 * @param {function} validityCheckFn - The progress nav will use this
                 *   to decide whether or not to disable the submit button. If the
                 *   interaction passes in null, the submit button will remain
                 *   enabled (for the entire duration of the current interaction).
                 */
                _submitAnswerFn = submitAnswerFn || null;
                _validityCheckFn = validityCheckFn || null;
            },
            registerPresubmitHook: function (hookFn) {
                /* Register a hook that will be called right before onSubmit.
                 * All hooks for the current interaction will be cleared right
                 * before loading the next card.
                 */
                _presubmitHooks.push(hookFn);
            },
            clearPresubmitHooks: function () {
                /* Clear out all the hooks for the current interaction. Should
                 * be called before loading the next card.
                 */
                _presubmitHooks = [];
            },
            onSubmit: function (answer, interactionRulesService) {
                for (var i = 0; i < _presubmitHooks.length; i++) {
                    _presubmitHooks[i]();
                }
                _onSubmitFn(answer, interactionRulesService);
            },
            submitAnswer: function () {
                /* This starts the answer submit process, it should be called once the
                 * learner presses the "Submit" button.
                 */
                if (_submitAnswerFn === null) {
                    var additionalInfo = ('\nUndefined submit answer debug logs:' +
                        '\nInteraction ID: ' + StateInteractionIdService.savedMemento +
                        '\nExploration ID: ' + ContextService.getExplorationId() +
                        '\nState name: ' + StateEditorService.getActiveStateName());
                    throw Error('The current interaction did not ' +
                        'register a _submitAnswerFn.' + additionalInfo);
                }
                else {
                    _submitAnswerFn();
                }
            },
            isSubmitButtonDisabled: function () {
                /* Returns whether or not the Submit button should be disabled based on
                 * the validity of the current answer. If the interaction does not pass
                 * in a _validityCheckFn, then _validityCheckFn will be null and by
                 * default we assume the answer is valid, so the submit button should
                 * not be disabled.
                 */
                if (_validityCheckFn === null) {
                    return false;
                }
                return !_validityCheckFn();
            },
        };
    }
]);


/***/ }),

/***/ "./core/templates/dev/head/services/CodeNormalizerService.ts":
/*!*******************************************************************!*\
  !*** ./core/templates/dev/head/services/CodeNormalizerService.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Service for code normalization. Used by the code REPL
 * and pencil code interactions.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var CodeNormalizerService = /** @class */ (function () {
    function CodeNormalizerService() {
    }
    CodeNormalizerService.prototype.removeLeadingWhitespace = function (str) {
        return str.replace(/^\s+/g, '');
    };
    CodeNormalizerService.prototype.removeTrailingWhitespace = function (str) {
        return str.replace(/\s+$/g, '');
    };
    CodeNormalizerService.prototype.removeIntermediateWhitespace = function (str) {
        return str.replace(/\s+/g, ' ');
    };
    CodeNormalizerService.prototype.getNormalizedCode = function (codeString) {
        var _this = this;
        /*
         * Normalizes a code string (which is assumed not to contain tab
         * characters). In particular:
         *
         * - Strips out lines that start with '#' (comments), possibly preceded by
         *     whitespace.
         * - Trims trailing whitespace on each line, and normalizes multiple
         *     whitespace characters within a single line into one space
         *     character.
         * - Removes blank newlines.
         * - Make the indentation level four spaces.
         */
        // TODO(sll): Augment this function to strip out comments that occur at
        // the end of a line. However, be careful with lines where '#' is
        // contained in quotes or the character is escaped.
        var FOUR_SPACES = '    ';
        // Maps the number of spaces at the beginning of a line to an int
        // specifying the desired indentation level.
        var numSpacesToDesiredIndentLevel = {
            0: 0
        };
        var codeLines = this.removeTrailingWhitespace(codeString).split('\n');
        var normalizedCodeLines = [];
        codeLines.forEach(function (line) {
            if (_this.removeLeadingWhitespace(line).indexOf('#') === 0) {
                return;
            }
            line = _this.removeTrailingWhitespace(line);
            if (!line) {
                return;
            }
            var numSpaces = line.length - _this.removeLeadingWhitespace(line).length;
            var existingNumSpaces = Object.keys(numSpacesToDesiredIndentLevel);
            var maxNumSpaces = Math.max.apply(null, existingNumSpaces);
            if (numSpaces > maxNumSpaces) {
                // Add a new indentation level
                numSpacesToDesiredIndentLevel[numSpaces] = existingNumSpaces.length;
            }
            // This is set when the indentation level of the current line does not
            // start a new scope, and also does not match any previous indentation
            // level. This case is actually invalid, but for now, we take the
            // largest indentation level that is less than this one.
            // TODO(sll): Bad indentation should result in an error nearer the
            // source.
            var isShortfallLine = !numSpacesToDesiredIndentLevel.hasOwnProperty(numSpaces) &&
                numSpaces < maxNumSpaces;
            // Clear all existing indentation levels to the right of this one.
            for (var indentLength in numSpacesToDesiredIndentLevel) {
                if (Number(indentLength) > numSpaces) {
                    delete numSpacesToDesiredIndentLevel[indentLength];
                }
            }
            if (isShortfallLine) {
                existingNumSpaces = Object.keys(numSpacesToDesiredIndentLevel);
                numSpaces = Math.max.apply(null, existingNumSpaces);
            }
            var normalizedLine = '';
            for (var i = 0; i < numSpacesToDesiredIndentLevel[numSpaces]; i++) {
                normalizedLine += FOUR_SPACES;
            }
            normalizedLine += _this.removeIntermediateWhitespace(_this.removeLeadingWhitespace(line));
            normalizedCodeLines.push(normalizedLine);
        });
        return normalizedCodeLines.join('\n');
    };
    CodeNormalizerService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], CodeNormalizerService);
    return CodeNormalizerService;
}());
exports.CodeNormalizerService = CodeNormalizerService;
angular.module('oppia').factory('CodeNormalizerService', static_1.downgradeInjectable(CodeNormalizerService));


/***/ }),

/***/ "./core/templates/dev/head/services/SuggestionModalService.ts":
/*!********************************************************************!*\
  !*** ./core/templates/dev/head/services/SuggestionModalService.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Service to handle common code for suggestion modal display.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var SuggestionModalService = /** @class */ (function () {
    function SuggestionModalService() {
        this.SUGGESTION_ACCEPTED_MSG = ('This suggestion has already been accepted.');
        this.SUGGESTION_REJECTED_MSG = ('This suggestion has already been rejected.');
        this.SUGGESTION_INVALID_MSG = ('This suggestion was made for a state that no longer exists.' +
            ' It cannot be accepted.');
        this.UNSAVED_CHANGES_MSG = ('You have unsaved changes to this exploration. Please save/discard your ' +
            'unsaved changes if you wish to accept.');
        this.ACTION_ACCEPT_SUGGESTION = 'accept';
        this.ACTION_REJECT_SUGGESTION = 'reject';
        this.ACTION_RESUBMIT_SUGGESTION = 'resubmit';
        this.SUGGESTION_ACCEPTED = 'accepted';
        this.SUGGESTION_REJECTED = 'rejected';
    }
    // TODO(YashJipkate): Replace 'any' with the exact type. This has been kept as
    // 'any' since '$uibModalInstance' is a AngularJS native object and does not
    // have a TS interface.
    SuggestionModalService.prototype.acceptSuggestion = function ($uibModalInstance, paramDict) {
        $uibModalInstance.close(paramDict);
    };
    // TODO(YashJipkate): Replace 'any' with the exact type. This has been kept as
    // 'any' since '$uibModalInstance' is a AngularJS native object and does not
    // have a TS interface.
    SuggestionModalService.prototype.rejectSuggestion = function ($uibModalInstance, paramDict) {
        $uibModalInstance.close(paramDict);
    };
    // TODO(YashJipkate): Replace 'any' with the exact type. This has been kept as
    // 'any' since '$uibModalInstance' is a AngularJS native object and does not
    // have a TS interface.
    SuggestionModalService.prototype.cancelSuggestion = function ($uibModalInstance) {
        $uibModalInstance.dismiss('cancel');
    };
    SuggestionModalService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], SuggestionModalService);
    return SuggestionModalService;
}());
exports.SuggestionModalService = SuggestionModalService;
angular.module('oppia').factory('SuggestionModalService', static_1.downgradeInjectable(SuggestionModalService));


/***/ }),

/***/ "./extensions/classifiers/classifiers-extension.constants.ajs.ts":
/*!***********************************************************************!*\
  !*** ./extensions/classifiers/classifiers-extension.constants.ajs.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for classfiers extensions.
 */
// TODO(#7092): Delete this file once migration is complete and these AngularJS
// equivalents of the Angular constants are no longer needed.
var classifiers_extension_constants_1 = __webpack_require__(/*! classifiers/classifiers-extension.constants */ "./extensions/classifiers/classifiers-extension.constants.ts");
angular.module('oppia').constant('PythonProgramTokenType', classifiers_extension_constants_1.ClassifiersExtensionConstants.PythonProgramTokenType);


/***/ }),

/***/ "./extensions/classifiers/classifiers-extension.constants.ts":
/*!*******************************************************************!*\
  !*** ./extensions/classifiers/classifiers-extension.constants.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for classfiers extensions.
 */
var ClassifiersExtensionConstants = /** @class */ (function () {
    function ClassifiersExtensionConstants() {
    }
    ClassifiersExtensionConstants.PythonProgramTokenType = {
        COMMENT: 'COMMENT',
        NL: 'NL',
        STRING: 'STRING',
        INDENT: 'INDENT',
        DEDENT: 'DEDENT',
        ENDMARKER: 'ENDMARKER',
        NUMBER: 'NUMBER',
        NAME: 'NAME',
        OP: 'OP',
        ERRORTOKEN: 'ERRORTOKEN'
    };
    return ClassifiersExtensionConstants;
}());
exports.ClassifiersExtensionConstants = ClassifiersExtensionConstants;


/***/ }),

/***/ "./extensions/classifiers/count-vectorizer.service.ts":
/*!************************************************************!*\
  !*** ./extensions/classifiers/count-vectorizer.service.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Vectorizer function which mirrors the CountVectorizer feature
 * extractor of sklearn.
 *
 * IMPORTANT NOTE: The Vectorizer function uses the vocabulary that was
 * extracted during the training. During training scikit's
 * CountVectorizer class is used for this purpose. If there are any changes
 * in scikit's CountVectorize class then corresponding changes must be
 * propagated here.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var CountVectorizerService = /** @class */ (function () {
    function CountVectorizerService() {
    }
    CountVectorizerService.prototype.vectorize = function (tokens, vocabulary) {
        var vectorLength = Object.keys(vocabulary).length;
        var vector = [];
        for (var i = 0; i < vectorLength; i++) {
            vector.push(0);
        }
        if (tokens === null) {
            return vector;
        }
        tokens.forEach(function (token) {
            if (vocabulary.hasOwnProperty(token)) {
                vector[vocabulary[token]] += 1;
            }
        });
        return vector;
    };
    CountVectorizerService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], CountVectorizerService);
    return CountVectorizerService;
}());
exports.CountVectorizerService = CountVectorizerService;
angular.module('oppia').factory('CountVectorizerService', static_1.downgradeInjectable(CountVectorizerService));


/***/ }),

/***/ "./extensions/classifiers/python-program.tokenizer.ts":
/*!************************************************************!*\
  !*** ./extensions/classifiers/python-program.tokenizer.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Tokenizer for Python code.
 *
 * IMPORTANT NOTE: The tokenizer is built using Python's own tokenizer module.
 * These functions are simply translated from Python code to JS code and they
 * both do same task. The unnecessary code from Python's tokenizer module
 * has been removed before translating it into JS and code relevant to
 * generating tokens has been kept intact. If Python version changes on Oppia-ml
 * then changes in Python's tokenizer module must be propagated here.
 *
 * Python's tokenizer module for Python version 2.7:
 * https://github.com/python/cpython/blob/2.7/Lib/tokenize.py
 */
__webpack_require__(/*! classifiers/classifiers-extension.constants.ajs.ts */ "./extensions/classifiers/classifiers-extension.constants.ajs.ts");
angular.module('oppia').factory('PythonProgramTokenizer', [
    '$log', 'PythonProgramTokenType', function ($log, PythonProgramTokenType) {
        var groupOfRegEx = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return '(' + Array.prototype.join.call(params, '|') + ')';
        };
        var regExMayBePresent = function (params) {
            return groupOfRegEx(params) + '?';
        };
        var repeatedRegEx = function (params) {
            return groupOfRegEx(params) + '*';
        };
        var whitespace = '[ \\f\\t]*';
        var comment = '#[^\\r\\n]*';
        var ignore = whitespace + repeatedRegEx('\\\\\\r?\\n' + whitespace) + regExMayBePresent(comment);
        var name = '[a-zA-Z_]\\w*';
        var hexnumber = '0[xX][\\da-fA-F]+[lL]?';
        var octnumber = '(0[oO][0-7]+)|(0[0-7]*)[lL]?';
        var binnumber = '0[bB][01]+[lL]?';
        var decnumber = '[1-9]\\d*[lL]?';
        var intnumber = groupOfRegEx(hexnumber, binnumber, octnumber, decnumber);
        var exponent = '[eE][-+]?\\d+';
        var pointfloat = groupOfRegEx('\\d+\\.\\d*', '\\\\d+\\\\.\\\\d*') + regExMayBePresent(exponent);
        var expfloat = '\\d+' + exponent;
        var floatnumber = groupOfRegEx(pointfloat, expfloat);
        var imagnumber = groupOfRegEx('\\d+[jJ]', floatnumber + '[jJ]');
        var num = groupOfRegEx(imagnumber, floatnumber, intnumber);
        // Tail end of ' string.
        var single = '[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'';
        // Tail end of " string.
        var doubleQuote = '[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
        // Tail end of ''' string.
        var single3 = "[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
        // Tail end of """ string.
        var double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
        var triple = groupOfRegEx("[uUbB]?[rR]?'''", '[uUbB]?[rR]?"""');
        // single-line ' or " string.
        var str = groupOfRegEx("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
        // Because of leftmost-then-longest match semantics, be sure to put the
        // longest operators first (e.g., if = came before ==, == would get
        // recognized as two instances of =).
        var operator = groupOfRegEx('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '[+\\-*/%&|^=<>]=?', '~');
        var bracket = '[(){}]';
        var special = groupOfRegEx('\\r?\\n', '[:;.,\\`@]');
        var funny = groupOfRegEx(operator, bracket, special);
        var plaintoken = groupOfRegEx(num, funny, str, name);
        var token = ignore + plaintoken;
        // First (or only) line of ' or " string.
        var contStr = groupOfRegEx("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'" +
            groupOfRegEx("'", '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' +
            groupOfRegEx('"', '\\\\\\r?\\n'));
        var pseudoextras = groupOfRegEx('\\\\\\r?\\n|\\Z', comment, triple);
        var pseudotoken = whitespace + groupOfRegEx(pseudoextras, num, funny, contStr, name);
        // Regular Expression object.
        var tokenprog = new RegExp(token);
        var pseudoprog = new RegExp(pseudotoken);
        var single3prog = new RegExp(single3);
        var double3prog = new RegExp(double3);
        var endprogs = {
            "'": new RegExp(single), '"': new RegExp(doubleQuote),
            "'''": single3prog, '"""': double3prog,
            "r'''": single3prog, 'r"""': double3prog,
            "u'''": single3prog, 'u"""': double3prog,
            "ur'''": single3prog, 'ur"""': double3prog,
            "R'''": single3prog, 'R"""': double3prog,
            "U'''": single3prog, 'U"""': double3prog,
            "uR'''": single3prog, 'uR"""': double3prog,
            "Ur'''": single3prog, 'Ur"""': double3prog,
            "UR'''": single3prog, 'UR"""': double3prog,
            "b'''": single3prog, 'b"""': double3prog,
            "br'''": single3prog, 'br"""': double3prog,
            "B'''": single3prog, 'B"""': double3prog,
            "bR'''": single3prog, 'bR"""': double3prog,
            "Br'''": single3prog, 'Br"""': double3prog,
            "BR'''": single3prog, 'BR"""': double3prog,
            r: null, R: null, u: null, U: null,
            b: null, B: null
        };
        var tripleQuoted = [
            "'''", '"""', "r'''", 'r"""', "R'''", 'R"""',
            "u'''", 'u"""', "U'''", 'U"""', "ur'''", 'ur"""', "Ur'''", 'Ur"""',
            "uR'''", 'uR"""', "UR'''", 'UR"""', "b'''", 'b"""', "B'''", 'B"""',
            "br'''", 'br"""', "Br'''", 'Br"""', "bR'''", 'bR"""', "BR'''", 'BR"""'
        ];
        var singleQuoted = [
            "'", '"', "r'", 'r"', "R'", 'R"', "u'", 'u"', "U'", 'U"', "ur'",
            'ur"', "Ur'", 'Ur"', "uR'", 'uR"', "UR'", 'UR"', "b'", 'b"', "B'", 'B"',
            "br'", 'br"', "Br'", 'Br"', "bR'", 'bR"', "BR'", 'BR"'
        ];
        var tabsize = 8;
        return {
            generateTokens: function (program) {
                var tokenizedProgram = [];
                var lnum = 0;
                var parenlev = 0;
                var continued = 0;
                var namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
                var numchars = '0123456789';
                var contstr = '';
                var needcont = 0;
                var contline = null;
                var indents = [0];
                var lcount = 0;
                var endprog = null;
                while (1) {
                    var line = program[lcount];
                    lcount++;
                    if (line === undefined) {
                        break;
                    }
                    var pos = 0;
                    var max = line.length;
                    if (contstr) {
                        if (!line) {
                            // Exception.
                            $log.error('EOF in multi-line string');
                        }
                        var endmatch = endprog.exec(line);
                        if (endmatch && endmatch.index === 0) {
                            token = endmatch[0];
                            pos = pos + token.length;
                            tokenizedProgram.push([PythonProgramTokenType.STRING, token]);
                            contstr = '';
                            needcont = 0;
                            contline = null;
                        }
                        else if (needcont && line.slice(-2) !== '\\\n' ||
                            line.slice(-3) !== '\\\r\n') {
                            tokenizedProgram.push([PythonProgramTokenType.ERRORTOKEN, contstr + line]);
                            contstr = '';
                            contline = null;
                            continue;
                        }
                        else {
                            contstr = contstr + line;
                            contline = contline + line;
                            continue;
                        }
                    }
                    else if (parenlev === 0 && !continued) {
                        // New statement.
                        if (!line) {
                            break;
                        }
                        var column = 0;
                        // Measure leading whitespace.
                        while (pos < max) {
                            if (line[pos] === ' ') {
                                column += 1;
                            }
                            else if (line[pos] === '\t') {
                                column = (column / tabsize + 1) * tabsize;
                            }
                            else if (line[pos] === '\f') {
                                column = 0;
                            }
                            else {
                                break;
                            }
                            pos += 1;
                        }
                        if (pos === max) {
                            break;
                        }
                        // Skip comments or blank lines.
                        if (('#\r\n').indexOf(line[pos]) !== -1) {
                            if (line[pos] === '#') {
                                var commentToken = line.slice(pos).replace('\\r\\n', '');
                                var nlPos = pos + commentToken.length;
                                tokenizedProgram.push([PythonProgramTokenType.COMMENT, commentToken]);
                                tokenizedProgram.push([PythonProgramTokenType.NL, line.slice(nlPos)]);
                            }
                            else {
                                var comment = PythonProgramTokenType.COMMENT;
                                var nl = PythonProgramTokenType.NL;
                                tokenizedProgram.push([
                                    PythonProgramTokenType.line[pos] === '#' ? comment : nl,
                                    line.slice(pos)
                                ]);
                            }
                            continue;
                        }
                        // Count indents or dedents.
                        if (column > indents[-1]) {
                            indents.push(column);
                            tokenizedProgram.push([PythonProgramTokenType.INDENT, line.slice(0, pos)]);
                        }
                        while (column < indents[-1]) {
                            if (indents.indexOf(column) === -1) {
                                $log.error('unindent does not match any outer indentation level');
                            }
                            indents = indents.slice(0, -1);
                            tokenizedProgram.push([PythonProgramTokenType.DEDENT, '']);
                        }
                    }
                    else {
                        // Continued statement.
                        if (!line) {
                            $log.error('EOF in multi-line statement');
                        }
                        continued = 0;
                    }
                    while (pos < max) {
                        var pseudomatch = pseudoprog.exec(line.slice(pos));
                        // Scan for tokens.
                        if (pseudomatch && pseudomatch.index === 0) {
                            var start = pos + pseudomatch[0].indexOf(pseudomatch[1]);
                            var end = start + pseudomatch[1].length;
                            pos = end;
                            if (start === end) {
                                continue;
                            }
                            var token = line.slice(start, end);
                            var initial = line[start];
                            // Ordinary number.
                            if (numchars.indexOf(initial) !== -1 ||
                                (initial === '.' && token !== '.')) {
                                tokenizedProgram.push([PythonProgramTokenType.NUMBER, token]);
                            }
                            else if ('\r\n'.indexOf(initial) !== -1) {
                                tokenizedProgram.push([PythonProgramTokenType.NL, token]);
                            }
                            else if (initial === '#') {
                                if (!token.endswith('\n')) {
                                    tokenizedProgram.push([PythonProgramTokenType.COMMENT, token]);
                                }
                            }
                            else if (tripleQuoted.indexOf(token) !== -1) {
                                endprog = endprogs[token];
                                endmatch = endprog.exec(line.slice(pos));
                                // All on one line.
                                if (endmatch) {
                                    pos = pos + endmatch[0].length;
                                    token = line.slice(start, pos);
                                    tokenizedProgram.push([PythonProgramTokenType.STRING, token]);
                                }
                                else {
                                    // Multiple lines.
                                    contstr = line.slice(start);
                                    contline = line;
                                    break;
                                }
                            }
                            else if (singleQuoted.indexOf(initial) !== -1 ||
                                singleQuoted.indexOf(token.slice(0, 2)) !== -1 ||
                                singleQuoted.indexOf(token.slice(0, 3)) !== -1) {
                                // Continued string.
                                if (token.slice(-1) === '\n') {
                                    endprog = (endprogs[initial] || endprogs[token[1]] ||
                                        endprogs[token[2]]);
                                    contstr = line.slice(start);
                                    needcont = 1;
                                    contline = line;
                                    break;
                                }
                                else {
                                    tokenizedProgram.push([PythonProgramTokenType.STRING, token]);
                                }
                            }
                            else if (namechars.indexOf(initial) !== -1) {
                                // Ordinary name
                                tokenizedProgram.push([PythonProgramTokenType.NAME, token]);
                            }
                            else if (initial === '\\') {
                                // Continued statement.
                                continued = 1;
                            }
                            else {
                                if ('([{'.indexOf(initial) !== -1) {
                                    parenlev += 1;
                                }
                                else if (')]}'.indexOf(initial) !== -1) {
                                    parenlev -= 1;
                                }
                                tokenizedProgram.push([PythonProgramTokenType.OP, token]);
                            }
                        }
                        else {
                            tokenizedProgram.push([PythonProgramTokenType.ERRORTOKEN, line[pos]]);
                            pos += 1;
                        }
                    }
                }
                // Pop remaining indent levels
                for (var indent in indents.slice(1)) {
                    tokenizedProgram.push([PythonProgramTokenType.DEDENT, '']);
                }
                tokenizedProgram.push([PythonProgramTokenType.ENDMARKER, '']);
                return tokenizedProgram;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/classifiers/svm-prediction.service.ts":
/*!**********************************************************!*\
  !*** ./extensions/classifiers/svm-prediction.service.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview SVM predict function for SVC classifier of sklearn.
 *
 * IMPORTANT NOTE: The predict function uses svm data that was extracted
 * after training of classifier on Oppia-ml. If there are any changes in
 * format of extracted data then corresponding changes must be propagated here.
 * Oppia-ml uses scikit's SVC class during training classifier which uses
 * libsvm's implementation. If there are any changes in following part of
 * code in libsvm then corresponding changes must be propagated here.
 *
 * libsvm's code for prediction:
 * https://github.com/arnaudsj/libsvm/blob/master/svm.cpp#L2481
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var PredictionResultObjectFactory_1 = __webpack_require__(/*! domain/classifier/PredictionResultObjectFactory */ "./core/templates/dev/head/domain/classifier/PredictionResultObjectFactory.ts");
var IKernelParams = /** @class */ (function () {
    function IKernelParams() {
    }
    return IKernelParams;
}());
exports.IKernelParams = IKernelParams;
var SVMPredictionService = /** @class */ (function () {
    function SVMPredictionService(predictionResultObjectFactory) {
        this.predictionResultObjectFactory = predictionResultObjectFactory;
    }
    SVMPredictionService.prototype.kernel = function (kernelParams, supportVectors, input) {
        var kernel = kernelParams.kernel;
        var kvalues = [];
        if (kernel === 'rbf') {
            var gamma = kernelParams.gamma;
            var vectorLength = input.length;
            for (var i = 0; i < supportVectors.length; i++) {
                var sum = 0;
                for (var j = 0; j < input.length; j++) {
                    sum += Math.pow((supportVectors[i][j] - input[j]), 2);
                }
                kvalues.push(Math.exp(-gamma * sum));
            }
        }
        else if (kernel === 'linear') {
            var vectorLength = input.length;
            for (var i = 0; i < supportVectors.length; i++) {
                var sum = 0;
                for (var j = 0; j < input.length; j++) {
                    sum += supportVectors[i][j] * input[j];
                }
                kvalues.push(sum);
            }
        }
        return kvalues;
    };
    // Find multiclass probabilities.
    // NOTE: This function is implemented as it is given in LibSVM.
    // For more information on exact approach used, read following paper:
    // https://www.csie.ntu.edu.tw/~cjlin/papers/svmprob/svmprob.pdf
    // Also take a look at implementation by LibSVM:
    // https://github.com/arnaudsj/libsvm/blob/master/svm.cpp#L1829
    SVMPredictionService.prototype.calculateMulticlassProbabilities = function (nClasses, pairwiseProb) {
        var Q = [];
        for (var i = 0; i < nClasses; i++) {
            Q.push([]);
            for (var j = 0; j < nClasses; j++) {
                Q[i].push(0);
            }
        }
        var Qp = [];
        for (var i = 0; i < nClasses; i++) {
            Qp.push(0);
        }
        var P = [];
        for (var i = 0; i < nClasses; i++) {
            P.push(0);
        }
        var maxIter = Math.max(100, nClasses);
        var eps = 0.005 / nClasses;
        for (var t = 0; t < nClasses; t++) {
            P[t] = 1.0 / nClasses;
            Q[t][t] = 0.0;
            for (var j = 0; j < t; j++) {
                Q[t][t] += pairwiseProb[j][t] * pairwiseProb[j][t];
                Q[t][j] = Q[j][t];
            }
            for (var j = t + 1; j < nClasses; j++) {
                Q[t][t] += pairwiseProb[j][t] * pairwiseProb[j][t];
                Q[t][j] = -pairwiseProb[j][t] * pairwiseProb[t][j];
            }
        }
        var iter = 0;
        for (iter = 0; iter < maxIter; iter++) {
            var pQp = 0.0;
            for (var t = 0; t < nClasses; t++) {
                Qp[t] = 0;
                for (var j = 0; j < nClasses; j++) {
                    Qp[t] += Q[t][j] * P[j];
                }
                pQp += P[t] * Qp[t];
            }
            var maxError = 0;
            for (var t = 0; t < nClasses; t++) {
                var error = Math.abs(Qp[t] - pQp);
                if (error > maxError) {
                    maxError = error;
                }
            }
            if (maxError < eps) {
                break;
            }
            for (var t = 0; t < nClasses; t++) {
                var diff = (-Qp[t] + pQp) / Q[t][t];
                P[t] += diff;
                pQp = ((pQp + diff * (diff * Q[t][t] + 2 * Qp[t])) /
                    (1 + diff) / (1 + diff));
                for (var j = 0; j < nClasses; j++) {
                    Qp[j] = (Qp[j] + diff * Q[t][j]) / (1 + diff);
                    P[j] /= (1 + diff);
                }
            }
        }
        if (iter >= maxIter) {
            console.warn('Exceeds maxIter in calculateMulticlassProbabilities');
        }
        return P;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'classifierData' is a dict with underscore_cased keys which
    // give tslint errors against underscore_casing in favor of camelCasing. Same
    // goes for 'input'.
    SVMPredictionService.prototype.predict = function (classifierData, input) {
        var nSupport = classifierData.n_support;
        var supportVectors = classifierData.support_vectors;
        var dualCoef = classifierData.dual_coef;
        var intercept = classifierData.intercept;
        var classes = classifierData.classes;
        var kernelParams = classifierData.kernel_params;
        var probA = classifierData.probA;
        var probB = classifierData.probB;
        var startIndices = [];
        startIndices[0] = 0;
        for (var i = 1; i < nSupport.length; i++) {
            startIndices[i] = startIndices[i - 1] + nSupport[i - 1];
        }
        if (supportVectors[0].length !== input.length) {
            // Support vector and input dimensions do not match.
            console.error('Dimension of support vectors and given input is different.');
        }
        // Find kernel values for supportVectors and given input. Assumes that
        // input has same dimension and data type as any of the supportVectors.
        var kvalues = this.kernel(kernelParams, supportVectors, input);
        var votes = [];
        for (var i = 0; i < classes.length; i++) {
            votes.push(0);
        }
        var pairwiseProb = [];
        for (var i = 0; i < classes.length; i++) {
            pairwiseProb.push([]);
            for (var j = 0; j < classes.length; j++) {
                pairwiseProb[i].push(0);
            }
        }
        var p = 0;
        for (var i = 0; i < classes.length; i++) {
            for (var j = i + 1; j < classes.length; j++) {
                var si = startIndices[i];
                var sj = startIndices[j];
                var ci = nSupport[i];
                var cj = nSupport[j];
                var minProb = 1e-7;
                var coef1 = dualCoef[j - 1];
                var coef2 = dualCoef[i];
                var sum = 0;
                for (var k = 0; k < ci; k++) {
                    sum += kvalues[si + k] * coef1[si + k];
                }
                for (var k = 0; k < cj; k++) {
                    sum += kvalues[sj + k] * coef2[sj + k];
                }
                // NOTE: libsvm substracts the intercept from sum in its prediction
                // function. Here intercept is added because sci-kit negates the
                // intercept before passing it on to libsvm for prediction.
                // For more info see github following issue:
                // https://github.com/oppia/oppia/issues/4166
                sum += intercept[p];
                // The following approach to calculate pairwise probabilities was
                // proposed by platt. For more info on LibSVM's implementation
                // of platt scaling, read following paper:
                // https://www.csie.ntu.edu.tw/~cjlin/papers/plattprob.pdf
                // Also take a look at following implementation by LibSVM:
                // https://github.com/arnaudsj/libsvm/blob/master/svm.cpp#L2552
                var f = probA[p] * sum + probB[p];
                var prob = 0;
                if (f >= 0) {
                    prob = Math.exp(-f) / (1 + Math.exp(-f));
                }
                else {
                    prob = 1 / (1 + Math.exp(f));
                }
                prob = Math.min(Math.max(prob, minProb), 1 - minProb);
                pairwiseProb[i][j] = prob;
                pairwiseProb[j][i] = 1 - prob;
                p++;
            }
        }
        var probabilities = this.calculateMulticlassProbabilities(classes.length, pairwiseProb);
        var maxProbIdx = 0;
        for (var i = 1; i < classes.length; i++) {
            if (probabilities[i] > probabilities[maxProbIdx]) {
                maxProbIdx = i;
            }
        }
        var predictedLabel = classes[maxProbIdx];
        var prediction = this.predictionResultObjectFactory.createNew(predictedLabel, probabilities[maxProbIdx]);
        return prediction;
    };
    var _a;
    SVMPredictionService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof PredictionResultObjectFactory_1.PredictionResultObjectFactory !== "undefined" && PredictionResultObjectFactory_1.PredictionResultObjectFactory) === "function" ? _a : Object])
    ], SVMPredictionService);
    return SVMPredictionService;
}());
exports.SVMPredictionService = SVMPredictionService;
angular.module('oppia').factory('SVMPredictionService', static_1.downgradeInjectable(SVMPredictionService));


/***/ }),

/***/ "./extensions/classifiers/text-input.tokenizer.ts":
/*!********************************************************!*\
  !*** ./extensions/classifiers/text-input.tokenizer.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Tokenizer for TextInput.
 *
 * Note: This is a simple tokenizer for tokenizing text input. The parameter
 * n_grams is used for deciding if we need to add n_gram tokens other than
 * the unigram tokens. As of now, we are only interested in unigrams but if
 * needed in the future, this tokenizer should be able to generate n-grams
 * also.
 *
 * For reference: https://github.com/scikit-learn/scikit-learn/
 *     blob/master/sklearn/feature_extraction/text.py#L541
 */
// TODO(anmol): Add functionality to add n_grams, remove stop words.
angular.module('oppia').factory('TextInputTokenizer', [function () {
        return {
            generateTokens: function (textInput) {
                var tokenizedTextInput;
                // The default regexp select tokens of 2 or more alphanumeric
                // characters (punctuation is completely ignored and always treated
                // as a token separator).
                var tokenPattern = '\\b\\w\\w+\\b';
                var regexp = new RegExp(tokenPattern, 'g');
                tokenizedTextInput = textInput.match(regexp);
                return tokenizedTextInput;
            }
        };
    }]);


/***/ }),

/***/ "./extensions/classifiers/winnowing-preprocessing.service.ts":
/*!*******************************************************************!*\
  !*** ./extensions/classifiers/winnowing-preprocessing.service.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Winnowing preprocessing functions.
 *
 * IMPORTANT NOTE: The preprocessing functions are implemented according to
 * winnowing preprocessing functions used on Oppia-ml. These functions
 * are simple translation of Python code to JS code and they both do exact
 * same task.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var WinnowingPreprocessingService = /** @class */ (function () {
    function WinnowingPreprocessingService() {
    }
    WinnowingPreprocessingService_1 = WinnowingPreprocessingService;
    WinnowingPreprocessingService.generateHashValue = function (tokens, tokenToId) {
        var hashVal = 0;
        var n = tokens.length - 1;
        var base = Math.pow(Object.keys(tokenToId).length, n);
        tokens.forEach(function (token) {
            hashVal += tokenToId[token] * base;
            base /= Object.keys(tokenToId).length;
        });
        return hashVal;
    };
    WinnowingPreprocessingService.prototype.getKGramHashes = function (tokens, tokenToId, K) {
        // Generate all possible k-gram hashes from tokens.
        var kGramHashes = [];
        var kTokens;
        for (var i = 0; i < tokens.length - K + 1; i += 1) {
            kTokens = tokens.slice(i, i + K);
            kGramHashes.push(WinnowingPreprocessingService_1.generateHashValue(kTokens, tokenToId));
        }
        return kGramHashes;
    };
    WinnowingPreprocessingService.prototype.getFingerprintFromHashes = function (kGramHashes, T, K) {
        // Generate fingerprint of a document from its k-gram hashes.
        var windowSize = T - K + 1;
        var fingerprintHashesIndex = new Set();
        for (var i = 0; i < kGramHashes.length - windowSize + 1; i += 1) {
            var windowHashes = kGramHashes.slice(i, i + windowSize);
            var minHashValue = Math.min.apply(Math, windowHashes);
            var minHashIndex = i + windowHashes.indexOf(minHashValue);
            fingerprintHashesIndex.add(minHashIndex);
        }
        var fingerprint = [];
        fingerprintHashesIndex.forEach(function (hashIndex) {
            fingerprint.push([kGramHashes[hashIndex], hashIndex]);
        });
        return fingerprint;
    };
    var WinnowingPreprocessingService_1;
    WinnowingPreprocessingService = WinnowingPreprocessingService_1 = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], WinnowingPreprocessingService);
    return WinnowingPreprocessingService;
}());
exports.WinnowingPreprocessingService = WinnowingPreprocessingService;
angular.module('oppia').factory('WinnowingPreprocessingService', static_1.downgradeInjectable(WinnowingPreprocessingService));


/***/ }),

/***/ "./extensions/interactions/CodeRepl/CodeRepl.ts":
/*!******************************************************!*\
  !*** ./extensions/interactions/CodeRepl/CodeRepl.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for CodeRepl interaction.
 */
__webpack_require__(/*! interactions/CodeRepl/static/code_repl.css */ "./extensions/interactions/CodeRepl/static/code_repl.css");
__webpack_require__(/*! interactions/CodeRepl/code-repl-prediction.service.ts */ "./extensions/interactions/CodeRepl/code-repl-prediction.service.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/code-repl-rules.service.ts */ "./extensions/interactions/CodeRepl/directives/code-repl-rules.service.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/code-repl-validation.service.ts */ "./extensions/interactions/CodeRepl/directives/code-repl-validation.service.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/oppia-interactive-code-repl.directive.ts */ "./extensions/interactions/CodeRepl/directives/oppia-interactive-code-repl.directive.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/oppia-response-code-repl.directive.ts */ "./extensions/interactions/CodeRepl/directives/oppia-response-code-repl.directive.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/oppia-short-response-code-repl.directive.ts */ "./extensions/interactions/CodeRepl/directives/oppia-short-response-code-repl.directive.ts");


/***/ }),

/***/ "./extensions/interactions/CodeRepl/code-repl-prediction.service.ts":
/*!**************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/code-repl-prediction.service.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview CodeRepl interaction prediction functions.
 *
 * IMPORTANT NOTE: The prediction function uses the classifier data
 * of trained model (code classifier model) for inference. These functions
 * must be changed if there are any changes in corresponding classifier training
 * function on Oppia-ml.
 */
__webpack_require__(/*! classifiers/count-vectorizer.service.ts */ "./extensions/classifiers/count-vectorizer.service.ts");
__webpack_require__(/*! classifiers/python-program.tokenizer.ts */ "./extensions/classifiers/python-program.tokenizer.ts");
__webpack_require__(/*! classifiers/svm-prediction.service.ts */ "./extensions/classifiers/svm-prediction.service.ts");
__webpack_require__(/*! classifiers/winnowing-preprocessing.service.ts */ "./extensions/classifiers/winnowing-preprocessing.service.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').factory('CodeReplPredictionService', [
    'CountVectorizerService', 'PythonProgramTokenType',
    'PythonProgramTokenizer', 'SVMPredictionService',
    'WinnowingPreprocessingService',
    'CODE_REPL_PREDICTION_SERVICE_THRESHOLD', function (CountVectorizerService, PythonProgramTokenType, PythonProgramTokenizer, SVMPredictionService, WinnowingPreprocessingService, CODE_REPL_PREDICTION_SERVICE_THRESHOLD) {
        // The string with which all the variable and method names need to be
        // replaced.
        var TOKEN_NAME_VAR = 'V';
        // The string with which all unknown tokens (tokens which are ignored
        // because they appear rarely in a program) will be replaced.
        var TOKEN_NAME_UNK = 'UNK';
        // List of python keywords.
        var KW_LIST = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',
            'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global',
            'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print',
            'raise', 'return', 'try', 'while', 'with', 'yield'
        ];
        var predictionService = {
            getTokenizedProgram: function (programTokens, tokenToId) {
                // Tokenize Python programs in dataset for winnowing.
                var tokenizedProgram = [];
                for (var i = 0; i < programTokens.length; i++) {
                    var token = programTokens[i];
                    var tokenId = token[0];
                    var tokenName = token[1];
                    if (tokenId === PythonProgramTokenType.NL ||
                        tokenId === PythonProgramTokenType.COMMENT ||
                        tokenName.trim() === '') {
                        continue;
                    }
                    else if (tokenId === PythonProgramTokenType.NAME &&
                        KW_LIST.indexOf(tokenName) === -1) {
                        tokenizedProgram.push(TOKEN_NAME_VAR);
                    }
                    else {
                        if (tokenToId.hasOwnProperty(tokenName)) {
                            tokenizedProgram.push(tokenName);
                        }
                        else {
                            tokenizedProgram.push(TOKEN_NAME_UNK);
                        }
                    }
                }
                return tokenizedProgram;
            },
            getTokenizedProgramForCV: function (programTokens) {
                // Tokenize Python programs in dataset for winnowing.
                var tokenizedProgram = [];
                for (var i = 0; i < programTokens.length; i++) {
                    var token = programTokens[i];
                    var tokenId = token[0];
                    var tokenName = token[1];
                    if (tokenId === PythonProgramTokenType.NL ||
                        tokenId === PythonProgramTokenType.COMMENT ||
                        tokenName.trim() === '') {
                        continue;
                    }
                    else if (tokenId === PythonProgramTokenType.NAME &&
                        KW_LIST.indexOf(tokenName) === -1) {
                        tokenizedProgram.push(TOKEN_NAME_VAR);
                    }
                    else {
                        tokenizedProgram.push(tokenName);
                    }
                }
                return tokenizedProgram;
            },
            calcJaccardIndex: function (multisetA, multisetB) {
                // Calculate jaccard index between two multisets.
                multisetA.sort(function (x, y) {
                    return x > y ? 1 : -1;
                });
                multisetB.sort(function (x, y) {
                    return x > y ? 1 : -1;
                });
                var smallSet = ((multisetA.length < multisetB.length) ?
                    multisetA.slice() : multisetB.slice());
                var unionSet = ((multisetA.length < multisetB.length) ?
                    multisetB.slice() : multisetA.slice());
                var index = 0;
                var extraElements = [];
                smallSet.forEach(function (elem) {
                    while (index < unionSet.length && elem > unionSet[index]) {
                        index += 1;
                    }
                    if (index >= unionSet.length || elem < unionSet[index]) {
                        extraElements.push(elem);
                    }
                    else if (elem === unionSet[index]) {
                        index += 1;
                    }
                });
                unionSet = unionSet.concat(extraElements);
                if (unionSet.length === 0) {
                    return 0;
                }
                index = 0;
                var intersectionSet = [];
                multisetA.forEach(function (elem) {
                    while (index < multisetB.length && elem > multisetB[index]) {
                        index += 1;
                    }
                    if (index < multisetB.length && elem === multisetB[index]) {
                        intersectionSet.push(elem);
                        index += 1;
                    }
                });
                var coeff = intersectionSet.length / unionSet.length;
                return coeff;
            },
            getProgramSimilarity: function (fingerprintA, fingerprintB) {
                // Calculate similarity between two programs' fingerprints.
                var multisetA = [];
                var multisetB = [];
                fingerprintA.forEach(function (hash) {
                    multisetA.push(hash[0]);
                });
                fingerprintB.forEach(function (hash) {
                    multisetB.push(hash[0]);
                });
                return predictionService.calcJaccardIndex(multisetA, multisetB);
            },
            findNearestNeighborsIndexes: function (knnData, program) {
                // Find index of nearest neighbor programs to given program.
                var K = knnData.K;
                var T = knnData.T;
                var fingerprintData = knnData.fingerprint_data;
                var tokenToId = knnData.token_to_id;
                var top = knnData.top;
                // Find program tokens using python program tokenizer.
                var programLines = program.split('\n');
                // Empty lines in between program causes parser to think that program
                // has ended which leads to generation of wrong set of tokens.
                programLines = programLines.filter(function (line) {
                    return line.trim().length !== 0;
                });
                var pythonProgramTokens = PythonProgramTokenizer.generateTokens(programLines);
                // Normalize program tokens for winnowing preprocessing. This removes
                // unnecessary tokens and normalizes variable and method name tokens.
                var tokenizedProgram = predictionService.getTokenizedProgram(pythonProgramTokens, tokenToId);
                // Find k-gram hashes from normalized program tokens.
                var programHashes = WinnowingPreprocessingService.getKGramHashes(tokenizedProgram, tokenToId, K);
                // Find fingerprint from k-gram hashes of program.
                var programFingerprint = (WinnowingPreprocessingService.getFingerprintFromHashes(programHashes, T, K));
                // Calculte similarity of the input program with every program in
                // classifier data for k nearest neighbor classification.
                var similarityList = [];
                Object.keys(fingerprintData).forEach(function (index) {
                    var fingerprintA = fingerprintData[index].fingerprint;
                    var similarity = predictionService.getProgramSimilarity(fingerprintA, programFingerprint);
                    similarityList.push([parseInt(index), similarity]);
                });
                // Sort the programs according to their similairy with the
                // input program.
                similarityList.sort(function (x, y) {
                    return x[1] > y[1] ? -1 : 1;
                });
                var nearestNeighborsIndexes = similarityList.slice(0, top);
                return nearestNeighborsIndexes;
            },
            predict: function (classifierData, answer) {
                // Get python code from the input answer.
                var program = answer.code;
                var knnData = classifierData.KNN;
                var svmData = classifierData.SVM;
                var cvVocabulary = classifierData.cv_vocabulary;
                var fingerprintData = knnData.fingerprint_data;
                var top = knnData.top;
                var occurrence = knnData.occurrence;
                var nearestNeighborsIndexes = (predictionService.findNearestNeighborsIndexes(knnData, program));
                var nearesNeighborsClasses = [];
                // Find classes of nearest neighbor programs.
                nearestNeighborsIndexes.forEach(function (neighbor) {
                    var index = neighbor[0];
                    var outputClassPropertyName = 'class';
                    var similarity = neighbor[1];
                    nearesNeighborsClasses.push([fingerprintData[index][outputClassPropertyName], similarity]);
                });
                // Count how many times a class appears in nearest neighbors.
                var classCount = {};
                nearesNeighborsClasses.forEach(function (neighbor) {
                    var outputClass = neighbor[0];
                    if (classCount.hasOwnProperty(outputClass)) {
                        classCount[outputClass] += 1;
                    }
                    else {
                        classCount[outputClass] = 1;
                    }
                });
                // Find the winning class.
                var classCountArray = [];
                Object.keys(classCount).forEach(function (k) {
                    classCountArray.push([parseInt(k), classCount[k]]);
                });
                classCountArray.sort(function (x, y) {
                    return x[1] > y[1] ? -1 : 1;
                });
                var predictedClass = classCountArray[0][0];
                var predictedClassOccurrence = classCountArray[0][1];
                var prediction = predictedClass;
                if (predictedClassOccurrence >= occurrence) {
                    if (classCountArray.length > 1) {
                        if (predictedClassOccurrence !== classCountArray[1][1]) {
                            // Check whether second most likely prediction does not have same
                            // occurrence count. If it does, then we assume that KNN has
                            // failed.
                            return prediction;
                        }
                    }
                    else {
                        return prediction;
                    }
                }
                // If KNN fails to predict then use SVM to predict the output class.
                // Find program tokens using python program tokenizer.
                var programLines = program.split('\n');
                // Empty lines in between program causes parser to think that program
                // has ended which leads to generation of wrong set of tokens.
                programLines = programLines.filter(function (line) {
                    return line.trim().length !== 0;
                });
                var pythonProgramTokens = PythonProgramTokenizer.generateTokens(programLines);
                var tokenizedProgram = predictionService.getTokenizedProgramForCV(pythonProgramTokens);
                var programVector = CountVectorizerService.vectorize(tokenizedProgram, cvVocabulary);
                var predictionResult = SVMPredictionService.predict(svmData, programVector);
                if (predictionResult.predictionConfidence >
                    CODE_REPL_PREDICTION_SERVICE_THRESHOLD) {
                    return predictionResult.predictionLabel;
                }
                return -1;
            }
        };
        return predictionService;
    }
]);


/***/ }),

/***/ "./extensions/interactions/CodeRepl/directives/code-repl-rules.service.ts":
/*!********************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/directives/code-repl-rules.service.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! filters/string-utility-filters/normalize-whitespace.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace.filter.ts");
__webpack_require__(/*! services/CodeNormalizerService.ts */ "./core/templates/dev/head/services/CodeNormalizerService.ts");
angular.module('oppia').factory('CodeReplRulesService', [
    '$filter', 'CodeNormalizerService',
    function ($filter, CodeNormalizerService) {
        return {
            CodeEquals: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedExpectedCode = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode === normalizedExpectedCode;
            },
            CodeContains: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedSnippet = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode.indexOf(normalizedSnippet) !== -1;
            },
            CodeDoesNotContain: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedSnippet = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode.indexOf(normalizedSnippet) === -1;
            },
            OutputContains: function (answer, inputs) {
                var normalizedOutput = $filter('normalizeWhitespace')(answer.output);
                var normalizedSnippet = $filter('normalizeWhitespace')(inputs.x);
                return normalizedOutput.indexOf(normalizedSnippet) !== -1;
            },
            OutputEquals: function (answer, inputs) {
                var normalizedOutput = $filter('normalizeWhitespace')(answer.output);
                var normalizedExpectedOutput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedOutput === normalizedExpectedOutput;
            },
            ResultsInError: function (answer) {
                return !!(answer.error.trim());
            },
            ErrorContains: function (answer, inputs) {
                var normalizedError = $filter('normalizeWhitespace')(answer.error);
                var normalizedSnippet = $filter('normalizeWhitespace')(inputs.x);
                return normalizedError.indexOf(normalizedSnippet) !== -1;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/CodeRepl/directives/code-repl-validation.service.ts":
/*!*************************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/directives/code-repl-validation.service.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var CodeReplValidationService = /** @class */ (function () {
    function CodeReplValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    CodeReplValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, [
            'language',
            'placeholder',
            'preCode',
            'postCode'
        ]);
        var language = customizationArgs.language.value;
        if (!(typeof language === 'string')) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Programming language name must be a string.'
            });
        }
        var placeholder = customizationArgs.placeholder.value;
        if (!(typeof placeholder === 'string')) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Placeholder text must be a string.'
            });
        }
        var preCode = customizationArgs.preCode.value;
        if (!(typeof preCode === 'string')) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'The pre-code text must be a string.'
            });
        }
        var postCode = customizationArgs.postCode.value;
        if (!(typeof postCode === 'string')) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'The post-code text must be a string.'
            });
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    CodeReplValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        return this.getCustomizationArgsWarnings(customizationArgs).concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
    };
    var _a;
    CodeReplValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], CodeReplValidationService);
    return CodeReplValidationService;
}());
exports.CodeReplValidationService = CodeReplValidationService;
angular.module('oppia').factory('CodeReplValidationService', static_1.downgradeInjectable(CodeReplValidationService));


/***/ }),

/***/ "./extensions/interactions/CodeRepl/directives/oppia-interactive-code-repl.directive.ts":
/*!**********************************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/directives/oppia-interactive-code-repl.directive.ts ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the CodeRepl interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! interactions/codemirrorRequires.ts */ "./extensions/interactions/codemirrorRequires.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/CodeRepl/directives/code-repl-rules.service.ts */ "./extensions/interactions/CodeRepl/directives/code-repl-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
angular.module('oppia').directive('oppiaInteractiveCodeRepl', [
    'CodeReplRulesService', 'HtmlEscaperService', 'UrlInterpolationService',
    'EVENT_NEW_CARD_AVAILABLE',
    function (CodeReplRulesService, HtmlEscaperService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer',
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/CodeRepl/directives/' +
                'code-repl-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', 'WindowDimensionsService',
                'CurrentInteractionService',
                function ($scope, $attrs, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                    });
                    ctrl.language = HtmlEscaperService.escapedJsonToObj($attrs.languageWithValue);
                    ctrl.placeholder = HtmlEscaperService.escapedJsonToObj($attrs.placeholderWithValue);
                    ctrl.preCode = HtmlEscaperService.escapedJsonToObj($attrs.preCodeWithValue);
                    ctrl.postCode = HtmlEscaperService.escapedJsonToObj($attrs.postCodeWithValue);
                    // Make sure ctrl.preCode ends with a newline:
                    if (ctrl.preCode.trim().length === 0) {
                        ctrl.preCode = '';
                    }
                    else if (ctrl.preCode.slice(-1) !== '\n') {
                        ctrl.preCode += '\n';
                    }
                    // Make sure ctrl.placeholder ends with a newline.
                    if (ctrl.placeholder.slice(-1) !== '\n') {
                        ctrl.placeholder += '\n';
                    }
                    ctrl.hasLoaded = false;
                    // Keep the code string given by the user and the stdout from the
                    // evaluation until sending them back to the server.
                    if (ctrl.interactionIsActive) {
                        ctrl.code = (ctrl.preCode + ctrl.placeholder + ctrl.postCode);
                        ctrl.output = '';
                    }
                    else {
                        ctrl.code = ctrl.getLastAnswer().code;
                        ctrl.output = ctrl.getLastAnswer().output;
                    }
                    ctrl.initCodeEditor = function (editor) {
                        editor.setValue(ctrl.code);
                        // Options for the ui-codemirror display.
                        editor.setOption('lineNumbers', true);
                        editor.setOption('indentWithTabs', true);
                        editor.setOption('indentUnit', 4);
                        editor.setOption('mode', 'python');
                        editor.setOption('extraKeys', {
                            Tab: function (cm) {
                                var spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
                                cm.replaceSelection(spaces);
                                // Move the cursor to the end of the selection.
                                var endSelectionPos = cm.getDoc().getCursor('head');
                                cm.getDoc().setCursor(endSelectionPos);
                            }
                        });
                        editor.setOption('theme', 'preview default');
                        // NOTE: this is necessary to avoid the textarea being greyed-out.
                        setTimeout(function () {
                            editor.refresh();
                            initMarkers(editor);
                        }, 200);
                        editor.on('change', function () {
                            ctrl.code = editor.getValue();
                        });
                        // Without this, the editor does not show up correctly on small
                        // screens when the user switches to the supplemental interaction.
                        $scope.$on('showInteraction', function () {
                            setTimeout(function () {
                                editor.refresh();
                                initMarkers(editor);
                            }, 200);
                        });
                        ctrl.hasLoaded = true;
                    };
                    // Configure Skulpt.
                    Sk.configure({
                        output: function (out) {
                            // This output function is called continuously throughout the
                            // runtime of the script.
                            ctrl.output += out;
                        },
                        read: function (name) {
                            // This function is called when a builtin module is imported
                            if (Sk.builtinFiles.files[name] === undefined) {
                                // If corresponding module is not present then,
                                // removal of this block also results in failure of import.
                                throw 'module ' + name + ' not found';
                            }
                            return Sk.builtinFiles.files[name];
                        },
                        timeoutMsg: function () {
                            ctrl.sendResponse('', 'timeout');
                        },
                        execLimit: 10000
                    });
                    ctrl.runAndSubmitCode = function (codeInput) {
                        ctrl.runCode(codeInput, function (evaluation, err) {
                            ctrl.sendResponse(evaluation, err);
                        });
                    };
                    var submitAnswer = function () {
                        ctrl.runAndSubmitCode(ctrl.code);
                    };
                    ctrl.runCode = function (codeInput, onFinishRunCallback) {
                        ctrl.code = codeInput;
                        ctrl.output = '';
                        // Evaluate the program asynchronously using Skulpt.
                        Sk.misceval.asyncToPromise(function () {
                            Sk.importMainWithBody('<stdin>', false, codeInput, true);
                        }).then(function () {
                            // Finished evaluating.
                            ctrl.evaluation = '';
                            ctrl.fullError = '';
                            if (onFinishRunCallback) {
                                onFinishRunCallback('', '');
                            }
                        }, function (err) {
                            if (!(err instanceof Sk.builtin.TimeLimitError)) {
                                ctrl.evaluation = '';
                                ctrl.fullError = String(err);
                                if (onFinishRunCallback) {
                                    onFinishRunCallback('', String(err));
                                }
                            }
                        });
                    };
                    var initMarkers = function (editor) {
                        var doc = editor.getDoc();
                        // The -1 here is because prepended code ends with a newline.
                        var preCodeNumLines = ctrl.preCode.split('\n').length - 1;
                        var postCodeNumLines = ctrl.postCode.split('\n').length;
                        var fullCodeNumLines = ctrl.code.split('\n').length;
                        var userCodeNumLines = (fullCodeNumLines - preCodeNumLines - postCodeNumLines);
                        // Mark pre- and post- code as uneditable, and give it some styling.
                        var markOptions = {
                            atomic: false,
                            readOnly: true,
                            inclusiveLeft: true,
                            inclusiveRight: true
                        };
                        if (ctrl.preCode.length !== 0) {
                            doc.markText({
                                line: 0,
                                ch: 0
                            }, {
                                line: preCodeNumLines,
                                ch: 0
                            }, angular.extend({}, markOptions, {
                                inclusiveRight: false
                            }));
                            for (var i = 0; i < preCodeNumLines; i++) {
                                editor.addLineClass(i, 'text', 'code-repl-noneditable-line');
                            }
                        }
                        if (ctrl.postCode.length !== 0) {
                            doc.markText({
                                line: preCodeNumLines + userCodeNumLines,
                                ch: 0
                            }, {
                                line: fullCodeNumLines,
                                ch: 0
                            }, markOptions);
                            for (var i = 0; i < postCodeNumLines; i++) {
                                editor.addLineClass(preCodeNumLines + userCodeNumLines + i, 'text', 'code-repl-noneditable-line');
                            }
                        }
                    };
                    ctrl.sendResponse = function (evaluation, err) {
                        CurrentInteractionService.onSubmit({
                            // Replace tabs with 2 spaces.
                            // TODO(sll): Change the default Python indentation to 4 spaces.
                            code: ctrl.code.replace(/\t/g, '  ') || '',
                            output: ctrl.output,
                            evaluation: ctrl.evaluation,
                            error: (err || '')
                        }, CodeReplRulesService);
                        // Without this, the error message displayed in the user-facing
                        // console will sometimes not update.
                        $scope.$apply();
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswer, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/CodeRepl/directives/oppia-response-code-repl.directive.ts":
/*!*******************************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/directives/oppia-response-code-repl.directive.ts ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the CodeRepl response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
angular.module('oppia').directive('oppiaResponseCodeRepl', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/CodeRepl/directives/' +
                'code-repl-response.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'FocusManagerService',
                function ($attrs, FocusManagerService) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    if (ctrl.answer.error) {
                        ctrl.errorFocusLabel = FocusManagerService.generateFocusLabel();
                        FocusManagerService.setFocus(ctrl.errorFocusLabel);
                    }
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/CodeRepl/directives/oppia-short-response-code-repl.directive.ts":
/*!*************************************************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/directives/oppia-short-response-code-repl.directive.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the CodeRepl short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! filters/string-utility-filters/truncate-at-first-line.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseCodeRepl', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/CodeRepl/directives/' +
                'code-repl-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/CodeRepl/static/code_repl.css":
/*!***************************************************************!*\
  !*** ./extensions/interactions/CodeRepl/static/code_repl.css ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!./code_repl.css */ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/CodeRepl/static/code_repl.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/interactions/Continue/Continue.ts":
/*!******************************************************!*\
  !*** ./extensions/interactions/Continue/Continue.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for Continue interaction.
 */
__webpack_require__(/*! interactions/Continue/directives/continue-rules.service.ts */ "./extensions/interactions/Continue/directives/continue-rules.service.ts");
__webpack_require__(/*! interactions/Continue/directives/continue-validation.service.ts */ "./extensions/interactions/Continue/directives/continue-validation.service.ts");
__webpack_require__(/*! interactions/Continue/directives/oppia-interactive-continue.directive.ts */ "./extensions/interactions/Continue/directives/oppia-interactive-continue.directive.ts");
__webpack_require__(/*! interactions/Continue/directives/oppia-response-continue.directive.ts */ "./extensions/interactions/Continue/directives/oppia-response-continue.directive.ts");
__webpack_require__(/*! interactions/Continue/directives/oppia-short-response-continue.directive.ts */ "./extensions/interactions/Continue/directives/oppia-short-response-continue.directive.ts");


/***/ }),

/***/ "./extensions/interactions/Continue/directives/continue-rules.service.ts":
/*!*******************************************************************************!*\
  !*** ./extensions/interactions/Continue/directives/continue-rules.service.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Rules service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var ContinueRulesService = /** @class */ (function () {
    function ContinueRulesService() {
    }
    ContinueRulesService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], ContinueRulesService);
    return ContinueRulesService;
}());
exports.ContinueRulesService = ContinueRulesService;
angular.module('oppia').factory('ContinueRulesService', static_1.downgradeInjectable(ContinueRulesService));


/***/ }),

/***/ "./extensions/interactions/Continue/directives/continue-validation.service.ts":
/*!************************************************************************************!*\
  !*** ./extensions/interactions/Continue/directives/continue-validation.service.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var ContinueValidationService = /** @class */ (function () {
    function ContinueValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    ContinueValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['buttonText']);
        if (customizationArgs.buttonText.value.length === 0) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'The button text should not be empty.'
            });
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    ContinueValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = this.getCustomizationArgsWarnings(customizationArgs);
        if (answerGroups.length > 0) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('Only the default outcome is necessary for a continue' +
                    ' interaction.')
            });
        }
        if (!defaultOutcome || defaultOutcome.isConfusing(stateName)) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: ('Please specify what Oppia should do after the button' +
                    ' is clicked.')
            });
        }
        return warningsList;
    };
    var _a;
    ContinueValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], ContinueValidationService);
    return ContinueValidationService;
}());
exports.ContinueValidationService = ContinueValidationService;
angular.module('oppia').factory('ContinueValidationService', static_1.downgradeInjectable(ContinueValidationService));


/***/ }),

/***/ "./extensions/interactions/Continue/directives/oppia-interactive-continue.directive.ts":
/*!*********************************************************************************************!*\
  !*** ./extensions/interactions/Continue/directives/oppia-interactive-continue.directive.ts ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Continue button interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/Continue/directives/continue-rules.service.ts */ "./extensions/interactions/Continue/directives/continue-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/ContextService.ts */ "./core/templates/dev/head/services/ContextService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
angular.module('oppia').directive('oppiaInteractiveContinue', [
    'ContinueRulesService', 'HtmlEscaperService', 'UrlInterpolationService',
    function (ContinueRulesService, HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/Continue/directives/' +
                'continue-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'WindowDimensionsService',
                'CurrentInteractionService', 'ContextService',
                function ($attrs, WindowDimensionsService, CurrentInteractionService, ContextService) {
                    var ctrl = this;
                    ctrl.buttonText = HtmlEscaperService.escapedJsonToObj($attrs.buttonTextWithValue);
                    var DEFAULT_BUTTON_TEXT = 'Continue';
                    var DEFAULT_HUMAN_READABLE_ANSWER = 'Please continue.';
                    ctrl.isInEditorMode = ContextService.isInExplorationEditorMode();
                    ctrl.submitAnswer = function () {
                        // We used to show "(Continue)" to indicate a 'continue' action when
                        // the learner browses through the history of the exploration, but
                        // this apparently can be mistaken for a button/control. The
                        // following makes the learner's "answer" a bit more conversational,
                        // as if they were chatting with Oppia.
                        var humanReadableAnswer = DEFAULT_HUMAN_READABLE_ANSWER;
                        if (ctrl.buttonText !== DEFAULT_BUTTON_TEXT) {
                            humanReadableAnswer = ctrl.buttonText;
                        }
                        CurrentInteractionService.onSubmit(humanReadableAnswer, ContinueRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitAnswer, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/Continue/directives/oppia-response-continue.directive.ts":
/*!******************************************************************************************!*\
  !*** ./extensions/interactions/Continue/directives/oppia-response-continue.directive.ts ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Continue button response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseContinue', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/Continue/directives/' +
                'continue-response.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'HtmlEscaperService',
                function ($attrs, HtmlEscaperService) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/Continue/directives/oppia-short-response-continue.directive.ts":
/*!************************************************************************************************!*\
  !*** ./extensions/interactions/Continue/directives/oppia-short-response-continue.directive.ts ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Continue button short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseContinue', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/Continue/directives/' +
                'continue-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'HtmlEscaperService',
                function ($attrs, HtmlEscaperService) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/DragAndDropSortInput.ts":
/*!******************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/DragAndDropSortInput.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for DragAndDropSortInput interaction.
 */
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts */ "./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-validation.service.ts */ "./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-validation.service.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/oppia-interactive-drag-and-drop-sort-input.directive.ts */ "./extensions/interactions/DragAndDropSortInput/directives/oppia-interactive-drag-and-drop-sort-input.directive.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/oppia-response-drag-and-drop-sort-input.directive.ts */ "./extensions/interactions/DragAndDropSortInput/directives/oppia-response-drag-and-drop-sort-input.directive.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/oppia-short-response-drag-and-drop-sort-input.directive.ts */ "./extensions/interactions/DragAndDropSortInput/directives/oppia-short-response-drag-and-drop-sort-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts":
/*!***********************************************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
// Rules Service for DragAndDropSortInput interaction.
angular.module('oppia').factory('DragAndDropSortInputRulesService', [
    function () {
        var checkEquality = function (answer, inputs) {
            for (var i = 0; i < answer.length; i++) {
                if (answer[i].length === inputs.x[i].length) {
                    for (var j = 0; j < answer[i].length; j++) {
                        if (inputs.x[i].indexOf(answer[i][j]) === -1) {
                            return false;
                        }
                    }
                }
                else {
                    return false;
                }
            }
            return true;
        };
        var checkEqualityWithIncorrectPositions = function (answer, inputs) {
            var noOfMismatches = 0;
            for (var i = 0; i < math.min(inputs.x.length, answer.length); i++) {
                for (var j = 0; j < math.max(answer[i].length, inputs.x[i].length); j++) {
                    if (inputs.x[i].length > answer[i].length) {
                        if (answer[i].indexOf(inputs.x[i][j]) === -1) {
                            noOfMismatches += 1;
                        }
                    }
                    else {
                        if (inputs.x[i].indexOf(answer[i][j]) === -1) {
                            noOfMismatches += 1;
                        }
                    }
                }
            }
            return noOfMismatches === 1;
        };
        return {
            IsEqualToOrdering: function (answer, inputs) {
                return answer.length === inputs.x.length && checkEquality(answer, inputs);
            },
            IsEqualToOrderingWithOneItemAtIncorrectPosition: function (answer, inputs) {
                return checkEqualityWithIncorrectPositions(answer, inputs);
            },
            HasElementXAtPositionY: function (answer, inputs) {
                for (var i = 0; i < answer.length; i++) {
                    var index = answer[i].indexOf(inputs.x);
                    if (index !== -1) {
                        return ((i + 1) === inputs.y);
                    }
                }
            },
            HasElementXBeforeElementY: function (answer, inputs) {
                var indX = -1;
                var indY = -1;
                for (var i = 0; i < answer.length; i++) {
                    var index = answer[i].indexOf(inputs.x);
                    if (index !== -1) {
                        indX = i;
                    }
                    index = answer[i].indexOf(inputs.y);
                    if (index !== -1) {
                        indY = i;
                    }
                }
                return indX < indY;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-validation.service.ts":
/*!****************************************************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-validation.service.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the drag and drop sorting interaction.
 */
// TODO(#7403): Convert this to partial imports.
var mathjs_1 = __importDefault(__webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js"));
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var DragAndDropSortInputValidationService = /** @class */ (function () {
    function DragAndDropSortInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    DragAndDropSortInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['choices']);
        var areAnyChoicesEmpty = false;
        var areAnyChoicesDuplicated = false;
        var seenChoices = [];
        var numChoices = customizationArgs.choices.value.length;
        if (numChoices < 2) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please enter at least two choices.'
            });
        }
        for (var i = 0; i < numChoices; i++) {
            var choice = customizationArgs.choices.value[i];
            if (choice.trim().length === 0) {
                areAnyChoicesEmpty = true;
            }
            if (seenChoices.indexOf(choice) !== -1) {
                areAnyChoicesDuplicated = true;
            }
            seenChoices.push(choice);
        }
        if (areAnyChoicesEmpty) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure that the choices are nonempty.'
            });
        }
        if (areAnyChoicesDuplicated) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure that the choices are unique.'
            });
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    DragAndDropSortInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        var seenItems = [];
        var ranges = [];
        var areAnyItemsEmpty = false;
        var areAnyItemsDuplicated = false;
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        var checkRedundancy = function (earlierRule, laterRule) {
            var noOfMismatches = 0;
            var inputs = earlierRule.inputs.x;
            var answer = laterRule.inputs.x;
            for (var i = 0; i < mathjs_1.default.min(inputs.length, answer.length); i++) {
                for (var j = 0; j < mathjs_1.default.max(answer[i].length, inputs[i].length); j++) {
                    if (inputs[i].length > answer[i].length) {
                        if (answer[i].indexOf(inputs[i][j]) === -1) {
                            noOfMismatches += 1;
                        }
                    }
                    else {
                        if (inputs[i].indexOf(answer[i][j]) === -1) {
                            noOfMismatches += 1;
                        }
                    }
                }
            }
            return noOfMismatches === 1;
        };
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                var inputs = rules[j].inputs;
                var rule = rules[j];
                var range = {
                    answerGroupIndex: i + 1,
                    ruleIndex: j + 1
                };
                seenItems = [];
                areAnyItemsEmpty = false;
                areAnyItemsDuplicated = false;
                switch (rule.type) {
                    case 'HasElementXBeforeElementY':
                        if (inputs.x === inputs.y) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: ('Rule ' + (j + 1) + ' from answer group ' +
                                    (i + 1) + ' will never be matched because both the ' +
                                    'selected elements are same.')
                            });
                        }
                        break;
                    case 'IsEqualToOrdering':
                    case 'IsEqualToOrderingWithOneItemAtIncorrectPosition':
                        for (var k = 0; k < inputs.x.length; k++) {
                            if (inputs.x[k].length === 0) {
                                areAnyItemsEmpty = true;
                            }
                            else {
                                for (var l = 0; l < inputs.x[k].length; l++) {
                                    var item = inputs.x[k][l];
                                    if (item.trim().length === 0) {
                                        areAnyItemsEmpty = true;
                                    }
                                    if (seenItems.indexOf(item) !== -1) {
                                        areAnyItemsDuplicated = true;
                                    }
                                    seenItems.push(item);
                                }
                            }
                        }
                        if (areAnyItemsEmpty) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: 'Please ensure the items are nonempty.'
                            });
                        }
                        if (areAnyItemsDuplicated) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: 'Please ensure the items are unique.'
                            });
                        }
                        break;
                    default:
                }
                for (var k = 0; k < ranges.length; k++) {
                    var earlierRule = answerGroups[ranges[k].answerGroupIndex - 1].
                        rules[ranges[k].ruleIndex - 1];
                    if (earlierRule.type ===
                        'IsEqualToOrderingWithOneItemAtIncorrectPosition' &&
                        rule.type === 'IsEqualToOrdering') {
                        if (checkRedundancy(earlierRule, rule)) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: ('Rule ' + (j + 1) + ' from answer group ' +
                                    (i + 1) + ' will never be matched because it ' +
                                    'is made redundant by rule ' + ranges[k].ruleIndex +
                                    ' from answer group ' + ranges[k].answerGroupIndex +
                                    '.')
                            });
                        }
                    }
                }
                ranges.push(range);
            }
        }
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
        return warningsList;
    };
    var _a;
    DragAndDropSortInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], DragAndDropSortInputValidationService);
    return DragAndDropSortInputValidationService;
}());
exports.DragAndDropSortInputValidationService = DragAndDropSortInputValidationService;
angular.module('oppia').factory('DragAndDropSortInputValidationService', static_1.downgradeInjectable(DragAndDropSortInputValidationService));


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/directives/oppia-interactive-drag-and-drop-sort-input.directive.ts":
/*!*************************************************************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/directives/oppia-interactive-drag-and-drop-sort-input.directive.ts ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the DragAndDropSortInput interaction.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts */ "./extensions/interactions/DragAndDropSortInput/directives/drag-and-drop-sort-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
angular.module('oppia').directive('oppiaInteractiveDragAndDropSortInput', [
    'DragAndDropSortInputRulesService', 'HtmlEscaperService',
    'UrlInterpolationService', function (DragAndDropSortInputRulesService, HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/DragAndDropSortInput/directives/' +
                'drag-and-drop-sort-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'UrlService', 'CurrentInteractionService',
                function ($attrs, UrlService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.choices = HtmlEscaperService.escapedJsonToObj($attrs.choicesWithValue);
                    var answers = [];
                    ctrl.list = [];
                    ctrl.dataMaxDepth = 1;
                    ctrl.allowMultipleItemsInSamePosition = ($attrs.allowMultipleItemsInSamePositionWithValue === 'true');
                    if (ctrl.allowMultipleItemsInSamePosition) {
                        ctrl.dataMaxDepth = 2;
                    }
                    else {
                        ctrl.dataMaxDepth = 1;
                    }
                    // Make list of dicts from the list of choices.
                    for (var i = 0; i < ctrl.choices.length; i++) {
                        ctrl.list.push({ title: ctrl.choices[i], items: [] });
                    }
                    ctrl.treeOptions = {
                        dragMove: function (e) {
                            // Change the color of the placeholder based on the position of
                            // the dragged item.
                            if (e.dest.nodesScope.$childNodesScope !== undefined) {
                                e.elements.placeholder[0].style.borderColor = '#add8e6';
                            }
                            else {
                                e.elements.placeholder[0].style.borderColor = '#000000';
                            }
                        }
                    };
                    ctrl.submitAnswer = function () {
                        // Converting list of dicts to list of lists to make it consistent
                        // with the ListOfSetsOfHtmlStrings object.
                        answers = [];
                        for (var i = 0; i < ctrl.list.length; i++) {
                            answers.push([ctrl.list[i].title]);
                            for (var j = 0; j < ctrl.list[i].items.length; j++) {
                                answers[i].push(ctrl.list[i].items[j].title);
                            }
                        }
                        CurrentInteractionService.onSubmit(answers, DragAndDropSortInputRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitAnswer, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/directives/oppia-response-drag-and-drop-sort-input.directive.ts":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/directives/oppia-response-drag-and-drop-sort-input.directive.ts ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the DragAndDropSortInput response.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseDragAndDropSortInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/DragAndDropSortInput/directives/' +
                'drag-and-drop-sort-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.chooseItemType = function (index) {
                        if (index === 0) {
                            ctrl.itemtype = 'drag-and-drop-response-item';
                        }
                        else {
                            ctrl.itemtype = 'drag-and-drop-response-subitem';
                        }
                        return true;
                    };
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.isAnswerLengthGreaterThanZero = (ctrl.answer.length > 0);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/DragAndDropSortInput/directives/oppia-short-response-drag-and-drop-sort-input.directive.ts":
/*!****************************************************************************************************************************!*\
  !*** ./extensions/interactions/DragAndDropSortInput/directives/oppia-short-response-drag-and-drop-sort-input.directive.ts ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the DragAndDropSortInput short response.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseDragAndDropSortInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/DragAndDropSortInput/directives/' +
                'drag-and-drop-sort-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.chooseItemType = function (index) {
                        if (index === 0) {
                            ctrl.itemtype = 'drag-and-drop-response-item';
                        }
                        else {
                            ctrl.itemtype = 'drag-and-drop-response-subitem';
                        }
                        return true;
                    };
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.isAnswerLengthGreaterThanZero = (ctrl.answer.length > 0);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/EndExploration/EndExploration.ts":
/*!******************************************************************!*\
  !*** ./extensions/interactions/EndExploration/EndExploration.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for EndExploration interaction.
 */
__webpack_require__(/*! interactions/EndExploration/directives/end-exploration-rules.service.ts */ "./extensions/interactions/EndExploration/directives/end-exploration-rules.service.ts");
__webpack_require__(/*! interactions/EndExploration/directives/end-exploration-validation.service.ts */ "./extensions/interactions/EndExploration/directives/end-exploration-validation.service.ts");
__webpack_require__(/*! interactions/EndExploration/directives/oppia-interactive-end-exploration.directive.ts */ "./extensions/interactions/EndExploration/directives/oppia-interactive-end-exploration.directive.ts");
__webpack_require__(/*! interactions/EndExploration/directives/oppia-response-end-exploration.directive.ts */ "./extensions/interactions/EndExploration/directives/oppia-response-end-exploration.directive.ts");
__webpack_require__(/*! interactions/EndExploration/directives/oppia-short-response-end-exploration.directive.ts */ "./extensions/interactions/EndExploration/directives/oppia-short-response-end-exploration.directive.ts");


/***/ }),

/***/ "./extensions/interactions/EndExploration/directives/end-exploration-rules.service.ts":
/*!********************************************************************************************!*\
  !*** ./extensions/interactions/EndExploration/directives/end-exploration-rules.service.ts ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Rules service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var EndExplorationRulesService = /** @class */ (function () {
    function EndExplorationRulesService() {
    }
    EndExplorationRulesService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], EndExplorationRulesService);
    return EndExplorationRulesService;
}());
exports.EndExplorationRulesService = EndExplorationRulesService;
angular.module('oppia').factory('EndExplorationRulesService', static_1.downgradeInjectable(EndExplorationRulesService));


/***/ }),

/***/ "./extensions/interactions/EndExploration/directives/end-exploration-validation.service.ts":
/*!*************************************************************************************************!*\
  !*** ./extensions/interactions/EndExploration/directives/end-exploration-validation.service.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var EndExplorationValidationService = /** @class */ (function () {
    function EndExplorationValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    EndExplorationValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['recommendedExplorationIds']);
        var recommendedExplorationIds = (customizationArgs.recommendedExplorationIds.value);
        if (!Array.isArray(recommendedExplorationIds)) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Set of recommended exploration IDs must be list.'
            });
        }
        for (var i = 0; i < recommendedExplorationIds.length; i++) {
            if (!(typeof recommendedExplorationIds[i] === 'string')) {
                warningsList.push({
                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                    message: 'Recommended exploration ID must be a string.'
                });
            }
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    EndExplorationValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        if (answerGroups.length !== 0) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Please make sure end exploration interactions do not ' +
                    'have any answer groups.'
            });
        }
        if (defaultOutcome) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Please make sure end exploration interactions do not ' +
                    'have a default outcome.'
            });
        }
        return warningsList;
    };
    var _a;
    EndExplorationValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], EndExplorationValidationService);
    return EndExplorationValidationService;
}());
exports.EndExplorationValidationService = EndExplorationValidationService;
angular.module('oppia').factory('EndExplorationValidationService', static_1.downgradeInjectable(EndExplorationValidationService));


/***/ }),

/***/ "./extensions/interactions/EndExploration/directives/oppia-interactive-end-exploration.directive.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/EndExploration/directives/oppia-interactive-end-exploration.directive.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the EndExploration 'interaction'.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/collection/ReadOnlyCollectionBackendApiService.ts */ "./core/templates/dev/head/domain/collection/ReadOnlyCollectionBackendApiService.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/ContextService.ts */ "./core/templates/dev/head/services/ContextService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
angular.module('oppia').directive('oppiaInteractiveEndExploration', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/EndExploration/directives/' +
                'end-exploration-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$http', '$attrs', '$q', 'UrlService',
                'ContextService', 'ReadOnlyCollectionBackendApiService',
                'PAGE_CONTEXT', 'EXPLORATION_EDITOR_TAB_CONTEXT',
                'HtmlEscaperService', 'EXPLORATION_SUMMARY_DATA_URL_TEMPLATE',
                function ($http, $attrs, $q, UrlService, ContextService, ReadOnlyCollectionBackendApiService, PAGE_CONTEXT, EXPLORATION_EDITOR_TAB_CONTEXT, HtmlEscaperService, EXPLORATION_SUMMARY_DATA_URL_TEMPLATE) {
                    var ctrl = this;
                    var authorRecommendedExplorationIds = (HtmlEscaperService.escapedJsonToObj($attrs.recommendedExplorationIdsWithValue));
                    ctrl.isIframed = UrlService.isIframed();
                    ctrl.isInEditorPage = (ContextService.getPageContext() === (PAGE_CONTEXT.EXPLORATION_EDITOR));
                    ctrl.isInEditorPreviewMode = ctrl.isInEditorPage && (ContextService.getEditorTabContext() ===
                        EXPLORATION_EDITOR_TAB_CONTEXT.PREVIEW);
                    ctrl.isInEditorMainTab = ctrl.isInEditorPage && (ContextService.getEditorTabContext() ===
                        EXPLORATION_EDITOR_TAB_CONTEXT.EDITOR);
                    ctrl.collectionId = UrlService.getCollectionIdFromExplorationUrl();
                    if (ctrl.collectionId) {
                        ReadOnlyCollectionBackendApiService
                            .loadCollection(ctrl.collectionId)
                            .then(function (collection) {
                            ctrl.getCollectionTitle = function () {
                                return collection.title;
                            };
                        });
                    }
                    ctrl.errorMessage = '';
                    if (ctrl.isInEditorPage) {
                        // Display a message if any author-recommended explorations are
                        // invalid.
                        var explorationId = ContextService.getExplorationId();
                        $http.get(EXPLORATION_SUMMARY_DATA_URL_TEMPLATE, {
                            params: {
                                stringified_exp_ids: JSON.stringify(authorRecommendedExplorationIds)
                            }
                        }).then(function (response) {
                            var data = response.data;
                            var foundExpIds = [];
                            data.summaries.map(function (expSummary) {
                                foundExpIds.push(expSummary.id);
                            });
                            var missingExpIds = [];
                            authorRecommendedExplorationIds.forEach(function (expId) {
                                if (foundExpIds.indexOf(expId) === -1) {
                                    missingExpIds.push(expId);
                                }
                            });
                            if (missingExpIds.length === 0) {
                                ctrl.errorMessage = '';
                            }
                            else {
                                var listOfIds = missingExpIds.join('", "');
                                ctrl.errorMessage = ('Warning: exploration(s) with the IDs "' + listOfIds +
                                    '" will ' + 'not be shown as recommendations because they ' +
                                    'either do not exist, or are not publicly viewable.');
                            }
                        });
                    }
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/EndExploration/directives/oppia-response-end-exploration.directive.ts":
/*!*******************************************************************************************************!*\
  !*** ./extensions/interactions/EndExploration/directives/oppia-response-end-exploration.directive.ts ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the EndExploration response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
angular.module('oppia').directive('oppiaResponseEndExploration', [function () {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            template: '',
            controllerAs: '$ctrl',
            controller: [function () { }]
        };
    }]);


/***/ }),

/***/ "./extensions/interactions/EndExploration/directives/oppia-short-response-end-exploration.directive.ts":
/*!*************************************************************************************************************!*\
  !*** ./extensions/interactions/EndExploration/directives/oppia-short-response-end-exploration.directive.ts ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the EndExploration short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
angular.module('oppia').directive('oppiaShortResponseEndExploration', [
    function () {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            template: '',
            controllerAs: '$ctrl',
            controller: [function () { }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/FractionInput/FractionInput.ts":
/*!****************************************************************!*\
  !*** ./extensions/interactions/FractionInput/FractionInput.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for FractionInput interaction.
 */
__webpack_require__(/*! interactions/FractionInput/directives/fraction-input-rules.service.ts */ "./extensions/interactions/FractionInput/directives/fraction-input-rules.service.ts");
__webpack_require__(/*! interactions/FractionInput/directives/fraction-input-validation.service.ts */ "./extensions/interactions/FractionInput/directives/fraction-input-validation.service.ts");
__webpack_require__(/*! interactions/FractionInput/directives/oppia-interactive-fraction-input.directive.ts */ "./extensions/interactions/FractionInput/directives/oppia-interactive-fraction-input.directive.ts");
__webpack_require__(/*! interactions/FractionInput/directives/oppia-response-fraction-input.directive.ts */ "./extensions/interactions/FractionInput/directives/oppia-response-fraction-input.directive.ts");
__webpack_require__(/*! interactions/FractionInput/directives/oppia-short-response-fraction-input.directive.ts */ "./extensions/interactions/FractionInput/directives/oppia-short-response-fraction-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/FractionInput/directives/fraction-input-rules.service.ts":
/*!******************************************************************************************!*\
  !*** ./extensions/interactions/FractionInput/directives/fraction-input-rules.service.ts ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
angular.module('oppia').factory('FractionInputRulesService', [
    'FractionObjectFactory',
    function (FractionObjectFactory) {
        var toFloat = function (fractionDict) {
            return FractionObjectFactory.fromDict(fractionDict).toFloat();
        };
        return {
            IsEquivalentTo: function (answer, inputs) {
                return toFloat(answer) === toFloat(inputs.f);
            },
            IsEquivalentToAndInSimplestForm: function (answer, inputs) {
                var simplestForm = FractionObjectFactory.fromDict(inputs.f).convertToSimplestForm();
                return toFloat(answer) === toFloat(inputs.f) &&
                    angular.equals(answer, simplestForm);
            },
            IsExactlyEqualTo: function (answer, inputs) {
                // Only returns true if both answers are structurally equal.
                return angular.equals(answer, inputs.f);
            },
            IsLessThan: function (answer, inputs) {
                return toFloat(answer) < toFloat(inputs.f);
            },
            IsGreaterThan: function (answer, inputs) {
                return toFloat(answer) > toFloat(inputs.f);
            },
            HasIntegerPartEqualTo: function (answer, inputs) {
                var answerFraction = FractionObjectFactory.fromDict(answer);
                return answerFraction.getIntegerPart() === inputs.x;
            },
            HasNumeratorEqualTo: function (answer, inputs) {
                return answer.numerator === inputs.x;
            },
            HasDenominatorEqualTo: function (answer, inputs) {
                return answer.denominator === inputs.x;
            },
            HasNoFractionalPart: function (answer) {
                return answer.numerator === 0;
            },
            HasFractionalPartExactlyEqualTo: function (answer, inputs) {
                return (answer.numerator === inputs.f.numerator &&
                    answer.denominator === inputs.f.denominator);
            },
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/FractionInput/directives/fraction-input-validation.service.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/FractionInput/directives/fraction-input-validation.service.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Validator service for the fraction interaction.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! interactions/base-interaction-validation.service.ts */ "./extensions/interactions/base-interaction-validation.service.ts");
angular.module('oppia').factory('FractionInputValidationService', [
    'FractionObjectFactory', 'baseInteractionValidationService',
    'WARNING_TYPES',
    function (FractionObjectFactory, baseInteractionValidationService, WARNING_TYPES) {
        var getNonIntegerInputWarning = function (i, j) {
            return {
                type: WARNING_TYPES.ERROR,
                message: ('Rule ' + (j + 1) + ' from answer group ' +
                    (i + 1) + ' is invalid: input should be an ' +
                    'integer.')
            };
        };
        return {
            getCustomizationArgsWarnings: function (customizationArgs) {
                return [];
            },
            getAllWarnings: function (stateName, customizationArgs, answerGroups, defaultOutcome) {
                var warningsList = [];
                var shouldBeInSimplestForm = customizationArgs.requireSimplestForm.value;
                var allowImproperFraction = customizationArgs.allowImproperFraction.value;
                var allowNonzeroIntegerPart = customizationArgs.allowNonzeroIntegerPart.value;
                warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
                var toFloat = function (fraction) {
                    return FractionObjectFactory.fromDict(fraction).toFloat();
                };
                /**
                 * Store an answer range for every rule, then check for redundant
                 * ranges. A range is an object of the form:
                 * {
                 *   lb: float, lower bound
                 *   ub: float, upper bound
                 *   lbi: bool, is lower bound inclusive
                 *   ubi: bool, is upper bound inclusive
                 * }
                 */
                var setLowerAndUpperBounds = function (range, lb, ub, lbi, ubi) {
                    range.lb = lb;
                    range.ub = ub;
                    range.lbi = lbi;
                    range.ubi = ubi;
                };
                var isEnclosedBy = function (ra, rb) {
                    if ((ra.lb === null && ra.ub === null) ||
                        (rb.lb === null && rb.ub === null)) {
                        return false;
                    }
                    // Checks if range ra is enclosed by range rb.
                    var lowerBoundConditionIsSatisfied = (rb.lb < ra.lb) || (rb.lb === ra.lb && (!ra.lbi || rb.lbi));
                    var upperBoundConditionIsSatisfied = (rb.ub > ra.ub) || (rb.ub === ra.ub && (!ra.ubi || rb.ubi));
                    return lowerBoundConditionIsSatisfied &&
                        upperBoundConditionIsSatisfied;
                };
                var shouldCheckRangeCriteria = function (earlierRule, laterRule) {
                    if ((earlierRule.type === 'IsExactlyEqualTo' &&
                        laterRule.type === 'IsExactlyEqualTo') ||
                        (earlierRule.type === 'IsExactlyEqualTo' &&
                            laterRule.type === 'IsEquivalentTo') ||
                        (earlierRule.type === 'IsExactlyEqualTo' &&
                            laterRule.type === 'IsEquivalentToAndInSimplestForm')) {
                        return false;
                    }
                    return true;
                };
                var ranges = [];
                var matchedDenominators = [];
                for (var i = 0; i < answerGroups.length; i++) {
                    var rules = answerGroups[i].rules;
                    for (var j = 0; j < rules.length; j++) {
                        var rule = rules[j];
                        var range = {
                            answerGroupIndex: i + 1,
                            ruleIndex: j + 1,
                            lb: null,
                            ub: null,
                            lbi: false,
                            ubi: false,
                        };
                        var matchedDenominator = {
                            answerGroupIndex: i + 1,
                            ruleIndex: j + 1,
                            denominator: null,
                        };
                        switch (rule.type) {
                            case 'IsExactlyEqualTo':
                                if (shouldBeInSimplestForm) {
                                    var fraction = rule.inputs.f;
                                    var fractionInSimplestForm = FractionObjectFactory.fromDict(fraction).convertToSimplestForm();
                                    if (!angular.equals(fraction, fractionInSimplestForm)) {
                                        warningsList.push({
                                            type: WARNING_TYPES.ERROR,
                                            message: ('Rule ' + (j + 1) + ' from answer group ' +
                                                (i + 1) +
                                                ' will never be matched because it is not ' +
                                                'in simplest form.')
                                        });
                                    }
                                }
                                if (!allowImproperFraction) {
                                    var fraction = FractionObjectFactory.fromDict(rule.inputs.f);
                                    if (fraction.isImproperFraction()) {
                                        warningsList.push({
                                            type: WARNING_TYPES.ERROR,
                                            message: ('Rule ' + (j + 1) + ' from answer group ' +
                                                (i + 1) +
                                                ' will never be matched because it is an ' +
                                                'improper fraction')
                                        });
                                    }
                                }
                                if (!allowNonzeroIntegerPart) {
                                    var fraction = FractionObjectFactory.fromDict(rule.inputs.f);
                                    if (fraction.hasNonzeroIntegerPart()) {
                                        warningsList.push({
                                            type: WARNING_TYPES.ERROR,
                                            message: ('Rule ' + (j + 1) + ' from answer group ' +
                                                (i + 1) +
                                                ' will never be matched because it has a ' +
                                                'non zero integer part')
                                        });
                                    }
                                }
                                var f = toFloat(rule.inputs.f);
                                setLowerAndUpperBounds(range, f, f, true, true);
                                break;
                            case 'IsEquivalentTo': // fall-through
                            case 'IsEquivalentToAndInSimplestForm':
                                var f = toFloat(rule.inputs.f);
                                setLowerAndUpperBounds(range, f, f, true, true);
                                break;
                            case 'IsGreaterThan':
                                var f = toFloat(rule.inputs.f);
                                setLowerAndUpperBounds(range, f, Infinity, false, false);
                                break;
                            case 'IsLessThan':
                                var f = toFloat(rule.inputs.f);
                                setLowerAndUpperBounds(range, -Infinity, f, false, false);
                                break;
                            case 'HasNumeratorEqualTo':
                                if (!Number.isInteger(rule.inputs.x)) {
                                    warningsList.push(getNonIntegerInputWarning(i, j));
                                }
                                break;
                            case 'HasIntegerPartEqualTo':
                                if (!allowNonzeroIntegerPart && rule.inputs.x !== 0) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) +
                                            ' will never be matched because integer part ' +
                                            'has to be zero')
                                    });
                                }
                                if (!Number.isInteger(rule.inputs.x)) {
                                    warningsList.push(getNonIntegerInputWarning(i, j));
                                }
                                break;
                            case 'HasDenominatorEqualTo':
                                if (!Number.isInteger(rule.inputs.x)) {
                                    warningsList.push(getNonIntegerInputWarning(i, j));
                                }
                                if (rule.inputs.x === 0) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) + ' is invalid: denominator ' +
                                            'should be greater than zero.')
                                    });
                                }
                                matchedDenominator.denominator = rule.inputs.x;
                                break;
                            case 'HasFractionalPartExactlyEqualTo':
                                if (rule.inputs.f.wholeNumber !== 0) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) +
                                            ' is invalid as integer part should be zero')
                                    });
                                }
                                if (rule.inputs.f.isNegative !== false) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) +
                                            ' is invalid as sign should be positive')
                                    });
                                }
                                if (!allowImproperFraction) {
                                    var fraction = FractionObjectFactory.fromDict(rule.inputs.f);
                                    if (fraction.isImproperFraction()) {
                                        warningsList.push({
                                            type: WARNING_TYPES.ERROR,
                                            message: ('Rule ' + (j + 1) + ' from answer group ' +
                                                (i + 1) +
                                                ' is invalid as improper fractions are not allowed')
                                        });
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                        for (var k = 0; k < ranges.length; k++) {
                            if (isEnclosedBy(range, ranges[k])) {
                                var earlierRule = answerGroups[ranges[k].answerGroupIndex - 1]
                                    .rules[ranges[k].ruleIndex - 1];
                                if (shouldCheckRangeCriteria(earlierRule, rule)) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) + ' will never be matched because it ' +
                                            'is made redundant by rule ' + ranges[k].ruleIndex +
                                            ' from answer group ' + ranges[k].answerGroupIndex +
                                            '.')
                                    });
                                }
                            }
                        }
                        for (var k = 0; k < matchedDenominators.length; k++) {
                            if (matchedDenominators[k].denominator !== null &&
                                rule.type === 'HasFractionalPartExactlyEqualTo') {
                                if (matchedDenominators[k].denominator ===
                                    rule.inputs.f.denominator) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) + ' will never be matched because it ' +
                                            'is made redundant by rule ' +
                                            matchedDenominators[k].ruleIndex +
                                            ' from answer group ' +
                                            matchedDenominators[k].answerGroupIndex + '.')
                                    });
                                }
                            }
                        }
                        ranges.push(range);
                        matchedDenominators.push(matchedDenominator);
                    }
                }
                warningsList = warningsList.concat(baseInteractionValidationService.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
                return warningsList;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/FractionInput/directives/oppia-interactive-fraction-input.directive.ts":
/*!********************************************************************************************************!*\
  !*** ./extensions/interactions/FractionInput/directives/oppia-interactive-fraction-input.directive.ts ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the FractionInput interaction.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/FractionInput/directives/fraction-input-rules.service.ts */ "./extensions/interactions/FractionInput/directives/fraction-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
angular.module('oppia').directive('oppiaInteractiveFractionInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/FractionInput/directives/' +
                'fraction-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', 'FocusManagerService', 'FractionInputRulesService',
                'FractionObjectFactory', 'FRACTION_PARSING_ERRORS',
                'WindowDimensionsService', 'CurrentInteractionService',
                function ($scope, $attrs, FocusManagerService, FractionInputRulesService, FractionObjectFactory, FRACTION_PARSING_ERRORS, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.answer = '';
                    ctrl.labelForFocusTarget = $attrs.labelForFocusTarget || null;
                    var requireSimplestForm = ($attrs.requireSimplestFormWithValue === 'true');
                    var allowImproperFraction = ($attrs.allowImproperFractionWithValue === 'true');
                    ctrl.allowNonzeroIntegerPart = ($attrs.allowNonzeroIntegerPartWithValue === 'true');
                    ctrl.customPlaceholder = HtmlEscaperService.escapedJsonToObj($attrs.customPlaceholderWithValue);
                    var errorMessage = '';
                    // Label for errors caused whilst parsing a fraction.
                    var FORM_ERROR_TYPE = 'FRACTION_FORMAT_ERROR';
                    ctrl.FRACTION_INPUT_FORM_SCHEMA = {
                        type: 'unicode',
                        ui_config: {}
                    };
                    ctrl.getWarningText = function () {
                        return errorMessage;
                    };
                    /**
                     * Disables the input box if the data entered is not a valid prefix
                     * for a fraction.
                     * Examples of valid prefixes:
                     * -- 1
                     * -- 1 2
                     * -- 1 2/
                     * -- 2/
                     * -- 1 2/3
                     */
                    $scope.$watch('$ctrl.answer', function (newValue) {
                        var INVALID_CHARS_REGEX = /[^\d\s\/-]/g;
                        // Accepts incomplete fraction inputs
                        // (see examples above except last).
                        var PARTIAL_FRACTION_REGEX = /^\s*(-?\s*((\d*\s*\d+\s*\/?\s*)|\d+)\s*)?$/;
                        // Accepts complete fraction inputs.
                        var FRACTION_REGEX = /^\s*-?\s*((\d*\s*\d+\s*\/\s*\d+)|\d+)\s*$/;
                        if (INVALID_CHARS_REGEX.test(newValue)) {
                            errorMessage = FRACTION_PARSING_ERRORS.INVALID_CHARS;
                            ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                        }
                        else if (!(FRACTION_REGEX.test(newValue) ||
                            PARTIAL_FRACTION_REGEX.test(newValue))) {
                            errorMessage = FRACTION_PARSING_ERRORS.INVALID_FORMAT;
                            ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                        }
                        else {
                            errorMessage = '';
                            ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, true);
                        }
                    });
                    ctrl.submitAnswer = function (answer) {
                        try {
                            var fraction = FractionObjectFactory.fromRawInputString(answer);
                            if (requireSimplestForm &&
                                !angular.equals(fraction, fraction.convertToSimplestForm())) {
                                errorMessage = ('Please enter an answer in simplest form ' +
                                    '(e.g., 1/3 instead of 2/6).');
                                ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                            }
                            else if (!allowImproperFraction && fraction.isImproperFraction()) {
                                errorMessage = ('Please enter an answer with a "proper" fractional part ' +
                                    '(e.g., 1 2/3 instead of 5/3).');
                                ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                            }
                            else if (!ctrl.allowNonzeroIntegerPart &&
                                fraction.hasNonzeroIntegerPart()) {
                                errorMessage = ('Please enter your answer as a fraction (e.g., 5/3 instead ' +
                                    'of 1 2/3).');
                                ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                            }
                            else {
                                CurrentInteractionService.onSubmit(fraction, FractionInputRulesService);
                            }
                        }
                        catch (parsingError) {
                            errorMessage = parsingError.message;
                            ctrl.FractionInputForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                        }
                    };
                    ctrl.isAnswerValid = function () {
                        if (ctrl.FractionInputForm === undefined) {
                            return false;
                        }
                        return (!ctrl.FractionInputForm.$invalid && ctrl.answer !== '');
                    };
                    var submitAnswerFn = function () {
                        ctrl.submitAnswer(ctrl.answer);
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswerFn, ctrl.isAnswerValid);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/FractionInput/directives/oppia-response-fraction-input.directive.ts":
/*!*****************************************************************************************************!*\
  !*** ./extensions/interactions/FractionInput/directives/oppia-response-fraction-input.directive.ts ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the FractionInput response.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseFractionInput', [
    'FractionObjectFactory', 'HtmlEscaperService', 'UrlInterpolationService',
    function (FractionObjectFactory, HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/FractionInput/directives/' +
                'fraction-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.answer = FractionObjectFactory.fromDict(answer).toString();
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/FractionInput/directives/oppia-short-response-fraction-input.directive.ts":
/*!***********************************************************************************************************!*\
  !*** ./extensions/interactions/FractionInput/directives/oppia-short-response-fraction-input.directive.ts ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the FractionInput short response.
 */
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseFractionInput', [
    'FractionObjectFactory', 'HtmlEscaperService', 'UrlInterpolationService',
    function (FractionObjectFactory, HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/FractionInput/directives/' +
                'fraction-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.answer = FractionObjectFactory.fromDict(answer).toString();
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/GraphInput/GraphInput.ts":
/*!**********************************************************!*\
  !*** ./extensions/interactions/GraphInput/GraphInput.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for GraphInput interaction.
 */
__webpack_require__(/*! interactions/GraphInput/directives/graph-input-rules.service.ts */ "./extensions/interactions/GraphInput/directives/graph-input-rules.service.ts");
__webpack_require__(/*! interactions/GraphInput/directives/graph-input-validation.service.ts */ "./extensions/interactions/GraphInput/directives/graph-input-validation.service.ts");
__webpack_require__(/*! interactions/GraphInput/directives/oppia-interactive-graph-input.directive.ts */ "./extensions/interactions/GraphInput/directives/oppia-interactive-graph-input.directive.ts");
__webpack_require__(/*! interactions/GraphInput/directives/oppia-response-graph-input.directive.ts */ "./extensions/interactions/GraphInput/directives/oppia-response-graph-input.directive.ts");
__webpack_require__(/*! interactions/GraphInput/directives/oppia-short-response-graph-input.directive.ts */ "./extensions/interactions/GraphInput/directives/oppia-short-response-graph-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/graph-detail.service.ts":
/*!*******************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/graph-detail.service.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Detail service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var GraphDetailService = /** @class */ (function () {
    function GraphDetailService() {
        this.VERTEX_RADIUS = 6;
        this.EDGE_WIDTH = 3;
    }
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'graph' is a dict with 'answer' type object which is itself
    // typed 'any'.
    GraphDetailService.prototype.getDirectedEdgeArrowPoints = function (graph, index) {
        var ARROW_WIDTH = 5;
        var ARROW_HEIGHT = 10;
        var edge = graph.edges[index];
        var srcVertex = graph.vertices[edge.src];
        var dstVertex = graph.vertices[edge.dst];
        var dx = dstVertex.x - srcVertex.x;
        var dy = dstVertex.y - srcVertex.y;
        var length = Math.sqrt(dx * dx + dy * dy);
        if (length === 0) {
            return '';
        }
        dx /= length;
        dy /= length;
        var endX = dstVertex.x - 4 * dx;
        var endY = dstVertex.y - 4 * dy;
        var ret = '';
        ret +=
            endX + ',' +
                endY + ' ';
        ret +=
            (endX - ARROW_HEIGHT * dx + ARROW_WIDTH * dy) + ',' +
                (endY - ARROW_HEIGHT * dy - ARROW_WIDTH * dx) + ' ';
        ret +=
            (endX - ARROW_HEIGHT * dx - ARROW_WIDTH * dy) + ',' +
                (endY - ARROW_HEIGHT * dy + ARROW_WIDTH * dx);
        return ret;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'graph' is a dict with 'answer' type object which is itself
    // typed 'any'.
    GraphDetailService.prototype.getEdgeCentre = function (graph, index) {
        var edge = graph.edges[index];
        var srcVertex = graph.vertices[edge.src];
        var dstVertex = graph.vertices[edge.dst];
        return {
            x: (srcVertex.x + dstVertex.x) / 2.0,
            y: (srcVertex.y + dstVertex.y) / 2.0
        };
    };
    GraphDetailService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], GraphDetailService);
    return GraphDetailService;
}());
exports.GraphDetailService = GraphDetailService;
angular.module('oppia').factory('GraphDetailService', static_1.downgradeInjectable(GraphDetailService));


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/graph-input-rules.service.ts":
/*!************************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/graph-input-rules.service.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! interactions/GraphInput/directives/graph-utils.service.ts */ "./extensions/interactions/GraphInput/directives/graph-utils.service.ts");
angular.module('oppia').factory('GraphInputRulesService', [
    'GraphUtilsService', function (GraphUtilsService) {
        /**
         * @param {object} graph - A graph object.
         * @return {boolean} Whether the graph is strongly connected.
         */
        var isStronglyConnected = function (graph) {
            // Uses depth first search on each vertex to try and visit every other
            // vertex in both the normal and inverted adjacency lists.
            if (graph.vertices.length === 0) {
                return true;
            }
            var adjacencyLists = GraphUtilsService.constructAdjacencyLists(graph, GraphUtilsService.GRAPH_ADJACENCY_MODE.DIRECTED);
            var invertedAdjacencyLists = GraphUtilsService.constructAdjacencyLists(graph, GraphUtilsService.GRAPH_ADJACENCY_MODE.INVERTED);
            var isVisited = graph.vertices.map(function () {
                return false;
            });
            GraphUtilsService.markAccessible(0, adjacencyLists, isVisited);
            var isAnyVertexUnreachable = isVisited.some(function (visited) {
                return visited === false;
            });
            var isVisitedInReverse = graph.vertices.map(function () {
                return false;
            });
            GraphUtilsService.markAccessible(0, invertedAdjacencyLists, isVisitedInReverse);
            var isAnyVertexUnreachableInReverse = isVisitedInReverse.some(function (visited) {
                return visited === false;
            });
            return !isAnyVertexUnreachable && !isAnyVertexUnreachableInReverse;
        };
        /**
         * @param {object} graph - A graph object.
         * @return {boolean} Whether the graph is weakly connected.
         */
        var isWeaklyConnected = function (graph) {
            // Generates adjacency lists assuming graph is undirected, then uses depth
            // first search on node 0 to try to reach every other vertex
            if (graph.vertices.length === 0) {
                return true;
            }
            var adjacencyLists = GraphUtilsService.constructAdjacencyLists(graph, GraphUtilsService.GRAPH_ADJACENCY_MODE.UNDIRECTED);
            var isVisited = graph.vertices.map(function () {
                return false;
            });
            GraphUtilsService.markAccessible(0, adjacencyLists, isVisited);
            return isVisited.every(function (visited) {
                return visited === true;
            });
        };
        /**
         * @param {object} graph - A graph object.
         * @return {boolean} Whether the graph is acyclic.
         */
        var isAcyclic = function (graph) {
            // Uses depth first search to ensure that we never have an edge to an
            // ancestor in the search tree.
            var isVisited = graph.vertices.map(function () {
                return GraphUtilsService.DFS_STATUS.UNVISITED;
            });
            var adjacencyLists = GraphUtilsService.constructAdjacencyLists(graph, GraphUtilsService.GRAPH_ADJACENCY_MODE.DIRECTED);
            for (var startVertex = 0; startVertex < graph.vertices.length; startVertex++) {
                if (isVisited[startVertex] === GraphUtilsService.DFS_STATUS.UNVISITED) {
                    if (GraphUtilsService.findCycle(startVertex, -1, adjacencyLists, isVisited, graph.isDirected)) {
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * @param {object} graph - A graph object.
         * @return {boolean} Whether the graph is acyclic.
         */
        var isRegular = function (graph) {
            // Checks that every vertex has outdegree and indegree equal to the first
            if (graph.vertices.length === 0) {
                return true;
            }
            var adjacencyLists = GraphUtilsService.constructAdjacencyLists(graph, GraphUtilsService.GRAPH_ADJACENCY_MODE.DIRECTED);
            var outdegreeCounts = adjacencyLists.map(function (list) {
                return list.length;
            });
            var indegreeCounts = adjacencyLists.map(function () {
                return 0;
            });
            adjacencyLists.forEach(function (list) {
                list.forEach(function (destination) {
                    indegreeCounts[destination]++;
                });
            });
            var areIndegreeCountsEqual = indegreeCounts.every(function (indegree) {
                return indegree === indegreeCounts[0];
            });
            var areOutdegreeCountsEqual = outdegreeCounts.every(function (outdegree) {
                return outdegree === outdegreeCounts[0];
            });
            return areIndegreeCountsEqual && areOutdegreeCountsEqual;
        };
        var isIsomorphic = function (graph1, graph2) {
            if (graph1.vertices.length !== graph2.vertices.length) {
                return false;
            }
            var adj1 = GraphUtilsService.constructAdjacencyMatrix(graph1);
            var adj2 = GraphUtilsService.constructAdjacencyMatrix(graph2);
            // Check that for every vertex from the first graph there is a vertex in
            // the second graph with the same sum of weights of outgoing edges
            var degrees1 = adj1.map(function (value) {
                return value.reduce(function (prev, cur) {
                    return prev + cur;
                });
            }).sort();
            var degrees2 = adj2.map(function (value) {
                return value.reduce(function (prev, cur) {
                    return prev + cur;
                });
            }).sort();
            if (!angular.equals(degrees1, degrees2)) {
                return false;
            }
            // Check against every permutation of vectices.
            var numVertices = graph2.vertices.length;
            var permutation = [];
            for (var i = 0; i < numVertices; i++) {
                permutation.push(i);
            }
            while (permutation !== null) {
                var doLabelsMatch = (!graph1.isLabeled && !graph2.isLabeled) ||
                    graph2.vertices.every(function (vertex, index) {
                        return vertex.label === graph1.vertices[permutation[index]].label;
                    });
                if (doLabelsMatch &&
                    GraphUtilsService.areAdjacencyMatricesEqualWithPermutation(adj1, adj2, permutation)) {
                    return true;
                }
                permutation = GraphUtilsService.nextPermutation(permutation);
            }
            return false;
        };
        return {
            HasGraphProperty: function (answer, inputs) {
                if (inputs.p === 'strongly_connected') {
                    return isStronglyConnected(answer);
                }
                else if (inputs.p === 'weakly_connected') {
                    return isWeaklyConnected(answer);
                }
                else if (inputs.p === 'acyclic') {
                    return isAcyclic(answer);
                }
                else if (inputs.p === 'regular') {
                    return isRegular(answer);
                }
                else {
                    return false;
                }
            },
            IsIsomorphicTo: function (answer, inputs) {
                return isIsomorphic(answer, inputs.g);
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/graph-input-validation.service.ts":
/*!*****************************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/graph-input-validation.service.ts ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var GraphInputValidationService = /** @class */ (function () {
    function GraphInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
        this.VERTICES_LIMIT = 50;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    GraphInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['graph', 'canEditEdgeWeight', 'canEditVertexLabel']);
        if (customizationArgs.graph.value.vertices.length > this.VERTICES_LIMIT) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('The graph used in customization exceeds supported ' +
                    'maximum number of vertices of ' + this.VERTICES_LIMIT + '.')
            });
        }
        if (!customizationArgs.graph.value.isWeighted &&
            customizationArgs.canEditEdgeWeight.value) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('The learner cannot edit edge weights for an unweighted graph.')
            });
        }
        if (!customizationArgs.graph.value.isLabeled &&
            customizationArgs.canEditVertexLabel.value) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('The learner cannot edit vertex labels for an unlabeled graph.')
            });
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    GraphInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var ISOMORPHISM_VERTICES_LIMIT = 10;
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                try {
                    if (rule.type === 'HasGraphProperty') {
                        continue;
                    }
                    else if (rule.type === 'IsIsomorphicTo' &&
                        rule.inputs.g.vertices.length > ISOMORPHISM_VERTICES_LIMIT) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: ('The graph used in the rule ' + (j + 1) + ' in group ' +
                                (i + 1) + ' exceeds supported maximum number of vertices ' +
                                'of ' + ISOMORPHISM_VERTICES_LIMIT +
                                ' for isomorphism check.')
                        });
                    }
                    else if (rule.inputs.g.vertices.length > this.VERTICES_LIMIT) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: ('The graph used in the rule ' + (j + 1) + ' in group ' +
                                (i + 1) + ' exceeds supported maximum number of vertices ' +
                                'of ' + this.VERTICES_LIMIT + '.')
                        });
                    }
                }
                catch (e) {
                    warningsList.push({
                        type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                        message: ('The rule ' + (j + 1) + ' in group ' + (i + 1) +
                            ' is invalid.')
                    });
                }
            }
        }
        return warningsList;
    };
    var _a;
    GraphInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], GraphInputValidationService);
    return GraphInputValidationService;
}());
exports.GraphInputValidationService = GraphInputValidationService;
angular.module('oppia').factory('GraphInputValidationService', static_1.downgradeInjectable(GraphInputValidationService));


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/graph-utils.service.ts":
/*!******************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/graph-utils.service.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Utils service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var GraphUtilsService = /** @class */ (function () {
    function GraphUtilsService() {
        this.GRAPH_ADJACENCY_MODE = {
            DIRECTED: 'directed',
            INVERTED: 'inverted',
            UNDIRECTED: 'undirected'
        };
        this.DFS_STATUS = {
            VISITED: 'visited',
            UNVISITED: 'unvisited',
            STILL_VISITING: 'still visiting'
        };
    }
    /**
     * @param {object} graph - A graph object.
     * @param {string} adjacencyListMode - A string indicating the mode.
     * @return {array} An adjacency list. Depending on the mode, the list has
     *   all edges (directed),
     *   all edges inverted (inverted),
     *   or all edges in both directions, as though the graph were undirected
     *   (undirected)
     */
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'graph' is a dict with 'answer' type object which is itself
    // typed 'any'.
    GraphUtilsService.prototype.constructAdjacencyLists = function (graph, adjacencyListMode) {
        var adjacencyLists = [];
        for (var i = 0; i < graph.vertices.length; i++) {
            adjacencyLists.push([]);
        }
        // If a graph is undirected, all modes work the same way anyway
        if (!graph.isDirected) {
            adjacencyListMode = this.GRAPH_ADJACENCY_MODE.UNDIRECTED;
        }
        for (var i = 0; i < graph.edges.length; i++) {
            var edge = graph.edges[i];
            if (adjacencyListMode === this.GRAPH_ADJACENCY_MODE.DIRECTED ||
                adjacencyListMode === this.GRAPH_ADJACENCY_MODE.UNDIRECTED) {
                adjacencyLists[edge.src].push(edge.dst);
            }
            if (adjacencyListMode === (this.GRAPH_ADJACENCY_MODE.INVERTED) || adjacencyListMode === (this.GRAPH_ADJACENCY_MODE.UNDIRECTED)) {
                adjacencyLists[edge.dst].push(edge.src);
            }
        }
        return adjacencyLists;
    };
    /**
     * @param {integer} startVertex - The index of the starting vertex.
     * @param {array} adjacencyLists - An array of arrays.
     * @param {array} isVisited - An array with length equal to the number of
     *     vertices. All the values should be false initially.
     * This function modifies the isVisited array and changes the values at
     * the indices of the vertices reachable from the starting vertex to true.
     */
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'isVisited' is an array with both string and boolean values;
    // a thorough check needs to be done to assure its exact type.
    GraphUtilsService.prototype.markAccessible = function (startVertex, adjacencyLists, isVisited) {
        isVisited[startVertex] = true;
        for (var i = 0; i < adjacencyLists[startVertex].length; i++) {
            var nextVertex = adjacencyLists[startVertex][i];
            if (!isVisited[nextVertex]) {
                this.markAccessible(nextVertex, adjacencyLists, isVisited);
            }
        }
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'isVisited' is an array with both string and boolean values;
    // A thorough check needs to be done to assure of its exact type.
    GraphUtilsService.prototype.findCycle = function (currentVertex, previousVertex, adjacencyLists, isVisited, isDirected) {
        isVisited[currentVertex] = this.DFS_STATUS.STILL_VISITING;
        for (var i = 0; i < adjacencyLists[currentVertex].length; i++) {
            var nextVertex = adjacencyLists[currentVertex][i];
            if (nextVertex === previousVertex && !isDirected) {
                continue;
            }
            if (isVisited[nextVertex] === (this.DFS_STATUS.STILL_VISITING)) {
                return true;
            }
            if (isVisited[nextVertex] === this.DFS_STATUS.UNVISITED &&
                this.findCycle(nextVertex, currentVertex, adjacencyLists, isVisited, isDirected)) {
                return true;
            }
        }
        isVisited[currentVertex] = this.DFS_STATUS.VISITED;
        return false;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'graph' is a dict with 'answer' type object which is itself
    // typed 'any'.
    GraphUtilsService.prototype.constructAdjacencyMatrix = function (graph) {
        var adjMatrix = [];
        for (var i = 0; i < graph.vertices.length; i++) {
            var adjMatrixRow = [];
            for (var j = 0; j < graph.vertices.length; j++) {
                adjMatrixRow.push(null);
            }
            adjMatrix.push(adjMatrixRow);
        }
        // TODO(#7165): Replace 'any' with the exact type. This has been typed
        // as 'any' since 'edge' is a dict with various keys. A thorough research
        // needs to be carried out to determine exact type.
        graph.edges.map(function (edge) {
            var weight = graph.isWeighted ? edge.weight : 1;
            adjMatrix[edge.src][edge.dst] = weight;
            if (!graph.isDirected) {
                adjMatrix[edge.dst][edge.src] = weight;
            }
        });
        return adjMatrix;
    };
    GraphUtilsService.prototype.nextPermutation = function (permutation) {
        // Generates (in place) the next lexicographical permutation.
        // permutation is a permutation of [0, 1, 2, ..., permutation.length - 1]
        // Find the pivot to longest decreasing suffix and successor
        var pivot = null;
        var successor = null;
        permutation.reduce(function (previousValue, currentValue, currentIndex) {
            if (previousValue < currentValue) {
                pivot = currentIndex - 1;
            }
            if (pivot !== null && currentValue > permutation[pivot]) {
                successor = currentIndex;
            }
            return currentValue;
        });
        if (pivot === null) {
            return null;
        }
        // Swap the pivot and successor and reverse the suffix
        var tmp = permutation[pivot];
        permutation[pivot] = permutation[successor];
        permutation[successor] = tmp;
        permutation = permutation.concat(permutation.splice(pivot + 1).reverse());
        return permutation;
    };
    GraphUtilsService.prototype.areAdjacencyMatricesEqualWithPermutation = function (adj1, adj2, permutation) {
        var numVertices = adj1.length;
        for (var i = 0; i < numVertices; i++) {
            for (var j = 0; j < numVertices; j++) {
                if (adj1[permutation[i]][permutation[j]] !== adj2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    };
    GraphUtilsService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], GraphUtilsService);
    return GraphUtilsService;
}());
exports.GraphUtilsService = GraphUtilsService;
angular.module('oppia').factory('GraphUtilsService', static_1.downgradeInjectable(GraphUtilsService));


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/graph-viz.directive.ts":
/*!******************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/graph-viz.directive.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the graph-viz.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/GraphInput/directives/graph-detail.service.ts */ "./extensions/interactions/GraphInput/directives/graph-detail.service.ts");
__webpack_require__(/*! services/contextual/DeviceInfoService.ts */ "./core/templates/dev/head/services/contextual/DeviceInfoService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').directive('graphViz', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                graph: '=',
                canAddVertex: '=',
                canDeleteVertex: '=',
                canMoveVertex: '=',
                canEditVertexLabel: '=',
                canAddEdge: '=',
                canDeleteEdge: '=',
                canEditEdgeWeight: '=',
                canEditOptions: '=',
                isInteractionActive: '&interactionIsActive'
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/GraphInput/directives/' +
                'graph-viz.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$element', '$attrs', '$document', '$timeout',
                'FocusManagerService', 'GraphDetailService', 'GRAPH_INPUT_LEFT_MARGIN',
                'EVENT_NEW_CARD_AVAILABLE', 'DeviceInfoService',
                function ($scope, $element, $attrs, $document, $timeout, FocusManagerService, GraphDetailService, GRAPH_INPUT_LEFT_MARGIN, EVENT_NEW_CARD_AVAILABLE, DeviceInfoService) {
                    var ctrl = this;
                    var _MODES = {
                        MOVE: 0,
                        ADD_EDGE: 1,
                        ADD_VERTEX: 2,
                        DELETE: 3
                    };
                    // The current state of the UI and stuff like that
                    ctrl.state = {
                        currentMode: _MODES.MOVE,
                        // Vertex, edge, mode button, label currently being hovered over
                        hoveredVertex: null,
                        hoveredEdge: null,
                        hoveredModeButton: null,
                        // If in ADD_EDGE mode, source vertex of the new edge, if it exists
                        addEdgeVertex: null,
                        // Currently dragged vertex
                        currentlyDraggedVertex: null,
                        // Selected vertex for editing label
                        selectedVertex: null,
                        // Selected edge for editing weight
                        selectedEdge: null,
                        // Mouse position in SVG coordinates
                        mouseX: 0,
                        mouseY: 0,
                        // Original position of dragged vertex
                        vertexDragStartX: 0,
                        vertexDragStartY: 0,
                        // Original position of mouse when dragging started
                        mouseDragStartX: 0,
                        mouseDragStartY: 0
                    };
                    ctrl.VERTEX_RADIUS = GraphDetailService.VERTEX_RADIUS;
                    ctrl.EDGE_WIDTH = GraphDetailService.EDGE_WIDTH;
                    ctrl.selectedEdgeWeightValue = 0;
                    ctrl.shouldShowWrongWeightWarning = false;
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.state.currentMode = null;
                    });
                    ctrl.isMobile = false;
                    if (DeviceInfoService.isMobileDevice()) {
                        ctrl.isMobile = true;
                    }
                    var vizContainer = $($element).find('.oppia-graph-viz-svg');
                    ctrl.vizWidth = vizContainer.width();
                    ctrl.mousemoveGraphSVG = function (event) {
                        if (!ctrl.isInteractionActive()) {
                            return;
                        }
                        // Note: Transform client (X, Y) to SVG (X, Y). This has to be
                        // done so that changes due to viewBox attribute are
                        // propagated nicely.
                        var pt = vizContainer[0].createSVGPoint();
                        pt.x = event.clientX;
                        pt.y = event.clientY;
                        var svgp = pt.matrixTransform(vizContainer[0].getScreenCTM().inverse());
                        ctrl.state.mouseX = svgp.x;
                        ctrl.state.mouseY = svgp.y;
                        // We use vertexDragStartX/Y and mouseDragStartX/Y to make
                        // mouse-dragging by label more natural, by moving the vertex
                        // according to the difference from the original position.
                        // Otherwise, mouse-dragging by label will make the vertex
                        // awkwardly jump to the mouse.
                        if (ctrl.state.currentlyDraggedVertex !== null &&
                            (ctrl.state.mouseX > GRAPH_INPUT_LEFT_MARGIN)) {
                            ctrl.graph.vertices[ctrl.state.currentlyDraggedVertex].x = (ctrl.state.vertexDragStartX + (ctrl.state.mouseX - ctrl.state.mouseDragStartX));
                            ctrl.graph.vertices[ctrl.state.currentlyDraggedVertex].y = (ctrl.state.vertexDragStartY + (ctrl.state.mouseY - ctrl.state.mouseDragStartY));
                        }
                    };
                    ctrl.onClickGraphSVG = function () {
                        if (!ctrl.isInteractionActive()) {
                            return;
                        }
                        if (ctrl.state.currentMode === _MODES.ADD_VERTEX &&
                            ctrl.canAddVertex) {
                            ctrl.graph.vertices.push({
                                x: ctrl.state.mouseX,
                                y: ctrl.state.mouseY,
                                label: ''
                            });
                        }
                        if (ctrl.state.hoveredVertex === null) {
                            ctrl.state.selectedVertex = null;
                        }
                        if (ctrl.state.hoveredEdge === null) {
                            ctrl.state.selectedEdge = null;
                        }
                    };
                    ctrl.init = function () {
                        initButtons();
                        ctrl.state.currentMode = ctrl.buttons[0].mode;
                        if (ctrl.isMobile) {
                            if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                                ctrl.helpText =
                                    'I18N_INTERACTIONS_GRAPH_EDGE_INITIAL_HELPTEXT';
                            }
                            else if (ctrl.state.currentMode === _MODES.MOVE) {
                                ctrl.helpText =
                                    'I18N_INTERACTIONS_GRAPH_MOVE_INITIAL_HELPTEXT';
                            }
                            else {
                                ctrl.helpText = null;
                            }
                        }
                        else {
                            ctrl.helpText = null;
                        }
                    };
                    var initButtons = function () {
                        ctrl.buttons = [];
                        if (ctrl.canMoveVertex) {
                            ctrl.buttons.push({
                                text: '\uE068',
                                description: 'I18N_INTERACTIONS_GRAPH_MOVE',
                                mode: _MODES.MOVE
                            });
                        }
                        if (ctrl.canAddEdge) {
                            ctrl.buttons.push({
                                text: '\uE144',
                                description: 'I18N_INTERACTIONS_GRAPH_ADD_EDGE',
                                mode: _MODES.ADD_EDGE
                            });
                        }
                        if (ctrl.canAddVertex) {
                            ctrl.buttons.push({
                                text: '\u002B',
                                description: 'I18N_INTERACTIONS_GRAPH_ADD_NODE',
                                mode: _MODES.ADD_VERTEX
                            });
                        }
                        if (ctrl.canDeleteVertex || ctrl.canDeleteEdge) {
                            ctrl.buttons.push({
                                text: '\u2212',
                                description: 'I18N_INTERACTIONS_GRAPH_DELETE',
                                mode: _MODES.DELETE
                            });
                        }
                    };
                    var initViewboxSize = function () {
                        var svgContainer = $($element).find('.oppia-graph-viz-svg')[0];
                        var boundingBox = svgContainer.getBBox();
                        var viewBoxHeight = Math.max(boundingBox.height + boundingBox.y, svgContainer.getAttribute('height'));
                        ctrl.svgViewBox = (0 + ' ' + 0 + ' ' + (boundingBox.width + boundingBox.x) +
                            ' ' + (viewBoxHeight));
                    };
                    ctrl.graphOptions = [{
                            text: 'Labeled',
                            option: 'isLabeled'
                        },
                        {
                            text: 'Directed',
                            option: 'isDirected'
                        },
                        {
                            text: 'Weighted',
                            option: 'isWeighted'
                        }];
                    ctrl.toggleGraphOption = function (option) {
                        // Handle the case when we have two edges s -> d and d -> s
                        if (option === 'isDirected' && ctrl.graph[option]) {
                            _deleteRepeatedUndirectedEdges();
                        }
                        ctrl.graph[option] = !ctrl.graph[option];
                    };
                    ctrl.helpText = null;
                    var setMode = function (mode) {
                        ctrl.state.currentMode = mode;
                        if (ctrl.isMobile) {
                            if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                                ctrl.helpText =
                                    'I18N_INTERACTIONS_GRAPH_EDGE_INITIAL_HELPTEXT';
                            }
                            else if (ctrl.state.currentMode === _MODES.MOVE) {
                                ctrl.helpText =
                                    'I18N_INTERACTIONS_GRAPH_MOVE_INITIAL_HELPTEXT';
                            }
                            else {
                                ctrl.helpText = null;
                            }
                        }
                        else {
                            ctrl.helpText = null;
                        }
                        ctrl.state.addEdgeVertex = null;
                        ctrl.state.selectedVertex = null;
                        ctrl.state.selectedEdge = null;
                        ctrl.state.currentlyDraggedVertex = null;
                        ctrl.state.hoveredVertex = null;
                    };
                    ctrl.onClickModeButton = function (mode, $event) {
                        $event.preventDefault();
                        $event.stopPropagation();
                        if (ctrl.isInteractionActive()) {
                            setMode(mode);
                        }
                    };
                    // TODO(czx): Consider if there's a neat way to write a reset()
                    // function to clear bits of ctrl.state
                    // (e.g. currentlyDraggedVertex, addEdgeVertex)
                    // Vertex events
                    ctrl.onClickVertex = function (index) {
                        if (ctrl.state.currentMode === _MODES.DELETE) {
                            if (ctrl.canDeleteVertex) {
                                deleteVertex(index);
                            }
                        }
                        if (ctrl.state.currentMode !== _MODES.DELETE &&
                            ctrl.graph.isLabeled &&
                            ctrl.canEditVertexLabel) {
                            beginEditVertexLabel(index);
                        }
                        if (ctrl.isMobile) {
                            ctrl.state.hoveredVertex = index;
                            if (ctrl.state.addEdgeVertex === null &&
                                ctrl.state.currentlyDraggedVertex === null) {
                                ctrl.onTouchInitialVertex(index);
                            }
                            else {
                                if (ctrl.state.addEdgeVertex === index) {
                                    ctrl.state.hoveredVertex = null;
                                    ctrl.helpText =
                                        'I18N_INTERACTIONS_GRAPH_EDGE_INITIAL_HELPTEXT';
                                    ctrl.state.addEdgeVertex = null;
                                    return;
                                }
                                ctrl.onTouchFinalVertex(index);
                            }
                        }
                    };
                    ctrl.onTouchInitialVertex = function (index) {
                        if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                            if (ctrl.canAddEdge) {
                                beginAddEdge(index);
                                ctrl.helpText = 'I18N_INTERACTIONS_GRAPH_EDGE_FINAL_HELPTEXT';
                            }
                        }
                        else if (ctrl.state.currentMode === _MODES.MOVE) {
                            if (ctrl.canMoveVertex) {
                                beginDragVertex(index);
                                ctrl.helpText = 'I18N_INTERACTIONS_GRAPH_MOVE_FINAL_HELPTEXT';
                            }
                        }
                    };
                    ctrl.onTouchFinalVertex = function (index) {
                        if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                            tryAddEdge(ctrl.state.addEdgeVertex, index);
                            endAddEdge();
                            ctrl.state.hoveredVertex = null;
                            ctrl.helpText = 'I18N_INTERACTIONS_GRAPH_EDGE_INITIAL_HELPTEXT';
                        }
                        else if (ctrl.state.currentMode === _MODES.MOVE) {
                            if (ctrl.state.currentlyDraggedVertex !== null) {
                                endDragVertex();
                                ctrl.state.hoveredVertex = null;
                                ctrl.helpText =
                                    'I18N_INTERACTIONS_GRAPH_MOVE_INITIAL_HELPTEXT';
                            }
                        }
                    };
                    ctrl.onMousedownVertex = function (index) {
                        if (ctrl.isMobile) {
                            return;
                        }
                        if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                            if (ctrl.canAddEdge) {
                                beginAddEdge(index);
                            }
                        }
                        else if (ctrl.state.currentMode === _MODES.MOVE) {
                            if (ctrl.canMoveVertex) {
                                beginDragVertex(index);
                            }
                        }
                    };
                    ctrl.onMouseleaveVertex = function (index) {
                        if (ctrl.isMobile) {
                            return;
                        }
                        ctrl.state.hoveredVertex = (index === ctrl.state.hoveredVertex) ?
                            null : ctrl.state.hoveredVertex;
                    };
                    ctrl.onClickVertexLabel = function (index) {
                        if (ctrl.graph.isLabeled && ctrl.canEditVertexLabel) {
                            beginEditVertexLabel(index);
                        }
                    };
                    // Edge events
                    ctrl.onClickEdge = function (index) {
                        if (ctrl.state.currentMode === _MODES.DELETE) {
                            if (ctrl.canDeleteEdge) {
                                deleteEdge(index);
                            }
                        }
                        if (ctrl.state.currentMode !== _MODES.DELETE &&
                            ctrl.graph.isWeighted &&
                            ctrl.canEditEdgeWeight) {
                            beginEditEdgeWeight(index);
                        }
                    };
                    ctrl.onClickEdgeWeight = function (index) {
                        if (ctrl.graph.isWeighted && ctrl.canEditEdgeWeight) {
                            beginEditEdgeWeight(index);
                        }
                    };
                    // Document event
                    ctrl.onMouseupDocument = function () {
                        if (ctrl.isMobile) {
                            return;
                        }
                        if (ctrl.state.currentMode === _MODES.ADD_EDGE) {
                            if (ctrl.state.hoveredVertex !== null) {
                                tryAddEdge(ctrl.state.addEdgeVertex, ctrl.state.hoveredVertex);
                            }
                            endAddEdge();
                        }
                        else if (ctrl.state.currentMode === _MODES.MOVE) {
                            if (ctrl.state.currentlyDraggedVertex !== null) {
                                endDragVertex();
                            }
                        }
                    };
                    $document.on('mouseup', ctrl.onMouseupDocument);
                    // Actions
                    var beginAddEdge = function (startIndex) {
                        ctrl.state.addEdgeVertex = startIndex;
                    };
                    var endAddEdge = function () {
                        ctrl.state.addEdgeVertex = null;
                    };
                    var tryAddEdge = function (startIndex, endIndex) {
                        if (startIndex === null ||
                            endIndex === null ||
                            startIndex === endIndex ||
                            startIndex < 0 ||
                            endIndex < 0 ||
                            startIndex >= ctrl.graph.vertices.length ||
                            endIndex >= ctrl.graph.vertices.length) {
                            return;
                        }
                        for (var i = 0; i < ctrl.graph.edges.length; i++) {
                            if (startIndex === ctrl.graph.edges[i].src &&
                                endIndex === ctrl.graph.edges[i].dst) {
                                return;
                            }
                            if (!ctrl.graph.isDirected) {
                                if (startIndex === ctrl.graph.edges[i].dst &&
                                    endIndex === ctrl.graph.edges[i].src) {
                                    return;
                                }
                            }
                        }
                        ctrl.graph.edges.push({
                            src: startIndex,
                            dst: endIndex,
                            weight: 1
                        });
                        return;
                    };
                    var beginDragVertex = function (index) {
                        ctrl.state.currentlyDraggedVertex = index;
                        ctrl.state.vertexDragStartX = ctrl.graph.vertices[index].x;
                        ctrl.state.vertexDragStartY = ctrl.graph.vertices[index].y;
                        ctrl.state.mouseDragStartX = ctrl.state.mouseX;
                        ctrl.state.mouseDragStartY = ctrl.state.mouseY;
                    };
                    var endDragVertex = function () {
                        ctrl.state.currentlyDraggedVertex = null;
                        ctrl.state.vertexDragStartX = 0;
                        ctrl.state.vertexDragStartY = 0;
                        ctrl.state.mouseDragStartX = 0;
                        ctrl.state.mouseDragStartY = 0;
                    };
                    var beginEditVertexLabel = function (index) {
                        ctrl.state.selectedVertex = index;
                        FocusManagerService.setFocus('vertexLabelEditBegun');
                    };
                    var beginEditEdgeWeight = function (index) {
                        ctrl.state.selectedEdge = index;
                        ctrl.selectedEdgeWeightValue = (ctrl.graph.edges[ctrl.state.selectedEdge].weight);
                        ctrl.shouldShowWrongWeightWarning = false;
                        FocusManagerService.setFocus('edgeWeightEditBegun');
                    };
                    var deleteEdge = function (index) {
                        ctrl.graph.edges.splice(index, 1);
                        ctrl.state.hoveredEdge = null;
                    };
                    var _deleteRepeatedUndirectedEdges = function () {
                        for (var i = 0; i < ctrl.graph.edges.length; i++) {
                            var edge1 = ctrl.graph.edges[i];
                            for (var j = i + 1; j < ctrl.graph.edges.length; j++) {
                                var edge2 = ctrl.graph.edges[j];
                                if ((edge1.src === edge2.src && edge1.dst === edge2.dst) ||
                                    (edge1.src === edge2.dst && edge1.dst === edge2.src)) {
                                    deleteEdge(j);
                                    j--;
                                }
                            }
                        }
                    };
                    var deleteVertex = function (index) {
                        // Using jQuery's map instead of normal array.map because
                        // it removes elements for which the callback returns null
                        ctrl.graph.edges = $.map(ctrl.graph.edges, function (edge) {
                            if (edge.src === index || edge.dst === index) {
                                return null;
                            }
                            if (edge.src > index) {
                                edge.src--;
                            }
                            if (edge.dst > index) {
                                edge.dst--;
                            }
                            return edge;
                        });
                        ctrl.graph.vertices.splice(index, 1);
                        ctrl.state.hoveredVertex = null;
                    };
                    ctrl.selectedVertexLabelGetterSetter = function (label) {
                        if (ctrl.state.selectedVertex === null) {
                            return '';
                        }
                        if (angular.isDefined(label)) {
                            ctrl.graph.vertices[ctrl.state.selectedVertex].label = label;
                        }
                        return ctrl.graph.vertices[ctrl.state.selectedVertex].label;
                    };
                    ctrl.selectedEdgeWeight = function (weight) {
                        if (ctrl.state.selectedEdge === null) {
                            return '';
                        }
                        if (weight === null) {
                            ctrl.selectedEdgeWeightValue = '';
                        }
                        if (angular.isNumber(weight)) {
                            ctrl.selectedEdgeWeightValue = weight;
                        }
                        return ctrl.selectedEdgeWeightValue;
                    };
                    ctrl.isValidEdgeWeight = function () {
                        return angular.isNumber(ctrl.selectedEdgeWeightValue);
                    };
                    ctrl.onUpdateEdgeWeight = function () {
                        if (angular.isNumber(ctrl.selectedEdgeWeightValue)) {
                            ctrl.graph.edges[ctrl.state.selectedEdge].weight = (ctrl.selectedEdgeWeightValue);
                        }
                        ctrl.state.selectedEdge = null;
                    };
                    // Styling functions
                    var DELETE_COLOR = 'red';
                    var HOVER_COLOR = 'aqua';
                    var SELECT_COLOR = 'orange';
                    var DEFAULT_COLOR = 'black';
                    ctrl.getEdgeColor = function (index) {
                        if (!ctrl.isInteractionActive()) {
                            return DEFAULT_COLOR;
                        }
                        if (ctrl.state.currentMode === _MODES.DELETE &&
                            index === ctrl.state.hoveredEdge &&
                            ctrl.canDeleteEdge) {
                            return DELETE_COLOR;
                        }
                        else if (index === ctrl.state.hoveredEdge) {
                            return HOVER_COLOR;
                        }
                        else if (ctrl.state.selectedEdge === index) {
                            return SELECT_COLOR;
                        }
                        else {
                            return DEFAULT_COLOR;
                        }
                    };
                    ctrl.getVertexColor = function (index) {
                        if (!ctrl.isInteractionActive()) {
                            return DEFAULT_COLOR;
                        }
                        if (ctrl.state.currentMode === _MODES.DELETE &&
                            index === ctrl.state.hoveredVertex &&
                            ctrl.canDeleteVertex) {
                            return DELETE_COLOR;
                        }
                        else if (index === ctrl.state.currentlyDraggedVertex) {
                            return HOVER_COLOR;
                        }
                        else if (index === ctrl.state.hoveredVertex) {
                            return HOVER_COLOR;
                        }
                        else if (ctrl.state.selectedVertex === index) {
                            return SELECT_COLOR;
                        }
                        else {
                            return DEFAULT_COLOR;
                        }
                    };
                    ctrl.getDirectedEdgeArrowPoints = function (index) {
                        return GraphDetailService.getDirectedEdgeArrowPoints(ctrl.graph, index);
                    };
                    ctrl.getEdgeCentre = function (index) {
                        return GraphDetailService.getEdgeCentre(ctrl.graph, index);
                    };
                    // Initial value of SVG view box.
                    ctrl.svgViewBox = initViewboxSize();
                    if (ctrl.isInteractionActive()) {
                        ctrl.init();
                    }
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/oppia-interactive-graph-input.directive.ts":
/*!**************************************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/oppia-interactive-graph-input.directive.ts ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the GraphInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! interactions/GraphInput/directives/graph-viz.directive.ts */ "./extensions/interactions/GraphInput/directives/graph-viz.directive.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/GraphInput/directives/graph-input-rules.service.ts */ "./extensions/interactions/GraphInput/directives/graph-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
angular.module('oppia').directive('oppiaInteractiveGraphInput', [
    'GraphInputRulesService', 'HtmlEscaperService', 'UrlInterpolationService',
    'EVENT_NEW_CARD_AVAILABLE',
    function (GraphInputRulesService, HtmlEscaperService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer',
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/GraphInput/directives/' +
                'graph-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$element', '$attrs', 'WindowDimensionsService',
                'CurrentInteractionService',
                function ($scope, $element, $attrs, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.errorMessage = '';
                    ctrl.graph = {
                        vertices: [],
                        edges: [],
                        isDirected: false,
                        isWeighted: false,
                        isLabeled: false
                    };
                    ctrl.submitGraph = function () {
                        // Here, angular.copy is needed to strip $$hashkey from the graph.
                        CurrentInteractionService.onSubmit(angular.copy(ctrl.graph), GraphInputRulesService);
                    };
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                        ctrl.canAddVertex = false;
                        ctrl.canDeleteVertex = false;
                        ctrl.canEditVertexLabel = false;
                        ctrl.canMoveVertex = false;
                        ctrl.canAddEdge = false;
                        ctrl.canDeleteEdge = false;
                        ctrl.canEditEdgeWeight = false;
                    });
                    ctrl.resetGraph = function () {
                        var newGraph = HtmlEscaperService.escapedJsonToObj($attrs.graphWithValue);
                        if (checkValidGraph(newGraph)) {
                            ctrl.graph = newGraph;
                        }
                        else {
                            ctrl.errorMessage = 'I18N_INTERACTIONS_GRAPH_ERROR_INVALID';
                        }
                    };
                    var init = function () {
                        if (ctrl.interactionIsActive) {
                            ctrl.resetGraph();
                        }
                        else {
                            ctrl.graph = ctrl.getLastAnswer();
                        }
                        var stringToBool = function (str) {
                            return (str === 'true');
                        };
                        ctrl.canAddVertex = ctrl.interactionIsActive ?
                            stringToBool($attrs.canAddVertexWithValue) : false;
                        ctrl.canDeleteVertex = ctrl.interactionIsActive ?
                            stringToBool($attrs.canDeleteVertexWithValue) : false;
                        ctrl.canEditVertexLabel = ctrl.interactionIsActive ?
                            stringToBool($attrs.canEditVertexLabelWithValue) : false;
                        ctrl.canMoveVertex = ctrl.interactionIsActive ?
                            stringToBool($attrs.canMoveVertexWithValue) : false;
                        ctrl.canAddEdge = ctrl.interactionIsActive ?
                            stringToBool($attrs.canAddEdgeWithValue) : false;
                        ctrl.canDeleteEdge = ctrl.interactionIsActive ?
                            stringToBool($attrs.canDeleteEdgeWithValue) : false;
                        ctrl.canEditEdgeWeight = ctrl.interactionIsActive ?
                            stringToBool($attrs.canEditEdgeWeightWithValue) : false;
                    };
                    // TODO(czxcjx): Write this function
                    var checkValidGraph = function (graph) {
                        return Boolean(graph);
                    };
                    var validityCheckFn = function () {
                        return checkValidGraph(ctrl.graph);
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitGraph, validityCheckFn);
                    init();
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/oppia-response-graph-input.directive.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/oppia-response-graph-input.directive.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the GraphInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/GraphInput/directives/graph-detail.service.ts */ "./extensions/interactions/GraphInput/directives/graph-detail.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').directive('oppiaResponseGraphInput', [
    'GraphDetailService', 'HtmlEscaperService', 'UrlInterpolationService',
    'GRAPH_INPUT_LEFT_MARGIN',
    function (GraphDetailService, HtmlEscaperService, UrlInterpolationService, GRAPH_INPUT_LEFT_MARGIN) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/GraphInput/directives/' +
                'graph-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.graph = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.VERTEX_RADIUS = GraphDetailService.VERTEX_RADIUS;
                    ctrl.EDGE_WIDTH = GraphDetailService.EDGE_WIDTH;
                    ctrl.GRAPH_INPUT_LEFT_MARGIN = GRAPH_INPUT_LEFT_MARGIN;
                    ctrl.getDirectedEdgeArrowPoints = function (index) {
                        return GraphDetailService.getDirectedEdgeArrowPoints(ctrl.graph, index);
                    };
                    ctrl.getEdgeCentre = function (index) {
                        return GraphDetailService.getEdgeCentre(ctrl.graph, index);
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/GraphInput/directives/oppia-short-response-graph-input.directive.ts":
/*!*****************************************************************************************************!*\
  !*** ./extensions/interactions/GraphInput/directives/oppia-short-response-graph-input.directive.ts ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the GraphInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseGraphInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/GraphInput/directives/' +
                'graph-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    // TODO(bhenning): Improve this short response by using a small version
                    // of the graph image instead of an arbitrary label of vertices and
                    // edges.
                    ctrl.graph = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/ImageClickInput.ts":
/*!********************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/ImageClickInput.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for ImageClickInput interaction.
 */
__webpack_require__(/*! interactions/ImageClickInput/directives/image-click-input-rules.service.ts */ "./extensions/interactions/ImageClickInput/directives/image-click-input-rules.service.ts");
__webpack_require__(/*! interactions/ImageClickInput/directives/image-click-input-validation.service.ts */ "./extensions/interactions/ImageClickInput/directives/image-click-input-validation.service.ts");
__webpack_require__(/*! interactions/ImageClickInput/directives/oppia-interactive-image-click-input.directive.ts */ "./extensions/interactions/ImageClickInput/directives/oppia-interactive-image-click-input.directive.ts");
__webpack_require__(/*! interactions/ImageClickInput/directives/oppia-response-image-click-input.directive.ts */ "./extensions/interactions/ImageClickInput/directives/oppia-response-image-click-input.directive.ts");
__webpack_require__(/*! interactions/ImageClickInput/directives/oppia-short-response-image-click-input.directive.ts */ "./extensions/interactions/ImageClickInput/directives/oppia-short-response-image-click-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/directives/image-click-input-rules.service.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/directives/image-click-input-rules.service.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Rules service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var ImageClickInputRulesService = /** @class */ (function () {
    function ImageClickInputRulesService() {
    }
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'answer' is a complex object having varying types. A general
    // type needs to be found. Same goes for 'inputs'.
    ImageClickInputRulesService.prototype.IsInRegion = function (answer, inputs) {
        return answer.clickedRegions.indexOf(inputs.x) !== -1;
    };
    ImageClickInputRulesService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], ImageClickInputRulesService);
    return ImageClickInputRulesService;
}());
exports.ImageClickInputRulesService = ImageClickInputRulesService;
angular.module('oppia').factory('ImageClickInputRulesService', static_1.downgradeInjectable(ImageClickInputRulesService));


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/directives/image-click-input-validation.service.ts":
/*!****************************************************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/directives/image-click-input-validation.service.ts ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var ImageClickInputValidationService = /** @class */ (function () {
    function ImageClickInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    ImageClickInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['imageAndRegions']);
        var warningsList = [];
        var imgAndRegionArgValue = customizationArgs.imageAndRegions.value;
        if (!imgAndRegionArgValue.imagePath) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please add an image for the learner to click on.'
            });
            // If there is no image specified, further warnings don't really
            // apply.
            return warningsList;
        }
        var areAnyRegionStringsEmpty = false;
        var areAnyRegionStringsNonAlphaNumeric = false;
        var areAnyRegionStringsDuplicated = false;
        var seenRegionStrings = [];
        if (imgAndRegionArgValue.labeledRegions.length === 0) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: 'Please specify at least one region in the image.'
            });
        }
        for (var i = 0; i < imgAndRegionArgValue.labeledRegions.length; i++) {
            var regionLabel = (imgAndRegionArgValue.labeledRegions[i].label);
            var ALPHANUMERIC_REGEX = /^[A-Za-z0-9]+$/;
            if (regionLabel.trim().length === 0) {
                areAnyRegionStringsEmpty = true;
            }
            else if (!ALPHANUMERIC_REGEX.test(regionLabel)) {
                areAnyRegionStringsNonAlphaNumeric = true;
            }
            else if (seenRegionStrings.indexOf(regionLabel) !== -1) {
                areAnyRegionStringsDuplicated = true;
            }
            else {
                seenRegionStrings.push(regionLabel);
            }
        }
        if (areAnyRegionStringsEmpty) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the region labels are nonempty.'
            });
        }
        if (areAnyRegionStringsNonAlphaNumeric) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('The region labels should consist of alphanumeric characters.')
            });
        }
        if (areAnyRegionStringsDuplicated) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the region labels are unique.'
            });
        }
        return warningsList;
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    ImageClickInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAnswerGroupWarnings(answerGroups, stateName));
        var imgAndRegionArgValue = customizationArgs.imageAndRegions.value;
        var seenRegionStrings = imgAndRegionArgValue.labeledRegions.map(function (region) {
            return region.label;
        });
        // Check that each rule refers to a valid region string.
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                if (rules[j].type === 'IsInRegion') {
                    var label = rules[j].inputs.x;
                    if (seenRegionStrings.indexOf(label) === -1) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: ('The region label \'' + label + '\' in rule ' +
                                String(j + 1) + ' in group ' + String(i + 1) +
                                ' is invalid.')
                        });
                    }
                }
            }
        }
        if (!defaultOutcome || defaultOutcome.isConfusing(stateName)) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: ('Please add a rule to cover what should happen if none of the ' +
                    'given regions are clicked.')
            });
        }
        return warningsList;
    };
    var _a;
    ImageClickInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], ImageClickInputValidationService);
    return ImageClickInputValidationService;
}());
exports.ImageClickInputValidationService = ImageClickInputValidationService;
angular.module('oppia').factory('ImageClickInputValidationService', static_1.downgradeInjectable(ImageClickInputValidationService));


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/directives/oppia-interactive-image-click-input.directive.ts":
/*!*************************************************************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/directives/oppia-interactive-image-click-input.directive.ts ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ImageClickInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! interactions/ImageClickInput/directives/image-click-input-rules.service.ts */ "./extensions/interactions/ImageClickInput/directives/image-click-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/image-preloader.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/image-preloader.service.ts");
__webpack_require__(/*! services/AssetsBackendApiService.ts */ "./core/templates/dev/head/services/AssetsBackendApiService.ts");
__webpack_require__(/*! services/ContextService.ts */ "./core/templates/dev/head/services/ContextService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveImageClickInput', [
    'AssetsBackendApiService', 'ContextService',
    'HtmlEscaperService', 'ImageClickInputRulesService', 'ImagePreloaderService',
    'UrlInterpolationService', 'EVENT_NEW_CARD_AVAILABLE',
    'EXPLORATION_EDITOR_TAB_CONTEXT', 'LOADING_INDICATOR_URL',
    function (AssetsBackendApiService, ContextService, HtmlEscaperService, ImageClickInputRulesService, ImagePreloaderService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE, EXPLORATION_EDITOR_TAB_CONTEXT, LOADING_INDICATOR_URL) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer'
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ImageClickInput/directives/' +
                'image-click-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$element', '$attrs', '$scope', 'CurrentInteractionService',
                function ($element, $attrs, $scope, CurrentInteractionService) {
                    var ctrl = this;
                    var imageAndRegions = HtmlEscaperService.escapedJsonToObj($attrs.imageAndRegionsWithValue);
                    ctrl.highlightRegionsOnHover =
                        ($attrs.highlightRegionsOnHoverWithValue === 'true');
                    ctrl.filepath = imageAndRegions.imagePath;
                    ctrl.imageUrl = '';
                    ctrl.loadingIndicatorUrl = UrlInterpolationService
                        .getStaticImageUrl(LOADING_INDICATOR_URL);
                    ctrl.isLoadingIndicatorShown = false;
                    ctrl.isTryAgainShown = false;
                    if (ImagePreloaderService.inExplorationPlayer()) {
                        ctrl.isLoadingIndicatorShown = true;
                        ctrl.dimensions = (ImagePreloaderService.getDimensionsOfImage(ctrl.filepath));
                        // For aligning the gif to the center of it's container
                        var loadingIndicatorSize = ((ctrl.dimensions.height < 124) ? 24 : 120);
                        ctrl.imageContainerStyle = {
                            height: ctrl.dimensions.height + 'px'
                        };
                        ctrl.loadingIndicatorStyle = {
                            height: loadingIndicatorSize + 'px',
                            width: loadingIndicatorSize + 'px'
                        };
                        ctrl.loadImage = function () {
                            ImagePreloaderService.getImageUrl(ctrl.filepath)
                                .then(function (objectUrl) {
                                ctrl.isTryAgainShown = false;
                                ctrl.isLoadingIndicatorShown = false;
                                ctrl.imageUrl = objectUrl;
                            }, function () {
                                ctrl.isTryAgainShown = true;
                                ctrl.isLoadingIndicatorShown = false;
                            });
                        };
                        ctrl.loadImage();
                    }
                    else {
                        // This is the case when user is in exploration editor or in
                        // preview mode. We don't have loading indicator or try again for
                        // showing images in the exploration editor or in preview mode. So
                        // we directly assign the url to the imageUrl.
                        ctrl.imageUrl = AssetsBackendApiService.getImageUrlForPreview(ContextService.getEntityType(), ContextService.getEntityId(), ctrl.filepath);
                    }
                    ctrl.mouseX = 0;
                    ctrl.mouseY = 0;
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    if (!ctrl.interactionIsActive) {
                        ctrl.lastAnswer = ctrl.getLastAnswer();
                    }
                    ctrl.currentlyHoveredRegions = [];
                    ctrl.allRegions = imageAndRegions.labeledRegions;
                    ctrl.updateCurrentlyHoveredRegions = function () {
                        for (var i = 0; i < imageAndRegions.labeledRegions.length; i++) {
                            var labeledRegion = imageAndRegions.labeledRegions[i];
                            var regionArea = labeledRegion.region.area;
                            if (regionArea[0][0] <= ctrl.mouseX &&
                                ctrl.mouseX <= regionArea[1][0] &&
                                regionArea[0][1] <= ctrl.mouseY &&
                                ctrl.mouseY <= regionArea[1][1]) {
                                ctrl.currentlyHoveredRegions.push(labeledRegion.label);
                            }
                        }
                    };
                    if (!ctrl.interactionIsActive) {
                        /* The following lines highlight the learner's last answer for this
                          card. This need only be done at the beginning as if he submits
                          an answer, based on EVENT_NEW_CARD_AVAILABLE, the image is made
                          inactive, so his last selection would be higlighted.*/
                        ctrl.mouseX = ctrl.getLastAnswer().clickPosition[0];
                        ctrl.mouseY = ctrl.getLastAnswer().clickPosition[1];
                        ctrl.updateCurrentlyHoveredRegions();
                    }
                    ctrl.getRegionDimensions = function (index) {
                        var image = $($element).find('.oppia-image-click-img');
                        var labeledRegion = imageAndRegions.labeledRegions[index];
                        var regionArea = labeledRegion.region.area;
                        var leftDelta = image.offset().left - image.parent().offset().left;
                        var topDelta = image.offset().top - image.parent().offset().top;
                        return {
                            left: regionArea[0][0] * image.width() + leftDelta,
                            top: regionArea[0][1] * image.height() + topDelta,
                            width: (regionArea[1][0] - regionArea[0][0]) * image.width(),
                            height: (regionArea[1][1] - regionArea[0][1]) * image.height()
                        };
                    };
                    ctrl.getRegionDisplay = function (label) {
                        if (ctrl.currentlyHoveredRegions.indexOf(label) === -1) {
                            return 'none';
                        }
                        else {
                            return 'inline';
                        }
                    };
                    ctrl.getDotDisplay = function () {
                        if (ContextService.getEditorTabContext() ===
                            EXPLORATION_EDITOR_TAB_CONTEXT.EDITOR) {
                            return 'none';
                        }
                        return 'inline';
                    };
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                        ctrl.lastAnswer = {
                            clickPosition: [ctrl.mouseX, ctrl.mouseY]
                        };
                    });
                    ctrl.getDotLocation = function () {
                        var image = $($element).find('.oppia-image-click-img');
                        var dotLocation = {
                            left: null,
                            top: null
                        };
                        if (ctrl.lastAnswer) {
                            dotLocation.left =
                                ctrl.lastAnswer.clickPosition[0] * image.width() +
                                    image.offset().left -
                                    image.parent().offset().left - 5;
                            dotLocation.top =
                                ctrl.lastAnswer.clickPosition[1] * image.height() +
                                    image.offset().top -
                                    image.parent().offset().top - 5;
                        }
                        return dotLocation;
                    };
                    ctrl.onMousemoveImage = function (event) {
                        if (!ctrl.interactionIsActive) {
                            return;
                        }
                        var image = $($element).find('.oppia-image-click-img');
                        ctrl.mouseX =
                            (event.pageX - image.offset().left) / image.width();
                        ctrl.mouseY =
                            (event.pageY - image.offset().top) / image.height();
                        ctrl.currentlyHoveredRegions = [];
                        ctrl.updateCurrentlyHoveredRegions();
                    };
                    ctrl.onClickImage = function () {
                        var answer = {
                            clickPosition: [ctrl.mouseX, ctrl.mouseY],
                            clickedRegions: ctrl.currentlyHoveredRegions
                        };
                        CurrentInteractionService.onSubmit(answer, ImageClickInputRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(null, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/directives/oppia-response-image-click-input.directive.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/directives/oppia-response-image-click-input.directive.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ImageClickInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseImageClickInput', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ImageClickInput/directives/' +
                'image-click-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'HtmlEscaperService',
                function ($attrs, HtmlEscaperService) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.clickRegionLabel = '(Clicks on ' + (_answer.clickedRegions.length > 0 ?
                        '\'' + _answer.clickedRegions[0] + '\'' : 'image') + ')';
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ImageClickInput/directives/oppia-short-response-image-click-input.directive.ts":
/*!****************************************************************************************************************!*\
  !*** ./extensions/interactions/ImageClickInput/directives/oppia-short-response-image-click-input.directive.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ImageClickInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseImageClickInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ImageClickInput/directives/' +
                'image-click-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.clickRegionLabel = (_answer.clickedRegions.length > 0 ? _answer.clickedRegions[0] :
                        'Clicked on image');
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/InteractiveMap.ts":
/*!******************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/InteractiveMap.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for InteractiveMap interaction.
 */
__webpack_require__(/*! interactions/InteractiveMap/directives/interactive-map-rules.service.ts */ "./extensions/interactions/InteractiveMap/directives/interactive-map-rules.service.ts");
__webpack_require__(/*! interactions/InteractiveMap/directives/interactive-map-validation.service.ts */ "./extensions/interactions/InteractiveMap/directives/interactive-map-validation.service.ts");
__webpack_require__(/*! interactions/InteractiveMap/directives/oppia-interactive-interactive-map.directive.ts */ "./extensions/interactions/InteractiveMap/directives/oppia-interactive-interactive-map.directive.ts");
__webpack_require__(/*! interactions/InteractiveMap/directives/oppia-response-interactive-map.directive.ts */ "./extensions/interactions/InteractiveMap/directives/oppia-response-interactive-map.directive.ts");
__webpack_require__(/*! interactions/InteractiveMap/directives/oppia-short-response-interactive-map.directive.ts */ "./extensions/interactions/InteractiveMap/directives/oppia-short-response-interactive-map.directive.ts");


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/directives/interactive-map-rules.service.ts":
/*!********************************************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/directives/interactive-map-rules.service.ts ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
angular.module('oppia').factory('InteractiveMapRulesService', [
    function () {
        var RADIUS_OF_EARTH_KM = 6371.0;
        var degreesToRadians = function (angle) {
            return angle / 180 * Math.PI;
        };
        var getDistanceInKm = function (point1, point2) {
            var latitude1 = degreesToRadians(point1[0]);
            var latitude2 = degreesToRadians(point2[0]);
            var latitudeDifference = degreesToRadians(point2[0] - point1[0]);
            var longitudeDifference = degreesToRadians(point2[1] - point1[1]);
            // Use the haversine formula
            var haversineOfCentralAngle = (Math.pow(Math.sin(latitudeDifference / 2), 2) +
                Math.cos(latitude1) * Math.cos(latitude2) *
                    Math.pow(Math.sin(longitudeDifference / 2), 2));
            return RADIUS_OF_EARTH_KM *
                2 * Math.asin(Math.sqrt(haversineOfCentralAngle));
        };
        return {
            Within: function (answer, inputs) {
                var actualDistance = getDistanceInKm(inputs.p, answer);
                return actualDistance <= inputs.d;
            },
            NotWithin: function (answer, inputs) {
                var actualDistance = getDistanceInKm(inputs.p, answer);
                return actualDistance > inputs.d;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/directives/interactive-map-validation.service.ts":
/*!*************************************************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/directives/interactive-map-validation.service.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validation service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var InteractiveMapValidationService = /** @class */ (function () {
    function InteractiveMapValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    InteractiveMapValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['latitude', 'longitude']);
        if (customizationArgs.latitude.value < -90 ||
            customizationArgs.latitude.value > 90) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please pick a starting latitude between -90 and 90.'
            });
        }
        if (customizationArgs.longitude.value < -180 ||
            customizationArgs.longitude.value > 180) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please pick a starting longitude between -180 and 180.'
            });
        }
        return warningsList;
    };
    InteractiveMapValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                if (rules[j].type === 'Within' ||
                    rules[j].type === 'NotWithin') {
                    if (rules[j].inputs.d < 0) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: 'Please ensure that rule ' + String(j + 1) +
                                ' in group ' + String(i + 1) +
                                ' refers to a valid distance.'
                        });
                    }
                }
            }
        }
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
        return warningsList;
    };
    var _a;
    InteractiveMapValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], InteractiveMapValidationService);
    return InteractiveMapValidationService;
}());
exports.InteractiveMapValidationService = InteractiveMapValidationService;
angular.module('oppia').factory('InteractiveMapValidationService', static_1.downgradeInjectable(InteractiveMapValidationService));


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/directives/oppia-interactive-interactive-map.directive.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/directives/oppia-interactive-interactive-map.directive.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the InteractiveMap interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! interactions/uiLeafletRequires.ts */ "./extensions/interactions/uiLeafletRequires.ts");
__webpack_require__(/*! domain/utilities/BrowserCheckerService.ts */ "./core/templates/dev/head/domain/utilities/BrowserCheckerService.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/InteractiveMap/directives/interactive-map-rules.service.ts */ "./extensions/interactions/InteractiveMap/directives/interactive-map-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveInteractiveMap', [
    'HtmlEscaperService', 'InteractiveMapRulesService', 'UrlInterpolationService',
    'EVENT_NEW_CARD_AVAILABLE',
    function (HtmlEscaperService, InteractiveMapRulesService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer'
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/directives/' +
                'interactive-map-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', '$scope', '$timeout', 'BrowserCheckerService',
                'CurrentInteractionService', function ($attrs, $scope, $timeout, BrowserCheckerService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.coords = [
                        HtmlEscaperService.escapedJsonToObj($attrs.latitudeWithValue),
                        HtmlEscaperService.escapedJsonToObj($attrs.longitudeWithValue)
                    ];
                    ctrl.zoom = (HtmlEscaperService.escapedJsonToObj($attrs.zoomWithValue));
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    ctrl.mapMarkers = {};
                    var coords = ctrl.coords || [0, 0];
                    var zoomLevel = parseInt(ctrl.zoom, 10) || 0;
                    ctrl.setOverlay = function () {
                        ctrl.overlayStyle = {
                            'background-color': 'white',
                            opacity: 0.5,
                            'z-index': 1001
                        };
                    };
                    ctrl.hideOverlay = function () {
                        ctrl.overlayStyle = {
                            'background-color': 'white'
                        };
                    };
                    var changeMarkerPosition = function (lat, lng) {
                        ctrl.mapMarkers.mainMarker = {
                            lat: lat,
                            lng: lng,
                            icon: {
                                iconUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon.png'),
                                // The size of the icon image in pixels.
                                iconSize: [25, 41],
                                // The coordinates of the "tip" of the icon.
                                iconAnchor: [12, 41],
                                shadowUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png'),
                                // The size of the shadow image in pixels.
                                shadowSize: [41, 41],
                                // The coordinates of the "tip" of the shadow.
                                shadowAnchor: [13, 41],
                                // The URL to a retina sized version of the icon image.
                                // Used for Retina screen devices.
                                iconRetinaUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon-2x.png'),
                                shadowRetinaUrl: (UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png'))
                            }
                        };
                    };
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                        ctrl.setOverlay();
                    });
                    $scope.$on('showInteraction', function () {
                        refreshMap();
                    });
                    var refreshMap = function () {
                        ctrl.mapOptions = {
                            center: {
                                lat: coords[0],
                                lng: coords[1],
                                zoom: zoomLevel
                            },
                            defaults: {
                                // Disable dragging for mobile devices.
                                dragging: !BrowserCheckerService.isMobileDevice()
                            },
                            events: {
                                map: {
                                    enable: ['click', 'mouseover', 'mouseout'],
                                    logic: 'emit'
                                }
                            }
                        };
                        if (!ctrl.interactionIsActive) {
                            changeMarkerPosition(ctrl.getLastAnswer()[0], ctrl.getLastAnswer()[1]);
                        }
                    };
                    $scope.$on('leafletDirectiveMap.interactiveMap.mouseover', function () {
                        if (!ctrl.interactionIsActive) {
                            ctrl.setOverlay();
                        }
                    });
                    $scope.$on('leafletDirectiveMap.interactiveMap.mouseout', function () {
                        if (!ctrl.interactionIsActive) {
                            ctrl.hideOverlay();
                        }
                    });
                    $scope.$on('leafletDirectiveMap.interactiveMap.click', function (evt, args) {
                        if (ctrl.interactionIsActive) {
                            var newLat = args.leafletEvent.latlng.lat;
                            var newLng = args.leafletEvent.latlng.lng;
                            changeMarkerPosition(newLat, newLng);
                            CurrentInteractionService.onSubmit([newLat, newLng], InteractiveMapRulesService);
                        }
                    });
                    refreshMap();
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/directives/oppia-response-interactive-map.directive.ts":
/*!*******************************************************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/directives/oppia-response-interactive-map.directive.ts ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the InteractiveMap response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! interactions/uiLeafletRequires.ts */ "./extensions/interactions/uiLeafletRequires.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseInteractiveMap', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/directives/' +
                'interactive-map-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.mapOptions = {
                        defaults: {
                            zoomControl: false,
                            attributionControl: false
                        },
                        center: {
                            lat: _answer[0],
                            lng: _answer[1],
                            zoom: 8
                        },
                        mapMarkers: {
                            mainMarker: {
                                lat: _answer[0],
                                lng: _answer[1],
                                icon: {
                                    iconUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon.png'),
                                    // The size of the icon image in pixels.
                                    iconSize: [25, 41],
                                    // The coordinates of the "tip" of the icon.
                                    iconAnchor: [12, 41],
                                    shadowUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png'),
                                    // The size of the shadow image in pixels.
                                    shadowSize: [41, 41],
                                    // The coordinates of the "tip" of the shadow.
                                    shadowAnchor: [13, 41],
                                    // The URL to a retina sized version of the icon image.
                                    // Used for Retina screen devices.
                                    iconRetinaUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon-2x.png'),
                                    shadowRetinaUrl: (UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png'))
                                }
                            }
                        }
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/InteractiveMap/directives/oppia-short-response-interactive-map.directive.ts":
/*!*************************************************************************************************************!*\
  !*** ./extensions/interactions/InteractiveMap/directives/oppia-short-response-interactive-map.directive.ts ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the InteractiveMap short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseInteractiveMap', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/directives/' +
                'interactive-map-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.formattedCoords = Math.abs(_answer[0]).toFixed(3) + ' ';
                    ctrl.formattedCoords += (_answer[0] >= 0 ? 'N' : 'S');
                    ctrl.formattedCoords += ', ';
                    ctrl.formattedCoords += Math.abs(_answer[1]).toFixed(3) + ' ';
                    ctrl.formattedCoords += (_answer[1] >= 0 ? 'E' : 'W');
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/ItemSelectionInput.ts":
/*!**************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/ItemSelectionInput.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for ItemSelectionInput interaction.
 */
__webpack_require__(/*! interactions/ItemSelectionInput/static/item_selection_input.css */ "./extensions/interactions/ItemSelectionInput/static/item_selection_input.css");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts */ "./extensions/interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/item-selection-input-validation.service.ts */ "./extensions/interactions/ItemSelectionInput/directives/item-selection-input-validation.service.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/oppia-interactive-item-selection-input.directive.ts */ "./extensions/interactions/ItemSelectionInput/directives/oppia-interactive-item-selection-input.directive.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/oppia-response-item-selection-input.directive.ts */ "./extensions/interactions/ItemSelectionInput/directives/oppia-response-item-selection-input.directive.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/oppia-short-response-item-selection-input.directive.ts */ "./extensions/interactions/ItemSelectionInput/directives/oppia-short-response-item-selection-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts":
/*!*****************************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! filters/remove-duplicates-in-array.filter.ts */ "./core/templates/dev/head/filters/remove-duplicates-in-array.filter.ts");
angular.module('oppia').factory('ItemSelectionInputRulesService', [
    '$filter', function ($filter) {
        return {
            Equals: function (answer, inputs) {
                var normalizedAnswer = $filter('removeDuplicatesInArray')(answer);
                var normalizedInput = $filter('removeDuplicatesInArray')(inputs.x);
                return normalizedAnswer.length === normalizedInput.length &&
                    normalizedAnswer.every(function (val) {
                        return normalizedInput.indexOf(val) !== -1;
                    });
            },
            ContainsAtLeastOneOf: function (answer, inputs) {
                var normalizedAnswer = $filter('removeDuplicatesInArray')(answer);
                var normalizedInput = $filter('removeDuplicatesInArray')(inputs.x);
                return normalizedAnswer.some(function (val) {
                    return normalizedInput.indexOf(val) !== -1;
                });
            },
            // TODO(wxy): migrate the name of this rule to OmitsAtLeastOneOf, keeping
            // in sync with the backend migration of the same rule.
            DoesNotContainAtLeastOneOf: function (answer, inputs) {
                var normalizedAnswer = $filter('removeDuplicatesInArray')(answer);
                var normalizedInput = $filter('removeDuplicatesInArray')(inputs.x);
                return normalizedInput.some(function (val) {
                    return normalizedAnswer.indexOf(val) === -1;
                });
            },
            // This function checks if the answer
            // given by the user is a subset of the correct answers.
            IsProperSubsetOf: function (answer, inputs) {
                var normalizedAnswer = $filter('removeDuplicatesInArray')(answer);
                var normalizedInput = $filter('removeDuplicatesInArray')(inputs.x);
                return normalizedAnswer.length < normalizedInput.length &&
                    normalizedAnswer.every(function (val) {
                        return normalizedInput.indexOf(val) !== -1;
                    });
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/directives/item-selection-input-validation.service.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/directives/item-selection-input-validation.service.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var ItemSelectionInputValidationService = /** @class */ (function () {
    function ItemSelectionInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    ItemSelectionInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['choices']);
        var areAnyChoicesEmpty = false;
        var areAnyChoicesDuplicated = false;
        var seenChoices = [];
        var handledAnswers = [];
        var numChoices = customizationArgs.choices.value.length;
        for (var i = 0; i < numChoices; i++) {
            var choice = customizationArgs.choices.value[i];
            if (choice.trim().length === 0) {
                areAnyChoicesEmpty = true;
            }
            if (seenChoices.indexOf(choice) !== -1) {
                areAnyChoicesDuplicated = true;
            }
            seenChoices.push(choice);
            handledAnswers.push(false);
        }
        if (areAnyChoicesEmpty) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the choices are nonempty.'
            });
        }
        if (areAnyChoicesDuplicated) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the choices are unique.'
            });
        }
        var minAllowedCount = customizationArgs.minAllowableSelectionCount.value;
        var maxAllowedCount = customizationArgs.maxAllowableSelectionCount.value;
        if (minAllowedCount > maxAllowedCount) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('Please ensure that the max allowed count is not less than the ' +
                    'min count.')
            });
        }
        if (numChoices < minAllowedCount) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('Please ensure that you have enough choices to reach the min ' +
                    'count.')
            });
        }
        else if (numChoices < maxAllowedCount) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: ('Please ensure that you have enough choices to reach the max ' +
                    'count.')
            });
        }
        return warningsList;
    };
    ItemSelectionInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAnswerGroupWarnings(answerGroups, stateName));
        var seenChoices = customizationArgs.choices.value;
        var handledAnswers = seenChoices.map(function (item) {
            return false;
        });
        var minAllowedCount = customizationArgs.minAllowableSelectionCount.value;
        var maxAllowedCount = customizationArgs.maxAllowableSelectionCount.value;
        var areAllChoicesCovered = false;
        if (maxAllowedCount === 1) {
            var answerChoiceToIndex = {};
            seenChoices.forEach(function (seenChoice, choiceIndex) {
                answerChoiceToIndex[seenChoice] = choiceIndex;
            });
            answerGroups.forEach(function (answerGroup, answerIndex) {
                var rules = answerGroup.rules;
                rules.forEach(function (rule, ruleIndex) {
                    var ruleInputs = rule.inputs.x;
                    ruleInputs.forEach(function (ruleInput) {
                        var choiceIndex = answerChoiceToIndex[ruleInput];
                        if (rule.type === 'Equals') {
                            handledAnswers[choiceIndex] = true;
                            if (ruleInputs.length > 1) {
                                warningsList.push({
                                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                    message: ('In answer group ' + (answerIndex + 1) + ', ' +
                                        'rule ' + (ruleIndex + 1) + ', ' +
                                        'please select only one answer choice.')
                                });
                            }
                        }
                        else if (rule.type === 'IsProperSubsetOf') {
                            handledAnswers[choiceIndex] = true;
                        }
                        else if (rule.type === 'ContainsAtLeastOneOf') {
                            handledAnswers[choiceIndex] = true;
                        }
                        else if (rule.type ===
                            'DoesNotContainAtLeastOneOf') {
                            for (var i = 0; i < handledAnswers.length; i++) {
                                if (i !== choiceIndex) {
                                    handledAnswers[i] = true;
                                }
                            }
                        }
                    });
                });
            });
            areAllChoicesCovered = handledAnswers.every(function (handledAnswer) {
                return handledAnswer;
            });
        }
        if (!areAllChoicesCovered) {
            if (!defaultOutcome || defaultOutcome.isConfusing(stateName)) {
                warningsList.push({
                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                    message: ('Please add something for Oppia to say in the ' +
                        '\"All other answers\" response.')
                });
            }
        }
        answerGroups.forEach(function (answerGroup, answerIndex) {
            var rules = answerGroup.rules;
            rules.forEach(function (rule, ruleIndex) {
                var ruleInputs = rule.inputs.x;
                ruleInputs.forEach(function (ruleInput) {
                    if (rule.type === 'IsProperSubsetOf') {
                        if (ruleInputs.length < 2) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: ('In answer group ' + (answerIndex + 1) + ', ' +
                                    'rule ' + (ruleIndex + 1) + ', the "proper subset" ' +
                                    'rule must include at least 2 options.')
                            });
                        }
                    }
                    else if (rule.type === 'Equals') {
                        if (minAllowedCount > ruleInputs.length ||
                            maxAllowedCount < ruleInputs.length) {
                            warningsList.push({
                                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                                message: ('In answer group ' + (answerIndex + 1) + ', ' +
                                    'rule ' + (ruleIndex + 1) + ', the number of correct ' +
                                    'options in the "Equals" rule should be between ' +
                                    minAllowedCount + ' and ' + maxAllowedCount +
                                    ' (the minimum and maximum allowed selection counts).')
                            });
                        }
                    }
                });
                if (ruleInputs.length === 0) {
                    if (rule.type === 'ContainsAtLeastOneOf') {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                            message: ('In answer group ' + (answerIndex + 1) + ', rule ' +
                                (ruleIndex + 1) + ', the "ContainsAtLeastOneOf" rule ' +
                                'should have at least one option.')
                        });
                    }
                }
            });
        });
        return warningsList;
    };
    var _a;
    ItemSelectionInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], ItemSelectionInputValidationService);
    return ItemSelectionInputValidationService;
}());
exports.ItemSelectionInputValidationService = ItemSelectionInputValidationService;
angular.module('oppia').factory('ItemSelectionInputValidationService', static_1.downgradeInjectable(ItemSelectionInputValidationService));


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/directives/oppia-interactive-item-selection-input.directive.ts":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/directives/oppia-interactive-item-selection-input.directive.ts ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ItemSelectionInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts */ "./extensions/interactions/ItemSelectionInput/directives/item-selection-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveItemSelectionInput', [
    'HtmlEscaperService', 'ItemSelectionInputRulesService',
    'UrlInterpolationService', function (HtmlEscaperService, ItemSelectionInputRulesService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ItemSelectionInput/directives/' +
                'item-selection-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'WindowDimensionsService',
                'UrlService', 'CurrentInteractionService',
                function ($attrs, WindowDimensionsService, UrlService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.choices = HtmlEscaperService.escapedJsonToObj($attrs.choicesWithValue);
                    ctrl.maxAllowableSelectionCount = ($attrs.maxAllowableSelectionCountWithValue);
                    ctrl.minAllowableSelectionCount = ($attrs.minAllowableSelectionCountWithValue);
                    // The following is an associative array where the key is a choice
                    // (html) and the value is a boolean value indicating whether the
                    // choice was selected by the user (default is false).
                    ctrl.userSelections = {};
                    for (var i = 0; i < ctrl.choices.length; i++) {
                        ctrl.userSelections[ctrl.choices[i]] = false;
                    }
                    ctrl.displayCheckboxes = (ctrl.maxAllowableSelectionCount > 1);
                    // The following indicates that the number of answers is more than
                    // maxAllowableSelectionCount.
                    ctrl.preventAdditionalSelections = false;
                    // The following indicates that the number of answers is less than
                    // minAllowableSelectionCount.
                    ctrl.notEnoughSelections = (ctrl.minAllowableSelectionCount > 0);
                    ctrl.onToggleCheckbox = function () {
                        ctrl.newQuestion = false;
                        ctrl.selectionCount = Object.keys(ctrl.userSelections).filter(function (obj) {
                            return ctrl.userSelections[obj];
                        }).length;
                        ctrl.preventAdditionalSelections = (ctrl.selectionCount >= ctrl.maxAllowableSelectionCount);
                        ctrl.notEnoughSelections = (ctrl.selectionCount < ctrl.minAllowableSelectionCount);
                    };
                    ctrl.submitMultipleChoiceAnswer = function (index) {
                        ctrl.userSelections[ctrl.choices[index]] = true;
                        ctrl.submitAnswer(ctrl.userSelections);
                    };
                    ctrl.submitAnswer = function () {
                        var answers = Object.keys(ctrl.userSelections).filter(function (obj) {
                            return ctrl.userSelections[obj];
                        });
                        CurrentInteractionService.onSubmit(answers, ItemSelectionInputRulesService);
                    };
                    var validityCheckFn = function () {
                        return !ctrl.notEnoughSelections;
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitAnswer, validityCheckFn);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/directives/oppia-response-item-selection-input.directive.ts":
/*!****************************************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/directives/oppia-response-item-selection-input.directive.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ItemSelectionInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseItemSelectionInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ItemSelectionInput/directives/' +
                'item-selection-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/directives/oppia-short-response-item-selection-input.directive.ts":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/directives/oppia-short-response-item-selection-input.directive.ts ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the ItemSelectionInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseItemSelectionInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/ItemSelectionInput/directives/' +
                'item-selection-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/ItemSelectionInput/static/item_selection_input.css":
/*!************************************************************************************!*\
  !*** ./extensions/interactions/ItemSelectionInput/static/item_selection_input.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!./item_selection_input.css */ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/ItemSelectionInput/static/item_selection_input.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/interactions/LogicProof/LogicProof.ts":
/*!**********************************************************!*\
  !*** ./extensions/interactions/LogicProof/LogicProof.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for LogicProof interaction.
 */
__webpack_require__(/*! interactions/LogicProof/static/logic_proof.css */ "./extensions/interactions/LogicProof/static/logic_proof.css");
__webpack_require__(/*! interactions/LogicProof/directives/logic-proof-rules.service.ts */ "./extensions/interactions/LogicProof/directives/logic-proof-rules.service.ts");
__webpack_require__(/*! interactions/LogicProof/directives/logic-proof-validation.service.ts */ "./extensions/interactions/LogicProof/directives/logic-proof-validation.service.ts");
__webpack_require__(/*! interactions/LogicProof/directives/oppia-interactive-logic-proof.directive.ts */ "./extensions/interactions/LogicProof/directives/oppia-interactive-logic-proof.directive.ts");
__webpack_require__(/*! interactions/LogicProof/directives/oppia-response-logic-proof.directive.ts */ "./extensions/interactions/LogicProof/directives/oppia-response-logic-proof.directive.ts");
__webpack_require__(/*! interactions/LogicProof/directives/oppia-short-response-logic-proof.directive.ts */ "./extensions/interactions/LogicProof/directives/oppia-short-response-logic-proof.directive.ts");


/***/ }),

/***/ "./extensions/interactions/LogicProof/directives/logic-proof-rules.service.ts":
/*!************************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/directives/logic-proof-rules.service.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
angular.module('oppia').factory('LogicProofRulesService', [function () {
        return {
            Correct: function (answer) {
                return answer.correct;
            },
            NotCorrect: function (answer) {
                return !answer.correct;
            },
            NotCorrectByCategory: function (answer, inputs) {
                return !answer.correct && answer.error_category === inputs.c;
            }
        };
    }]);


/***/ }),

/***/ "./extensions/interactions/LogicProof/directives/logic-proof-validation.service.ts":
/*!*****************************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/directives/logic-proof-validation.service.ts ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var LogicProofValidationService = /** @class */ (function () {
    function LogicProofValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    LogicProofValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        // TODO(juansaba): Implement customization args validations.
        return [];
    };
    LogicProofValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        // We do not require a default rule for this interaction, since the
        // feedback is mostly provided from within the interaction itself.
        return this.getCustomizationArgsWarnings(customizationArgs).concat(this.baseInteractionValidationServiceInstance.getAnswerGroupWarnings(answerGroups, stateName));
    };
    var _a;
    LogicProofValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], LogicProofValidationService);
    return LogicProofValidationService;
}());
exports.LogicProofValidationService = LogicProofValidationService;
angular.module('oppia').factory('LogicProofValidationService', static_1.downgradeInjectable(LogicProofValidationService));


/***/ }),

/***/ "./extensions/interactions/LogicProof/directives/oppia-interactive-logic-proof.directive.ts":
/*!**************************************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/directives/oppia-interactive-logic-proof.directive.ts ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Directive for the LogicProof Interaction.
 */
__webpack_require__(/*! interactions/codemirrorRequires.ts */ "./extensions/interactions/codemirrorRequires.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/LogicProof/directives/logic-proof-rules.service.ts */ "./extensions/interactions/LogicProof/directives/logic-proof-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/UrlService.ts */ "./core/templates/dev/head/services/contextual/UrlService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
var shared_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/shared.ts */ "./extensions/interactions/LogicProof/static/js/shared.ts"));
var student_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/student.ts */ "./extensions/interactions/LogicProof/static/js/student.ts"));
var data_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/data.ts */ "./extensions/interactions/LogicProof/static/js/data.ts"));
var conversion_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/conversion.ts */ "./extensions/interactions/LogicProof/static/js/conversion.ts"));
var generatedDefaultData_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/generatedDefaultData.ts */ "./extensions/interactions/LogicProof/static/js/generatedDefaultData.ts"));
angular.module('oppia').directive('oppiaInteractiveLogicProof', [
    'HtmlEscaperService', 'UrlInterpolationService', 'EVENT_NEW_CARD_AVAILABLE',
    function (HtmlEscaperService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer',
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/LogicProof/directives/' +
                'logic-proof-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', '$uibModal', 'LogicProofRulesService',
                'WindowDimensionsService', 'UrlService',
                'CurrentInteractionService',
                function ($scope, $attrs, $uibModal, LogicProofRulesService, WindowDimensionsService, UrlService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.localQuestionData = HtmlEscaperService.escapedJsonToObj($attrs.questionWithValue);
                    // This is the information about how to mark a question (e.g. the
                    // permitted line templates) that is stored in defaultData.js within
                    // the dependencies.
                    ctrl.questionData = angular.copy(generatedDefaultData_ts_1.default);
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                    });
                    ctrl.questionData.assumptions =
                        ctrl.localQuestionData.assumptions;
                    ctrl.questionData.results = ctrl.localQuestionData.results;
                    // Deduce the new operators, as in logicProofTeacher.buildQuestion(),
                    // since these are not currently stored separately for each question.
                    ctrl.expressions = [];
                    ctrl.topTypes = [];
                    for (var i = 0; i < ctrl.questionData.assumptions.length; i++) {
                        ctrl.expressions.push(ctrl.questionData.assumptions[i]);
                        ctrl.topTypes.push('boolean');
                    }
                    ctrl.expressions.push(ctrl.questionData.results[0]);
                    ctrl.topTypes.push('boolean');
                    ctrl.typing = shared_ts_1.default.assignTypesToExpressionArray(ctrl.expressions, ctrl.topTypes, data_ts_1.default.BASE_STUDENT_LANGUAGE, ['variable', 'constant', 'prefix_function']);
                    ctrl.questionData.language.operators = ctrl.typing[0].operators;
                    if (ctrl.questionData.assumptions.length <= 1) {
                        ctrl.assumptionsString = shared_ts_1.default.displayExpressionArray(ctrl.questionData.assumptions, ctrl.questionData.language.operators);
                    }
                    else {
                        ctrl.assumptionsString = shared_ts_1.default.displayExpressionArray(ctrl.questionData.assumptions.slice(0, ctrl.questionData.assumptions.length - 1), ctrl.questionData.language.operators) + ' and ' + shared_ts_1.default.displayExpression(ctrl.questionData.assumptions[ctrl.questionData.assumptions.length - 1], ctrl.questionData.language.operators);
                    }
                    ctrl.targetString = shared_ts_1.default.displayExpression(ctrl.questionData.results[0], ctrl.questionData.language.operators);
                    ctrl.questionString = (ctrl.assumptionsString === '' ?
                        'I18N_INTERACTIONS_LOGIC_PROOF_QUESTION_STR_NO_ASSUMPTION' :
                        'I18N_INTERACTIONS_LOGIC_PROOF_QUESTION_STR_ASSUMPTIONS');
                    ctrl.questionStringData = {
                        target: ctrl.targetString,
                        assumptions: ctrl.assumptionsString
                    };
                    ctrl.questionInstance = student_ts_1.default.buildInstance(ctrl.questionData);
                    // Denotes whether messages are in response to a submission, in which
                    // case they persist for longer.
                    ctrl.messageIsSticky = false;
                    // NOTE: for information on integrating angular and code-mirror see
                    // http://github.com/angular-ui/ui-codemirror
                    ctrl.codeEditor = function (editor) {
                        var proofString = (ctrl.interactionIsActive ?
                            ctrl.localQuestionData.default_proof_string :
                            ctrl.getLastAnswer().proof_string);
                        editor.setValue(proofString);
                        ctrl.proofString = editor.getValue();
                        var cursorPosition = editor.doc.getCursor();
                        editor.setOption('lineNumbers', true);
                        editor.setOption('lineWrapping', true);
                        // NOTE: this is necessary to avoid the textarea being greyed-out.
                        // See: http://stackoverflow.com/questions/8349571 for discussion.
                        setTimeout(function () {
                            editor.refresh();
                        }, 500);
                        // NOTE: we must use beforeChange rather than change here to avoid
                        // an infinite loop (which code-mirror will not catch).
                        editor.on('beforeChange', function (instance, change) {
                            var convertedText = conversion_ts_1.default.convertToLogicCharacters(change.text.join('\n'));
                            if (convertedText !== change.text.join('\n')) {
                                // We update using the converted text, then cancel its being
                                // overwritten by the original text.
                                editor.doc.replaceRange(convertedText, change.from, change.to);
                                change.cancel();
                            }
                        });
                        editor.on('cursorActivity', function () {
                            if (editor.doc.getCursor().line !== cursorPosition.line) {
                                ctrl.checkForBasicErrors();
                                cursorPosition = editor.doc.getCursor();
                            }
                        });
                        // NOTE: we use change rather than beforeChange here so that
                        // checking for mistakes is done with respect to the updated text.
                        editor.on('change', function (instance, change) {
                            ctrl.proofString = editor.getValue();
                            // We update the message only if the user has added or removed a
                            // line break, so that it remains while they work on a single
                            // line.
                            if (change.text.length > 1 || change.removed.length > 1) {
                                ctrl.checkForBasicErrors();
                            }
                        });
                        ctrl.editor = editor;
                    };
                    // This performs simple error checks that are done as the student
                    // types rather than waiting for the proof to be submitted.
                    ctrl.checkForBasicErrors = function () {
                        if (!ctrl.messageIsSticky) {
                            ctrl.clearMessage();
                        }
                        try {
                            student_ts_1.default.validateProof(ctrl.proofString, ctrl.questionInstance);
                        }
                        catch (err) {
                            ctrl.clearMessage();
                            ctrl.showMessage(err.message, err.line);
                            ctrl.messageIsSticky = false;
                        }
                        // NOTE: this line is necessary to force angular to refresh the
                        // displayed errorMessage.
                        $scope.$apply();
                    };
                    ctrl.clearMessage = function () {
                        if (ctrl.errorMark) {
                            ctrl.errorMark.clear();
                        }
                        ctrl.errorMessage = '';
                    };
                    ctrl.showMessage = function (message, lineNum) {
                        ctrl.errorMessage = ctrl.constructDisplayedMessage(message, lineNum);
                        ctrl.errorMark = ctrl.editor.doc.markText({
                            line: lineNum,
                            ch: 0
                        }, {
                            line: lineNum,
                            ch: 100
                        }, {
                            className: 'logic-proof-erroneous-line'
                        });
                    };
                    ctrl.constructDisplayedMessage = function (message, lineNum) {
                        return 'line ' + (lineNum + 1) + ': ' + message;
                    };
                    ctrl.displayProof = function (proofString, errorLineNum) {
                        var proofLines = proofString.split('\n');
                        var numberedLines = [];
                        for (var i = 0; i < proofLines.length; i++) {
                            numberedLines.push((i + 1) + '  ' + proofLines[i]);
                        }
                        // We split incorrect proofs into three parts so that response.html
                        // can make the invalid line bold.
                        return (errorLineNum === undefined) ?
                            [numberedLines.join('\n')] :
                            [
                                numberedLines.slice(0, errorLineNum).join('\n'),
                                numberedLines[errorLineNum],
                                numberedLines.slice(errorLineNum + 1, numberedLines.length).join('\n')
                            ];
                    };
                    // NOTE: proof_num_lines, displayed_question and displayed_proof are
                    // only computed here because response.html needs them and does not
                    // have its own javascript.
                    ctrl.submitProof = function () {
                        ctrl.clearMessage();
                        var submission = {
                            assumptions_string: ctrl.assumptionsString,
                            target_string: ctrl.targetString,
                            proof_string: ctrl.proofString,
                            proof_num_lines: ctrl.proofString.split('\n').length,
                            displayed_question: ctrl.questionString,
                            correct: null,
                            error_category: null,
                            error_code: null,
                            error_message: null,
                            error_line_number: null,
                            displayed_message: null,
                            displayed_proof: null
                        };
                        try {
                            var proof = student_ts_1.default.buildProof(ctrl.proofString, ctrl.questionInstance);
                            student_ts_1.default.checkProof(proof, ctrl.questionInstance);
                            submission.correct = true;
                        }
                        catch (err) {
                            submission.correct = false;
                            submission.error_category = err.category;
                            submission.error_code = err.code;
                            submission.error_message = err.message;
                            submission.error_line_number = err.line;
                            submission.displayed_message =
                                ctrl.constructDisplayedMessage(err.message, err.line);
                            submission.displayed_proof =
                                ctrl.displayProof(ctrl.proofString, err.line);
                            ctrl.showMessage(err.message, err.line);
                            ctrl.messageIsSticky = true;
                        }
                        if (submission.correct) {
                            submission.displayed_message = '';
                            submission.displayed_proof = ctrl.displayProof(ctrl.proofString);
                        }
                        CurrentInteractionService.onSubmit(submission, LogicProofRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitProof, null);
                    ctrl.showHelp = function () {
                        $uibModal.open({
                            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/LogicProof/directives/' +
                                'logic-proof-help-modal.directive.html'),
                            backdrop: true,
                            controller: [
                                '$scope', '$uibModalInstance',
                                function ($scope, $uibModalInstance) {
                                    $scope.close = function () {
                                        $uibModalInstance.close();
                                    };
                                }
                            ]
                        }).result.then(function () { });
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/LogicProof/directives/oppia-response-logic-proof.directive.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/directives/oppia-response-logic-proof.directive.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the LogicProof response.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseLogicProof', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/LogicProof/directives/' +
                'logic-proof-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/LogicProof/directives/oppia-short-response-logic-proof.directive.ts":
/*!*****************************************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/directives/oppia-short-response-logic-proof.directive.ts ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the LogicProof short response.
 */
__webpack_require__(/*! filters/string-utility-filters/truncate-at-first-line.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseLogicProof', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/LogicProof/directives/' +
                'logic-proof-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/conversion.ts":
/*!********************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/conversion.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Functions to convert symbols available on the keyboard to
 *   desired logic symbols as a user types.
 */
var logicProofConversion = (function () {
    // NOTE: the 'old' values must all be single characters
    var REPLACEMENT_PAIRS = [{
            old: '&',
            // eslint-disable quote-props
            'new': '\u2227'
        }, {
            old: '|',
            'new': '\u2228'
        }, {
            old: '@',
            'new': '\u2200'
        }, {
            old: '$',
            'new': '\u2203'
        }, {
            old: '^',
            'new': '\u2227'
        }, {
            old: '\u0009',
            'new': '  '
            // eslint-enable quote-props
        }];
    var convertToLogicCharacters = function (oldString) {
        var replacedString = oldString;
        for (var i = 0; i < REPLACEMENT_PAIRS.length; i++) {
            // We don't use .replace() as it only affects the first instance
            replacedString = replacedString.split(REPLACEMENT_PAIRS[i].old).join(REPLACEMENT_PAIRS[i]['new']);
        }
        return replacedString;
    };
    return {
        convertToLogicCharacters: convertToLogicCharacters
    };
}());
exports.default = logicProofConversion;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/data.ts":
/*!**************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/data.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Contains logic proof data.
 */
var logicProofData = (function () {
    var BASE_VOCABULARY = {
        from: ['from'],
        and: ['and'],
        have: ['we have', 'we know', 'have'],
        hence: ['hence', 'so', 'thus', 'thence', 'whence'],
        whichever: [
            'and whichever is true', 'and either way', 'and in either case'
        ],
        arbitrary: ['was arbitrary', 'is arbitrary'],
        take: ['take'],
        satisfying: ['satisfying', 'such that'],
        // eslint-disable quote-props
        'if': ['if'],
        given: ['given'],
        contradiction: ['contradiction'],
        at: ['at']
    };
    var SINGLE_BOOLEAN = {
        type: 'boolean',
        arbitrarily_many: false
    };
    var SINGLE_ELEMENT = {
        type: 'element',
        arbitrarily_many: false
    };
    // NOTE: By default, 'and' & 'or' must be binary.
    // NOTE: We are not yet using the display keys from the kinds (we are using
    // symbol keys from the list of operators).
    var BASE_STUDENT_LANGUAGE = {
        types: {
            'boolean': {
                // eslint-enable quote-props
                quantifiable: false
            },
            element: {
                quantifiable: true
            }
        },
        kinds: {
            binary_connective: {
                display: [{
                        format: 'argument_index',
                        content: 0
                    }, {
                        format: 'name'
                    }, {
                        format: 'argument_index',
                        content: 1
                    }]
            },
            unary_connective: {
                matchable: false,
                display: [{
                        format: 'name'
                    }, {
                        format: 'argument_index',
                        content: 0
                    }]
            },
            quantifier: {
                matchable: false,
                display: [{
                        format: 'name'
                    }, {
                        format: 'dummy_index',
                        content: 0
                    }, {
                        format: 'string',
                        content: '.'
                    }, {
                        format: 'argument_index',
                        conent: 0
                    }]
            },
            binary_function: {
                matchable: false,
                display: [{
                        format: 'argument_index',
                        content: 0
                    }, {
                        format: 'name'
                    }, {
                        format: 'argument_index',
                        content: 1
                    }],
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }]
            },
            prefix_function: {
                matchable: false,
                typing: [{
                        arguments: [{
                                type: 'element',
                                arbitrarily_many: true
                            }],
                        dummies: [],
                        output: 'element'
                    }, {
                        arguments: [{
                                type: 'element',
                                arbitrarily_many: true
                            }],
                        dummies: [],
                        output: 'boolean'
                    }]
            },
            constant: {
                matchable: false,
                display: [{
                        format: 'name'
                    }],
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'element'
                    }]
            },
            variable: {
                matchable: true,
                display: [{
                        format: 'name'
                    }],
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'element'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'boolean'
                    }]
            }
        },
        operators: {
            and: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['\u2227']
            },
            or: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['\u2228']
            },
            implies: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['=>']
            },
            iff: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<=>']
            },
            not: {
                kind: 'unary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['~']
            },
            for_all: {
                kind: 'quantifier',
                typing: [{
                        arguments: [SINGLE_BOOLEAN],
                        dummies: [SINGLE_ELEMENT],
                        output: 'boolean'
                    }],
                symbols: ['\u2200', '.']
            },
            exists: {
                kind: 'quantifier',
                typing: [{
                        arguments: [SINGLE_BOOLEAN],
                        dummies: [SINGLE_ELEMENT],
                        output: 'boolean'
                    }],
                symbols: ['\u2203', '.']
            },
            equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['=']
            },
            not_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['!=']
            },
            less_than: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<']
            },
            greater_than: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['>']
            },
            less_than_or_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<=']
            },
            greater_than_or_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['>=']
            },
            addition: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }],
                symbols: ['+']
            },
            subtraction: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }],
                symbols: ['-']
            },
            multiplication: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }],
                symbols: ['*']
            },
            division: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }],
                symbols: ['/']
            },
            exponentiation: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
                        dummies: [],
                        output: 'element'
                    }],
                symbols: ['^']
            }
        }
    };
    var SINGLE_INTEGER = {
        type: 'integer',
        arbitrarily_many: false
    };
    var SINGLE_STRING = {
        type: 'string',
        arbitrarily_many: false
    };
    var SINGLE_FORMULA = {
        type: 'formula',
        arbitrarily_many: false
    };
    var SINGLE_SET_OF_FORMULAS = {
        type: 'set_of_formulas',
        arbitrarily_many: false
    };
    var BASE_CONTROL_LANGUAGE = {
        types: {
            // eslint-disable-next-line quote-props
            'boolean': {
                quantifiable: false
            },
            // Used for line numbers & indentation.
            integer: {
                quantifiable: true
            },
            // Used for line.template.
            string: {
                quantifiable: false
            },
            // Used for matchings, target.
            formula: {
                quantifiable: true
            },
            // Used for antecedents, results & assumptions.
            set_of_formulas: {
                quantifiable: false
            }
        },
        kinds: {
            binary_connective: {},
            unary_connective: {},
            quantifier: {},
            bounded_quantifier: {},
            binary_relation: {},
            binary_function: {},
            // NOTE: new prefix_functions will be explicitely added by making
            // definitions, and from these definitions their types will be known.
            // Thus it is not necessary for their kinds to have typing rules (and
            // such typing rules would in any case have to be inconveniently long).
            prefix_function: {},
            ranged_function: {},
            constant: {
                matchable: false,
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'integer'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'string'
                    }]
            },
            variable: {
                matchable: true,
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'integer'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'string'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'formula'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'set_of_formulas'
                    }, {
                        arguments: [],
                        dummies: [],
                        output: 'boolean'
                    }]
            }
        },
        operators: {
            and: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [{
                                type: 'boolean',
                                arbitrarily_many: true
                            }],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['\u2227']
            },
            or: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [{
                                type: 'boolean',
                                arbitrarily_many: true
                            }],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['\u2228']
            },
            implies: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['=>']
            },
            iff: {
                kind: 'binary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<=>']
            },
            not: {
                kind: 'unary_connective',
                typing: [{
                        arguments: [SINGLE_BOOLEAN],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['~']
            },
            equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_STRING, SINGLE_STRING],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_FORMULA, SINGLE_FORMULA],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['=']
            },
            not_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_STRING, SINGLE_STRING],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_FORMULA, SINGLE_FORMULA],
                        dummies: [],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['!=']
            },
            less_than: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<']
            },
            greater_than: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['>']
            },
            less_than_or_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['<=']
            },
            greater_than_or_equals: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['>=']
            },
            is_in: {
                kind: 'binary_relation',
                typing: [{
                        arguments: [SINGLE_FORMULA, SINGLE_SET_OF_FORMULAS],
                        dummies: [],
                        output: 'boolean'
                    }],
                symbols: ['\u2208']
            },
            addition: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'integer'
                    }],
                symbols: ['+']
            },
            subtraction: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'integer'
                    }],
                symbols: ['-']
            },
            multiplication: {
                kind: 'binary_function',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'integer'
                    }],
                symbols: ['*']
            },
            bounded_for_all: {
                kind: 'bounded_quantifier',
                typing: [{
                        // The first argument is the bounding.
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_INTEGER],
                        output: 'boolean'
                    }, {
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_INTEGER],
                        output: 'boolean'
                    }],
                symbols: ['\u2200', '.']
            },
            bounded_exists: {
                kind: 'bounded_quantifier',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_INTEGER],
                        output: 'boolean'
                    }, {
                        // The first argument is the bounding.
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_FORMULA],
                        output: 'boolean'
                    }],
                symbols: ['\u2203', '.']
            },
            // This has form min{n<m|A(n)}, A(n) is the argument and n the dummy, or
            // alteratively min{pantecedents(n)|B(p)} which will return the first
            // element of set_of_formulas antecedents(n) satisfying B.
            min: {
                kind: 'ranged_function',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_INTEGER],
                        output: 'integer'
                    }, {
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_FORMULA],
                        output: 'formula'
                    }],
                symbols: ['min', '{', '|', '}']
            },
            max: {
                kind: 'ranged_function',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_INTEGER],
                        output: 'integer'
                    }, {
                        arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
                        dummies: [SINGLE_FORMULA],
                        output: 'formula'
                    }],
                symbols: ['max', '{', '|', '}']
            },
            indentation: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'integer'
                    }]
            },
            template: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'string'
                    }]
            },
            antecedents: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            results: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            variables: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            text: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER],
                        dummies: [],
                        output: 'string'
                    }]
            },
            element: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_STRING, SINGLE_INTEGER],
                        dummies: [],
                        output: 'formula'
                    }]
            },
            num_lines: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'integer'
                    }]
            },
            assumptions: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            target: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'formula'
                    }]
            },
            question_variables: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            // eslint-disable-next-line quote-props
            'if': {
                // NOTE: this prefix function is unusual in having a boolean input
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_BOOLEAN, SINGLE_INTEGER, SINGLE_INTEGER],
                        dummies: [],
                        output: 'integer'
                    }, {
                        arguments: [SINGLE_BOOLEAN, SINGLE_STRING, SINGLE_STRING],
                        dummies: [],
                        output: 'string'
                    }, {
                        arguments: [SINGLE_BOOLEAN, SINGLE_FORMULA, SINGLE_FORMULA],
                        dummies: [],
                        output: 'formula'
                    }, {
                        arguments: [
                            SINGLE_BOOLEAN, SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS
                        ],
                        dummies: [],
                        output: 'set_of_formulas'
                    }]
            },
            entry: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_INTEGER, SINGLE_SET_OF_FORMULAS],
                        dummies: [],
                        output: 'formula'
                    }]
            },
            substitute: {
                kind: 'prefix_function',
                typing: [{
                        arguments: [SINGLE_FORMULA, SINGLE_FORMULA, SINGLE_FORMULA],
                        dummies: [],
                        output: 'formula'
                    }]
            }
        }
    };
    var BASE_GENERAL_MESSAGES = {
        odd_number_spaces: {
            templates: [[{
                        isFixed: true,
                        content: ('An indentation is indicated by a double space at the start of ' +
                            'the line, but this line starts with an odd number of spaces.')
                    }]],
            parameters: {},
            category: 'parsing'
        },
        unmatched_line: {
            templates: [[{
                        isFixed: true,
                        content: ('This line could not be identified as valid - please check the ' +
                            'list of possible lines.')
                    }]],
            parameters: {},
            category: 'parsing'
        },
        wrong_kind_in_line: {
            templates: [[{
                        isFixed: true,
                        content: 'In a line of this form, your '
                    }, {
                        isFixed: false,
                        content: 'expression'
                    }, {
                        isFixed: true,
                        content: ' should be a '
                    }, {
                        isFixed: false,
                        content: 'expected_kind'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                expression: {
                    format: 'expression'
                },
                expected_kind: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        unspecified_mistake: {
            templates: [[{
                        isFixed: true,
                        content: 'This line contains a mistake in its '
                    }, {
                        isFixed: false,
                        content: 'section'
                    }, {
                        isFixed: true,
                        content: ' (with code '
                    }, {
                        isFixed: false,
                        content: 'entry'
                    }, {
                        isFixed: true,
                        content: ').'
                    }]],
            parameters: {
                section: {
                    format: 'string'
                },
                entry: {
                    format: 'string'
                }
            },
            category: 'mistake'
        },
        illegal_symbol: {
            templates: [[{
                        isFixed: true,
                        content: 'The symbol '
                    }, {
                        isFixed: false,
                        content: 'symbol'
                    }, {
                        isFixed: true,
                        content: ' was not recognised.'
                    }]],
            parameters: {
                symbol: {
                    format: 'string'
                }
            },
            category: 'parsing'
        },
        blank_line: {
            templates: [[{
                        isFixed: true,
                        content: 'This line is blank.'
                    }]],
            parameters: {},
            category: 'parsing'
        },
        unidentified_word: {
            templates: [[{
                        isFixed: true,
                        content: 'We could not identify \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: ('\'; please make sure you are using vocabulary from the ' +
                            'given list, and don\'t have two consecutive expressions.')
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            },
            category: 'parsing'
        },
        unidentified_words: {
            templates: [[{
                        isFixed: true,
                        content: 'We could not identify either of \''
                    }, {
                        isFixed: false,
                        content: 'word1'
                    }, {
                        isFixed: true,
                        content: '\' or \''
                    }, {
                        isFixed: false,
                        content: 'word2'
                    }, {
                        isFixed: true,
                        content: ('\' as words; please make sure you are using vocabulary from the ' +
                            'given list, and don\'t have two consecutive expressions.')
                    }]],
            parameters: {
                word1: {
                    format: 'string'
                },
                word2: {
                    format: 'string'
                }
            },
            category: 'parsing'
        },
        consecutive_expressions: {
            templates: [[{
                        isFixed: true,
                        content: 'This line has two expressions in a row ('
                    }, {
                        isFixed: false,
                        content: 'word1'
                    }, {
                        isFixed: true,
                        content: ' and '
                    }, {
                        isFixed: false,
                        content: 'word2'
                    }, {
                        isFixed: true,
                        content: ') which is not allowed.'
                    }]],
            parameters: {
                word1: {
                    format: 'string'
                },
                word2: {
                    format: 'string'
                }
            },
            category: 'parsing'
        },
        unidentified_phrase_starting_at: {
            templates: [[{
                        isFixed: true,
                        content: 'The phrase starting \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: ('\' could not be identified; please make sure you are only ' +
                            'using phrases from the given list of vocabulary.')
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            },
            category: 'formattting'
        },
        forbidden_word: {
            templates: [[{
                        isFixed: true,
                        content: 'The name \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: '\' is reserved for vocabulary and so cannot be used here.'
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            },
            category: 'parsing'
        },
        not_enough_inputs: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' must have at least '
                    }, {
                        isFixed: false,
                        content: 'num_needed'
                    }, {
                        isFixed: true,
                        content: ' '
                    }, {
                        isFixed: false,
                        content: 'input_category'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                num_needed: {
                    format: 'string'
                },
                input_category: {
                    format: 'string'
                },
                operator: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        wrong_num_inputs: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' must have '
                    }, {
                        isFixed: false,
                        content: 'num_needed'
                    }, {
                        isFixed: true,
                        content: ' '
                    }, {
                        isFixed: false,
                        content: 'input_category'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                num_needed: {
                    format: 'string'
                },
                input_category: {
                    format: 'string'
                },
                operator: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        wrong_kind: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' is supposed to be a '
                    }, {
                        isFixed: false,
                        content: 'expected_kind'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                },
                expected_kind: {
                    format: 'string'
                },
                actual_kind: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        wrong_type: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' yields a '
                    }, {
                        isFixed: false,
                        content: 'actual_type'
                    }, {
                        isFixed: true,
                        content: ' but you are trying to use it to give a '
                    }, {
                        isFixed: false,
                        content: 'expected_type'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                },
                expected_type: {
                    format: 'string'
                },
                actual_type: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        duplicate_dummy_name: {
            templates: [[{
                        isFixed: true,
                        content: 'The name \''
                    }, {
                        isFixed: false,
                        content: 'dummy'
                    }, {
                        isFixed: true,
                        content: '\' is already in use and so cannot be quantified over in '
                    }, {
                        isFixed: false,
                        content: 'expression'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                dummy: {
                    format: 'expression'
                },
                expression: {
                    format: 'expression'
                }
            },
            category: 'typing'
        },
        dummy_not_variable: {
            templates: [[{
                        isFixed: true,
                        content: 'You can only quantify over variables, not  '
                    }, {
                        isFixed: false,
                        content: 'dummy'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                dummy: {
                    format: 'expression'
                },
                expression: {
                    format: 'expression'
                }
            },
            category: 'typing'
        },
        unknown_operator: {
            templates: [[{
                        isFixed: true,
                        content: 'The operator '
                    }, {
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' could not be identified.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                }
            },
            category: 'typing'
        },
        too_many_parsings: {
            templates: [[{
                        isFixed: true,
                        content: ('This can be parsed in too many different ways - try using fewer ' +
                            'words, especially single-character words.')
                    }]],
            parameters: {},
            category: 'parsing'
        },
        too_many_typings: {
            templates: [[{
                        isFixed: true,
                        content: ('This has too many possible typings - try using fewer variables.')
                    }]],
            parameters: {}
        },
        category: 'typing'
    };
    return {
        BASE_VOCABULARY: BASE_VOCABULARY,
        BASE_STUDENT_LANGUAGE: BASE_STUDENT_LANGUAGE,
        BASE_CONTROL_LANGUAGE: BASE_CONTROL_LANGUAGE,
        BASE_GENERAL_MESSAGES: BASE_GENERAL_MESSAGES
    };
})();
exports.default = logicProofData;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/generatedDefaultData.ts":
/*!******************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/generatedDefaultData.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/data.ts */ "./extensions/interactions/LogicProof/static/js/data.ts"));
// Paste generated code here.
var LOGIC_PROOF_DEFAULT_QUESTION_DATA = { assumptions: [], results: [], language: data_ts_1.default.BASE_STUDENT_LANGUAGE, general_messages: data_ts_1.default.BASE_GENERAL_MESSAGES, "line_templates": [{ "name": "and_eliminate_left", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "and_eliminate_right", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "and_introduce", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "and_introduce", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_right", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_right", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_left", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_left", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_cis", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_eliminate_trans", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_introduce", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "iff_introduce", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "iff", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "assumption", "reader_view": [{ "format": "phrase", "content": "if" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "implies_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "implies_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "implies_introduce", "reader_view": [{ "format": "phrase", "content": "hence" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "implies", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "not_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "phrase", "content": "contradiction" }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [], "variables": [], "error": [] }, { "name": "not_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "phrase", "content": "contradiction" }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [], "variables": [], "error": [] }, { "name": "contradiction_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "phrase", "content": "contradiction" }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "not_introduce", "reader_view": [{ "format": "phrase", "content": "hence" }, { "format": "expression", "content": { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "excluded_middle_1", "reader_view": [{ "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "excluded_middle_2", "reader_view": [{ "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "excluded_middle_3", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "or_eliminate", "reader_view": [{ "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "whichever" }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "or_introduce_left", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "or_introduce_right", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "exists_eliminate", "reader_view": [{ "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "quantifier", "top_operator_name": "exists", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "hence" }, { "format": "phrase", "content": "take" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element", "kind": "variable" } }, { "format": "phrase", "content": "satisfying" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "quantifier", "top_operator_name": "exists", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" }], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "exists_introduce", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" } }, { "format": "phrase", "content": "at" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "quantifier", "top_operator_name": "exists", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "quantifier", "top_operator_name": "exists", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" }], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "for_all_eliminate", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "quantifier", "top_operator_name": "for_all", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "at" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "quantifier", "top_operator_name": "for_all", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }, "substitutions": [{ "x": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] } }], "type": "boolean" }], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "for_all_introduce", "reader_view": [{ "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element", "kind": "variable" } }, { "format": "phrase", "content": "arbitrary" }, { "format": "phrase", "content": "hence" }, { "format": "expression", "content": { "expression": { "top_kind_name": "quantifier", "top_operator_name": "for_all", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "quantifier", "top_operator_name": "for_all", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "p", "arguments": [], "dummies": [] }], "dummies": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }] }, "substitutions": [], "type": "boolean" }], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "given", "reader_view": [{ "format": "phrase", "content": "given" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element" } }], "antecedents": [], "results": [], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "take", "reader_view": [{ "format": "phrase", "content": "take" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }, "substitutions": [], "type": "element" } }], "antecedents": [], "results": [], "variables": [{ "top_kind_name": "variable", "top_operator_name": "a", "arguments": [], "dummies": [] }], "error": [] }, { "name": "reminder", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "reminder", "reader_view": [{ "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [] }, { "name": "and_introduce_e1", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "Should this be 'From " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " and " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " we have " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "'?" }], [{ "format": "string", "content": "To prove " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " you need to have shown " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " as well." }]] }, { "name": "and_introduce_e2", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "Should this be 'From " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " and " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " we have " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "'?" }], [{ "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " means that " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " and " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " are both true, so you also need to have shown " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "." }]] }, { "name": "and_introduce_e3", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "You have shown " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": ", not " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "." }]] }, { "name": "and_introduce_e4", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "and" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }, { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "You have shown " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": ", not " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "." }]] }, { "name": "and_eliminate_e", "reader_view": [{ "format": "phrase", "content": "from" }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "phrase", "content": "have" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [{ "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" }], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "T", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "From " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "and", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " you can conclude either " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " or " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "." }]] }, { "name": "not_introduce_e", "reader_view": [{ "format": "phrase", "content": "hence" }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }], "antecedents": [], "results": [{ "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" }], "variables": [], "error": [[{ "format": "string", "content": "If you want to reach a contradiction from " }, { "format": "expression", "content": { "expression": { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " and so conclude " }, { "format": "expression", "content": { "expression": { "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": " then you'll need to start from the law of the excluded middle 'We know " }, { "format": "expression", "content": { "expression": { "top_kind_name": "binary_connective", "top_operator_name": "or", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "unary_connective", "top_operator_name": "not", "arguments": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }], "dummies": [] }], "dummies": [] }, "substitutions": [], "type": "boolean" } }, { "format": "string", "content": "'." }]] }], "vocabulary": { "from": ["from"], "and": ["and"], "have": ["we have", "we know", "have"], "hence": ["hence", "so", "thus", "whence", "therefore"], "whichever": ["and whichever is true", "and either way", "and in either case"], "arbitrary": ["was arbitrary", "is arbitrary"], "take": ["take"], "satisfying": ["satisfying", "such that"], "if": ["if"], "given": ["given"], "contradiction": ["contradiction"], "at": ["at"] }, "mistake_table": [{ "name": "layout", "entries": [{ "name": "first_line_indented", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "The first line of a proof should not be indented." }]] }, { "name": "illegal_indent", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_scope_creator", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "Indents should only occur after lines of the form 'If..' or 'Given...'." }]] }, { "name": "double_indent", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "addition", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_scope_creator", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "Only indent once after '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "'." }]] }, { "name": "missing_indent_given", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "After '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' the following lines in which you reason using the variable " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " should be indented. Then stop indenting once you reach a statement of the form '\u2200x.....' in which the " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " no longer occurs." }]] }, { "name": "missing_indent_assumption", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "After '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' the following lines in which you reason under the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " should be indented. Once you have proved some statement p assuming " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " then you can write an unindented line 'Hence " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "=>p'. Alternatively you can simply stop indenting if you no longer wish to use the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "missing_deindent_forall_0", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To prove " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " you need to start by writing 'Given " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "' and then start indenting your lines until you manage to prove " }, { "format": "expression", "content": { "top_operator_name": "entry", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ". After this you can write this line (which should not be indented)." }]] }, { "name": "incorrect_deindent_forall", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "We are still working under the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " and must stop doing so (for example by moving to a statement of the form " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "=>p) before we can leave the scope of " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " and introduce a for-all quantifier." }]] }, { "name": "missing_deindent_for_all_1", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "This line should no longer being indented (because we are no longer within the scope of " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ")." }]] }, { "name": "missing_deindent_for_all_2", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "This line should be indented one step less than the previous line (because it is no longer in the scope of " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ")." }]] }, { "name": "double_deindent_forall", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "We only reduce the level of indentation by one here; we are just leaving the scope of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "'." }]] }, { "name": "missing_deindent_implies_0", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To prove " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " you need to start by writing 'If " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "', then give a chain of reasoning (which should be indented) that ends with " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ". After that you can put this line (which should not be indented)." }]] }, { "name": "missing_deindent_not_0", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To prove " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " you need to start by writing 'If " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "' and then give a chain of reasoning (on indented lines) that ends with a contradiction. After that you are allowed to write this line (unindented)." }]] }, { "name": "incorrect_deindent", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You are still working withing the scope of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' and you need to stop doing so (typically be introducing a forall statement) before you can drop the assumption of " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ". Alternatively you could try changing the order of your 'Given...' and 'If...' lines." }]] }, { "name": "missing_deindent_1", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "Stop indenting at this point, because the truth of this line does not rely on the assumption of " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "missing_deindent_2", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "When writing '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' we reduce the level of indentation by one, to indicate that we are no longer making the assumption that " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "double_deindent_assumption", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You should only de-indent once here; we are dropping the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " but not that of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "double_deindent_given", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "Only deindent once here; we are dropping the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " but are still within the scope of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "'." }]] }, { "name": "illegal_first_line", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You can't have this as the first line of your proof" }]] }] }, { "name": "variables", "entries": [{ "name": "unspecified_variable", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "variables", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_initialized", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You haven't said where " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " comes from; if you want it to be arbitrary then add a preceding line saying 'Given " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "'; alternatively you might want to take a particular " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " witnessing some existential formula." }]] }, { "name": "inaccessible_variable", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "variables", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_accessible", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "The variable " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " was only specified within the scope of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper2", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' in line " }, { "format": "expression", "content": { "top_operator_name": "scoper2", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" } }, { "format": "string", "content": ", and so can only be used there. If you want it as an arbitrary variable again then write 'Given " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "'." }]] }, { "name": "incorrect_variable_forall", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "We originally took " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " as our arbitrary variable so this, rather than " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ", needs to be the one that we quantify out over." }]] }, { "name": "arbitrary_variable_clash", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_accessible", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "The variable " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " is already in use; chose a new variable to work with instead." }]] }, { "name": "variable_clash", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'exists_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_accessible", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You just know that there is some " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " such that " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "; you can't assume that it is the " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " we were previously discussing. Try using an entirely new variable in place of " }, { "format": "expression", "content": { "top_operator_name": "variable", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }] }, { "name": "logic", "entries": [{ "name": "missing_antecedent", "occurs": { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_proven", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "boolean" }, "message": [[{ "format": "string", "content": "This line uses " }, { "format": "expression", "content": { "top_operator_name": "min", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_proven", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "formula" } }, { "format": "string", "content": ", so you need to have an earlier line proving that " }, { "format": "expression", "content": { "top_operator_name": "min", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_proven", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "formula" } }, { "format": "string", "content": " is true." }]] }, { "name": "inaccessible_antecedent", "occurs": { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_available", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "boolean" }, "message": [[{ "format": "string", "content": "You are using here that " }, { "format": "expression", "content": { "top_operator_name": "min", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_available", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "formula" } }, { "format": "string", "content": ", which was only proved within the context of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "prover", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "min", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_available", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' and so is no longer available to you." }]] }, { "name": "missing_false", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "needs_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "This line assumes you have already proved a contradiction, which is not the case." }]] }, { "name": "inaccessible_false", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "needs_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in_scope", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "It is true that you proved a contradiction in line " }, { "format": "expression", "content": { "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" } }, { "format": "string", "content": " but this line is no longer available to you." }]] }, { "name": "for_all_incorrect_conclusion", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "substitute", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'p'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'x'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'a'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To conclude this you need to have shown " }, { "format": "expression", "content": { "top_operator_name": "substitute", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'p'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'x'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'a'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " on the immediately preceding line." }]] }, { "name": "implies_incorrect_conclusion", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To deduce '" }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "' you need to have proved " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " in the immediately preceding line (under the assumption of " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ")." }]] }, { "name": "implies_incorrect_assumption", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'implies_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You started with the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " not " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ", so you must conclude 'Hence " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "=>" }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "'." }]] }, { "name": "not_incorrect_conclusion", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To prove the statement " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " you need to start by assuming " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " is true and prove a contradiction. Then write this line immediately afterwards." }]] }, { "name": "not_incorrect_assumption", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_introduce'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "We started with the assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ", so what we have in fact shown is ~" }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "subtraction", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "or_missing_antecedent_both", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "To conclude that " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " follows from " }, { "format": "expression", "content": { "top_operator_name": "entry", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "antecedents", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " you need to show that it follows if either " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " or " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " is true. Write 'If " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "' and then give an (indented) series of lines that deduce " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " (or a contradiction) from " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ". Then separately write 'If " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "' and prove " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " (or a contradiction) under this assumption." }]] }, { "name": "or_missing_antecedent_left", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You have proved that " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " follows if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " holds; you need to also prove it follows if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " holds." }]] }, { "name": "or_missing_antecedent_right", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You have proved that " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " follows if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " holds; you need to also prove it follows if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " holds." }]] }, { "name": "or_inaccessible_antecedent_left", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_available_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You proved that if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " then " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ", but this was in the context of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'R'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "', which we have since left." }]] }, { "name": "or_inaccessible_antecedent_right", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_available_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "You proved that if " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": " then " }, { "format": "expression", "content": { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": ", but this was in the context of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'S'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "element", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "'T'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "', which we have since left." }]] }] }, { "name": "target", "entries": [{ "name": "last_line_indented_assumption", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "num_lines", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "The last line of a proof should not be indented; you need to prove that the given formulas holds just from the original assumptions, not the additional assumption of " }, { "format": "expression", "content": { "top_operator_name": "result", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "formula" } }, { "format": "string", "content": "." }]] }, { "name": "last_line_indented_given", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "num_lines", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "The last line of a proof should not be indented; you should have ceased working within the scope of '" }, { "format": "expression", "content": { "top_operator_name": "text", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" } }, { "format": "string", "content": "' by this point, typically by introducing a forall statement." }]] }, { "name": "last_line_not_target", "occurs": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "num_lines", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "target", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "message": [[{ "format": "string", "content": "We are trying to prove " }, { "format": "expression", "content": { "top_operator_name": "target", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "formula" } }, { "format": "string", "content": " so it should be given by the final line of the proof." }]] }] }], "control_functions": [{ "name": "variable", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "formula" }], "definition": { "top_operator_name": "entry", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "variables", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "formula" }, "description": "The free variable occurring in line n (if any)" }, { "name": "result", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "formula" }], "definition": { "top_operator_name": "entry", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "formula" }, "description": "The result of line n (if any)" }, { "name": "is_scope_creator", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether the line after this one should be indented" }, { "name": "scoper", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "integer" }], "definition": { "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" }, "description": "The most recent line (not including n) in whose scope line n is" }, { "name": "scoper2", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "integer" }], "definition": { "top_operator_name": "if", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "is_scope_creator", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "scoper", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, "description": "The most recent line (including n) in whose scope line n is" }, { "name": "is_in_scope", "variables": [{ "top_kind_name": "variable", "top_operator_name": "k", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "is_scope_creator", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether the results and variables of line k<=n are accessible to line n" }, { "name": "is_initializer", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'for_all_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'exists_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'take'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether line n initializes its variables" }, { "name": "initializes", "variables": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "variables", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether line n initializes variable x" }, { "name": "is_initialized", "variables": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "question_variables", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "initializes", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether variable x is initialized by line n (this does not mean it is legal to use, as it may be out of scope)." }, { "name": "initializer", "variables": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "integer" }], "definition": { "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "initializes", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" }, "description": "The most recent line before n that initializes x" }, { "name": "is_accessible", "variables": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "question_variables", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "initializes", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in_scope", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether variable x is initialized and still available by line n" }, { "name": "is_arbitrary", "variables": [{ "top_kind_name": "variable", "top_operator_name": "x", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "initializer", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "x", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'given'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, "description": "Whether variable x is arbitrary at line n" }, { "name": "is_proven", "variables": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "assumptions", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether there is a line before n that proves R (again, it may still be out of scope and thus unusable)." }, { "name": "prover", "variables": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "integer" }], "definition": { "top_operator_name": "max", "top_kind_name": "ranged_function", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "integer" }, "description": "The most recent line before n that proves R." }, { "name": "is_available", "variables": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "assumptions", "top_kind_name": "prefix_function", "arguments": [], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in_scope", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether R is available to use by line n" }, { "name": "yields_false", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'not_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'or_eliminate_false'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether line n proves a contradiction" }, { "name": "needs_false", "variables": [{ "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'contradiction_eliminate'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, "description": "Whether line n assumes a contradiction has been proved" }, { "name": "yields_implication", "variables": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "S", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "m", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "or", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "S", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "addition", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether line n is a proof of S under the assumption of R, made on line m" }, { "name": "yields_implies_false", "variables": [{ "top_kind_name": "variable", "top_operator_name": "R", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "m", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 0, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "yields_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "template", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "string" }, { "top_operator_name": "'assumption'", "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "string" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "is_in", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "R", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "results", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "set_of_formulas" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "addition", "top_kind_name": "binary_function", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": 1, "top_kind_name": "constant", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "m", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }, "description": "Whether line n is a proof of contradiction under the assumption of R, made on line m" }, { "name": "is_available_implication", "variables": [{ "top_kind_name": "variable", "top_operator_name": "A", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "B", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "yields_implication", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "B", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }, "description": "Whether there is a proof of B under the assumption of A available at line n" }, { "name": "is_available_implies_false", "variables": [{ "top_kind_name": "variable", "top_operator_name": "A", "arguments": [], "dummies": [] }, { "top_kind_name": "variable", "top_operator_name": "n", "arguments": [], "dummies": [] }], "typing": [{ "arguments": [{ "type": "formula", "arbitrarily_many": false }, { "type": "integer", "arbitrarily_many": false }], "dummies": [], "output": "boolean" }], "definition": { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "yields_implies_false", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "A", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "formula" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "not", "top_kind_name": "unary_connective", "arguments": [{ "top_operator_name": "bounded_exists", "top_kind_name": "bounded_quantifier", "arguments": [{ "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "and", "top_kind_name": "binary_connective", "arguments": [{ "top_operator_name": "greater_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }, { "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "k", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [], "type": "boolean" }, { "top_operator_name": "less_than_or_equals", "top_kind_name": "binary_relation", "arguments": [{ "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }, { "top_operator_name": "indentation", "top_kind_name": "prefix_function", "arguments": [{ "top_operator_name": "n", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "dummies": [], "type": "integer" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [], "type": "boolean" }], "dummies": [{ "top_operator_name": "i", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }], "dummies": [{ "top_operator_name": "j", "top_kind_name": "variable", "arguments": [], "dummies": [], "type": "integer" }], "type": "boolean" }, "description": "Whether there is a proof of contradiction under the assumption of A available at line n" }] };
// ^^Paste generated code above this line^^
exports.default = LOGIC_PROOF_DEFAULT_QUESTION_DATA;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/generatedParser.ts":
/*!*************************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/generatedParser.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var logicProofParser = (function () {
    /*
     * Generated by PEG.js 0.7.0.
     *
     * http://pegjs.majda.cz/
     */
    function quote(s) {
        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
         * string literal except for the closing quote character, backslash,
         * carriage return, line separator, paragraph separator, and line feed.
         * Any character may appear in the form of an escape sequence.
         *
         * For portability, we also escape escape all control and non-ASCII
         * characters. Note that "\0" and "\v" escape sequences are not used
         * because JSHint does not like the first and IE the second.
         */
        return '"' + s
            .replace(/\\/g, '\\\\') // backslash
            .replace(/"/g, '\\"') // closing quote character
            .replace(/\x08/g, '\\b') // backspace
            .replace(/\t/g, '\\t') // horizontal tab
            .replace(/\n/g, '\\n') // line feed
            .replace(/\f/g, '\\f') // form feed
            .replace(/\r/g, '\\r') // carriage return
            .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
            + '"';
    }
    var result = {
        /*
         * Parses the input with a generated parser. If the parsing is successfull,
         * returns a value explicitly or implicitly specified by the grammar from
         * which the parser was generated (see |PEG.buildParser|). If the parsing is
         * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
         */
        parse: function (input, startRule) {
            var parseFunctions = {
                "expressionTemplate": parse_expressionTemplate,
                "booleanTemplate": parse_booleanTemplate,
                "substitution": parse_substitution,
                "elementTemplate": parse_elementTemplate,
                "variableTemplate": parse_variableTemplate,
                "listOfBooleanTemplates": parse_listOfBooleanTemplates,
                "commaThenBooleanTemplate": parse_commaThenBooleanTemplate,
                "expressionTemplate2": parse_expressionTemplate2,
                "booleanTemplate2": parse_booleanTemplate2,
                "formulaLHS": parse_formulaLHS,
                "listOfVariables": parse_listOfVariables,
                "commaThenVariable": parse_commaThenVariable,
                "expression": parse_expression,
                "listOfExpressions": parse_listOfExpressions,
                "commaThenExpression": parse_commaThenExpression,
                "iffSymbol": parse_iffSymbol,
                "impliesSymbol": parse_impliesSymbol,
                "forAllSymbol": parse_forAllSymbol,
                "existsSymbol": parse_existsSymbol,
                "andSymbol": parse_andSymbol,
                "orSymbol": parse_orSymbol,
                "notSymbol": parse_notSymbol,
                "equalsSymbol": parse_equalsSymbol,
                "lessThanOrEqualsSymbol": parse_lessThanOrEqualsSymbol,
                "greaterThanOrEqualsSymbol": parse_greaterThanOrEqualsSymbol,
                "lessThanSymbol": parse_lessThanSymbol,
                "greaterThanSymbol": parse_greaterThanSymbol,
                "notEqualsSymbol": parse_notEqualsSymbol,
                "membershipSymbol": parse_membershipSymbol,
                "addition": parse_addition,
                "subtraction": parse_subtraction,
                "multiplication": parse_multiplication,
                "division": parse_division,
                "exponentiation": parse_exponentiation,
                "iffFormula": parse_iffFormula,
                "impliesFormula": parse_impliesFormula,
                "quantifierFormula": parse_quantifierFormula,
                "forAllFormula": parse_forAllFormula,
                "existsFormula": parse_existsFormula,
                "boundedForAllFormula": parse_boundedForAllFormula,
                "boundedExistsFormula": parse_boundedExistsFormula,
                "orFormula": parse_orFormula,
                "andFormula": parse_andFormula,
                "andRHS": parse_andRHS,
                "unaryFormula": parse_unaryFormula,
                "notFormula": parse_notFormula,
                "notRHS": parse_notRHS,
                "infixRelationFormula": parse_infixRelationFormula,
                "infixRelationName": parse_infixRelationName,
                "boundableInfixRelationName": parse_boundableInfixRelationName,
                "infixRelationRHS": parse_infixRelationRHS,
                "additionArgument": parse_additionArgument,
                "additionRHS": parse_additionRHS,
                "subtractionArgument": parse_subtractionArgument,
                "subtractionRHS": parse_subtractionRHS,
                "multiplicationArgument": parse_multiplicationArgument,
                "multiplicationRHS": parse_multiplicationRHS,
                "divisionArgument": parse_divisionArgument,
                "divisionRHS": parse_divisionRHS,
                "exponentiationArgument": parse_exponentiationArgument,
                "exponentiationRHS": parse_exponentiationRHS,
                "reducedArgument": parse_reducedArgument,
                "bracketExpression": parse_bracketExpression,
                "prefixFunction": parse_prefixFunction,
                "rangedFunction": parse_rangedFunction,
                "constant": parse_constant,
                "string": parse_string,
                "variable": parse_variable,
                "name": parse_name
            };
            if (startRule !== undefined) {
                if (parseFunctions[startRule] === undefined) {
                    throw new Error("Invalid rule name: " + quote(startRule) + ".");
                }
            }
            else {
                startRule = "expression";
            }
            var pos = 0;
            var reportFailures = 0;
            var rightmostFailuresPos = 0;
            var rightmostFailuresExpected = [];
            var cache = {};
            function padLeft(input, padding, length) {
                var result = input;
                var padLength = length - input.length;
                for (var i = 0; i < padLength; i++) {
                    result = padding + result;
                }
                return result;
            }
            function escape(ch) {
                var charCode = ch.charCodeAt(0);
                var escapeChar;
                var length;
                if (charCode <= 0xFF) {
                    escapeChar = 'x';
                    length = 2;
                }
                else {
                    escapeChar = 'u';
                    length = 4;
                }
                return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
            }
            function matchFailed(failure) {
                if (pos < rightmostFailuresPos) {
                    return;
                }
                if (pos > rightmostFailuresPos) {
                    rightmostFailuresPos = pos;
                    rightmostFailuresExpected = [];
                }
                rightmostFailuresExpected.push(failure);
            }
            function parse_expressionTemplate() {
                var cacheKey = "expressionTemplate@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_variableTemplate();
                if (result0 === null) {
                    result0 = parse_elementTemplate();
                    if (result0 === null) {
                        result0 = parse_booleanTemplate();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_booleanTemplate() {
                var cacheKey = "booleanTemplate@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_expression();
                if (result0 !== null) {
                    result1 = [];
                    result2 = parse_substitution();
                    while (result2 !== null) {
                        result1.push(result2);
                        result2 = parse_substitution();
                    }
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, expression, subs) {
                        return {
                            expression: expression,
                            substitutions: subs,
                            type: 'boolean',
                        };
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_substitution() {
                var cacheKey = "substitution@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 91) {
                    result0 = "[";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"[\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        if (input.substr(pos, 2) === "->") {
                            result2 = "->";
                            pos += 2;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"->\"");
                            }
                        }
                        if (result2 !== null) {
                            result3 = parse_expression();
                            if (result3 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                    result4 = "]";
                                    pos++;
                                }
                                else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\"]\"");
                                    }
                                }
                                if (result4 !== null) {
                                    result0 = [result0, result1, result2, result3, result4];
                                }
                                else {
                                    result0 = null;
                                    pos = pos1;
                                }
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, from, to) {
                        var output = {};
                        output[from.top_operator_name] = to;
                        return output;
                    })(pos0, result0[1], result0[3]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_elementTemplate() {
                var cacheKey = "elementTemplate@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 2) === "{{") {
                    result0 = "{{";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"{{\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_additionArgument();
                    if (result1 !== null) {
                        if (input.substr(pos, 10) === "|element}}") {
                            result2 = "|element}}";
                            pos += 10;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"|element}}\"");
                            }
                        }
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, element) {
                        return {
                            expression: element,
                            substitutions: [],
                            type: 'element',
                        };
                    })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_variableTemplate() {
                var cacheKey = "variableTemplate@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 2) === "{{") {
                    result0 = "{{";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"{{\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        if (input.substr(pos, 11) === "|variable}}") {
                            result2 = "|variable}}";
                            pos += 11;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"|variable}}\"");
                            }
                        }
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, variable) {
                        return {
                            expression: variable,
                            substitutions: [],
                            type: 'element',
                            kind: 'variable'
                        };
                    })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_listOfBooleanTemplates() {
                var cacheKey = "listOfBooleanTemplates@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_booleanTemplate();
                result0 = result0 !== null ? result0 : "";
                if (result0 !== null) {
                    result1 = [];
                    result2 = parse_commaThenBooleanTemplate();
                    while (result2 !== null) {
                        result1.push(result2);
                        result2 = parse_commaThenBooleanTemplate();
                    }
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av, avList) {
                        var result = (av === '') ? [] : [av];
                        for (var i = 0; i < avList.length; i++) {
                            result.push(avList[i]);
                        }
                        return result;
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_commaThenBooleanTemplate() {
                var cacheKey = "commaThenBooleanTemplate@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\",\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_booleanTemplate();
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av) { return av; })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_expressionTemplate2() {
                var cacheKey = "expressionTemplate2@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_elementTemplate();
                if (result0 === null) {
                    result0 = parse_variableTemplate();
                    if (result0 === null) {
                        result0 = parse_booleanTemplate2();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_booleanTemplate2() {
                var cacheKey = "booleanTemplate2@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 2) === "{{") {
                    result0 = "{{";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"{{\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_expression();
                    if (result1 !== null) {
                        result2 = [];
                        result3 = parse_substitution();
                        while (result3 !== null) {
                            result2.push(result3);
                            result3 = parse_substitution();
                        }
                        if (result2 !== null) {
                            if (input.substr(pos, 2) === "}}") {
                                result3 = "}}";
                                pos += 2;
                            }
                            else {
                                result3 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\"}}\"");
                                }
                            }
                            if (result3 !== null) {
                                result0 = [result0, result1, result2, result3];
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, expression, subs) {
                        return {
                            expression: expression,
                            substitutions: subs,
                            type: 'boolean',
                        };
                    })(pos0, result0[1], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_formulaLHS() {
                var cacheKey = "formulaLHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_name();
                if (result0 !== null) {
                    if (input.charCodeAt(pos) === 40) {
                        result1 = "(";
                        pos++;
                    }
                    else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"(\"");
                        }
                    }
                    if (result1 !== null) {
                        result2 = parse_listOfVariables();
                        if (result2 !== null) {
                            if (input.charCodeAt(pos) === 41) {
                                result3 = ")";
                                pos++;
                            }
                            else {
                                result3 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                }
                            }
                            if (result3 !== null) {
                                result0 = [result0, result1, result2, result3];
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, name, args) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: name,
                            arguments: args,
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_listOfVariables() {
                var cacheKey = "listOfVariables@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_variable();
                result0 = result0 !== null ? result0 : "";
                if (result0 !== null) {
                    result1 = [];
                    result2 = parse_commaThenVariable();
                    while (result2 !== null) {
                        result1.push(result2);
                        result2 = parse_commaThenVariable();
                    }
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av, avList) {
                        var result = (av === '') ? [] : [av];
                        for (var i = 0; i < avList.length; i++) {
                            result.push(avList[i]);
                        }
                        return result;
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_commaThenVariable() {
                var cacheKey = "commaThenVariable@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\",\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av) { return av; })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_expression() {
                var cacheKey = "expression@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_iffFormula();
                if (result0 !== null) {
                    result0 = (function (offset, a) { return a; })(pos0, result0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_listOfExpressions() {
                var cacheKey = "listOfExpressions@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_expression();
                result0 = result0 !== null ? result0 : "";
                if (result0 !== null) {
                    result1 = [];
                    result2 = parse_commaThenExpression();
                    while (result2 !== null) {
                        result1.push(result2);
                        result2 = parse_commaThenExpression();
                    }
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av, avList) {
                        var result = (av === '') ? [] : [av];
                        for (var i = 0; i < avList.length; i++) {
                            result.push(avList[i]);
                        }
                        return result;
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_commaThenExpression() {
                var cacheKey = "commaThenExpression@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\",\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_expression();
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, av) { return av; })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_iffSymbol() {
                var cacheKey = "iffSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.substr(pos, 3) === "<=>") {
                    result0 = "<=>";
                    pos += 3;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"<=>\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_impliesSymbol() {
                var cacheKey = "impliesSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.substr(pos, 2) === "=>") {
                    result0 = "=>";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"=>\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_forAllSymbol() {
                var cacheKey = "forAllSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 8704) {
                    result0 = "\u2200";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"\\u2200\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_existsSymbol() {
                var cacheKey = "existsSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 8707) {
                    result0 = "\u2203";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"\\u2203\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_andSymbol() {
                var cacheKey = "andSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 8743) {
                    result0 = "\u2227";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"\\u2227\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_orSymbol() {
                var cacheKey = "orSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 8744) {
                    result0 = "\u2228";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"\\u2228\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_notSymbol() {
                var cacheKey = "notSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 126) {
                    result0 = "~";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"~\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_equalsSymbol() {
                var cacheKey = "equalsSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"=\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'equals'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_lessThanOrEqualsSymbol() {
                var cacheKey = "lessThanOrEqualsSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.substr(pos, 2) === "<=") {
                    result0 = "<=";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"<=\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'less_than_or_equals'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_greaterThanOrEqualsSymbol() {
                var cacheKey = "greaterThanOrEqualsSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.substr(pos, 2) === ">=") {
                    result0 = ">=";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\">=\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'greater_than_or_equals'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_lessThanSymbol() {
                var cacheKey = "lessThanSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.charCodeAt(pos) === 60) {
                    result0 = "<";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"<\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'less_than'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_greaterThanSymbol() {
                var cacheKey = "greaterThanSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.charCodeAt(pos) === 62) {
                    result0 = ">";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\">\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'greater_than'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_notEqualsSymbol() {
                var cacheKey = "notEqualsSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.substr(pos, 2) === "!=") {
                    result0 = "!=";
                    pos += 2;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"!=\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'not_equals'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_membershipSymbol() {
                var cacheKey = "membershipSymbol@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                if (input.charCodeAt(pos) === 8712) {
                    result0 = "\u2208";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"\\u2208\"");
                    }
                }
                if (result0 !== null) {
                    result0 = (function (offset) { return 'is_in'; })(pos0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_addition() {
                var cacheKey = "addition@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"+\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_subtraction() {
                var cacheKey = "subtraction@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 45) {
                    result0 = "-";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"-\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_multiplication() {
                var cacheKey = "multiplication@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 42) {
                    result0 = "*";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"*\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_division() {
                var cacheKey = "division@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 47) {
                    result0 = "/";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"/\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_exponentiation() {
                var cacheKey = "exponentiation@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                if (input.charCodeAt(pos) === 94) {
                    result0 = "^";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"^\"");
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_iffFormula() {
                var cacheKey = "iffFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_impliesFormula();
                if (result0 !== null) {
                    result1 = parse_iffSymbol();
                    if (result1 !== null) {
                        result2 = parse_iffFormula();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_connective',
                            top_operator_name: 'iff',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_impliesFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_impliesFormula() {
                var cacheKey = "impliesFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_quantifierFormula();
                if (result0 !== null) {
                    result1 = parse_impliesSymbol();
                    if (result1 !== null) {
                        result2 = parse_impliesFormula();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_connective',
                            top_operator_name: 'implies',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_quantifierFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_quantifierFormula() {
                var cacheKey = "quantifierFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_orFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_forAllFormula() {
                var cacheKey = "forAllFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_forAllSymbol();
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        if (input.charCodeAt(pos) === 46) {
                            result2 = ".";
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\".\"");
                            }
                        }
                        result2 = result2 !== null ? result2 : "";
                        if (result2 !== null) {
                            result3 = parse_quantifierFormula();
                            if (result3 !== null) {
                                result0 = [result0, result1, result2, result3];
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'quantifier',
                            top_operator_name: 'for_all',
                            arguments: [right],
                            dummies: [left]
                        };
                    })(pos0, result0[1], result0[3]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_existsFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_existsFormula() {
                var cacheKey = "existsFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_existsSymbol();
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        if (input.charCodeAt(pos) === 46) {
                            result2 = ".";
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\".\"");
                            }
                        }
                        result2 = result2 !== null ? result2 : "";
                        if (result2 !== null) {
                            result3 = parse_quantifierFormula();
                            if (result3 !== null) {
                                result0 = [result0, result1, result2, result3];
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'quantifier',
                            top_operator_name: 'exists',
                            arguments: [right],
                            dummies: [left]
                        };
                    })(pos0, result0[1], result0[3]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_boundedForAllFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_boundedForAllFormula() {
                var cacheKey = "boundedForAllFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_forAllSymbol();
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        result2 = parse_boundableInfixRelationName();
                        if (result2 !== null) {
                            result3 = parse_additionArgument();
                            if (result3 !== null) {
                                if (input.charCodeAt(pos) === 46) {
                                    result4 = ".";
                                    pos++;
                                }
                                else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\".\"");
                                    }
                                }
                                result4 = result4 !== null ? result4 : "";
                                if (result4 !== null) {
                                    result5 = parse_quantifierFormula();
                                    if (result5 !== null) {
                                        result0 = [result0, result1, result2, result3, result4, result5];
                                    }
                                    else {
                                        result0 = null;
                                        pos = pos1;
                                    }
                                }
                                else {
                                    result0 = null;
                                    pos = pos1;
                                }
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, k, relation, n, A) {
                        return {
                            top_kind_name: 'bounded_quantifier',
                            top_operator_name: 'bounded_for_all',
                            arguments: [{
                                    top_kind_name: 'binary_relation',
                                    top_operator_name: relation,
                                    arguments: [k, n],
                                    dummies: []
                                }, A],
                            dummies: [k]
                        };
                    })(pos0, result0[1], result0[2], result0[3], result0[5]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_boundedExistsFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_boundedExistsFormula() {
                var cacheKey = "boundedExistsFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_existsSymbol();
                if (result0 !== null) {
                    result1 = parse_variable();
                    if (result1 !== null) {
                        result2 = parse_boundableInfixRelationName();
                        if (result2 !== null) {
                            result3 = parse_additionArgument();
                            if (result3 !== null) {
                                if (input.charCodeAt(pos) === 46) {
                                    result4 = ".";
                                    pos++;
                                }
                                else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("\".\"");
                                    }
                                }
                                result4 = result4 !== null ? result4 : "";
                                if (result4 !== null) {
                                    result5 = parse_quantifierFormula();
                                    if (result5 !== null) {
                                        result0 = [result0, result1, result2, result3, result4, result5];
                                    }
                                    else {
                                        result0 = null;
                                        pos = pos1;
                                    }
                                }
                                else {
                                    result0 = null;
                                    pos = pos1;
                                }
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, k, relation, n, A) {
                        return {
                            top_kind_name: 'bounded_quantifier',
                            top_operator_name: 'bounded_exists',
                            arguments: [{
                                    top_kind_name: 'binary_relation',
                                    top_operator_name: relation,
                                    arguments: [k, n],
                                    dummies: []
                                }, A],
                            dummies: [k]
                        };
                    })(pos0, result0[1], result0[2], result0[3], result0[5]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_orFormula() {
                var cacheKey = "orFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_andFormula();
                if (result0 !== null) {
                    result1 = parse_orSymbol();
                    if (result1 !== null) {
                        result2 = parse_quantifierFormula();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_connective',
                            top_operator_name: 'or',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_andFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_andFormula() {
                var cacheKey = "andFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_unaryFormula();
                if (result0 !== null) {
                    result1 = parse_andSymbol();
                    if (result1 !== null) {
                        result2 = parse_andRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_connective',
                            top_operator_name: 'and',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_unaryFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_andRHS() {
                var cacheKey = "andRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_andFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_unaryFormula() {
                var cacheKey = "unaryFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_notFormula();
                if (result0 === null) {
                    result0 = parse_infixRelationFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_notFormula() {
                var cacheKey = "notFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_notSymbol();
                if (result0 !== null) {
                    result1 = parse_notRHS();
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, right) {
                        return {
                            top_kind_name: 'unary_connective',
                            top_operator_name: 'not',
                            arguments: [right],
                            dummies: []
                        };
                    })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_notRHS() {
                var cacheKey = "notRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_unaryFormula();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_infixRelationFormula() {
                var cacheKey = "infixRelationFormula@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_additionArgument();
                if (result0 !== null) {
                    result1 = parse_infixRelationName();
                    if (result1 !== null) {
                        result2 = parse_infixRelationRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, name, right) {
                        return {
                            top_kind_name: 'binary_relation',
                            top_operator_name: name,
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[1], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_additionArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_infixRelationName() {
                var cacheKey = "infixRelationName@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_equalsSymbol();
                if (result0 === null) {
                    result0 = parse_lessThanOrEqualsSymbol();
                    if (result0 === null) {
                        result0 = parse_greaterThanOrEqualsSymbol();
                        if (result0 === null) {
                            result0 = parse_lessThanSymbol();
                            if (result0 === null) {
                                result0 = parse_greaterThanSymbol();
                                if (result0 === null) {
                                    result0 = parse_notEqualsSymbol();
                                    if (result0 === null) {
                                        result0 = parse_membershipSymbol();
                                    }
                                }
                            }
                        }
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_boundableInfixRelationName() {
                var cacheKey = "boundableInfixRelationName@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_lessThanOrEqualsSymbol();
                if (result0 === null) {
                    result0 = parse_lessThanSymbol();
                    if (result0 === null) {
                        result0 = parse_membershipSymbol();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_infixRelationRHS() {
                var cacheKey = "infixRelationRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_infixRelationFormula();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_additionArgument() {
                var cacheKey = "additionArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_subtractionArgument();
                if (result0 !== null) {
                    result1 = parse_addition();
                    if (result1 !== null) {
                        result2 = parse_additionRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: 'addition',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_subtractionArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_additionRHS() {
                var cacheKey = "additionRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_additionArgument();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_subtractionArgument() {
                var cacheKey = "subtractionArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_multiplicationArgument();
                if (result0 !== null) {
                    result1 = parse_subtraction();
                    if (result1 !== null) {
                        result2 = parse_subtractionRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: 'subtraction',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_multiplicationArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_subtractionRHS() {
                var cacheKey = "subtractionRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_subtractionArgument();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_multiplicationArgument() {
                var cacheKey = "multiplicationArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_divisionArgument();
                if (result0 !== null) {
                    result1 = parse_multiplication();
                    if (result1 !== null) {
                        result2 = parse_multiplicationRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: 'multiplication',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_divisionArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_multiplicationRHS() {
                var cacheKey = "multiplicationRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_multiplicationArgument();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_divisionArgument() {
                var cacheKey = "divisionArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_exponentiationArgument();
                if (result0 !== null) {
                    result1 = parse_division();
                    if (result1 !== null) {
                        result2 = parse_divisionRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: 'division',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_exponentiationArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_divisionRHS() {
                var cacheKey = "divisionRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_divisionArgument();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_exponentiationArgument() {
                var cacheKey = "exponentiationArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_reducedArgument();
                if (result0 !== null) {
                    result1 = parse_exponentiation();
                    if (result1 !== null) {
                        result2 = parse_exponentiationRHS();
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, left, right) {
                        return {
                            top_kind_name: 'binary_function',
                            top_operator_name: 'exponentiation',
                            arguments: [left, right],
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_reducedArgument();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_exponentiationRHS() {
                var cacheKey = "exponentiationRHS@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_forAllFormula();
                if (result0 === null) {
                    result0 = parse_notFormula();
                    if (result0 === null) {
                        result0 = parse_exponentiationArgument();
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_reducedArgument() {
                var cacheKey = "reducedArgument@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                result0 = parse_bracketExpression();
                if (result0 === null) {
                    result0 = parse_prefixFunction();
                    if (result0 === null) {
                        result0 = parse_constant();
                        if (result0 === null) {
                            result0 = parse_variable();
                        }
                    }
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_bracketExpression() {
                var cacheKey = "bracketExpression@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 40) {
                    result0 = "(";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"(\"");
                    }
                }
                if (result0 !== null) {
                    result1 = parse_expression();
                    if (result1 !== null) {
                        if (input.charCodeAt(pos) === 41) {
                            result2 = ")";
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\")\"");
                            }
                        }
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, e) { return e; })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_prefixFunction() {
                var cacheKey = "prefixFunction@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_name();
                if (result0 !== null) {
                    if (input.charCodeAt(pos) === 40) {
                        result1 = "(";
                        pos++;
                    }
                    else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"(\"");
                        }
                    }
                    if (result1 !== null) {
                        result2 = parse_listOfExpressions();
                        if (result2 !== null) {
                            if (input.charCodeAt(pos) === 41) {
                                result3 = ")";
                                pos++;
                            }
                            else {
                                result3 = null;
                                if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                }
                            }
                            if (result3 !== null) {
                                result0 = [result0, result1, result2, result3];
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, name, args) {
                        return {
                            top_kind_name: 'prefix_function',
                            top_operator_name: name,
                            arguments: args,
                            dummies: []
                        };
                    })(pos0, result0[0], result0[2]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_rangedFunction();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_rangedFunction() {
                var cacheKey = "rangedFunction@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2, result3, result4, result5, result6, result7;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_name();
                if (result0 !== null) {
                    if (input.charCodeAt(pos) === 123) {
                        result1 = "{";
                        pos++;
                    }
                    else {
                        result1 = null;
                        if (reportFailures === 0) {
                            matchFailed("\"{\"");
                        }
                    }
                    if (result1 !== null) {
                        result2 = parse_variable();
                        if (result2 !== null) {
                            result3 = parse_boundableInfixRelationName();
                            if (result3 !== null) {
                                result4 = parse_additionArgument();
                                if (result4 !== null) {
                                    if (input.charCodeAt(pos) === 124) {
                                        result5 = "|";
                                        pos++;
                                    }
                                    else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("\"|\"");
                                        }
                                    }
                                    if (result5 !== null) {
                                        result6 = parse_expression();
                                        if (result6 !== null) {
                                            if (input.charCodeAt(pos) === 125) {
                                                result7 = "}";
                                                pos++;
                                            }
                                            else {
                                                result7 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed("\"}\"");
                                                }
                                            }
                                            if (result7 !== null) {
                                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                            }
                                            else {
                                                result0 = null;
                                                pos = pos1;
                                            }
                                        }
                                        else {
                                            result0 = null;
                                            pos = pos1;
                                        }
                                    }
                                    else {
                                        result0 = null;
                                        pos = pos1;
                                    }
                                }
                                else {
                                    result0 = null;
                                    pos = pos1;
                                }
                            }
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, name, k, relation, n, A) {
                        return {
                            top_kind_name: 'ranged_function',
                            top_operator_name: name,
                            arguments: [{
                                    top_kind_name: 'binary_relation',
                                    top_operator_name: relation,
                                    arguments: [k, n],
                                    dummies: []
                                }, A],
                            dummies: [k]
                        };
                    })(pos0, result0[0], result0[2], result0[3], result0[4], result0[6]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_constant() {
                var cacheKey = "constant@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1;
                var pos0;
                pos0 = pos;
                if (/^[0-9]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                }
                else {
                    result1 = null;
                    if (reportFailures === 0) {
                        matchFailed("[0-9]");
                    }
                }
                if (result1 !== null) {
                    result0 = [];
                    while (result1 !== null) {
                        result0.push(result1);
                        if (/^[0-9]/.test(input.charAt(pos))) {
                            result1 = input.charAt(pos);
                            pos++;
                        }
                        else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9]");
                            }
                        }
                    }
                }
                else {
                    result0 = null;
                }
                if (result0 !== null) {
                    result0 = (function (offset, digits) {
                        return {
                            top_kind_name: 'constant',
                            top_operator_name: parseInt(digits.join(""), 10),
                            arguments: [],
                            dummies: [],
                            type: 'integer'
                        };
                    })(pos0, result0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                if (result0 === null) {
                    result0 = parse_string();
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_string() {
                var cacheKey = "string@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 39) {
                    result0 = "'";
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("\"'\"");
                    }
                }
                if (result0 !== null) {
                    result1 = [];
                    if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
                        result2 = input.charAt(pos);
                        pos++;
                    }
                    else {
                        result2 = null;
                        if (reportFailures === 0) {
                            matchFailed("[a-zA-Z0-9_]");
                        }
                    }
                    while (result2 !== null) {
                        result1.push(result2);
                        if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
                            result2 = input.charAt(pos);
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("[a-zA-Z0-9_]");
                            }
                        }
                    }
                    if (result1 !== null) {
                        if (input.charCodeAt(pos) === 39) {
                            result2 = "'";
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("\"'\"");
                            }
                        }
                        if (result2 !== null) {
                            result0 = [result0, result1, result2];
                        }
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, characters) {
                        return {
                            top_kind_name: 'constant',
                            top_operator_name: '\'' + characters.join('') + '\'',
                            arguments: [],
                            dummies: [],
                            type: 'string'
                        };
                    })(pos0, result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_variable() {
                var cacheKey = "variable@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_name();
                if (result0 !== null) {
                    result0 = (function (offset, name) {
                        return {
                            top_kind_name: 'variable',
                            top_operator_name: name,
                            arguments: [],
                            dummies: []
                        };
                    })(pos0, result0);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function parse_name() {
                var cacheKey = "name@" + pos;
                var cachedResult = cache[cacheKey];
                if (cachedResult) {
                    pos = cachedResult.nextPos;
                    return cachedResult.result;
                }
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (/^[A-Za-z]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                }
                else {
                    result0 = null;
                    if (reportFailures === 0) {
                        matchFailed("[A-Za-z]");
                    }
                }
                if (result0 !== null) {
                    result1 = [];
                    if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                        result2 = input.charAt(pos);
                        pos++;
                    }
                    else {
                        result2 = null;
                        if (reportFailures === 0) {
                            matchFailed("[A-Za-z0-9_]");
                        }
                    }
                    while (result2 !== null) {
                        result1.push(result2);
                        if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                            result2 = input.charAt(pos);
                            pos++;
                        }
                        else {
                            result2 = null;
                            if (reportFailures === 0) {
                                matchFailed("[A-Za-z0-9_]");
                            }
                        }
                    }
                    if (result1 !== null) {
                        result0 = [result0, result1];
                    }
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                }
                else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) {
                    result0 = (function (offset, first, middle) {
                        return first + middle.join('');
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                    pos = pos0;
                }
                cache[cacheKey] = {
                    nextPos: pos,
                    result: result0
                };
                return result0;
            }
            function cleanupExpected(expected) {
                expected.sort();
                var lastExpected = null;
                var cleanExpected = [];
                for (var i = 0; i < expected.length; i++) {
                    if (expected[i] !== lastExpected) {
                        cleanExpected.push(expected[i]);
                        lastExpected = expected[i];
                    }
                }
                return cleanExpected;
            }
            function computeErrorPosition() {
                /*
                 * The first idea was to use |String.split| to break the input up to the
                 * error position along newlines and derive the line and column from
                 * there. However IE's |split| implementation is so broken that it was
                 * enough to prevent it.
                 */
                var line = 1;
                var column = 1;
                var seenCR = false;
                for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
                    var ch = input.charAt(i);
                    if (ch === "\n") {
                        if (!seenCR) {
                            line++;
                        }
                        column = 1;
                        seenCR = false;
                    }
                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                        line++;
                        column = 1;
                        seenCR = true;
                    }
                    else {
                        column++;
                        seenCR = false;
                    }
                }
                return { line: line, column: column };
            }
            var result = parseFunctions[startRule]();
            /*
             * The parser is now in one of the following three states:
             *
             * 1. The parser successfully parsed the whole input.
             *
             *    - |result !== null|
             *    - |pos === input.length|
             *    - |rightmostFailuresExpected| may or may not contain something
             *
             * 2. The parser successfully parsed only a part of the input.
             *
             *    - |result !== null|
             *    - |pos < input.length|
             *    - |rightmostFailuresExpected| may or may not contain something
             *
             * 3. The parser did not successfully parse any part of the input.
             *
             *   - |result === null|
             *   - |pos === 0|
             *   - |rightmostFailuresExpected| contains at least one failure
             *
             * All code following this comment (including called functions) must
             * handle these states.
             */
            if (result === null || pos !== input.length) {
                var offset = Math.max(pos, rightmostFailuresPos);
                var found = offset < input.length ? input.charAt(offset) : null;
                var errorPosition = computeErrorPosition();
                throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
            }
            return result;
        },
        /* Returns the parser source code. */
        toSource: function () { return this._source; },
        SyntaxError: null
    };
    /* Thrown when a parser encounters a syntax error. */
    result.SyntaxError = function (expected, found, offset, line, column) {
        function buildMessage(expected, found) {
            var expectedHumanized, foundHumanized;
            switch (expected.length) {
                case 0:
                    expectedHumanized = "end of input";
                    break;
                case 1:
                    expectedHumanized = expected[0];
                    break;
                default:
                    expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
                        + " or "
                        + expected[expected.length - 1];
            }
            foundHumanized = found ? quote(found) : "end of input";
            return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
        }
        this.name = "SyntaxError";
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
    };
    result.SyntaxError.prototype = Error.prototype;
    return result;
})();
exports.default = logicProofParser;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/shared.ts":
/*!****************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/shared.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Components used by both the editor and reader of the
 *  LogicProof interaction.
 */
var generatedParser_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/generatedParser.ts */ "./extensions/interactions/LogicProof/static/js/generatedParser.ts"));
var logicProofShared = (function () {
    // Used by parseLineString() to limit the number of possible parsings of a
    // line (or line template) considered.
    var MAX_NUM_PARSINGS_PERMITTED = 1000;
    // Used by assignTypesToExpressionArray() to limit the number of possible
    // typings of an expression considered.
    var MAX_NUM_TYPINGS_PERMITTED = 1000;
    // ERROR-HANDLING
    // UserErrors have codes that refer to entries in the errorDictionary (which
    // is either logicProofData.BASE_GENERAL_MESSAGES or
    // logicProofTeacher.TEACHER_ERROR_MESSAGES), from which a human-readable
    // message can be constructed.
    var UserError = function (code, parameters) {
        this.name = 'UserError';
        this.code = code;
        this.parameters = parameters || {};
    };
    // These errors already have messages which are user-readable.
    var PreRenderedUserError = function (messages, code) {
        this.name = 'PreRenderedUserError';
        this.messages = messages;
        this.code = code;
    };
    // TODO(Jacob): Make these errors prototype from Error()
    /** Converts a message template into a string to show to the user.
     * @param messageTemplate: a GeneralMessageTemplate object that determines how
     * to build the string describing an error.
     * @param parameterFormats: a dictionary of GeneralMessageParameters, which
     *        specify the format of the parameter in question (e.g. 'string').
     * @param parameters: a dictionary giving the values of the parameters for
     *        this particular instance of the message.
     * @param language: the relevant Language.
     * @result a user-readable string.
     */
    var renderGeneralMessage = function (messageTemplate, parameterFormats, parameters, language) {
        var message = '';
        for (var i = 0; i < messageTemplate.length; i++) {
            if (messageTemplate[i].isFixed) {
                message += messageTemplate[i].content;
            }
            else {
                var parameterFormat = parameterFormats[messageTemplate[i].content].format;
                var parameter = parameters[messageTemplate[i].content];
                switch (parameterFormat) {
                    case 'string':
                        message += parameter;
                        break;
                    case 'expression':
                        message += displayExpression(parameter, language.operators);
                        break;
                    default:
                        throw Error('Unknown format ' + parameterFormat +
                            ' sent to renderGeneralMessage().');
                }
            }
        }
        return message;
    };
    /**
     * @param {UserError} error - a UserError object
     * @param {object} errorDictionary - a dictionary keyed by error codes for
     *        each of which it provides a description of possible ways to display
     *        the error to the user, one of which will be chosen at random.
     * @param {Language} language - the relevant Language
     * @return {string} A string to show to the user describing what went wrong.
     */
    var renderError = function (error, errorDictionary, language) {
        if (error.name === 'UserError') {
            if (!errorDictionary.hasOwnProperty(error.code)) {
                throw new Error('Unknown error code ' + error.code + ' sent to renderError().');
            }
            var messageTemplates = errorDictionary[error.code].templates;
            var messageTemplate = messageTemplates[Math.floor((Math.random() * messageTemplates.length))];
            return renderGeneralMessage(messageTemplate, errorDictionary[error.code].parameters, error.parameters, language);
        }
        else if (error.name === 'PreRenderedUserError') {
            return error.messages[Math.floor((Math.random() * error.messages.length))];
        }
        else {
            throw error;
        }
    };
    // DISPLAY
    /**
     * @param {Expression} expression - an Expression, which is to be displayed
     * @param {object} operators - provides the symbols keys of the operators so
     *        that we we know e.g. 'for_all' should be displayed using '@'.
     * @return {string} A string representing the expression that can be shown to
     *        the user.
     */
    var displayExpression = function (expression, operators) {
        return displayExpressionHelper(expression, operators, 0);
    };
    /**
     * Recursive helper for displayExpression().
     *
     * @param {Expression} expression - an Expression, which is to be displayed
     * @param {object} operators - provides the symbols keys of the operators so
     *        that we we know e.g. 'for_all' should be displayed using '@'.
     * @param {int} desirabilityOfBrackets - used internally to determine whether
     *        to surround the formula with brackets.
     * @return {string} A string representing the expression.
     */
    var displayExpressionHelper = function (expression, operators, desirabilityOfBrackets) {
        if (desirabilityOfBrackets === void 0) { desirabilityOfBrackets = 0; }
        var desirabilityOfBracketsBelow = (expression.top_kind_name === 'binary_connective' ||
            expression.top_kind_name === 'binary_relation' ||
            expression.top_kind_name === 'binary_function') ? 2 : (expression.top_kind_name === 'unary_connective' ||
            expression.top_kind_name === 'quantifier') ? 1 : 0;
        var processedArguments = [];
        var processedDummies = [];
        for (var i = 0; i < expression.arguments.length; i++) {
            processedArguments.push(displayExpressionHelper(expression.arguments[i], operators, desirabilityOfBracketsBelow));
        }
        for (var i = 0; i < expression.dummies.length; i++) {
            processedDummies.push(displayExpressionHelper(expression.dummies[i], operators, desirabilityOfBracketsBelow));
        }
        var symbol = (!operators.hasOwnProperty(expression.top_operator_name)) ?
            expression.top_operator_name :
            (!operators[expression.top_operator_name].hasOwnProperty('symbols')) ?
                expression.top_operator_name :
                operators[expression.top_operator_name].symbols[0];
        var output = null;
        if (expression.top_kind_name === 'binary_connective' ||
            expression.top_kind_name === 'binary_relation' ||
            expression.top_kind_name === 'binary_function') {
            return (desirabilityOfBrackets > 0 ?
                '(' + processedArguments.join(symbol) + ')' :
                processedArguments.join(symbol));
        }
        else if (expression.top_kind_name === 'unary_connective') {
            output = symbol + processedArguments[0];
            return (desirabilityOfBrackets === 2) ? '(' + output + ')' : output;
        }
        else if (expression.top_kind_name === 'quantifier') {
            output = symbol + processedDummies[0] + '.' + processedArguments[0];
            return (desirabilityOfBrackets === 2) ? '(' + output + ')' : output;
        }
        else if (expression.top_kind_name === 'bounded_quantifier') {
            output = symbol + processedArguments[0] + '.' + processedArguments[1];
            return (desirabilityOfBrackets === 2) ? '(' + output + ')' : output;
        }
        else if (expression.top_kind_name === 'prefix_relation' ||
            expression.top_kind_name === 'prefix_function') {
            return symbol + '(' + processedArguments.join(',') + ')';
        }
        else if (expression.top_kind_name === 'ranged_function') {
            return (symbol + '{' + processedArguments[0] + ' | ' + processedArguments[1] +
                '}');
        }
        else if (expression.top_kind_name === 'atom' ||
            expression.top_kind_name === 'constant' ||
            expression.top_kind_name === 'variable') {
            return symbol;
        }
        else {
            throw Error('Unknown kind ' + expression.top_kind_name +
                ' sent to displayExpression()');
        }
    };
    var displayExpressionArray = function (expressionArray, operators) {
        var processedArray = [];
        for (var i = 0; i < expressionArray.length; i++) {
            processedArray.push(displayExpressionHelper(expressionArray[i], operators));
        }
        return processedArray.join(', ');
    };
    // PARSING
    /**
     * This function checks whether the string contains any symbol that occurs
     * in a member of the symbols key for some operator (these will be
     * symbols such as , =, <).
     * @param {string} string - contains the characters we check
     * @param {object} operators - a dictionary of Operator objects
     * @param {boolean} isTemplate - denotes that the string represents a line
     *        template (which may have substitutions) and not just a line.
     * @return {boolean} true or false
     */
    var containsLogicalCharacter = function (string, operators, isTemplate) {
        var GENERAL_LOGICAL_CHARACTERS = '(),';
        var TEMPLATE_LOGICAL_CHARACTERS = '[->]{|}';
        if (containsCharacterFromArray(string, GENERAL_LOGICAL_CHARACTERS)) {
            return true;
        }
        if (isTemplate &&
            containsCharacterFromArray(string, TEMPLATE_LOGICAL_CHARACTERS)) {
            return true;
        }
        for (var key in operators) {
            if (operators[key].hasOwnProperty('symbols')) {
                for (var i = 0; i < operators[key].symbols.length; i++) {
                    // We check each character of a multi-character symbol in turn.
                    for (var j = 0; j < operators[key].symbols[i].length; j++) {
                        if (string.indexOf(operators[key].symbols[i][j]) !== -1) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    /**
     * This function strips whitespace from within expressions, whilst using the
     * whitespace between expressions to split a line into an array of word /
     * expression strings.
     *  e.g. 'from p and q we have p  q' will be converted to ['from', 'p',
     *   'and', 'q', 'we', 'have', 'pq'].
     * @param {string} inputString - the string from which whitespace is to be
     *        stripped.
     * @param {object} operators - a dictionary of the Operator objects usable in
     *        the line
     * @param {boolean} isTemplate - denotes that the string represents a line
     *        template (which may have substitutions) and not just a line.
     * @return {Array} A non-empty array of words and expressions (as strings).
     * @throws if the line is blank or contains an unknown character.
     */
    var preParseLineString = function (inputString, operators, isTemplate) {
        // The logical characters that may occur at the start and end of a formula
        // respectively. The unicode characters are 'for all' and 'exists'.
        var POSSIBLE_START_CHARS = '({\u2200\u2203~';
        var POSSIBLE_END_CHARS = ')}]';
        var POSSIBLE_NAME_CHARS = ('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _');
        var _absorbsSpacesToTheLeft = function (character) {
            return containsLogicalCharacter(character, operators, isTemplate) &&
                !containsCharacter(POSSIBLE_START_CHARS, character);
        };
        var _absorbsSpacesToTheRight = function (character) {
            return (containsLogicalCharacter(character, operators, isTemplate) &&
                !containsCharacter(POSSIBLE_END_CHARS, character)) ||
                character === ' ';
        };
        var _isLegalCharacter = function (character) {
            return containsCharacter(POSSIBLE_NAME_CHARS, character) ||
                containsLogicalCharacter(character, operators, isTemplate);
        };
        var strippedString = '';
        for (var i = 0; i < inputString.length; i++) {
            if (!_isLegalCharacter(inputString[i])) {
                throw new UserError('illegal_symbol', {
                    symbol: inputString[i]
                });
            }
            // We keep all non-spaces, and all spaces that are absorbed neither by
            // characters to their left nor their right.
            if (inputString[i] !== ' ' ||
                (i === 0 || !_absorbsSpacesToTheRight(strippedString[strippedString.length - 1])) &&
                    (i === inputString.length - 1 || !_absorbsSpacesToTheLeft(inputString[i + 1]))) {
                strippedString += inputString[i];
            }
        }
        if (strippedString.replace(/ /g, '') === '') {
            throw new UserError('blank_line', {});
        }
        return strippedString.trim().split(' ');
    };
    /**
     * @param {string} inputString - written by the user - we will parse it.
     * @param {object} operators - the relevant operators, which are just needed
     *        for their symbols so we can identify whether the symbols the user
     *        is using are legitimate.
     * @param {object} vocabulary - a dictionary whose keys are phrases such as
     *        'have' whose entries are arrays of possible ways to write each
     *        phrase, for example ['have', 'we have']. We will attempt to match
     *        sections of the inputString to the ways of writing each phrase.
     * @param {boolean} isTemplate - if true, we parse the input as a
     *        LineTemplate; otherwise we parse it as a Line.
     * @return {*} A LineTemplate.reader_view if isTemplate === true, and a
     *         ProtoLine if isTemplate === false.
     * @throws If a section of the string cannot be identified as either a phrase
     *         or an expression then we throw an error that tries to best identify
     *         what the user intended and did wrong.
     */
    var parseLineString = function (inputString, operators, vocabulary, isTemplate) {
        if (isTemplate === void 0) { isTemplate = false; }
        var unparsedArray = preParseLineString(inputString, operators, isTemplate);
        // We compile all words occurring in the vocabulary, to help us identify
        // them in lines.
        var vocabularyWords = [];
        for (var key in vocabulary) {
            for (var i = 0; i < vocabulary[key].length; i++) {
                for (var j = 0; j < vocabulary[key][i].split(' ').length; j++) {
                    if (vocabularyWords.indexOf(vocabulary[key][i].split(' ')[j]) === -1) {
                        vocabularyWords.push(vocabulary[key][i].split(' ')[j]);
                    }
                }
            }
        }
        // The lth entry in this array will contain all parsings of the first
        // l-many elements of the unparsedArray.
        var partiallyParsedArrays = [[[]]];
        for (var i = 1; i <= unparsedArray.length; i++) {
            partiallyParsedArrays.push([]);
        }
        for (var i = 0; i < unparsedArray.length; i++) {
            // We have parsed the first i-many entries in the given unparsedArray,
            // and will now attempt to parse the next one.
            // This will only occur in pathological cases
            if (partiallyParsedArrays[i].length > MAX_NUM_PARSINGS_PERMITTED) {
                throw new UserError('too_many_parsings', {});
            }
            for (var j = i + 1; j <= unparsedArray.length; j++) {
                for (var key in vocabulary) {
                    for (var k = 0; k < vocabulary[key].length; k++) {
                        if (unparsedArray.slice(i, j).join(' ').toLowerCase() ===
                            vocabulary[key][k]) {
                            // We have identified the next (j-i)-many words together form a
                            // phrase in the vocabulary dictionary.
                            for (var l = 0; l < partiallyParsedArrays[i].length; l++) {
                                partiallyParsedArrays[j].push(partiallyParsedArrays[i][l].concat([{
                                        format: 'phrase',
                                        content: key
                                    }]));
                            }
                        }
                    }
                }
            }
            // If something is a known word then we do not attempt to parse it as an
            // expression. This is because any word can be regarded as an expression
            // (as a single atom) so otherwise we would end up with a large number of
            // spurious parsings. The exception is single-character words, because
            // e.g. 'a' could reasonably be either a word or the name of an atom.
            if (unparsedArray[i].length === 1 ||
                vocabularyWords.indexOf(unparsedArray[i].toLowerCase()) === -1) {
                // We attempt to parse this entry as an expression / expression template
                try {
                    var expression = generatedParser_ts_1.default.parse(unparsedArray[i], isTemplate ? 'expressionTemplate' : 'expression');
                    for (var j = 0; j < partiallyParsedArrays[i].length; j++) {
                        // We do not allow a line to have two expressions in a row. This is
                        // to allow the identification of typos: For example if the user
                        // types 'fron pq ...' then otherwise we would think that both
                        // 'fron' and 'pq' are expressions. We also do not attempt to
                        // parse a word as an expression if it is a vocabulary word, to
                        // avoid masses of silly attempts to parse the line.
                        if (i === 0 ||
                            partiallyParsedArrays[i][j][partiallyParsedArrays[i][j].length - 1].format === 'phrase') {
                            partiallyParsedArrays[i + 1].push(partiallyParsedArrays[i][j].concat([{
                                    format: 'expression',
                                    content: expression
                                }]));
                        }
                    }
                }
                catch (err) { }
            }
        }
        if (partiallyParsedArrays[unparsedArray.length].length > 0) {
            // We have succeeded in fully parsing
            return partiallyParsedArrays[unparsedArray.length];
        }
        else {
            // We identify the best attempts
            for (var i = unparsedArray.length; i >= 0; i--) {
                if (partiallyParsedArrays[i].length > 0) {
                    var numEntriesMatched = i;
                    break;
                }
            }
            // We return a description of the problem, based on one of the best
            // attempts.
            // NOTE: This is not guaranteed to correctly identify the mistake the
            // user made. It could do with improvement based on user feedback.
            // containsLogicalCharacter is used to guess if something is an
            // expression, but it is not always correct because expressions may
            // consist only of letters.
            var bestAttempt = partiallyParsedArrays[numEntriesMatched][0];
            if (numEntriesMatched === 0 ||
                bestAttempt[bestAttempt.length - 1].format === 'phrase') {
                var word = unparsedArray[numEntriesMatched];
                throw (vocabularyWords.indexOf(word) !== -1) ?
                    new UserError('unidentified_phrase_starting_at', {
                        word: word
                    }) :
                    new UserError('unidentified_word', {
                        word: word
                    });
            }
            else {
                var word1 = unparsedArray[numEntriesMatched - 1];
                var word2 = unparsedArray[numEntriesMatched];
                if (vocabularyWords.indexOf(word1) !== -1) {
                    throw new UserError('unidentified_phrase_starting_at', {
                        word: word1
                    });
                }
                else if (containsLogicalCharacter(word1, operators, isTemplate)) {
                    throw (vocabularyWords.indexOf(word2) !== -1) ?
                        new UserError('unidentified_phrase_starting_at', {
                            word: word2
                        }) :
                        containsLogicalCharacter(word2, operators, isTemplate) ?
                            new UserError('consecutive_expressions', {
                                word1: word1,
                                word2: word2
                            }) :
                            new UserError('unidentified_word', {
                                word: word2
                            });
                }
                else {
                    throw (vocabularyWords.indexOf(word2) !== -1) ?
                        new UserError('unidentified_phrase_starting_at', {
                            word: word2
                        }) :
                        containsLogicalCharacter(word2, operators, isTemplate) ?
                            new UserError('unidentified_word', {
                                word: word1
                            }) :
                            new UserError('unidentified_words', {
                                word1: word1,
                                word2: word2
                            });
                }
            }
        }
    };
    // TYPING ASSIGNMENT
    /**
     * This takes an array of TypingElements and converts it into an array of
     * types.
     * @param {Array.<Object>} types - an array of dictionaries of the form {
     *               type: the name of an available type ('boolean' or 'element')
     *               arbitrarily_many: boolean
     *            }
     *          where at most one member can have 'arbitrarily_many' set to
     *          true, signifying that any number of arguments of this type
     *          can occur here.
     * @param {int} desiredLength - the number of entries we would like to have.
     * @returns {array} an array of types with the right number of entries,
     *          derived from 'types'.
     * @throws if this is not possible.
     */
    var instantiateTypingElementArray = function (types, desiredLength) {
        var listOfTypes = [];
        for (var i = 0; i < types.length; i++) {
            listOfTypes.push(types[i].type);
            if (types[i].arbitrarily_many) {
                var indexWithArbitrarilyMany = i;
            }
        }
        if (indexWithArbitrarilyMany === undefined) {
            if (types.length === desiredLength) {
                return listOfTypes;
            }
            else {
                throw new UserError('wrong_num_inputs', {
                    num_needed: desiredLength
                });
            }
        }
        else {
            var output = [];
            if (types.length <= desiredLength + 1) {
                for (var i = 0; i < types.length; i++) {
                    if (i === indexWithArbitrarilyMany) {
                        for (var j = 0; j < desiredLength - types.length + 1; j++) {
                            output.push(listOfTypes[indexWithArbitrarilyMany]);
                        }
                    }
                    else {
                        output.push(listOfTypes[i]);
                    }
                }
                return output;
            }
            else {
                throw new UserError('not_enough_inputs', {
                    num_needed: desiredLength
                });
            }
        }
    };
    /**
     * This takes an (untyped) Expression, usually provided by the parser, and
     * returns a TypedExpression in which types have been added at each level.
     * @param {Expression} untypedExpression - the expression to be typed
     * @param {Array} possibleTopTypes - an array of types that the expression as
     *        a whole could have - each will be tried in turn.
     * @param {Language} language - the relevant language
     * @param {Array} newKindsPermitted - an array of kinds (e.g. 'variable',
     *        'constant') of which the user is allowed to create new operators.
     *        Any operator with a kind not in this list and that does not already
     *        occur in the language will cause an error.
     * @param {boolean} permitDuplicateDummyNames - if true the user can write
     *        e.g. x.p even if x is already in use; if false they cannot.
     * @return {array} An array of dictionaries of the form: {
     *           typedExpression: A TypedExpression
     *           operators: the given language.operatorss together with any new
     *             operators that occurred in the expression.
     * @throws If a valid typing cannot be found this function will throw a
     *         UserError. The parameters of this error will contain an additional
     *         key 'amountTyped' that determines where the error occurred. e.g.
     *         [1,2,0] would indicate that there was a problem at the 0th input
     *         (dummy or argument) of the 2nd input of the 1st input of this
     *         expression. We return the typing attempt for which this  value is
     *         largest (in lexicographic ordering) as this is likely to be closest
     *         to what the user intended.
     */
    var assignTypesToExpression = function (untypedExpression, possibleTopTypes, language, newKindsPermitted, permitDuplicateDummyNames) {
        if (newKindsPermitted === void 0) { newKindsPermitted = ['constant', 'variable']; }
        if (permitDuplicateDummyNames === void 0) { permitDuplicateDummyNames = false; }
        var operators = language.operators;
        var _attemptTyping = function (topType, typingRule) {
            if (!operatorIsNew &&
                untypedExpression.top_kind_name !==
                    operators[untypedExpression.top_operator_name].kind) {
                throw new UserError('wrong_kind', {
                    operator: untypedExpression.top_operator_name,
                    expected_kind: operators[untypedExpression.top_operator_name].kind,
                    actual_kind: untypedExpression.top_kind_name,
                    amount_typed: []
                });
            }
            if (topType !== typingRule.output) {
                throw new UserError('wrong_type', {
                    operator: untypedExpression.top_operator_name,
                    expected_type: topType,
                    actual_type: typingRule.output,
                    amount_typed: []
                });
            }
            var _isNumber = function (n) {
                return !isNaN(parseFloat(n)) && isFinite(n);
            };
            var _isString = function (s) {
                return s[0] === '\'' && s[s.length - 1] === '\'';
            };
            if (language.types.hasOwnProperty('integer') &&
                _isNumber(untypedExpression.top_operator_name) &&
                untypedExpression.top_kind_name === 'constant' &&
                topType !== 'integer') {
                throw new UserError('wrong_type', {
                    operator: untypedExpression.top_operator_name,
                    expected_type: topType,
                    actual_type: 'integer',
                    amount_typed: []
                });
            }
            if (language.types.hasOwnProperty('string') &&
                _isString(untypedExpression.top_operator_name) &&
                untypedExpression.top_kind_name === 'constant' &&
                topType !== 'string') {
                throw new UserError('wrong_type', {
                    operator: untypedExpression.top_operator_name,
                    expected_type: topType,
                    actual_type: 'string',
                    amount_typed: []
                });
            }
            try {
                var argumentTypes = instantiateTypingElementArray(typingRule.arguments, untypedExpression.arguments.length);
            }
            catch (err) {
                err.parameters.operator = untypedExpression.top_operator_name;
                err.parameters.input_category = 'arguments';
                err.parameters.amount_typed = [];
                throw err;
            }
            try {
                var dummyTypes = instantiateTypingElementArray(typingRule.dummies, untypedExpression.dummies.length);
            }
            catch (err) {
                err.parameters.operator = untypedExpression.top_operator_name;
                err.parameters.input_category = 'dummies';
                err.parameters.amount_typed = [];
                throw err;
            }
            var updatedOperators = {};
            for (var key in operators) {
                updatedOperators[key] = operators[key];
            }
            if (operatorIsNew) {
                var _decorateTypes = function (types) {
                    var decoratedTypes = [];
                    for (var k = 0; k < types.length; k++) {
                        decoratedTypes.push({
                            type: types[k],
                            arbitrarily_many: false
                        });
                    }
                    return decoratedTypes;
                };
                updatedOperators[untypedExpression.top_operator_name] = {
                    kind: untypedExpression.top_kind_name,
                    typing: [{
                            arguments: _decorateTypes(argumentTypes),
                            dummies: _decorateTypes(dummyTypes),
                            output: topType
                        }]
                };
            }
            for (var n = 0; n < untypedExpression.dummies.length; n++) {
                if (!permitDuplicateDummyNames &&
                    updatedOperators.hasOwnProperty(untypedExpression.dummies[n].top_operator_name)) {
                    throw new UserError('duplicate_dummy_name', {
                        dummy: untypedExpression.dummies[n],
                        expression: untypedExpression,
                        amount_typed: []
                    });
                }
                else if (untypedExpression.dummies[n].top_kind_name !== 'variable') {
                    // The parser does not currently permit this to happen
                    throw new UserError('dummy_not_variable', {
                        dummy: untypedExpression.dummies[n],
                        expression: untypedExpression,
                        amount_typed: []
                    });
                }
            }
            return assignTypesToExpressionArray(untypedExpression.dummies.concat(untypedExpression.arguments), dummyTypes.concat(argumentTypes), {
                operators: updatedOperators,
                kinds: language.kinds,
                types: language.types
            }, newKindsPermitted, permitDuplicateDummyNames, untypedExpression.dummies.length);
        };
        var operatorIsNew = false;
        if (!operators.hasOwnProperty(untypedExpression.top_operator_name)) {
            if (newKindsPermitted.indexOf(untypedExpression.top_kind_name) === -1) {
                throw new UserError('unknown_operator', {
                    operator: untypedExpression.top_operator_name,
                    amount_typed: []
                });
            }
            else {
                operatorIsNew = true;
            }
        }
        var typingRules = (operatorIsNew) ?
            language.kinds[untypedExpression.top_kind_name].typing :
            operators[untypedExpression.top_operator_name].typing;
        var results = [];
        for (var i = 0; i < possibleTopTypes.length; i++) {
            for (var j = 0; j < typingRules.length; j++) {
                try {
                    var newAttempts = _attemptTyping(possibleTopTypes[i], typingRules[j]);
                    for (var k = 0; k < newAttempts.length; k++) {
                        var typedDummies = [];
                        for (var l = 0; l < untypedExpression.dummies.length; l++) {
                            typedDummies.push(newAttempts[k].typedArray[l]);
                            // These dummy variables should not be available outside this
                            // part of the untypedExpression.
                            if (!operators.hasOwnProperty(untypedExpression.dummies[l].top_operator_name)) {
                                delete newAttempts[k].operators[untypedExpression.dummies[l].top_operator_name];
                            }
                        }
                        var typedArguments = [];
                        for (var m = untypedExpression.dummies.length; m < untypedExpression.dummies.length +
                            untypedExpression.arguments.length; m++) {
                            typedArguments.push(newAttempts[k].typedArray[m]);
                        }
                        results.push({
                            typedExpression: {
                                top_operator_name: untypedExpression.top_operator_name,
                                top_kind_name: untypedExpression.top_kind_name,
                                arguments: typedArguments,
                                dummies: typedDummies,
                                type: possibleTopTypes[i]
                            },
                            operators: newAttempts[k].operators
                        });
                    }
                }
                catch (err) {
                    if (bestAttemptSoFar !== undefined &&
                        !bestAttemptSoFar.hasOwnProperty('parameters')) {
                        throw bestAttemptSoFar;
                    }
                    if (bestAttemptSoFar === undefined ||
                        greaterThanInLex(err.parameters.amount_typed, bestAttemptSoFar.parameters.amount_typed)) {
                        var bestAttemptSoFar = err;
                    }
                }
            }
        }
        if (results.length > 0) {
            return results;
        }
        else {
            throw bestAttemptSoFar;
        }
    };
    /** Companion function to assignTypesToExpression, with the following
     * modifications:
     * @param untypedArray: an array of expressions to type
     *  @param topTypes: an array of types that the expressions in the array must
     *        have (only one option for each).
     * @numDummies: the number of elements in the array (from the start) that are
     *              dummies rather than arguments.
     * @result: {
     *            typedArray: an array of TypedExpressions
     *            operators: the updated list of operators
     *          }
     * @raises: as before
     */
    var assignTypesToExpressionArray = function (untypedArray, topTypes, language, newKindsPermitted, isTemplate, numDummies) {
        if (newKindsPermitted === void 0) { newKindsPermitted = ['constant', 'variable']; }
        if (isTemplate === void 0) { isTemplate = false; }
        if (numDummies === void 0) { numDummies = 0; }
        var partiallyTypedArrays = [[[]]];
        var partiallyUpdatedOperators = [[{}]];
        for (var key in language.operators) {
            partiallyUpdatedOperators[0][0][key] = language.operators[key];
        }
        for (var i = 1; i <= untypedArray.length; i++) {
            partiallyTypedArrays.push([]);
            partiallyUpdatedOperators.push([]);
        }
        for (var i = 0; i < untypedArray.length; i++) {
            // This will only happen in pathological cases.
            if (partiallyTypedArrays[i].length > MAX_NUM_TYPINGS_PERMITTED) {
                throw new UserError('too_many_typings', {});
            }
            for (var j = 0; j < partiallyTypedArrays[i].length; j++) {
                // Dummies are always allowed to have previously unseen names
                var newKindsPermittedHere = (i < numDummies) ?
                    newKindsPermitted.concat(['variable']) :
                    newKindsPermitted;
                try {
                    var newResults = assignTypesToExpression(untypedArray[i], [topTypes[i]], {
                        operators: partiallyUpdatedOperators[i][j],
                        kinds: language.kinds,
                        types: language.types
                    }, newKindsPermittedHere, isTemplate);
                    for (var k = 0; k < newResults.length; k++) {
                        partiallyTypedArrays[i + 1].push(partiallyTypedArrays[i][j].concat([
                            newResults[k].typedExpression
                        ]));
                        partiallyUpdatedOperators[i + 1].push(newResults[k].operators);
                    }
                }
                catch (err) {
                    if (!err.hasOwnProperty('parameters')) {
                        throw err;
                    }
                    var amountTyped = [i].concat(err.parameters.amount_typed);
                    if (bestAttemptSoFar === undefined ||
                        greaterThanInLex(amountTyped, bestAttemptSoFar.parameters.amount_typed)) {
                        err.parameters.amount_typed = amountTyped;
                        var bestAttemptSoFar = err;
                    }
                }
            }
        }
        var fullyTypedArrays = partiallyTypedArrays[untypedArray.length];
        var fullyUpdatedOperatorss = partiallyUpdatedOperators[untypedArray.length];
        if (fullyTypedArrays.length > 0) {
            var result = [];
            for (var i = 0; i < fullyTypedArrays.length; i++) {
                result.push({
                    typedArray: fullyTypedArrays[i],
                    operators: fullyUpdatedOperatorss[i]
                });
            }
            return result;
        }
        else {
            throw bestAttemptSoFar;
        }
    };
    // UTILITIES
    // Expressions with different dummy variables are considered different
    var checkExpressionsAreEqual = function (expression1, expression2) {
        if (expression1.top_kind_name !== expression2.top_kind_name ||
            expression1.top_operator_name !== expression2.top_operator_name ||
            expression1.arguments.length !== expression2.arguments.length ||
            expression1.dummies.length !== expression2.dummies.length) {
            return false;
        }
        if (expression1.hasOwnProperty('type')) {
            if (expression1.type !== expression2.type) {
                return false;
            }
        }
        for (var i = 0; i < expression1.arguments.length + expression1.dummies.length; i++) {
            if (!checkExpressionsAreEqual((expression1.arguments.concat(expression1.dummies))[i], (expression2.arguments.concat(expression2.dummies))[i])) {
                return false;
            }
        }
        return true;
    };
    var checkExpressionIsInSet = function (expression, set) {
        for (var i = 0; i < set.length; i++) {
            if (checkExpressionsAreEqual(expression, set[i])) {
                return true;
            }
        }
        return false;
    };
    var checkSetsOfExpressionsAreEqual = function (set1, set2) {
        for (var i = 0; i < set1.length; i++) {
            if (!checkExpressionIsInSet(set1[i], set2)) {
                return false;
            }
        }
        for (var i = 0; i < set2.length; i++) {
            if (!checkExpressionIsInSet(set2[i], set1)) {
                return false;
            }
        }
        return true;
    };
    // Returns a list of all the names of operators in an expression. kinds is an
    // array specifying which kinds of operators to return; if it is not supplied
    // then all are returned
    var getOperatorsFromExpression = function (expression, kinds) {
        if (kinds === void 0) { kinds = null; }
        var output = getOperatorsFromExpressionArray(expression.arguments.concat(expression.dummies), kinds);
        return (output.indexOf(expression.top_operator_name) === -1 &&
            (kinds === null || kinds.indexOf(expression.top_kind_name) !== -1)) ?
            output.concat([expression.top_operator_name]) :
            output;
    };
    var getOperatorsFromExpressionArray = function (array, kinds) {
        if (kinds === void 0) { kinds = null; }
        var output = [];
        for (var i = 0; i < array.length; i++) {
            var newOutput = getOperatorsFromExpression(array[i], kinds);
            for (var j = 0; j < newOutput.length; j++) {
                if (output.indexOf(newOutput[j]) === -1) {
                    output = output.concat([newOutput[j]]);
                }
            }
        }
        return output;
    };
    // The expression should be typed; returns the type of operator (or throws an
    // error if not found). Does not check for inconsistent typing.
    // NOTE: treats dummy variables like free ones.
    var seekTypeInExpression = function (expression, operator) {
        return operator === expression.top_operator_name ? expression.type :
            seekTypeInExpressionArray(expression.arguments.concat(expression.dummies), operator);
    };
    var seekTypeInExpressionArray = function (array, operator) {
        for (var i = 0; i < array.length; i++) {
            try {
                return seekTypeInExpression(array[i], operator);
            }
            catch (err) { }
        }
        throw UserError('unknown_typing_error', {
            array: array
        });
    };
    // Returns whether LHS is larger than RHS in lexicographic ordering
    var greaterThanInLex = function (LHS, RHS) {
        for (var i = 0; i < LHS.length; i++) {
            if (i >= RHS.length) {
                return true;
            }
            else if (LHS[i] > RHS[i]) {
                return true;
            }
            else if (LHS[i] < RHS[i]) {
                return false;
            }
        }
        return false;
    };
    // Checks if the string contains the character
    var containsCharacter = function (string, character) {
        return (string.indexOf(character) !== -1);
    };
    // Checks if the string contains some character from the array
    var containsCharacterFromArray = function (string, array) {
        for (var i = 0; i < array.length; i++) {
            if (string.indexOf(array[i]) !== -1) {
                return true;
            }
        }
        return false;
    };
    return {
        UserError: UserError,
        PreRenderedUserError: PreRenderedUserError,
        renderError: renderError,
        displayExpression: displayExpression,
        displayExpressionArray: displayExpressionArray,
        preParseLineString: preParseLineString,
        parseLineString: parseLineString,
        instantiateTypingElementArray: instantiateTypingElementArray,
        assignTypesToExpression: assignTypesToExpression,
        assignTypesToExpressionArray: assignTypesToExpressionArray,
        checkExpressionsAreEqual: checkExpressionsAreEqual,
        checkExpressionIsInSet: checkExpressionIsInSet,
        checkSetsOfExpressionsAreEqual: checkSetsOfExpressionsAreEqual,
        getOperatorsFromExpression: getOperatorsFromExpression,
        getOperatorsFromExpressionArray: getOperatorsFromExpressionArray,
        seekTypeInExpression: seekTypeInExpression,
        greaterThanInLex: greaterThanInLex
    };
})();
exports.default = logicProofShared;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/student.ts":
/*!*****************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/student.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Components used by the LogicProof interaction reader.
 */
var shared_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/shared.ts */ "./extensions/interactions/LogicProof/static/js/shared.ts"));
var data_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/data.ts */ "./extensions/interactions/LogicProof/static/js/data.ts"));
var logicProofStudent = (function () {
    // BUILD INSTANCE
    // These evaluation rules must all return an object of their specified output
    // type (boolean, integer, string, formula or set_of_formulas) or throw an
    // error with message 'evaluation failed'. They will be used by evaluate()
    // when computing the value of an expression that contains these operators.
    // Evaluation strictness: if an error occurs at any point in a computation
    // then the entire computation will return an error; so for example
    // true||error evaluates as error rather than true. The exceptions to this
    // are bounded quantification and ranged functions; for these we will
    // evaluate until we reach an answer and then return without computing any
    // later values. So for example min{x<n|A(x)} where ~A(1)=false, A(2)=true
    // and A(3)=error will return true rather than error. The default control
    // functions rely heavily on this functionality and will need to be rewritten
    // if it is changed.
    var BASE_CONTROL_MODEL = {
        evaluation_rules: {
            and: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    for (var i = 0; i < args.length; i++) {
                        if (!args[i]) {
                            return false;
                        }
                    }
                    return true;
                }
            },
            or: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    for (var i = 0; i < args.length; i++) {
                        if (args[i]) {
                            return true;
                        }
                    }
                    return false;
                }
            },
            not: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return !args[0];
                }
            },
            implies: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return !args[0] || args[1];
                }
            },
            iff: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return (args[0] && args[1]) || (!args[0] && !args[1]);
                }
            },
            equals: {
                format: 'bottom_up',
                evaluateExpression: function (args, types) {
                    return (types[0] === 'formula') ?
                        shared_ts_1.default.checkExpressionsAreEqual(args[0], args[1]) :
                        (args[0].type === 'set_of_formulas') ?
                            shared_ts_1.default.checkSetsOfExpressionsAreEqual(args[0], args[1]) :
                            (args[0] === args[1]);
                }
            },
            not_equals: {
                format: 'bottom_up',
                evaluateExpression: function (args, types) {
                    return (types[0] === 'formula') ?
                        !shared_ts_1.default.checkExpressionsAreEqual(args[0], args[1]) :
                        (args[0].type === 'set_of_formulas') ?
                            !shared_ts_1.default.checkSetsOfExpressionsAreEqual(args[0], args[1]) :
                            (args[0] !== args[1]);
                }
            },
            less_than: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return (args[0] < args[1]);
                }
            },
            less_than_or_equals: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return (args[0] <= args[1]);
                }
            },
            greater_than: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return (args[0] > args[1]);
                }
            },
            greater_than_or_equals: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return (args[0] >= args[1]);
                }
            },
            is_in: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return shared_ts_1.default.checkExpressionIsInSet(args[0], args[1]);
                }
            },
            addition: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] + args[1];
                }
            },
            subtraction: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] - args[1];
                }
            },
            multiplication: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] * args[1];
                }
            },
            division: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] / args[1];
                }
            },
            exponentiation: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] ^ args[1];
                }
            },
            bounded_for_all: {
                format: 'top_down',
                evaluateExpression: function (expression, inputs, model, evaluationParameters, cache) {
                    var newInputs = {};
                    for (var key in inputs) {
                        newInputs[key] = inputs[key];
                    }
                    var bounder = evaluate(expression.arguments[0].arguments[1], inputs, model, evaluationParameters, cache);
                    if (expression.arguments[0].arguments[0].type === 'integer') {
                        var rangeEnd = (expression.arguments[0].top_operator_name === 'less_than') ?
                            bounder :
                            bounder + 1;
                        for (var i = 1; i < rangeEnd; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = i;
                            if (!evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    else {
                        // Here, the bounder is a set_of_formulas (so an array).
                        for (var i = 0; i < bounder.length; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = bounder[i];
                            if (!evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            },
            bounded_exists: {
                format: 'top_down',
                evaluateExpression: function (expression, inputs, model, evaluationParameters, cache) {
                    var newInputs = {};
                    for (var key in inputs) {
                        newInputs[key] = inputs[key];
                    }
                    var bounder = evaluate(expression.arguments[0].arguments[1], inputs, model, evaluationParameters, cache);
                    if (expression.arguments[0].arguments[0].type === 'integer') {
                        var rangeEnd = (expression.arguments[0].top_operator_name === 'less_than') ?
                            bounder :
                            bounder + 1;
                        for (var i = 1; i < rangeEnd; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = i;
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    else {
                        // Here, the bounder is a set_of_formulas (so an array).
                        for (var i = 0; i < bounder.length; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = bounder[i];
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }
            },
            // Note that min{k<n|A(k)} will range over [1,..,n-1], throwing an error
            // if no match is found.
            // min{pantecedents(n)|A(p)} will range over antecedents(n), throwing
            // an error if no match is found.
            min: {
                format: 'top_down',
                evaluateExpression: function (expression, inputs, model, evaluationParameters, cache) {
                    var newInputs = {};
                    for (var key in inputs) {
                        newInputs[key] = inputs[key];
                    }
                    var bounder = evaluate(expression.arguments[0].arguments[1], inputs, model, evaluationParameters, cache);
                    if (expression.arguments[0].arguments[0].type === 'integer') {
                        var rangeEnd = (expression.arguments[0].top_operator_name === 'less_than') ?
                            bounder :
                            bounder + 1;
                        for (var i = 1; i < rangeEnd; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = i;
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return i;
                            }
                        }
                        throw new Error('evaluation failed');
                    }
                    else {
                        for (var i = 0; i < bounder.length; i++) {
                            newInputs[expression.dummies[0].top_operator_name] = bounder[i];
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return bounder[i];
                            }
                        }
                        throw new Error('evaluation failed');
                    }
                }
            },
            max: {
                format: 'top_down',
                evaluateExpression: function (expression, inputs, model, evaluationParameters, cache) {
                    var newInputs = {};
                    for (var key in inputs) {
                        newInputs[key] = inputs[key];
                    }
                    var bounder = evaluate(expression.arguments[0].arguments[1], inputs, model, evaluationParameters, cache);
                    if (expression.arguments[0].arguments[0].type === 'integer') {
                        var rangeEnd = (expression.arguments[0].top_operator_name === 'less_than') ?
                            bounder :
                            bounder + 1;
                        for (var i = rangeEnd - 1; i > 0; i--) {
                            newInputs[expression.dummies[0].top_operator_name] = i;
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return i;
                            }
                        }
                        throw new Error('evaluation failed');
                    }
                    else {
                        for (var i = bounder.length - 1; i >= 0; i--) {
                            newInputs[expression.dummies[0].top_operator_name] = bounder[i];
                            if (evaluate(expression.arguments[1], newInputs, model, evaluationParameters, cache)) {
                                return bounder[i];
                            }
                        }
                        throw new Error('evaluation failed');
                    }
                }
            },
            // We subtract one for these because for the user proof lines are indexed
            // from 1.
            indentation: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return line.indentation;
                }
            },
            template: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return '\'' + line.template_name + '\'';
                }
            },
            antecedents: {
                // NOTE: assumes antecedents are given as formulas, not integers
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    var result = [];
                    for (var i = 0; i < line.antecedents.length; i++) {
                        result.push(line.antecedents[i].content);
                    }
                    return result;
                }
            },
            results: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return line.results;
                }
            },
            variables: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return line.variables;
                }
            },
            text: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var line = evaluationParameters.proof.lines[args[0] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return line.text;
                }
            },
            element: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    // The name of the element is provided as a string such as \'R\', so
                    // we must strip the quotes.
                    var element = args[0].substr(1, args[0].length - 2);
                    var line = evaluationParameters.proof.lines[args[1] - 1];
                    if (line === undefined) {
                        throw new Error('evaluation failed');
                    }
                    var result = line.matchings[element];
                    if (result === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return result;
                }
            },
            num_lines: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    return evaluationParameters.proof.lines.length;
                }
            },
            assumptions: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    return evaluationParameters.assumptions;
                }
            },
            target: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    return evaluationParameters.target;
                }
            },
            question_variables: {
                format: 'bottom_up',
                evaluateExpression: function (args, types, evaluationParameters) {
                    var names = shared_ts_1.default.getOperatorsFromExpressionArray(evaluationParameters.assumptions.concat([evaluationParameters.target]), ['variable']);
                    // This gives us the variables as strings, we convert them to
                    // expressions.
                    var result = [];
                    for (var i = 0; i < names.length; i++) {
                        result.push({
                            top_kind_name: 'variable',
                            top_operator_name: names[i],
                            args: [],
                            dummies: []
                        });
                    }
                    return result;
                }
            },
            entry: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    var result = args[1][args[0] - 1];
                    if (result === undefined) {
                        throw new Error('evaluation failed');
                    }
                    return result;
                }
            },
            // eslint-disable-next-line quote-props
            'if': {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    return args[0] ? args[1] : args[2];
                }
            },
            substitute: {
                format: 'bottom_up',
                evaluateExpression: function (args) {
                    var substitutions = {};
                    substitutions[args[1].top_operator_name] = args[2];
                    return substituteIntoExpression(args[0], substitutions);
                }
            }
        }
    };
    /**
     * This function is run when the state is loaded, it is top-level.
     * @param {Object} questionData - The information from the teacher specifying
     *        the question - this will be one of the keys of the interaction's
     *        customization_args.
     * @return {Object} A QuestionInstance object that will be used to build and
     *        check proofs from the student.
     */
    var buildInstance = function (questionData) {
        var evaluationRules = angular.copy(BASE_CONTROL_MODEL.evaluation_rules);
        var controlOperators = angular.copy(data_ts_1.default.BASE_CONTROL_LANGUAGE.operators);
        // NOTE: the javascript fails if we try to omit this function and define
        // evaluateExpression() directly inside the for loop. See
        // http://jslinterrors.com/dont-make-functions-within-a-loop
        var makeEvaluateExpression = function (definition, variables) {
            return function (expression, inputs, model, evaluationParameters, cache) {
                var argumentValues = {};
                for (var i = 0; i < variables.length; i++) {
                    argumentValues[variables[i].top_operator_name] = evaluate(expression.arguments[i], inputs, model, evaluationParameters, cache);
                }
                return evaluate(definition, argumentValues, model, evaluationParameters, cache);
            };
        };
        for (var i = 0; i < questionData.control_functions.length; i++) {
            evaluationRules[questionData.control_functions[i].name] = {
                format: 'definition',
                evaluateExpression: makeEvaluateExpression(questionData.control_functions[i].definition, questionData.control_functions[i].variables)
            };
            controlOperators[questionData.control_functions[i].name] = {
                kind: 'prefix_function',
                typing: questionData.control_functions[i].typing
            };
        }
        return {
            assumptions: questionData.assumptions,
            results: questionData.results,
            language: {
                types: data_ts_1.default.BASE_STUDENT_LANGUAGE.types,
                kinds: data_ts_1.default.BASE_STUDENT_LANGUAGE.kinds,
                operators: questionData.language.operators
            },
            line_templates: questionData.line_templates,
            vocabulary: questionData.vocabulary,
            general_messages: questionData.general_messages,
            mistake_table: questionData.mistake_table,
            control_language: {
                types: data_ts_1.default.BASE_CONTROL_LANGUAGE.types,
                kinds: data_ts_1.default.BASE_CONTROL_LANGUAGE.kinds,
                operators: controlOperators
            },
            control_model: {
                evaluation_rules: evaluationRules
            }
        };
    };
    // BUILD PROOF
    /**
     * This function identifies a way in which the expression is an instance of
     * template, or throws an error if it is not. Examples:
     * - A(x)t, pq, {} will return {p: A(x), q:t}
     * - A(x)t, pq, {q: s} will throw an error
     * - y.R(y), x.p, {} will return {x:y, p: R(y)} as dummies also matched
     * Only variables in the template can be matched to arbitrary expressions in
     * the expression; e.g. rs is not an instance of pq because  is not a
     * variable and so needs to be matched exactly.
     * @param {Expression} expression - an Expression, which is to be matched
     * @param {Expression} template - the Expression against which we will match
     * @param {object} oldMatchings - variables potentially in the template whose
     *        corresponding sub-expressions in the expression we have previously
     *        identified.
     * @return {Object} a dictionary extending oldElements, that for new
     *   operators in template gives the corresponding operator in expression.
     * @throws If the expression cannot be viewed as an instance of the template.
     */
    var matchExpression = function (expression, template, oldMatchings) {
        var matchings = {};
        for (var key in oldMatchings) {
            matchings[key] = oldMatchings[key];
        }
        if (template.top_kind_name === 'variable') {
            if (oldMatchings.hasOwnProperty(template.top_operator_name)) {
                if (shared_ts_1.default.checkExpressionsAreEqual(expression, oldMatchings[template.top_operator_name])) {
                    return matchings;
                }
                else {
                    throw new shared_ts_1.default.UserError('unmatched_line', {});
                }
            }
            else {
                matchings[template.top_operator_name] = expression;
                return matchings;
            }
        }
        else if (expression.top_operator_name !== template.top_operator_name ||
            expression.top_kind_name !== template.top_kind_name ||
            expression.arguments.length !== template.arguments.length ||
            expression.dummies.length !== template.dummies.length) {
            throw new shared_ts_1.default.UserError('unmatched_line', {});
        }
        else {
            // For matching purposes arguments and dummies are equivalent
            var subExpressions = expression.arguments.concat(expression.dummies);
            var subTemplates = template.arguments.concat(template.dummies);
            return matchExpressionArray(subExpressions, subTemplates, matchings);
        }
    };
    // Companion of matchExpression.
    var matchExpressionArray = function (array, templateArray, matchings) {
        for (var i = 0; i < array.length; i++) {
            matchings = matchExpression(array[i], templateArray[i], matchings);
        }
        return matchings;
    };
    /**
     * @param {Expression} expression - an Expression into which we are
     *   substituting, e.g. x=y
     * @param {Object} substitutions - a dictionary of {string: Expression}
     *   specifying the substitions to perform (simultaneously), e.g
     *   {x:2, y:a+b}
     * @return {Expression} the substituted Expression, e.g. 2=a+b
     */
    var substituteIntoExpression = function (expression, substitutions) {
        // We ignore substitutions for dummy variables.
        var newSubstitutions = {};
        for (var key in substitutions) {
            var isDummy = false;
            for (var i = 0; i < expression.dummies.length; i++) {
                if (expression.dummies[i].top_operator_name === key) {
                    isDummy = true;
                }
            }
            if (!isDummy) {
                newSubstitutions[key] = substitutions[key];
            }
        }
        if (substitutions.hasOwnProperty(expression.top_operator_name)) {
            return substitutions[expression.top_operator_name];
        }
        else {
            return {
                top_operator_name: expression.top_operator_name,
                top_kind_name: expression.top_kind_name,
                arguments: substituteIntoExpressionArray(expression.arguments, newSubstitutions),
                dummies: substituteIntoExpressionArray(expression.dummies, newSubstitutions)
            };
        }
    };
    // Companion to substituteIntoExpression.
    var substituteIntoExpressionArray = function (array, substitutions) {
        var output = [];
        for (var i = 0; i < array.length; i++) {
            output.push(substituteIntoExpression(array[i], substitutions));
        }
        return output;
    };
    // Replaces all operators from expression (including dummies) that appear in
    // the dictionary 'matchings' with their values in matchings.
    var instantiateExpression = function (expression, matchings) {
        if (matchings.hasOwnProperty(expression.top_operator_name)) {
            return matchings[expression.top_operator_name];
        }
        else {
            var output = {
                top_operator_name: expression.top_operator_name,
                top_kind_name: expression.top_kind_name,
                arguments: instantiateExpressionArray(expression.arguments, matchings),
                dummies: instantiateExpressionArray(expression.dummies, matchings)
            };
            return output;
        }
    };
    var instantiateExpressionArray = function (array, matchings) {
        var output = [];
        for (var i = 0; i < array.length; i++) {
            output.push(instantiateExpression(array[i], matchings));
        }
        return output;
    };
    /**
     * @param {ExpressionTemplate} template - an ExpressionTemplate
     * @param {Object} matchings - a dictionary of {string: Expression}
     * @return {Expression}
     */
    var computeExpressionFromTemplate = function (template, matchings) {
        // E.g. template represents p[x -> a] and matchings represents
        // {p: A(y), x: y, a: 2}
        var newExpression = instantiateExpression(template.expression, matchings);
        var newSubstitutions = [];
        for (var i = 0; i < template.substitutions.length; i++) {
            var substitution = {};
            for (var key in template.substitutions[i]) {
                substitution[matchings[key].top_operator_name] = instantiateExpression(template.substitutions[i][key], matchings);
            }
            newSubstitutions.push(substitution);
        }
        // E.g. now new_expression is A(y) and new_subsitutions represents [y -> 2]
        for (var i = 0; i < newSubstitutions.length; i++) {
            newExpression = substituteIntoExpression(newExpression, newSubstitutions[i]);
        }
        return newExpression;
        // E.g. result is A(2)
    };
    var computeExpressionsFromTemplateArray = function (templateArray, matchings) {
        var output = [];
        for (var i = 0; i < templateArray.length; i++) {
            output.push(computeExpressionFromTemplate(templateArray[i], matchings));
        }
        return output;
    };
    /**
     * @param {Array.<LineMessages>} messages - an array of LineMessages, each of
     *        which describes the mistake the student has made by writing this
     *        sort of line.
     * @param {string} templateName - the name of the LineTemplate from which the
     *        messages come.
     * @param {object} matchings - a {string: Expression} dictionary deduced from
     *        comparing the line the student actually wrote to the LineTemplate
     *        provided by the techer of which it is an instance.
     * @param {object} operators - from the student Language and used for display
     *        purposes.
     * @throws This function throws a logicProofShared.UserError (with the
     *         'pre-rendered' code) that contains an array of strings describing
     *         the error, one of which will be chosen later to show to the
     *         student. If the messages list is empty (signifying that the line
     *         in question is a correct one) we do nothing.
     */
    var throwLineMessages = function (messages, templateName, matchings, operators) {
        if (messages.length > 0) {
            var renderedMessages = [];
            for (var i = 0; i < messages.length; i++) {
                renderedMessages.push('');
                for (var j = 0; j < messages[i].length; j++) {
                    if (messages[i][j].format === 'string') {
                        renderedMessages[i] += messages[i][j].content;
                    }
                    else {
                        renderedMessages[i] += shared_ts_1.default.displayExpression(computeExpressionFromTemplate(messages[i][j].content, matchings), operators);
                    }
                }
            }
            throw new shared_ts_1.default.PreRenderedUserError(renderedMessages, templateName);
        }
    };
    /**
     * Checks whether protoLine is an instance of template, in terms of both
     * expressions and phrases.
     * @param {array} protoLine - a ProtoLine, that is an array of phrases
     *        and expressions
     * @param {array} template - the value corresponding to the reader_view key
     *        of a LineTemplate, so an array of phrases and ExpressionTemplates.
     * @return {object} a dictionary of the form {string: Expression} that
     *        specifies what each variable / atom in the template corresponds to
     *        in the protoLine.
     * @throws If the line is not an instance of the template.
     */
    var matchLineToTemplate = function (protoLine, template) {
        // These witness that the protoLine is an instance of the template. For
        // example if the protoLine is 'we know AB' and the template is 'we know
        // p' then matchings would end up as {p: AB}.
        var matchings = {};
        // Check unsubstituted expressions agree
        if (protoLine.length !== template.length) {
            throw new shared_ts_1.default.UserError('unmatched_line', {});
        }
        for (var i = 0; i < protoLine.length; i++) {
            if (protoLine[i].format !== template[i].format) {
                throw new shared_ts_1.default.UserError('unmatched_line', {});
            }
            if (protoLine[i].format === 'expression') {
                // Only unsubstituted expression templates are useful in establishing
                // the matchings. e.g. if we are told simple the expression
                // corresponding to p[x->a] it will not be possible to discern p, x or
                // a, because there are many possible subsitutions that could have
                // produced the expression we see.
                if (template[i].content.substitutions.length === 0) {
                    matchings = matchExpression(protoLine[i].content, template[i].content.expression, matchings);
                }
            }
        }
        // Now, check the substituted expression templates agree.
        for (var i = 0; i < protoLine.length; i++) {
            if (protoLine[i].format === 'expression' &&
                template[i].content.substitutions.length > 0) {
                var expression = computeExpressionFromTemplate(template[i].content, matchings);
                if (!shared_ts_1.default.checkExpressionsAreEqual(protoLine[i].content, expression)) {
                    throw new shared_ts_1.default.UserError('unmatched_line', {});
                }
            }
        }
        // Finally check phrases agree.
        for (var i = 0; i < protoLine.length; i++) {
            if (protoLine[i].format === 'phrase' &&
                protoLine[i].content !== template[i].content) {
                throw new shared_ts_1.default.UserError('unmatched_line', {});
            }
        }
        return matchings;
    };
    /**
     * This is used by buildLine. It checks that the types of the line are
     * correct and at the top agree with those the template requires, and
     * likewise for the kinds of the line (if the template has an opinion).
     * @param {object} matchings - a dictionary of {string: Expression} that
     *        allows the line the student wrote to be deduced from the
     *        reader_view key of the LineTemplate in question.
     * @param {array} templateReaderView - the value of the reader_view key of a
     *        LineTemplate, so an array of phrases and ExpressionTemplates.
     * @param {object} language - a Language object giving the student language
     * @throws A typing error if the types are invalid.
     */
    var requireValidMatching = function (matchings, templateReaderView, language) {
        var expressionsToCheck = [];
        var typesRequired = [];
        for (var i = 0; i < templateReaderView.length; i++) {
            if (templateReaderView[i].format === 'expression') {
                var expression = computeExpressionFromTemplate(templateReaderView[i].content, matchings);
                if (templateReaderView[i].content.hasOwnProperty('kind') &&
                    templateReaderView[i].content.kind !== expression.top_kind_name) {
                    throw new shared_ts_1.default.UserError('wrong_kind_in_line', {
                        expression: expression,
                        expected_kind: templateReaderView[i].content.kind
                    });
                }
                expressionsToCheck.push(expression);
                typesRequired.push(templateReaderView[i].content.type);
            }
        }
        shared_ts_1.default.assignTypesToExpressionArray(expressionsToCheck, typesRequired, language, ['variable', 'constant']);
    };
    /**
     * This function is run on each line as the student types it, to make sure the
     * line is of a known type. It does not check for more sophisticated errors.
     * @param {string} lineString - one of the lines written by the student
     * @param {Array.<LineTemplate>} lineTemplates - as for buildLine()
     * @param {Language} language - as for buildLine()
     * @param {object} vocabulary - as for buildLine()
     * @param {object} generalMessages - a dictionary of GeneralMessages, used to
     *         render errors into human-readable messages.
     * @throws If the line cannot be identified, {
     *           message: a string describing the problem
     *         }
     */
    var requireIdentifiableLine = function (lineString, lineTemplates, language, vocabulary, generalMessages) {
        try {
            var protoLines = shared_ts_1.default.parseLineString(lineString.trim(), language.operators, vocabulary, false);
        }
        catch (err) {
            throw {
                message: shared_ts_1.default.renderError(err, generalMessages, language)
            };
        }
        var lineIdentified = false;
        for (var i = 0; i < protoLines.length; i++) {
            for (var j = 0; j < lineTemplates.length; j++) {
                try {
                    matchLineToTemplate(protoLines[i], lineTemplates[j].reader_view);
                    lineIdentified = true;
                }
                catch (err) {
                    if (errorMessage === undefined) {
                        var errorMessage = shared_ts_1.default.renderError(err, generalMessages, language);
                    }
                }
            }
        }
        if (!lineIdentified) {
            throw {
                message: errorMessage
            };
        }
    };
    /**
     * This is a top-level function that checks all lines of a proof match some
     * line template (or are blank), but nothing else. It is run as the student
     * types.
     * @param {string} proofString - the proof as written by the student
     * @param {object} questionInstance - the object representing the problem,
     *        which was constructed from the QuestionData by buildInstance().
     * @throws (if there is an unmatchable line) a dictionary {
     *           message: a message describing something that went wrong,
     *           line: the line in which the problem occurred (zero-indexed),
     *          }
     */
    var validateProof = function (proofString, questionInstance) {
        if (proofString.slice(-1) === '\n') {
            proofString = proofString.slice(0, proofString.length - 1);
        }
        var lineStrings = proofString.split('\n');
        for (var i = 0; i < lineStrings.length; i++) {
            if (lineStrings[i].split(' ').join('').length !== 0) {
                try {
                    requireIdentifiableLine(lineStrings[i], questionInstance.line_templates, questionInstance.language, questionInstance.vocabulary, questionInstance.general_messages);
                }
                catch (err) {
                    throw {
                        message: err.message,
                        line: i
                    };
                }
            }
        }
    };
    /**
     * @param {string} lineString - a line of text written by the student
     * @param {Array.<LineTemplate>} lineTemplates - an array of LineTemplates
     *        written by the teacher, that describe the sorts of lines a student
     *        might write; we try to find one of which the given line is an
     *        instance.
     * @param {Language} language - the student language (a Language object)
     * @param {object} vocabulary - the phrases available for the student to use.
     *        It is a dictionary with entries like
     *            satisfying: ['satisfying', 'such that']
     *        which indicates that the student can convey the concept of
     *        'satisfying' by writing either 'satisfying' or 'such that'.
     * @return {object} a Line object that is an abstract representation of the
     *          student's lineString, constructed from this string and one of the
     *          lineTemplates.
     * @throws an error representing the closest we got to understanding the line,
     *         generally 'unmatched line', a complaint about typing, or a
     *         LineMessage from the teacher if this is identified as an instance
     *         of an invalid deduction.
     */
    var buildLine = function (lineString, lineTemplates, language, vocabulary) {
        // Get list of possible parsings of line (usually there is only one)
        var n = 0;
        while (lineString[n] === ' ') {
            n++;
        }
        if (n % 2 !== 0) {
            throw new shared_ts_1.default.UserError('odd_number_spaces', {});
        }
        var indentation = n / 2;
        var protoLines = shared_ts_1.default.parseLineString(lineString.slice(n, lineString.length), language.operators, vocabulary, false);
        // At this stage we wish to return the 'best' matching with the following
        // priority list:
        // 1. A correctly typed matching to a 'correct' line template - i.e. one
        //    for a logically correct derivation. If we find one we return it
        //    immediately
        // 2. A correctly typed matching to an incorrect line template
        // 3. An incorrectly typed matching to a line template
        // Returns true iff error1 is a better attempt than error2
        var _isBetterAttempt = function (error1, error2) {
            return error2 === undefined ||
                (error1.code === 'pre-rendered' && error2.code !== 'pre-rendered') ||
                (error1.code !== 'unmatched_line' && error2.code === 'unmatched_line');
        };
        for (var i = 0; i < protoLines.length; i++) {
            for (var j = 0; j < lineTemplates.length; j++) {
                try {
                    var matchings = matchLineToTemplate(protoLines[i], lineTemplates[j].reader_view);
                    requireValidMatching(matchings, lineTemplates[j].reader_view, language);
                    throwLineMessages(lineTemplates[j].error, lineTemplates[j].name, matchings, language.operators);
                    var antecedents = [];
                    for (var k = 0; k < lineTemplates[j].antecedents.length; k++) {
                        antecedents.push({
                            format: 'expression',
                            content: computeExpressionFromTemplate(lineTemplates[j].antecedents[k], matchings)
                        });
                    }
                    return {
                        template_name: lineTemplates[j].name,
                        matchings: matchings,
                        antecedents: antecedents,
                        results: computeExpressionsFromTemplateArray(lineTemplates[j].results, matchings),
                        variables: instantiateExpressionArray(lineTemplates[j].variables, matchings),
                        indentation: indentation,
                        text: lineString
                    };
                }
                catch (err) {
                    if (_isBetterAttempt(err, bestAttemptSoFar)) {
                        var bestAttemptSoFar = err;
                    }
                }
            }
        }
        throw bestAttemptSoFar;
    };
    /**
     * This is one of the two main top-level student functions (with checkProof).
     * @param {string} proofString - the proof as written by the student
     * @param {object} questionInstance - the object representing the problem,
     *        which was constructed from the QuestionData by buildInstance().
     * @return {Proof} a Proof object built from the given proofString
     * @throws a dictionary {
     *           message: a message describing something that went wrong,
     *           line: the line in which the problem occurred (zero-indexed),
     *           code: the code of the error that occurred,
     *           category: either 'line', 'parsing' or 'typing'
     *          }
     */
    var buildProof = function (proofString, questionInstance) {
        var lineStrings = proofString.split('\n');
        // Ignore blank lines at the end
        var lastLineNum = lineStrings.length - 1;
        while (lastLineNum > 0 &&
            lineStrings[lastLineNum].replace(/ /g, '').length === 0) {
            lastLineNum--;
        }
        var builtLines = [];
        for (var i = 0; i <= lastLineNum; i++) {
            try {
                builtLines.push(buildLine(lineStrings[i], questionInstance.line_templates, questionInstance.language, questionInstance.vocabulary));
            }
            catch (err) {
                throw {
                    message: shared_ts_1.default.renderError(err, questionInstance.general_messages, questionInstance.language),
                    line: i,
                    code: err.code,
                    category: (err.name === 'PreRenderedUserError') ?
                        'line' :
                        questionInstance.general_messages[err.code].category
                };
            }
        }
        return {
            lines: builtLines
        };
    };
    // CHECK PROOF
    /**
     * This function is a core component of the program - it takes an expression
     * and returns its value (with respect to given inputs, model and parameters).
     * @param {TypedExpression} expression - the TypedExpression (in the control
     *        language) to be evaluated, e.g. n+2
     * @param {object} inputs - a dictionary with keys the free variables in the
     *        expression, giving for each the value they should be taken to have,
     *        e.g. {n:3}
     * @param {Model} model - a Model object that specifies how to evaluate
     *        functions, e.g., that '+' should be interpreted as the usual
     *        addition.
     * @param {object} evaluationRuleParameters - these are sent to all of the
     *        EvaluationRules occurring in the model, for them to make use of if
     *        they wish. e.g. here they would include the student's proof, and
     *        the function 'num_lines' would evaluate by examining this proof.
     * @param {object} cache - expressions, at particular inputs, that were
     *        already evaluated.
     * @return {*} the result of the expression with these inputs, e.g. 5
     * @throws an error if any part of the evaluation failed, for example by
     *         trying to access an element of an array beyond the array's length.
     */
    var evaluate = function (expression, inputs, model, evaluationRuleParameters, cache) {
        var cacheKey = JSON.stringify(expression) + '#' + JSON.stringify(inputs);
        if (cache.hasOwnProperty(cacheKey) && false) {
            return cache[cacheKey];
        }
        if (expression.top_kind_name === 'variable') {
            var answer = inputs[expression.top_operator_name];
        }
        else if (expression.top_kind_name === 'constant') {
            var answer = expression.top_operator_name;
        }
        else {
            var evaluationRule = model.evaluation_rules[expression.top_operator_name];
            if (evaluationRule.format === 'top_down') {
                var answer = evaluationRule.evaluateExpression(expression, inputs, model, evaluationRuleParameters, cache);
            }
            else if (evaluationRule.format === 'definition') {
                // Evaluate arguments (spec requires that the expression has no
                // dummies).
                if (expression.dummies.length > 0) {
                    throw new Error('evaluate() received ' +
                        expression.top_operator_name +
                        ' to be evaluated via a definition but it has dummies');
                }
                var answer = evaluationRule.evaluateExpression(expression, inputs, model, evaluationRuleParameters, cache);
            }
            else if (evaluationRule.format === 'bottom_up') {
                // Evaluate arguments (spec requires that there are no dummies).
                if (expression.dummies.length > 0) {
                    throw new Error('evaluate() received ' +
                        expression.top_operator_name +
                        ' to be evaluated bottom-up but it has dummies');
                }
                var argumentsList = [];
                for (var i = 0; i < expression.arguments.length; i++) {
                    argumentsList.push(evaluate(expression.arguments[i], inputs, model, evaluationRuleParameters, cache));
                }
                var types = [];
                for (var i = 0; i < expression.arguments.length; i++) {
                    types.push(expression.arguments[i].type);
                }
                var answer = evaluationRule.evaluateExpression(argumentsList, types, evaluationRuleParameters);
            }
            else {
                throw Error('Unknown evaluation rule format (' +
                    evaluationRule.format + ') sent to evaluate().');
            }
        }
        cache[cacheKey] = answer;
        return answer;
    };
    /**
     * @param {MistakeEntry} mistake - a MistakeEntry that describes when a
     *        mistake occurs, and if so what to say to the student.
     * @param {int} lineNumber - the number of the line in the proof in which the
     *        mistake was made (zero-indexed)
     * @param {Model} model - a Model object providing information on how to
     *        evaluate functions the teacher may have used.
     * @param {object} parameters - should be a dictionary of {
     *          proof: the student's proof in which the mistake was made
     *          assumptions: the assumptions allowed in the question
     *          target: what the student should prove (is
     *            questionInstance.result[0])
     *        }
     * @param {object} operators - from the student language, this is used to
     *        display expressions.
     * @throws This function will take the MistakeMessages given in the
     *         MistakeEntry and evaluate them to get strings describing the
     *         problem that could be shown to the student. It then throws a
     *         logicProofShared.UserError containing these strings.
     */
    var renderMistakeMessages = function (mistake, lineNumber, model, parameters, operators) {
        var renderedMessages = [];
        for (var i = 0; i < mistake.message.length; i++) {
            try {
                var message = mistake.message[i];
                var renderedMessage = '';
                for (var j = 0; j < message.length; j++) {
                    if (message[j].format === 'string') {
                        renderedMessage += message[j].content;
                    }
                    else {
                        var rawResult = evaluate(message[j].content, {
                            n: lineNumber + 1
                        }, model, parameters, {});
                        renderedMessage += (message[j].content.type === 'set_of_formulas') ?
                            shared_ts_1.default.displayExpressionArray(rawResult, operators) :
                            (message[j].content.type === 'formula') ?
                                shared_ts_1.default.displayExpression(rawResult, operators) :
                                rawResult;
                    }
                }
                renderedMessages.push(renderedMessage);
            }
            catch (err) {
                if (err.message !== 'evaluation failed') {
                    throw err;
                }
            }
        }
        return renderedMessages;
    };
    /**
     * This is the second top-level function for the student.
     * @param {Proof} proof - a Proof object constructed by buildProof()
     * @param {object} questionInstance - the object describing the problem built
     *        from the QuestionData (an argument of the interaction's
     *        customization_args) by buildInstance().
     * @throws if a mistake from the mistake_table has been
     *          made in the proof, {
     *            message: a human-readable description of the first mistake
     *              identified,
     *            line: the line (zero-indexed) the error occurred in,
     *            code: the name of the mistake that was made
     *            category: the MistakeSection that the mistake came from
     *          }
     */
    var checkProof = function (proof, questionInstance) {
        var evaluationCache = {};
        var parameters = {
            proof: proof,
            assumptions: questionInstance.assumptions,
            // Note that questionInstance.results is an array of expressions, to
            // allow for future questions in which the student has to prove more than
            // one thing, but for now we only permit one target per question.
            target: questionInstance.results[0]
        };
        // We check for all mistakes in the first mistake section (layout) first so
        // that formulas in subsequent sections can assume the layout is correct,
        // and so on with the subsequent sections.
        for (var i = 0; i < questionInstance.mistake_table.length; i++) {
            for (var lineNumber = 0; lineNumber < proof.lines.length; lineNumber++) {
                for (var j = 0; j < questionInstance.mistake_table[i].entries.length; j++) {
                    var mistake = questionInstance.mistake_table[i].entries[j];
                    // If the formula determining whether an error occurs cannot be
                    // evaluated then the error is deemed not to have occurred. This is
                    // so the teacher can write formulas like 'indentation(n-1)' and have
                    // it implicit that n>1.
                    var check = false;
                    try {
                        check = evaluate(mistake.occurs, {
                            n: lineNumber + 1
                        }, questionInstance.control_model, parameters, evaluationCache);
                    }
                    catch (err) {
                        if (err.message !== 'evaluation failed') {
                            throw err;
                        }
                    }
                    if (check) {
                        var mistakeMessages = renderMistakeMessages(mistake, lineNumber, questionInstance.control_model, parameters, questionInstance.language.operators);
                        // If the teacher has made a mistake and none of the messages they
                        // have provided can be evaluated then we try to return to the
                        // student as helpful a message as possible.
                        var error = (mistakeMessages.length > 0) ?
                            new shared_ts_1.default.PreRenderedUserError(mistakeMessages, mistake.name) :
                            new shared_ts_1.default.UserError('unspecified_mistake', {
                                section: questionInstance.mistake_table[i].name,
                                entry: mistake.name
                            });
                        throw {
                            message: shared_ts_1.default.renderError(error, questionInstance.general_messages, questionInstance.language),
                            line: lineNumber,
                            code: mistake.name,
                            category: questionInstance.mistake_table[i].name
                        };
                    }
                }
            }
        }
    };
    return {
        BASE_CONTROL_MODEL: BASE_CONTROL_MODEL,
        buildInstance: buildInstance,
        matchExpression: matchExpression,
        substituteIntoExpression: substituteIntoExpression,
        instantiateExpression: instantiateExpression,
        computeExpressionFromTemplate: computeExpressionFromTemplate,
        throwLineMessages: throwLineMessages,
        matchLineToTemplate: matchLineToTemplate,
        requireIdentifiableLine: requireIdentifiableLine,
        validateProof: validateProof,
        buildLine: buildLine,
        buildProof: buildProof,
        evaluate: evaluate,
        renderMistakeMessages: renderMistakeMessages,
        checkProof: checkProof
    };
})();
exports.default = logicProofStudent;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/js/teacher.ts":
/*!*****************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/js/teacher.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Components used by the LogicProof interaction editor.
 */
var shared_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/shared.ts */ "./extensions/interactions/LogicProof/static/js/shared.ts"));
var data_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/data.ts */ "./extensions/interactions/LogicProof/static/js/data.ts"));
var generatedParser_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/generatedParser.ts */ "./extensions/interactions/LogicProof/static/js/generatedParser.ts"));
var logicProofTeacher = (function () {
    // QUESTION
    /**
     * A question is composed of the formulas the student may assume and the
     * formula she must prove; it will be different for each state in which the
     * interaction is used.
     * @param {string} assumptionsString - typed by the teacher to describe the
     *        assumptions the student is allowed to make.
     * @param {string} targetString - typed by the teacher to describe what the
     *        student is supposed to prove.
     * @param {object} vocabulary - A vocabulary object, the words from which the
     *        teacher is not allowed to use as function names.
     * @returns {
     *           operators: the operators occurring in the question including both
     *             ordinary ones (like ) and specific ones (like f).
     *           assumptions: an array of Expressions, which will form the
     *             'assumptions' key in the interaction.
     *           results: an array of length one built from the targetString which
     *             will form the 'results' key in the interaction.
     *         }
     * @throws If the given strings cannot be parsed, or are mal-typed or use
     *         words that are reserved for the vocabulary.
     */
    var buildQuestion = function (assumptionsString, targetString, vocabulary) {
        var assumptions = null;
        if (assumptionsString.replace(/ /g, '') === '') {
            assumptions = [];
        }
        else {
            try {
                assumptions = generatedParser_ts_1.default.parse(assumptionsString.replace(/ /g, ''), 'listOfExpressions');
            }
            catch (err) {
                var error = new shared_ts_1.default.UserError('unparseable', {
                    field: 'assumptions'
                });
                throw {
                    message: shared_ts_1.default.renderError(error, TEACHER_ERROR_MESSAGES, data_ts_1.default.BASE_STUDENT_LANGUAGE)
                };
            }
        }
        try {
            var target = generatedParser_ts_1.default.parse(targetString.replace(/ /g, ''), 'expression');
        }
        catch (err) {
            var error = new shared_ts_1.default.UserError('unparseable', {
                field: 'target'
            });
            throw {
                message: shared_ts_1.default.renderError(error, TEACHER_ERROR_MESSAGES, data_ts_1.default.BASE_STUDENT_LANGUAGE)
            };
        }
        // All assumptions and the target must be booleans.
        var expressions = [];
        var topTypes = [];
        for (var i = 0; i < assumptions.length; i++) {
            expressions.push(assumptions[i]);
            topTypes.push('boolean');
        }
        expressions.push(target);
        topTypes.push('boolean');
        try {
            var typing = shared_ts_1.default.assignTypesToExpressionArray(expressions, topTypes, data_ts_1.default.BASE_STUDENT_LANGUAGE, ['variable', 'constant', 'prefix_function']);
            if (typing.length > 1) {
                throw new shared_ts_1.default.UserError('ambiguous_typing', {});
            }
            requireNoVocabularyWordsUsed(expressions, data_ts_1.default.BASE_STUDENT_LANGUAGE.operators, vocabulary);
        }
        catch (err) {
            throw {
                message: shared_ts_1.default.renderError(err, TEACHER_ERROR_MESSAGES, data_ts_1.default.BASE_STUDENT_LANGUAGE)
            };
        }
        return {
            operators: typing[0].operators,
            assumptions: assumptions,
            results: [target]
        };
    };
    // Throws an error if the given expression array uses an operator that is not
    // in knownOperators and whose name has length greater than one and occurs as
    // a word in the vocabulary.
    var requireNoVocabularyWordsUsed = function (expressionArray, knownOperators, vocabulary) {
        var _isMember = function (entry, array) {
            return (array.indexOf(entry) !== -1);
        };
        var vocabularyWords = [];
        for (var key in vocabulary) {
            for (var i = 0; i < vocabulary[key].length; i++) {
                var wordArray = vocabulary[key][i].split(' ');
                for (var j = 0; j < wordArray.length; j++) {
                    if (!_isMember(wordArray[j], vocabularyWords)) {
                        vocabularyWords.push(wordArray[j]);
                    }
                }
            }
        }
        var operatorNamesToCheck = shared_ts_1.default.getOperatorsFromExpressionArray(expressionArray);
        for (var i = 0; i < operatorNamesToCheck.length; i++) {
            if (_isMember(operatorNamesToCheck[i], vocabularyWords) &&
                operatorNamesToCheck[i].length > 1 &&
                !knownOperators.hasOwnProperty(operatorNamesToCheck[i])) {
                throw new shared_ts_1.default.UserError('forbidden_word', {
                    word: operatorNamesToCheck[i]
                });
            }
        }
    };
    // DATA
    var TEACHER_ERROR_MESSAGES = {
        unparseable: {
            templates: [[{
                        isFixed: true,
                        content: 'The '
                    }, {
                        isFixed: false,
                        content: 'field'
                    }, {
                        isFixed: true,
                        content: ' could not be parsed.'
                    }]],
            parameters: {
                field: {
                    format: 'string'
                }
            }
        },
        ambiguous_typing: {
            templates: [[{
                        isFixed: true,
                        content: ('Unfortunately this cannot be accepted as it has multiple possible ' +
                            'typings.')
                    }]],
            parameters: {}
        },
        hidden_operator: {
            templates: [[{
                        isFixed: true,
                        content: 'It will not be possible to uniquely identify '
                    }, {
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' from a line of this form.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                }
            }
        },
        duplicate_function_name: {
            templates: [[{
                        isFixed: true,
                        content: 'The function '
                    }, {
                        isFixed: false,
                        content: 'function'
                    }, {
                        isFixed: true,
                        content: ' has already been defined.'
                    }]],
            parameters: {
                // eslint-disable-next-line quote-props
                'function': {
                    format: 'string'
                }
            }
        },
        function_name_is_n: {
            templates: [[{
                        isFixed: true,
                        content: ('You cannot use n as a function name; it is reserved to refer to ' +
                            'line numbers')
                    }]]
        },
        argument_is_function_name: {
            templates: [[{
                        isFixed: true,
                        content: '\''
                    }, {
                        isFixed: false,
                        content: 'argument'
                    }, {
                        isFixed: true,
                        content: ('\' is the name of a function and so cannot be used as an argument.')
                    }]],
            parameters: {
                argument: {
                    format: 'string'
                }
            }
        },
        duplicate_argument: {
            templates: [[{
                        isFixed: true,
                        content: 'The variables used as arguments must all be distinct'
                    }]],
            parameters: {
                argument: {
                    format: 'string'
                }
            }
        },
        unused_argument: {
            templates: [[{
                        isFixed: true,
                        content: 'The argument \''
                    }, {
                        isFixed: false,
                        content: 'argument'
                    }, {
                        isFixed: true,
                        content: '\' does not occur in the definition.'
                    }]],
            parameters: {
                argument: {
                    format: 'string'
                }
            }
        },
        unknown_typing_error: {
            templates: [[{
                        isFixed: true,
                        content: 'A typing error has occurred with '
                    }, {
                        isFixed: false,
                        content: 'expression'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                expression: {
                    format: 'expression'
                }
            }
        },
        'unmatched_{{': {
            templates: [[{
                        isFixed: true,
                        content: 'This has an unmatched {{.'
                    }]],
            parameters: {}
        },
        unparseable_fragment: {
            templates: [[{
                        isFixed: true,
                        content: 'It was not possible to parse '
                    }, {
                        isFixed: false,
                        content: 'fragment'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                fragment: {
                    format: 'string'
                }
            }
        },
        ambiguous_parsing: {
            templates: [[{
                        isFixed: true,
                        content: 'The '
                    }, {
                        isFixed: false,
                        content: 'field'
                    }, {
                        isFixed: true,
                        content: (' can be understood in more than one way. Try using fewer ' +
                            'single-character words and variables so that it is easier to ' +
                            'distinguish between the two.')
                    }]],
            parameters: {
                field: {
                    format: 'string'
                }
            }
        },
        illegal_symbol: {
            templates: [[{
                        isFixed: true,
                        content: 'The symbol '
                    }, {
                        isFixed: false,
                        content: 'symbol'
                    }, {
                        isFixed: true,
                        content: ' was not recognised.'
                    }]],
            parameters: {
                symbol: {
                    format: 'string'
                }
            }
        },
        blank_line: {
            templates: [[{
                        isFixed: true,
                        content: 'This line is blank.'
                    }]],
            parameters: {}
        },
        unidentified_word: {
            templates: [[{
                        isFixed: true,
                        content: 'We could not identify \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: ('\'; please make sure you are using vocabulary from the given ' +
                            'list, and don\'t have two consecutive expressions.')
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            }
        },
        unidentified_words: {
            templates: [[{
                        isFixed: true,
                        content: 'We could not identify either of \''
                    }, {
                        isFixed: false,
                        content: 'word1'
                    }, {
                        isFixed: true,
                        content: '\' or \''
                    }, {
                        isFixed: false,
                        content: 'word2'
                    }, {
                        isFixed: true,
                        content: ('\' as words; please make sure you are using vocabulary from ' +
                            'the given list, and don\'t have two consecutive expressions.')
                    }]],
            parameters: {
                word1: {
                    format: 'string'
                },
                word2: {
                    format: 'string'
                }
            }
        },
        consecutive_expressions: {
            templates: [[{
                        isFixed: true,
                        content: 'This line has two expressions in a row ('
                    }, {
                        isFixed: false,
                        content: 'word1'
                    }, {
                        isFixed: true,
                        content: ' and '
                    }, {
                        isFixed: false,
                        content: 'word2'
                    }, {
                        isFixed: true,
                        content: ') which is not allowed.'
                    }]],
            parameters: {
                word1: {
                    format: 'string'
                },
                word2: {
                    format: 'string'
                }
            }
        },
        unidentified_phrase_starting_at: {
            templates: [[{
                        isFixed: true,
                        content: 'The phrase starting \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: ('\' could not be identified; please make sure you are only ' +
                            'using phrases from the given list of vocabulary.')
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            }
        },
        forbidden_word: {
            templates: [[{
                        isFixed: true,
                        content: 'The name \''
                    }, {
                        isFixed: false,
                        content: 'word'
                    }, {
                        isFixed: true,
                        content: '\' is reserved for vocabulary and so cannot be used here.'
                    }]],
            parameters: {
                word: {
                    format: 'string'
                }
            }
        },
        not_enough_inputs: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' must have at least '
                    }, {
                        isFixed: false,
                        content: 'num_needed'
                    }, {
                        isFixed: true,
                        content: ' '
                    }, {
                        isFixed: false,
                        content: 'input_category'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                num_needed: {
                    format: 'string'
                },
                input_category: {
                    format: 'string'
                },
                operator: {
                    format: 'string'
                }
            }
        },
        wrong_num_inputs: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' must have '
                    }, {
                        isFixed: false,
                        content: 'num_needed'
                    }, {
                        isFixed: true,
                        content: ' '
                    }, {
                        isFixed: false,
                        content: 'input_category'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                num_needed: {
                    format: 'string'
                },
                input_category: {
                    format: 'string'
                },
                operator: {
                    format: 'string'
                }
            }
        },
        wrong_kind: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' is supposed to be a '
                    }, {
                        isFixed: false,
                        content: 'expected_kind'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                },
                expected_kind: {
                    format: 'string'
                },
                actual_kind: {
                    format: 'string'
                }
            }
        },
        wrong_type: {
            templates: [[{
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' yields a '
                    }, {
                        isFixed: false,
                        content: 'actual_type'
                    }, {
                        isFixed: true,
                        content: ' but you are trying to use it to give a '
                    }, {
                        isFixed: false,
                        content: 'expected_type'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                },
                expected_type: {
                    format: 'string'
                },
                actual_type: {
                    format: 'string'
                }
            }
        },
        duplicate_dummy_name: {
            templates: [[{
                        isFixed: true,
                        content: 'The name \''
                    }, {
                        isFixed: false,
                        content: 'dummy'
                    }, {
                        isFixed: true,
                        content: '\' is already in use and so cannot be quantified over in '
                    }, {
                        isFixed: false,
                        content: 'expression'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                dummy: {
                    format: 'expression'
                },
                expression: {
                    format: 'expression'
                }
            }
        },
        dummy_not_variable: {
            templates: [[{
                        isFixed: true,
                        content: 'You can only quantify over variables, not  '
                    }, {
                        isFixed: false,
                        content: 'dummy'
                    }, {
                        isFixed: true,
                        content: '.'
                    }]],
            parameters: {
                dummy: {
                    format: 'expression'
                },
                expression: {
                    format: 'expression'
                }
            }
        },
        unknown_operator: {
            templates: [[{
                        isFixed: true,
                        content: 'The operator '
                    }, {
                        isFixed: false,
                        content: 'operator'
                    }, {
                        isFixed: true,
                        content: ' could not be identified.'
                    }]],
            parameters: {
                operator: {
                    format: 'string'
                }
            }
        },
        too_many_parsings: {
            templates: [[{
                        isFixed: true,
                        content: ('This can be parsed in too many different ways - try using ' +
                            'fewer words, especially single-character words.')
                    }]],
            parameters: {}
        },
        too_many_typings: {
            templates: [[{
                        isFixed: true,
                        content: ('This has too many possible typings - try using fewer variables.')
                    }]],
            parameters: {}
        }
    };
    return {
        buildQuestion: buildQuestion,
        TEACHER_ERROR_MESSAGES: TEACHER_ERROR_MESSAGES
    };
})();
exports.default = logicProofTeacher;


/***/ }),

/***/ "./extensions/interactions/LogicProof/static/logic_proof.css":
/*!*******************************************************************!*\
  !*** ./extensions/interactions/LogicProof/static/logic_proof.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!./logic_proof.css */ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/LogicProof/static/logic_proof.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/MathExpressionInput.ts":
/*!****************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/MathExpressionInput.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for MathExpressionInput interaction.
 */
__webpack_require__(/*! interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts */ "./extensions/interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts");
__webpack_require__(/*! interactions/MathExpressionInput/directives/math-expression-input-validation.service.ts */ "./extensions/interactions/MathExpressionInput/directives/math-expression-input-validation.service.ts");
__webpack_require__(/*! interactions/MathExpressionInput/directives/oppia-interactive-math-expression-input.directive.ts */ "./extensions/interactions/MathExpressionInput/directives/oppia-interactive-math-expression-input.directive.ts");
__webpack_require__(/*! interactions/MathExpressionInput/directives/oppia-response-math-expression-input.directive.ts */ "./extensions/interactions/MathExpressionInput/directives/oppia-response-math-expression-input.directive.ts");
__webpack_require__(/*! interactions/MathExpressionInput/directives/oppia-short-response-math-expression-input.directive.ts */ "./extensions/interactions/MathExpressionInput/directives/oppia-short-response-math-expression-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts":
/*!*******************************************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Rules service for the interaction.
 */
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var MathExpressionInputRulesService = /** @class */ (function () {
    function MathExpressionInputRulesService() {
    }
    // TODO(#7165): Replace 'any' with the exact type. This has been typed
    // as 'any' since 'answer' is a complex object having varying types. A general
    // type needs to be found. Same goes for 'inputs'.
    MathExpressionInputRulesService.prototype.IsMathematicallyEquivalentTo = function (answer, inputs) {
        try {
            MathExpression.fromLatex(answer.latex);
        }
        catch (e) {
            throw Error('Bad expression in answer.latex: ' + e.message() + ' inputs: ' +
                JSON.stringify(answer));
        }
        try {
            MathExpression.fromLatex(inputs.x);
        }
        catch (e) {
            throw Error('Bad expression in inputs.x: ' + e.message() + ' inputs: ' +
                JSON.stringify(inputs));
        }
        return (MathExpression.fromLatex(answer.latex).equals(MathExpression.fromLatex(inputs.x)));
    };
    MathExpressionInputRulesService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], MathExpressionInputRulesService);
    return MathExpressionInputRulesService;
}());
exports.MathExpressionInputRulesService = MathExpressionInputRulesService;
angular.module('oppia').factory('MathExpressionInputRulesService', static_1.downgradeInjectable(MathExpressionInputRulesService));


/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/directives/math-expression-input-validation.service.ts":
/*!************************************************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/directives/math-expression-input-validation.service.ts ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var MathExpressionInputValidationService = /** @class */ (function () {
    function MathExpressionInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    MathExpressionInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        // TODO(juansaba): Implement customization args validations.
        return [];
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    MathExpressionInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
        // Check that each rule has a valid math expression.
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                try {
                    MathExpression.fromLatex(rules[j].inputs.x);
                }
                catch (e) {
                    warningsList.push({
                        type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                        message: ('The math expression used in rule ' + String(j + 1) +
                            ' in group ' + String(i + 1) + ' is invalid.')
                    });
                }
            }
        }
        return warningsList;
    };
    var _a;
    MathExpressionInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], MathExpressionInputValidationService);
    return MathExpressionInputValidationService;
}());
exports.MathExpressionInputValidationService = MathExpressionInputValidationService;
angular.module('oppia').factory('MathExpressionInputValidationService', static_1.downgradeInjectable(MathExpressionInputValidationService));


/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/directives/oppia-interactive-math-expression-input.directive.ts":
/*!*********************************************************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/directives/oppia-interactive-math-expression-input.directive.ts ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MathExpressionInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts */ "./extensions/interactions/MathExpressionInput/directives/math-expression-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/DeviceInfoService.ts */ "./core/templates/dev/head/services/contextual/DeviceInfoService.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/DebouncerService.ts */ "./core/templates/dev/head/services/DebouncerService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveMathExpressionInput', [
    'MathExpressionInputRulesService',
    'UrlInterpolationService',
    function (MathExpressionInputRulesService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MathExpressionInput/directives/' +
                'math-expression-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', '$timeout', '$element', 'LABEL_FOR_CLEARING_FOCUS',
                'DebouncerService', 'DeviceInfoService', 'WindowDimensionsService',
                'CurrentInteractionService',
                function ($scope, $attrs, $timeout, $element, LABEL_FOR_CLEARING_FOCUS, DebouncerService, DeviceInfoService, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    var guppyDivElt = $element[0].querySelector('.guppy-div');
                    // Dynamically assigns a unique id to the guppy-div
                    guppyDivElt.setAttribute('id', 'guppy_' + Math.floor(Math.random() * 100000000));
                    var guppyDivId = guppyDivElt.id;
                    /**
                     * Adds a button overlay and invisible text field used to bring up
                     * the keyboard on mobile devices.
                     *
                     * TODO(Oishikatta): On iOS/Safari, keyboard may only appear on first
                     * press. This may not be a significant issue as the
                     * MathExpressionInput is recreated if the given answer is incorrect.
                     */
                    var makeGuppyMobileFriendly = function () {
                        /**
                         * Checks if the guppy div has a width and height greater than 0,
                         * if not schedules a timeout to run again after 100ms. If the
                         * guppy div has a valid width/height, position the invisible
                         * button directly over the guppy div. For mobile browsers, focus()
                         * can only be called from within an onclick handler. Using a form
                         * element was more reliable than attaching the handler to the
                         * guppy div directly.
                         */
                        var positionButtonOverlay = function () {
                            var guppyOffset = $(guppyDivElt).position();
                            var guppySize = guppyDivElt.getBoundingClientRect();
                            // If the guppy div hasn't rendered yet, retry after 100ms.
                            if (guppySize.width === 0 || guppySize.height === 0) {
                                $timeout(positionButtonOverlay, 100);
                            }
                            else {
                                $('#startMathInputButton').css({
                                    top: guppyOffset.top,
                                    left: guppyOffset.left,
                                    width: guppySize.width,
                                    height: guppySize.height
                                });
                            }
                        };
                        positionButtonOverlay();
                        // The focus() call must be in a click event handler and on a text
                        // field to make the mobile keyboard appear.
                        ctrl.startMobileMathInput = function () {
                            guppyInstance.activate();
                            var fakeInputElement = document.querySelector('#fakeInputForMathExpression');
                            fakeInputElement.focus();
                            // Place the cursor at the end of the text input, so that the
                            // user can use backspace to delete.
                            fakeInputElement.setSelectionRange(fakeInputElement.value.length, fakeInputElement.value.length);
                        };
                        var setGuppyContentFromInput = function () {
                            // Clear the Guppy instance by setting its content to the
                            // output of get_content when empty.
                            guppyInstance.import_xml('<m><e></e></m>');
                            guppyInstance.render(true);
                            // Get content of the text input field as an array of characters.
                            var textContent = document
                                .querySelector('#fakeInputForMathExpression').value
                                .toLowerCase().split('');
                            // Replay key combination for each character on the document.
                            for (var i = 0; i < textContent.length; i++) {
                                // If the character is a space, send a 'right' to enable mobile
                                // users to complete expressions without arrow keys.
                                if (textContent[i] === ' ') {
                                    Mousetrap.trigger('right');
                                }
                                else {
                                    Mousetrap.trigger(textContent[i]);
                                }
                            }
                        };
                        // Debounce clear/refill cycles to 1 per 100ms.
                        $('#fakeInputForMathExpression').on('input change compositionupdate keydown', DebouncerService.debounce(function () {
                            setGuppyContentFromInput();
                        }, 100)).on('blur', function () {
                            guppyInstance.activate();
                            setGuppyContentFromInput();
                        });
                    };
                    var oppiaSymbolsUrl = UrlInterpolationService.getStaticAssetUrl('/overrides/guppy/oppia_symbols.json');
                    Guppy.init({
                        symbols: ['/third_party/static/guppy-b5055b/sym/symbols.json',
                            oppiaSymbolsUrl]
                    });
                    var guppyInstance = new Guppy(guppyDivId, {
                        settings: {
                            empty_content: ('\\color{grey}{\\text{\\small{Type a formula here.}}}'),
                            buttons: []
                        },
                        events: {
                            done: function (e) {
                                ctrl.submitAnswer();
                            },
                            change: function (e) {
                                // Need to manually trigger the digest cycle
                                // to make any 'watchers' aware of changes in answer.
                                $scope.$apply();
                            },
                            ready: function () {
                                if (DeviceInfoService.isMobileUserAgent() &&
                                    DeviceInfoService.hasTouchEvents()) {
                                    ctrl.mobileOverlayIsShown = true;
                                    // Wait for the scope change to apply. Since we interact with
                                    // the DOM elements, they need to be added by angular before
                                    // the function is called. Timeout of 0 to wait
                                    // until the end of the current digest cycle,
                                    // false to not start a new digest cycle.
                                    // A new cycle is not needed since no angular variables
                                    // are changed within the function.
                                    $timeout(makeGuppyMobileFriendly, 0, false);
                                }
                            }
                        }
                    });
                    guppyInstance.render();
                    var labelForFocusTarget = $attrs.labelForFocusTarget || null;
                    $scope.$on('focusOn', function (e, name) {
                        if (!labelForFocusTarget) {
                            return;
                        }
                        if (name === labelForFocusTarget) {
                            guppyInstance.activate();
                        }
                        else if (name === LABEL_FOR_CLEARING_FOCUS) {
                            guppyInstance.deactivate();
                        }
                    });
                    var answer = {
                        ascii: '',
                        latex: ''
                    };
                    ctrl.isCurrentAnswerValid = function () {
                        var latexAnswer = guppyInstance.latex();
                        try {
                            MathExpression.fromLatex(latexAnswer);
                        }
                        catch (e) {
                            return false;
                        }
                        return true;
                    };
                    ctrl.submitAnswer = function () {
                        if (!ctrl.isCurrentAnswerValid()) {
                            return;
                        }
                        answer.latex = guppyInstance.latex();
                        answer.ascii = guppyInstance.text();
                        CurrentInteractionService.onSubmit(answer, MathExpressionInputRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(ctrl.submitAnswer, ctrl.isCurrentAnswerValid);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/directives/oppia-response-math-expression-input.directive.ts":
/*!******************************************************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/directives/oppia-response-math-expression-input.directive.ts ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MathExpressionInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! directives/mathjax-bind.directive.ts */ "./core/templates/dev/head/directives/mathjax-bind.directive.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseMathExpressionInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MathExpressionInput/directives/' +
                'math-expression-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.latexAnswer = HtmlEscaperService.escapedJsonToObj($attrs.answer).latex;
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MathExpressionInput/directives/oppia-short-response-math-expression-input.directive.ts":
/*!************************************************************************************************************************!*\
  !*** ./extensions/interactions/MathExpressionInput/directives/oppia-short-response-math-expression-input.directive.ts ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MathExpressionInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! directives/mathjax-bind.directive.ts */ "./core/templates/dev/head/directives/mathjax-bind.directive.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseMathExpressionInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MathExpressionInput/directives/' +
                'math-expression-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.latexAnswer = HtmlEscaperService.escapedJsonToObj($attrs.answer).latex;
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/MultipleChoiceInput.ts":
/*!****************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/MultipleChoiceInput.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for MultipleChoiceInput interaction.
 */
__webpack_require__(/*! interactions/MultipleChoiceInput/static/multiple_choice_input.css */ "./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts */ "./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/multiple-choice-input-validation.service.ts */ "./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-validation.service.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/oppia-interactive-multiple-choice-input.directive.ts */ "./extensions/interactions/MultipleChoiceInput/directives/oppia-interactive-multiple-choice-input.directive.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/oppia-response-multiple-choice-input.directive.ts */ "./extensions/interactions/MultipleChoiceInput/directives/oppia-response-multiple-choice-input.directive.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/oppia-short-response-multiple-choice-input.directive.ts */ "./extensions/interactions/MultipleChoiceInput/directives/oppia-short-response-multiple-choice-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts":
/*!*******************************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
angular.module('oppia').factory('MultipleChoiceInputRulesService', [function () {
        return {
            Equals: function (answer, inputs) {
                return answer === inputs.x;
            }
        };
    }]);


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-validation.service.ts":
/*!************************************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-validation.service.ts ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var MultipleChoiceInputValidationService = /** @class */ (function () {
    function MultipleChoiceInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    MultipleChoiceInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        var warningsList = [];
        this.baseInteractionValidationServiceInstance.requireCustomizationArguments(customizationArgs, ['choices']);
        var areAnyChoicesEmpty = false;
        var areAnyChoicesDuplicated = false;
        var seenChoices = [];
        var numChoices = customizationArgs.choices.value.length;
        for (var i = 0; i < customizationArgs.choices.value.length; i++) {
            var choice = customizationArgs.choices.value[i];
            if (choice.trim().length === 0) {
                areAnyChoicesEmpty = true;
            }
            if (seenChoices.indexOf(choice) !== -1) {
                areAnyChoicesDuplicated = true;
            }
            seenChoices.push(choice);
        }
        if (areAnyChoicesEmpty) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the choices are nonempty.'
            });
        }
        if (areAnyChoicesDuplicated) {
            warningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                message: 'Please ensure the choices are unique.'
            });
        }
        return warningsList;
    };
    MultipleChoiceInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        var numChoices = customizationArgs.choices.value.length;
        var selectedEqualsChoices = [];
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                if (rules[j].type === 'Equals') {
                    var choicePreviouslySelected = (selectedEqualsChoices.indexOf(rules[j].inputs.x) !== -1);
                    if (!choicePreviouslySelected) {
                        selectedEqualsChoices.push(rules[j].inputs.x);
                    }
                    else {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: 'Please ensure rule ' + String(j + 1) +
                                ' in group ' + String(i + 1) + ' is not equaling the ' +
                                'same multiple choice option as another rule.'
                        });
                    }
                    if (rules[j].inputs.x >= numChoices) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.CRITICAL,
                            message: 'Please ensure rule ' + String(j + 1) +
                                ' in group ' + String(i + 1) + ' refers to a valid choice.'
                        });
                    }
                }
            }
        }
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAnswerGroupWarnings(answerGroups, stateName));
        // Only require a default rule if some choices have not been taken care
        // of by rules.
        if (selectedEqualsChoices.length < numChoices) {
            if (!defaultOutcome || defaultOutcome.isConfusing(stateName)) {
                warningsList.push({
                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                    message: 'Please add something for Oppia to say in the ' +
                        '\"All other answers\" response.'
                });
            }
        }
        return warningsList;
    };
    var _a;
    MultipleChoiceInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], MultipleChoiceInputValidationService);
    return MultipleChoiceInputValidationService;
}());
exports.MultipleChoiceInputValidationService = MultipleChoiceInputValidationService;
angular.module('oppia').factory('MultipleChoiceInputValidationService', static_1.downgradeInjectable(MultipleChoiceInputValidationService));


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/directives/oppia-interactive-multiple-choice-input.directive.ts":
/*!*********************************************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/directives/oppia-interactive-multiple-choice-input.directive.ts ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MultipleChoiceInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts */ "./extensions/interactions/MultipleChoiceInput/directives/multiple-choice-input-rules.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveMultipleChoiceInput', [
    'HtmlEscaperService', 'MultipleChoiceInputRulesService',
    'UrlInterpolationService',
    function (HtmlEscaperService, MultipleChoiceInputRulesService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MultipleChoiceInput/directives/' +
                'multiple-choice-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'CurrentInteractionService',
                function ($attrs, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.choices = HtmlEscaperService.escapedJsonToObj($attrs.choicesWithValue);
                    ctrl.answer = null;
                    ctrl.submitAnswer = function (answer) {
                        if (answer === null) {
                            return;
                        }
                        answer = parseInt(answer, 10);
                        CurrentInteractionService.onSubmit(answer, MultipleChoiceInputRulesService);
                    };
                    CurrentInteractionService.registerCurrentInteraction(null, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/directives/oppia-response-multiple-choice-input.directive.ts":
/*!******************************************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/directives/oppia-response-multiple-choice-input.directive.ts ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MultipleChoiceInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseMultipleChoiceInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MultipleChoiceInput/directives/' +
                'multiple-choice-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    var _choices = HtmlEscaperService.escapedJsonToObj($attrs.choices);
                    ctrl.response = _choices[_answer];
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/directives/oppia-short-response-multiple-choice-input.directive.ts":
/*!************************************************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/directives/oppia-short-response-multiple-choice-input.directive.ts ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the MultipleChoiceInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! filters/string-utility-filters/convert-to-plain-text.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/convert-to-plain-text.filter.ts");
__webpack_require__(/*! filters/string-utility-filters/truncate-at-first-line.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseMultipleChoiceInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MultipleChoiceInput/directives/' +
                'multiple-choice-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', '$filter',
                function ($attrs, $filter) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    var _choices = HtmlEscaperService.escapedJsonToObj($attrs.choices);
                    var response = $filter('convertToPlainText')(_choices[_answer]);
                    ctrl.response = $filter('truncateAtFirstLine')(response);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css":
/*!**************************************************************************************!*\
  !*** ./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!./multiple_choice_input.css */ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/MusicNotesInput.ts":
/*!********************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/MusicNotesInput.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for MusicNotesInput interaction.
 */
__webpack_require__(/*! interactions/MusicNotesInput/static/music_notes_input.css */ "./extensions/interactions/MusicNotesInput/static/music_notes_input.css");
__webpack_require__(/*! interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts */ "./extensions/interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/music-notes-input-validation.service.ts */ "./extensions/interactions/MusicNotesInput/directives/music-notes-input-validation.service.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts */ "./extensions/interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/oppia-response-music-notes-input.directive.ts */ "./extensions/interactions/MusicNotesInput/directives/oppia-response-music-notes-input.directive.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/oppia-short-response-music-notes-input.directive.ts */ "./extensions/interactions/MusicNotesInput/directives/oppia-short-response-music-notes-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
// The below file is imported just for its constant.
__webpack_require__(/*! interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts */ "./extensions/interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').factory('MusicNotesInputRulesService', [
    'NOTE_NAMES_TO_MIDI_VALUES', function (NOTE_NAMES_TO_MIDI_VALUES) {
        var _getMidiNoteValue = function (note) {
            if (NOTE_NAMES_TO_MIDI_VALUES.hasOwnProperty(note.readableNoteName)) {
                return NOTE_NAMES_TO_MIDI_VALUES[note.readableNoteName];
            }
            else {
                throw new Error('Invalid music note ' + note);
            }
        };
        var _convertSequenceToMidi = function (sequence) {
            return sequence.map(function (note) {
                return _getMidiNoteValue(note);
            });
        };
        return {
            Equals: function (answer, inputs) {
                return angular.equals(_convertSequenceToMidi(answer), _convertSequenceToMidi(inputs.x));
            },
            IsLongerThan: function (answer, inputs) {
                return _convertSequenceToMidi(answer).length > inputs.k;
            },
            // TODO(wxy): validate that inputs.a <= inputs.b
            HasLengthInclusivelyBetween: function (answer, inputs) {
                var answerLength = _convertSequenceToMidi(answer).length;
                return answerLength >= inputs.a && answerLength <= inputs.b;
            },
            IsEqualToExceptFor: function (answer, inputs) {
                var targetSequence = _convertSequenceToMidi(inputs.x);
                var userSequence = _convertSequenceToMidi(answer);
                if (userSequence.length !== targetSequence.length) {
                    return false;
                }
                var numWrongNotes = 0;
                userSequence.map(function (noteValue, index) {
                    if (noteValue !== targetSequence[index]) {
                        numWrongNotes++;
                    }
                });
                return numWrongNotes <= inputs.k;
            },
            IsTranspositionOf: function (answer, inputs) {
                var targetSequence = _convertSequenceToMidi(inputs.x);
                var userSequence = _convertSequenceToMidi(answer);
                if (userSequence.length !== targetSequence.length) {
                    return false;
                }
                return userSequence.every(function (noteValue, index) {
                    return targetSequence[index] + inputs.y === noteValue;
                });
            },
            IsTranspositionOfExceptFor: function (answer, inputs) {
                var targetSequence = _convertSequenceToMidi(inputs.x);
                var userSequence = _convertSequenceToMidi(answer);
                if (userSequence.length !== targetSequence.length) {
                    return false;
                }
                var numWrongNotes = 0;
                userSequence.map(function (noteValue, index) {
                    if (targetSequence[index] + inputs.y !== noteValue) {
                        numWrongNotes++;
                    }
                });
                return numWrongNotes <= inputs.k;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/music-notes-input-validation.service.ts":
/*!****************************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/music-notes-input-validation.service.ts ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var MusicNotesInputValidationService = /** @class */ (function () {
    function MusicNotesInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    MusicNotesInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        // TODO(juansaba): Implement customization args validations.
        return [];
    };
    MusicNotesInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        return this.getCustomizationArgsWarnings(customizationArgs).concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
    };
    var _a;
    MusicNotesInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], MusicNotesInputValidationService);
    return MusicNotesInputValidationService;
}());
exports.MusicNotesInputValidationService = MusicNotesInputValidationService;
angular.module('oppia').factory('MusicNotesInputValidationService', static_1.downgradeInjectable(MusicNotesInputValidationService));


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/music-phrase-player.service.ts":
/*!*******************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/music-phrase-player.service.ts ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Player service for the interaction.
 */
angular.module('oppia').factory('MusicPhrasePlayerService', [
    '$timeout', function ($timeout) {
        var _MIDI_CHANNEL = 0;
        var _MIDI_VELOCITY = 127;
        var _SECS_TO_MILLISECS = 1000.0;
        var _playNote = function (midiValues, durationInSecs, delayInSecs) {
            $timeout(function () {
                MIDI.chordOn(_MIDI_CHANNEL, midiValues, _MIDI_VELOCITY, 0);
                MIDI.chordOff(_MIDI_CHANNEL, midiValues, durationInSecs);
            }, delayInSecs * _SECS_TO_MILLISECS);
        };
        /**
         * Plays a music phrase. The input is given as an Array of notes. Each
         * note is represented as an object with three key-value pairs:
         * - midiValue: Integer. The midi value of the note.
         * - duration: Float. A decimal number representing the length of the note,
         *     in seconds.
         * - start: Float. A decimal number representing the time offset (after the
         *     beginning of the phrase) at which to start playing the note.
         */
        var _playMusicPhrase = function (notes) {
            MIDI.Player.stop();
            for (var i = 0; i < notes.length; i++) {
                _playNote([notes[i].midiValue], notes[i].duration, notes[i].start);
            }
        };
        return {
            playMusicPhrase: function (notes) {
                _playMusicPhrase(notes);
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts":
/*!*************************************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/oppia-interactive-music-notes-input.directive.ts ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directives for the MusicNotesInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts */ "./extensions/interactions/MusicNotesInput/directives/music-notes-input-rules.service.ts");
__webpack_require__(/*! interactions/MusicNotesInput/directives/music-phrase-player.service.ts */ "./extensions/interactions/MusicNotesInput/directives/music-phrase-player.service.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').directive('oppiaInteractiveMusicNotesInput', [
    'CurrentInteractionService', 'HtmlEscaperService',
    'MusicNotesInputRulesService', 'MusicPhrasePlayerService',
    'UrlInterpolationService',
    'EVENT_NEW_CARD_AVAILABLE', 'NOTE_NAMES_TO_MIDI_VALUES',
    function (CurrentInteractionService, HtmlEscaperService, MusicNotesInputRulesService, MusicPhrasePlayerService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE, NOTE_NAMES_TO_MIDI_VALUES) {
        return {
            restrict: 'E',
            scope: {
                getLastAnswer: '&lastAnswer',
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MusicNotesInput/directives/' +
                'music-notes-input-interaction.directive.html'),
            link: function (scope, element, attrs) {
                // This is needed in order for the scope to be retrievable during Karma
                // unit testing. See http://stackoverflow.com/a/29833832 for more
                // details.
                element[0].getControllerScope = function () {
                    return scope;
                };
                scope.SOUNDFONT_URL =
                    '/third_party/static/midi-js-a8a842/examples/soundfont/';
                scope.sequenceToGuess = HtmlEscaperService.escapedJsonToObj(attrs.sequenceToGuessWithValue);
                scope.interactionIsActive = (scope.getLastAnswer() === null);
                scope.initialSequence = scope.interactionIsActive ?
                    HtmlEscaperService.escapedJsonToObj(attrs.initialSequenceWithValue) :
                    scope.getLastAnswer();
                scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                    scope.interactionIsActive = false;
                    scope.initialSequence = scope.getLastAnswer();
                    scope.reinitStaff();
                });
                /**
                 * A note Object has a baseNoteMidiNumber and an offset property. For
                 * example, C#4 would be -> note = {baseNoteMidiNumber: 61, offset: 1};
                 *
                 * A readableNote Object has a readableNoteName property. For example,
                 * Gb5 would be -> readableNote = {readableNoteName: 'Gb5'};
                 */
                /**
                 * Array to hold the notes placed on staff. Notes are represented as
                 * objects with two keys: baseNoteMidiNumber and offset. The
                 * baseNoteMidiNumber is an integer value denoting the MIDI number of
                 * the staff-line the note is on, and the offset is either -1, 0 or 1,
                 * denoting a flat, natural or sharp respectively.
                 */
                scope.noteSequence = [];
                scope._addNoteToNoteSequence = function (note) {
                    scope.noteSequence.push({
                        note: note
                    });
                };
                // Remove a specific note with given noteId from noteSequence. If given
                // noteId is not in noteSequence, nothing will be removed.
                scope._removeNotesFromNoteSequenceWithId = function (noteId) {
                    for (var i = 0; i < scope.noteSequence.length; i++) {
                        if (scope.noteSequence[i].note.noteId === noteId) {
                            scope.noteSequence.splice(i, 1);
                        }
                    }
                };
                // Sorts noteSequence elements according to the return value of the
                // compareNoteStarts function.
                scope._sortNoteSequence = function () {
                    scope.noteSequence.sort(compareNoteStarts);
                };
                /**
                 * Counter to create unique id for each note dropped on staff.
                 */
                scope._currentNoteId = 0;
                scope.generateNoteId = function () {
                    scope._currentNoteId += 1;
                    return 'note_id_' + (scope._currentNoteId - 1);
                };
                var NOTE_TYPE_NATURAL = 0;
                // TODO(wagnerdmike): More notes types will be added to NOTE_TYPES.
                var NOTE_TYPES = [NOTE_TYPE_NATURAL];
                var NOTES_ON_LINES = ['E4', 'G4', 'B4', 'D5', 'F5'];
                var LEDGER_LINE_NOTES = ['C4', 'A5'];
                var verticalGridKeys = [
                    81, 79, 77, 76, 74, 72, 71, 69, 67, 65, 64, 62, 60
                ];
                // Highest number of notes that can fit on the staff at any given time.
                var MAXIMUM_NOTES_POSSIBLE = 8;
                var noteChoicesElt = element.find('.oppia-music-input-note-choices');
                var staffContainerElt = element.find('.oppia-music-input-staff');
                // Staff has to be reinitialized every time that the staff is resized or
                // displayed. The staffContainerElt and all subsequent measurements
                // must be recalculated in order for the grid to work properly.
                scope.reinitStaff = function () {
                    $('.oppia-music-input-valid-note-area').css('visibility', 'hidden');
                    setTimeout(function () {
                        $('.oppia-music-input-valid-note-area').css('visibility', 'visible');
                        scope.init();
                    }, 20);
                };
                // When page is in the smaller one card format, reinitialize staff after
                // the user navigates to the Interaction Panel. Otherwise the dimensions
                // for the staff will be incorrectly calculated.
                scope.$on('showInteraction', function () {
                    scope.reinitStaff();
                });
                // Creates draggable notes and droppable staff.
                scope.init = function () {
                    scope.CONTAINER_WIDTH = staffContainerElt.width();
                    scope.CONTAINER_HEIGHT = 0.2 * scope.CONTAINER_WIDTH;
                    // The grid rectangle dimensions defining the grid which the notes
                    // fall on.
                    scope.HORIZONTAL_GRID_SPACING = scope.CONTAINER_WIDTH /
                        (MAXIMUM_NOTES_POSSIBLE + 1);
                    scope.VERTICAL_GRID_SPACING = scope.CONTAINER_HEIGHT /
                        verticalGridKeys.length;
                    var staffTop = computeStaffTop();
                    var staffBottom = computeStaffBottom();
                    // The farthest edge of the staff. If a note is placed beyond this
                    // position, it will be discarded.
                    var RIGHT_EDGE_OF_STAFF_POSITION = element.find('.oppia-music-input-valid-note-area').width();
                    clearNotesFromStaff();
                    initPalette();
                    clearDroppableStaff();
                    buildDroppableStaff();
                    repaintNotes();
                };
                // Initial notes are placed on the staff at the
                // start of the exploration and can be removed by the learner.
                var initializeNoteSequence = function (initialNotesToAdd) {
                    for (var i = 0; i < initialNotesToAdd.length; i++) {
                        var initialNote = _convertReadableNoteToNote(initialNotesToAdd[i]);
                        initialNote = Object.assign(initialNote, {
                            noteId: scope.generateNoteId(),
                            noteStart: {
                                num: i,
                                den: 1
                            }
                        });
                        scope._addNoteToNoteSequence(initialNote);
                    }
                };
                // Gets the staff top by getting the first staff line's position and
                // subtracting one vertical grid space from it.
                var computeStaffTop = function () {
                    return (getStaffLinePositions()[verticalGridKeys[0]] -
                        scope.VERTICAL_GRID_SPACING);
                };
                // Gets the staff bottom position by adding the staff top position value
                // with the total sum of all the vertical grid spaces (staff lines).
                var computeStaffBottom = function () {
                    return computeStaffTop() + (scope.VERTICAL_GRID_SPACING * verticalGridKeys.length);
                };
                // Removes all notes from staff.
                var clearNotesFromStaff = function () {
                    element.find('.oppia-music-input-note-choices div').remove();
                };
                // Removes all droppable staff lines.
                var clearDroppableStaff = function () {
                    element.find('.oppia-music-input-staff div').remove();
                };
                // Returns an Object containing the baseNoteMidiValues (81, 79, 77...)
                // as keys and the vertical positions of the staff lines as values.
                var getStaffLinePositions = function () {
                    var staffLinePositionsArray = [];
                    var staffLinePositions = {};
                    element.find('.oppia-music-input-staff div.oppia-music-staff-position').each(function () {
                        staffLinePositionsArray.push($(this).position().top);
                    });
                    for (var i = 0; i < staffLinePositionsArray.length; i++) {
                        staffLinePositions[verticalGridKeys[i]] = (staffLinePositionsArray[i]);
                    }
                    return staffLinePositions;
                };
                // Creates the notes and helper-clone notes for the noteChoices div.
                var initPalette = function () {
                    var noteChoicesDiv = element.find('.oppia-music-input-note-choices');
                    var validNoteArea = element.find('.oppia-music-input-valid-note-area');
                    for (var i = 0; i < NOTE_TYPES.length; i++) {
                        var className = 'oppia-music-input-natural-note';
                        var innerDiv = $('<div></div>')
                            .data('noteType', NOTE_TYPES[i])
                            .addClass(function (index, currentClassName) {
                            var addedClass = null;
                            if ($(this).data('noteType') === NOTE_TYPE_NATURAL) {
                                addedClass = 'oppia-music-input-natural-note';
                                $(this).addClass('oppia-music-input-natural-note');
                            }
                            return addedClass;
                        });
                        if (scope.interactionIsActive) {
                            innerDiv.draggable({
                                // Keeps note from being placed on top of the clef.
                                containment: validNoteArea,
                                cursor: 'pointer',
                                helper: 'clone',
                                stack: '.oppia-music-input-note-choices div',
                                grid: [scope.HORIZONTAL_GRID_SPACING, 1],
                                stop: function (evt, ui) {
                                    if (!isCloneOffStaff($(ui.helper))) {
                                        // This makes the helper clone a new draggable note.
                                        var helperClone = $(ui.helper)
                                            // Retains original note type (e.g. natural, flat, sharp).
                                            .data('noteType', $(this).data('noteType'))
                                            .draggable({
                                            // The leftPosBeforeDrag helps with the sorting of user
                                            // sequence.
                                            start: function () {
                                                $(this).data('leftPosBeforeDrag', $(this).position().left);
                                            },
                                            containment: '.oppia-music-input-valid-note-area',
                                            cursor: 'pointer',
                                            grid: [scope.HORIZONTAL_GRID_SPACING, 1],
                                            // Stops helper clone from being cloned again.
                                            helper: 'original',
                                            stack: '.oppia-music-input-note-choices div',
                                            tolerance: 'intersect',
                                            revert: function () {
                                                var draggableOptions = $(this);
                                                // If note is out of droppable or off staff,
                                                // remove it.
                                                if (isCloneOffStaff(draggableOptions)) {
                                                    scope._removeNotesFromNoteSequenceWithId(draggableOptions.data('noteId'));
                                                    scope._sortNoteSequence();
                                                    draggableOptions.remove();
                                                }
                                            }
                                        });
                                    }
                                }
                            });
                        }
                        noteChoicesDiv.append(innerDiv);
                    }
                };
                var repaintNotes = function () {
                    var noteChoicesDiv = element.find('.oppia-music-input-note-choices');
                    for (var i = 0; i < scope.noteSequence.length; i++) {
                        var innerDiv = $('<div></div>')
                            .data('noteType', NOTE_TYPE_NATURAL)
                            .data('noteId', scope.noteSequence[i].note.noteId)
                            .addClass('oppia-music-input-natural-note')
                            .addClass('oppia-music-input-on-staff')
                            // Position notes horizontally by their noteStart positions and
                            // vertically by the midi value they hold.
                            .css({
                            top: getVerticalPosition(scope.noteSequence[i].note.baseNoteMidiNumber) -
                                scope.VERTICAL_GRID_SPACING / 2.0,
                            left: getHorizontalPosition(getNoteStartAsFloat(scope.noteSequence[i].note)),
                            position: 'absolute'
                        });
                        if (scope.interactionIsActive) {
                            innerDiv.draggable({
                                // Keeps note from being placed on top of the clef.
                                containment: '.oppia-music-input-valid-note-area',
                                cursor: 'pointer',
                                stack: '.oppia-music-input-note-choices div',
                                grid: [scope.HORIZONTAL_GRID_SPACING, 1],
                                start: function () {
                                    $(this).data('leftPosBeforeDrag', $(this).position().left);
                                },
                                revert: function () {
                                    var draggableOptions = $(this);
                                    // If note is out of droppable or off staff, remove it.
                                    if (isCloneOffStaff(draggableOptions)) {
                                        scope._removeNotesFromNoteSequenceWithId(draggableOptions.data('noteId'));
                                        scope._sortNoteSequence();
                                        draggableOptions.remove();
                                    }
                                }
                            });
                        }
                        noteChoicesDiv.append(innerDiv);
                    }
                    repaintLedgerLines();
                };
                // Creates a staff of droppable lines.
                var buildDroppableStaff = function () {
                    var lineValues = Object.keys(NOTE_NAMES_TO_MIDI_VALUES);
                    for (var i = 0; i < lineValues.length; i++) {
                        var staffLineDiv = $('<div></div>')
                            .addClass('oppia-music-staff-position')
                            .css('height', scope.VERTICAL_GRID_SPACING)
                            .data('lineValue', lineValues[i])
                            .droppable({
                            accept: '.oppia-music-input-note-choices div',
                            // Over and out are used to remove helper clone if
                            // note is not placed on staff.
                            over: function (evt, ui) {
                                var lineValue = $(evt.target).data('lineValue');
                                // Draws a ledger-line when note is hovering over staff-line.
                                if (isLedgerLineNote(lineValue)) {
                                    // Position of current dropped note.
                                    var leftPos = ui.helper.position().left;
                                    var topPos = $(evt.target).position().top;
                                    var noteId = $(ui.helper).data('noteId');
                                    if (noteId === undefined) {
                                        noteId = scope.generateNoteId();
                                        $(ui.helper).data('noteId', noteId);
                                    }
                                    drawLedgerLine(topPos, leftPos);
                                }
                            },
                            out: function () {
                                // Removes a ledger line when note is dragged out of
                                // droppable.
                                $('.oppia-music-input-ledger-line').last().hide();
                            },
                            hoverClass: 'oppia-music-input-hovered',
                            // Handles note drops and appends new note to noteSequence.
                            drop: function (evt, ui) {
                                // Makes helper clone not disappear when dropped on staff.
                                $.ui.ddmanager.current.cancelHelperRemoval = true;
                                $('.oppia-music-input-ledger-line').last().hide();
                                // Previous position of note or undefined.
                                var startPos = $(ui.helper).data('leftPosBeforeDrag');
                                // Position of current dropped note.
                                var leftPos = ui.helper.position().left;
                                var leftPosBeforeMove = leftPos;
                                var topPos = $(evt.target).position().top;
                                // The staff line's value.
                                var lineValue = $(this).data('lineValue');
                                var noteType = ui.draggable.data('noteType');
                                // A note that is dragged from noteChoices box
                                // has an undefined noteId. This sets the id.
                                // Otherwise, the note has an id.
                                var noteId = $(ui.helper).data('noteId');
                                if (noteId === undefined) {
                                    noteId = scope.generateNoteId();
                                    $(ui.helper).data('noteId', noteId);
                                }
                                // Creates a note object.
                                var note = {
                                    baseNoteMidiNumber: NOTE_NAMES_TO_MIDI_VALUES[lineValue],
                                    offset: parseInt(noteType, 10),
                                    noteId: noteId,
                                    noteStart: null
                                };
                                // When a note is moved, its previous state must be removed
                                // from the noteSequence. Otherwise, the sequence would
                                // erroneously hold notes that have been moved to other
                                // positions. Also this allows an on-staff note's position
                                // to be freed up if it is moved.
                                scope._removeNotesFromNoteSequenceWithId(note.noteId);
                                // Makes sure that a note can move vertically on it's
                                // position.
                                if (startPos !== leftPos) {
                                    // Moves the note to the next available spot on the staff.
                                    // If the staff is full, note is moved off staff,
                                    // and thus removed.
                                    while (checkIfNotePositionTaken(leftPos)) {
                                        leftPos += scope.HORIZONTAL_GRID_SPACING;
                                    }
                                    $(ui.helper).css({
                                        top: topPos,
                                        left: leftPos
                                    });
                                    if (Math.floor(leftPos) > Math.floor(getHorizontalPosition(MAXIMUM_NOTES_POSSIBLE - 1))) {
                                        $(ui.helper).remove();
                                        repaintLedgerLines();
                                        return;
                                    }
                                }
                                // Adjusts note so it is right on top of the staff line by
                                // calculating half of the VERTICAL_GRID_SPACING and
                                // subtracting that from its current top Position.
                                $(ui.helper).css({
                                    top: topPos - (scope.VERTICAL_GRID_SPACING / 2.0)
                                });
                                // Add noteStart property to note object.
                                if (getNoteStartFromLeftPos(leftPos) !== undefined) {
                                    note.noteStart =
                                        getNoteStartFromLeftPos(leftPos).note.noteStart;
                                }
                                else {
                                    repaintLedgerLines();
                                    return;
                                }
                                scope._addNoteToNoteSequence(note);
                                scope._sortNoteSequence();
                                // Sounds the note when it is dropped onto staff.
                                playSequence([[_convertNoteToMidiPitch(note)]]);
                                $(ui.helper).addClass('oppia-music-input-on-staff');
                                repaintLedgerLines();
                            }
                        });
                        element.find('.oppia-music-input-staff').append(staffLineDiv);
                        if (i === 0) {
                            scope.topPositionForCenterOfTopStaffLine =
                                $(staffLineDiv).position().top + scope.VERTICAL_GRID_SPACING;
                        }
                        var noteName = lineValues[i];
                        // Check if noteName is a valid staff line and if so, paint staff
                        // line.
                        if (NOTES_ON_LINES.indexOf(noteName) !== -1) {
                            staffLineDiv.append($('<div></div>')
                                // Positions and centers the staff line directly on top of its
                                // associated droppable.
                                .css('margin-top', scope.VERTICAL_GRID_SPACING / 2.5)
                                .addClass('oppia-music-staff-line'));
                        }
                    }
                };
                // When compareNoteStarts(a, b) returns less than 0, a is less than b.
                // When compareNoteStarts(a, b) returns 0, a is equal to b.
                // When compareNoteStarts(a, b) returns greater than 0, a is greater
                //   than b.
                var compareNoteStarts = function (a, b) {
                    if (a.note.noteStart && b.note.noteStart) {
                        return (a.note.noteStart.num * b.note.noteStart.den -
                            a.note.noteStart.den * b.note.noteStart.num) /
                            (a.note.noteStart.den * b.note.noteStart.den);
                    }
                };
                // If a note position is taken, return true,
                // otherwise the position is available
                var checkIfNotePositionTaken = function (leftPos) {
                    if (getNoteStartFromLeftPos(leftPos)) {
                        var newNoteToCheck = getNoteStartFromLeftPos(leftPos);
                        if (newNoteToCheck.note.noteStart !== undefined) {
                            for (var i = 0; i < scope.noteSequence.length; i++) {
                                var noteComparison = compareNoteStarts(scope.noteSequence[i], newNoteToCheck);
                                if (noteComparison === 0) {
                                    return true;
                                }
                            }
                            return false;
                        }
                    }
                    return false;
                };
                // Converts a note's leftPosition to a noteStart object by checking if
                // leftPos is close to available horizontal grid position. If there is
                // not a close match, return undefined.
                var getNoteStartFromLeftPos = function (leftPos) {
                    for (var i = 0; i < MAXIMUM_NOTES_POSSIBLE; i++) {
                        // If the difference between leftPos and a horizontalGrid Position
                        // is less than 2, then they are close enough to set a position.
                        // This gives some wiggle room for rounding differences.
                        if (Math.abs(leftPos - getHorizontalPosition(i)) < 2) {
                            var note = {
                                noteStart: {
                                    num: i,
                                    den: 1
                                }
                            };
                            return {
                                note: note
                            };
                        }
                    }
                    return undefined;
                };
                var getNoteStartAsFloat = function (note) {
                    return note.noteStart.num / note.noteStart.den;
                };
                // Clear noteSequence values and remove all notes
                // and Ledger Lines from the staff.
                scope.clearSequence = function () {
                    scope.noteSequence = [];
                    element.find('.oppia-music-input-on-staff').remove();
                    element.find('.oppia-music-input-ledger-line').remove();
                };
                // Converts the midiValue of a droppable line that a note is on
                // into a top position.
                var getVerticalPosition = function (baseNoteMidiNumber) {
                    return getStaffLinePositions()[baseNoteMidiNumber];
                };
                /**
                 * Gets a horizontal grid position based on the position of note-choices
                 * div. '.oppia-music-input-note-choices div:first-child' (the note that
                 * gets cloned to create all other subsequent notes) is the last
                 * horizontal position, so to determine the others values, we multiply
                 * the MAXIMUM_NOTES_POSSIBLE that will fit on the staff by the
                 * scope.HORIZONTAL_GRID_SPACING and subtract that from the last
                 * Horizontal Position value and return the result.
                 */
                var getHorizontalPosition = function (noteStartAsFloat) {
                    var lastHorizontalPositionOffset = element.find('.oppia-music-input-note-choices div:first-child').position().left;
                    var leftOffset = lastHorizontalPositionOffset - ((MAXIMUM_NOTES_POSSIBLE - 1) *
                        scope.HORIZONTAL_GRID_SPACING);
                    return leftOffset + (noteStartAsFloat * scope.HORIZONTAL_GRID_SPACING);
                };
                var isCloneOffStaff = function (helperClone) {
                    return (!(helperClone.position().top > scope.staffTop &&
                        helperClone.position().top < scope.staffBottom));
                };
                var isLedgerLineNote = function (lineValue) {
                    return LEDGER_LINE_NOTES.indexOf(lineValue) !== -1;
                };
                var drawLedgerLine = function (topPos, leftPos) {
                    var ledgerLineDiv = $('<div></div>')
                        .addClass('oppia-music-input-ledger-line oppia-music-input-natural-note')
                        .droppable({
                        accept: '.oppia-music-input-note-choices div',
                        // When a ledgerLine note is moved out of its droppable,
                        // remove ledger line.
                        out: function () {
                            $(this).hide();
                        },
                        hoverClass: 'oppia-music-input-hovered',
                        containment: '.oppia-music-input-valid-note-area'
                    })
                        // Adjust ledger line to be centered with the note.
                        .css({
                        left: leftPos - 1,
                        // 0.4 is a little less than half to allow for the height of the
                        // ledger line when considering its placement.
                        top: topPos + scope.VERTICAL_GRID_SPACING * 0.4
                    });
                    element.find('.oppia-music-input-staff').append(ledgerLineDiv);
                };
                var repaintLedgerLines = function () {
                    for (var i = 0; i < scope.noteSequence.length; i++) {
                        var note = scope.noteSequence[i].note;
                        var lineValue = _getCorrespondingNoteName(note.baseNoteMidiNumber);
                        if (isLedgerLineNote(lineValue)) {
                            drawLedgerLine(getVerticalPosition(note.baseNoteMidiNumber), getHorizontalPosition(getNoteStartAsFloat(note)));
                        }
                    }
                };
                var _getCorrespondingNoteName = function (midiNumber) {
                    var correspondingNoteName = null;
                    for (var noteName in NOTE_NAMES_TO_MIDI_VALUES) {
                        if (NOTE_NAMES_TO_MIDI_VALUES[noteName] === midiNumber) {
                            correspondingNoteName = noteName;
                            break;
                        }
                    }
                    if (correspondingNoteName === null) {
                        console.error('Invalid MIDI pitch: ' + midiNumber);
                    }
                    return correspondingNoteName;
                };
                /*
                 * Returns a note object with a readable note name, such as Eb5, A5 or
                 * F#4, given a note object with baseNoteMidiNumber and sharp/flat
                 * offset properties. For example, if note.baseNoteMidiNumber = 64 and
                 * note.offset = -1, this will return {'readableNoteName': 'Eb4'}
                 * (since 64 is the baseNoteMidiNumber for 'E', and -1 indicates a
                 * flat).
                 */
                var _convertNoteToReadableNote = function (note) {
                    if (note.offset !== -1 && note.offset !== 0 && note.offset !== 1) {
                        console.error('Invalid note offset: ' + note.offset);
                    }
                    var correspondingNoteName = _getCorrespondingNoteName(note.baseNoteMidiNumber);
                    var accidental = (note.offset === 1 ? '#' :
                        note.offset === 0 ? '' : 'b');
                    return {
                        readableNoteName: correspondingNoteName[0] + accidental + correspondingNoteName[1]
                    };
                };
                /*
                 * Returns a note object with a baseNoteMidiNumber and an
                 * offset property, given a note object with a readableNoteName
                 * property. For example, if note.readableNoteName = 'Eb4' this will
                 * return {'baseNoteMidiNumber': 64, 'offset': -1} (since 64 is the
                 * baseNoteMidiNumber for 'E', and -1 indicates a flat).
                 */
                var _convertReadableNoteToNote = function (readableNote) {
                    var readableNoteName = readableNote.readableNoteName;
                    if (readableNoteName.length === 2) {
                        // This is a natural note.
                        return {
                            baseNoteMidiNumber: NOTE_NAMES_TO_MIDI_VALUES[readableNoteName],
                            offset: 0
                        };
                    }
                    else if (readableNoteName.length === 3) {
                        // This is a note with an accidental.
                        var offset = (readableNoteName[1] === '#') ? 1 :
                            (readableNoteName[1] === 'b') ? -1 : null;
                        if (offset === null) {
                            console.error('Invalid readable note: ' + readableNoteName);
                        }
                        return {
                            baseNoteMidiNumber: NOTE_NAMES_TO_MIDI_VALUES[readableNoteName[0] + readableNoteName[2]],
                            offset: offset
                        };
                    }
                    else {
                        // This is not a valid readableNote.
                        console.error('Invalid readable note: ' + readableNote);
                    }
                };
                // For each note in a sequence, add a noteDuration property.
                // TODO(wagnerdmike): - add more options for note durations.
                var _makeAllNotesHaveDurationOne = function (noteArray) {
                    for (var i = 0; i < noteArray.length; i++) {
                        noteArray[i].noteDuration = {
                            num: 1,
                            den: 1
                        };
                    }
                    return noteArray;
                };
                scope.submitAnswer = function () {
                    var readableSequence = [];
                    for (var i = 0; i < scope.noteSequence.length; i++) {
                        readableSequence.push(_convertNoteToReadableNote(scope.noteSequence[i].note));
                    }
                    readableSequence = _makeAllNotesHaveDurationOne(readableSequence);
                    CurrentInteractionService.onSubmit(readableSequence, MusicNotesInputRulesService);
                };
                CurrentInteractionService.registerCurrentInteraction(scope.submitAnswer, null);
                /** *****************************************************************
                 * Functions involving MIDI playback.
                 ******************************************************************/
                scope.playSequenceToGuess = function () {
                    var noteSequenceToGuess = [];
                    for (var i = 0; i < scope.sequenceToGuess.length; i++) {
                        noteSequenceToGuess.push(_convertReadableNoteToNote(scope.sequenceToGuess[i]));
                    }
                    playSequence(convertSequenceToGuessToMidiSequence(noteSequenceToGuess));
                };
                scope.playCurrentSequence = function () {
                    playSequence(convertNoteSequenceToMidiSequence(scope.noteSequence));
                };
                // Takes an input > 0, converts to a noteStart object and returns a
                // float representation of the noteStart position.
                var getNoteStart = function (noteIndex) {
                    return getNoteStartAsFloat({
                        noteStart: {
                            num: noteIndex,
                            den: 1
                        }
                    });
                };
                // Input is a midiSequence, which is an array of arrays, in the form of
                // [[72], [62], [67, 71, 74]]. An inner array with more than one value
                // is treated like a chord and all its values are played back
                // simultaneously.
                var playSequence = function (midiSequence) {
                    var notes = [];
                    for (var i = 0; i < midiSequence.length; i++) {
                        for (var j = 0; j < midiSequence[i].length; j++) {
                            notes.push({
                                midiValue: midiSequence[i][j],
                                duration: 1.0,
                                start: getNoteStart(i)
                            });
                        }
                    }
                    MusicPhrasePlayerService.playMusicPhrase(notes);
                };
                // A MIDI pitch is the baseNoteMidiNumber of the note plus the offset.
                var _convertNoteToMidiPitch = function (note) {
                    return note.baseNoteMidiNumber + note.offset;
                };
                // Return the MIDI value for each note in the sequence.
                // TODO(wagnerdmike): - add chord functionality.
                var convertSequenceToGuessToMidiSequence = function (sequence) {
                    var midiSequence = [];
                    for (var i = 0; i < sequence.length; i++) {
                        if (sequence[i].hasOwnProperty('baseNoteMidiNumber')) {
                            midiSequence.push([_convertNoteToMidiPitch(sequence[i])]);
                        }
                        else {
                            console.error('Invalid note: ' + sequence[i]);
                        }
                    }
                    return midiSequence;
                };
                // Return the MIDI value for each note in the sequence.
                // TODO(wagnerdmike): - add chord functionality.
                var convertNoteSequenceToMidiSequence = function (sequence) {
                    var midiSequence = [];
                    for (var i = 0; i < sequence.length; i++) {
                        if (sequence[i].hasOwnProperty('note')) {
                            // Single note.
                            midiSequence.push([_convertNoteToMidiPitch(sequence[i].note)]);
                        }
                        else {
                            console.error('Invalid note: ' + sequence[i]);
                        }
                    }
                    return midiSequence;
                };
                // Initialization code.
                initializeNoteSequence(scope.initialSequence);
                scope.init();
                // Sets grid positions, displays the staff and note,
                // and then initializes the view after staff has loaded.
                $(document).ready(function () {
                    scope.reinitStaff();
                });
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/oppia-response-music-notes-input.directive.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/oppia-response-music-notes-input.directive.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directives for the MusicNotesInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseMusicNotesInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MusicNotesInput/directives/' +
                'music-notes-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    var _notes = [];
                    for (var i = 0; i < _answer.length; i++) {
                        if (_answer[i].readableNoteName) {
                            _notes.push(_answer[i].readableNoteName);
                        }
                    }
                    if (_notes.length > 0) {
                        ctrl.displayedAnswer = _notes.join(', ');
                    }
                    else {
                        ctrl.displayedAnswer = 'No answer given.';
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/directives/oppia-short-response-music-notes-input.directive.ts":
/*!****************************************************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/directives/oppia-short-response-music-notes-input.directive.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directives for the MusicNotesInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseMusicNotesInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/MusicNotesInput/directives/' +
                'music-notes-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    var _notes = [];
                    for (var i = 0; i < _answer.length; i++) {
                        if (_answer[i].readableNoteName) {
                            _notes.push(_answer[i].readableNoteName);
                        }
                    }
                    if (_notes.length > 0) {
                        ctrl.displayedAnswer = _notes.join(', ');
                    }
                    else {
                        ctrl.displayedAnswer = 'No answer given.';
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/MusicNotesInput/static/music_notes_input.css":
/*!******************************************************************************!*\
  !*** ./extensions/interactions/MusicNotesInput/static/music_notes_input.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!./music_notes_input.css */ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MusicNotesInput/static/music_notes_input.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/NumberWithUnits.ts":
/*!********************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/NumberWithUnits.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for NumberWithUnits interaction.
 */
__webpack_require__(/*! interactions/NumberWithUnits/directives/number-with-units-rules.service.ts */ "./extensions/interactions/NumberWithUnits/directives/number-with-units-rules.service.ts");
__webpack_require__(/*! interactions/NumberWithUnits/directives/number-with-units-validation.service.ts */ "./extensions/interactions/NumberWithUnits/directives/number-with-units-validation.service.ts");
__webpack_require__(/*! interactions/NumberWithUnits/directives/oppia-interactive-number-with-units.directive.ts */ "./extensions/interactions/NumberWithUnits/directives/oppia-interactive-number-with-units.directive.ts");
__webpack_require__(/*! interactions/NumberWithUnits/directives/oppia-response-number-with-units.directive.ts */ "./extensions/interactions/NumberWithUnits/directives/oppia-response-number-with-units.directive.ts");
__webpack_require__(/*! interactions/NumberWithUnits/directives/oppia-short-response-number-with-units.directive.ts */ "./extensions/interactions/NumberWithUnits/directives/oppia-short-response-number-with-units.directive.ts");


/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/directives/number-with-units-rules.service.ts":
/*!***********************************************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/directives/number-with-units-rules.service.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Rules service for the interaction.
 */
// TODO(#7403): Convert this to partial imports.
var mathjs_1 = __importDefault(__webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js"));
__webpack_require__(/*! domain/objects/FractionObjectFactory.ts */ "./core/templates/dev/head/domain/objects/FractionObjectFactory.ts");
__webpack_require__(/*! domain/objects/NumberWithUnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts");
// Rules service for number with units interaction.
angular.module('oppia').factory('NumberWithUnitsRulesService', [
    'NumberWithUnitsObjectFactory',
    function (NumberWithUnitsObjectFactory) {
        try {
            NumberWithUnitsObjectFactory.createCurrencyUnits();
        }
        catch (parsingError) { }
        return {
            IsEqualTo: function (answer, inputs) {
                // Returns true only if input is exactly equal to answer.
                answer = NumberWithUnitsObjectFactory.fromDict(answer);
                inputs = NumberWithUnitsObjectFactory.fromDict(inputs.f);
                var answerString = answer.toMathjsCompatibleString();
                var inputsString = inputs.toMathjsCompatibleString();
                var answerList = NumberWithUnitsObjectFactory.fromRawInputString(answerString).toDict();
                var inputsList = NumberWithUnitsObjectFactory.fromRawInputString(inputsString).toDict();
                return angular.equals(answerList, inputsList);
            },
            IsEquivalentTo: function (answer, inputs) {
                answer = NumberWithUnitsObjectFactory.fromDict(answer);
                inputs = NumberWithUnitsObjectFactory.fromDict(inputs.f);
                if (answer.type === 'fraction') {
                    answer.type = 'real';
                    answer.real = answer.fraction.toFloat();
                }
                if (inputs.type === 'fraction') {
                    inputs.type = 'real';
                    inputs.real = inputs.fraction.toFloat();
                }
                var answerString = answer.toMathjsCompatibleString();
                var inputsString = inputs.toMathjsCompatibleString();
                return mathjs_1.default.unit(answerString).equals(mathjs_1.default.unit(inputsString));
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/directives/number-with-units-validation.service.ts":
/*!****************************************************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/directives/number-with-units-validation.service.ts ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the number with units interaction.
 */
// TODO(#7403): Convert this to partial imports.
var mathjs_1 = __importDefault(__webpack_require__(/*! mathjs */ "./node_modules/mathjs/index.js"));
__webpack_require__(/*! domain/objects/NumberWithUnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts");
__webpack_require__(/*! interactions/base-interaction-validation.service.ts */ "./extensions/interactions/base-interaction-validation.service.ts");
angular.module('oppia').factory('NumberWithUnitsValidationService', [
    'NumberWithUnitsObjectFactory', 'baseInteractionValidationService',
    'WARNING_TYPES',
    function (NumberWithUnitsObjectFactory, baseInteractionValidationService, WARNING_TYPES) {
        return {
            getCustomizationArgsWarnings: function (customizationArgs) {
                return [];
            },
            getAllWarnings: function (stateName, customizationArgs, answerGroups, defaultOutcome) {
                var warningsList = [];
                warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
                try {
                    NumberWithUnitsObjectFactory.createCurrencyUnits();
                }
                catch (parsingError) { }
                var checkEquality = function (earlierRule, laterRule) {
                    var answer = NumberWithUnitsObjectFactory.fromDict(earlierRule.inputs.f);
                    var inputs = NumberWithUnitsObjectFactory.fromDict(laterRule.inputs.f);
                    var answerString = answer.toMathjsCompatibleString();
                    var inputsString = inputs.toMathjsCompatibleString();
                    var answerList = NumberWithUnitsObjectFactory.fromRawInputString(answerString).toDict();
                    var inputsList = NumberWithUnitsObjectFactory.fromRawInputString(inputsString).toDict();
                    return angular.equals(answerList, inputsList);
                };
                var checkEquivalency = function (earlierRule, laterRule) {
                    var earlierInput = NumberWithUnitsObjectFactory.fromDict(earlierRule.inputs.f);
                    var laterInput = NumberWithUnitsObjectFactory.fromDict(laterRule.inputs.f);
                    if (earlierInput.type === 'fraction') {
                        earlierInput.type = 'real';
                        earlierInput.real = earlierInput.fraction.toFloat();
                    }
                    if (laterInput.type === 'fraction') {
                        laterInput.type = 'real';
                        laterInput.real = laterInput.fraction.toFloat();
                    }
                    var earlierInputString = earlierInput.toMathjsCompatibleString();
                    var laterInputString = laterInput.toMathjsCompatibleString();
                    try {
                        return mathjs_1.default.unit(laterInputString).equals(mathjs_1.default.unit(earlierInputString));
                    }
                    catch (e) {
                        var additionalInfo = ('\nlaterInput: ' + JSON.stringify(laterInput.toDict()) +
                            '\nearlierInput: ' + JSON.stringify(earlierInput.toDict()));
                        e.message += additionalInfo;
                        throw e;
                    }
                };
                var ranges = [];
                for (var i = 0; i < answerGroups.length; i++) {
                    var rules = answerGroups[i].rules;
                    for (var j = 0; j < rules.length; j++) {
                        var rule = rules[j];
                        var range = {
                            answerGroupIndex: i + 1,
                            ruleIndex: j + 1,
                        };
                        for (var k = 0; k < ranges.length; k++) {
                            var earlierRule = answerGroups[ranges[k].answerGroupIndex - 1].
                                rules[ranges[k].ruleIndex - 1];
                            if (earlierRule.type === 'IsEqualTo' &&
                                rule.type === 'IsEqualTo') {
                                if (checkEquality(earlierRule, rule)) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) + ' will never be matched because it ' +
                                            'is made redundant by rule ' + ranges[k].ruleIndex +
                                            ' from answer group ' + ranges[k].answerGroupIndex +
                                            '.')
                                    });
                                }
                            }
                            if (earlierRule.type === 'IsEquivalentTo') {
                                if (checkEquivalency(earlierRule, rule)) {
                                    warningsList.push({
                                        type: WARNING_TYPES.ERROR,
                                        message: ('Rule ' + (j + 1) + ' from answer group ' +
                                            (i + 1) + ' will never be matched because it ' +
                                            'is made redundant by rule ' + ranges[k].ruleIndex +
                                            ' from answer group ' + ranges[k].answerGroupIndex +
                                            '.')
                                    });
                                }
                            }
                        }
                        ranges.push(range);
                    }
                }
                warningsList = warningsList.concat(baseInteractionValidationService.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
                return warningsList;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/directives/oppia-interactive-number-with-units.directive.ts":
/*!*************************************************************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/directives/oppia-interactive-number-with-units.directive.ts ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumberWithUnits interaction.
 */
__webpack_require__(/*! domain/objects/NumberWithUnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! interactions/NumberWithUnits/directives/number-with-units-rules.service.ts */ "./extensions/interactions/NumberWithUnits/directives/number-with-units-rules.service.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaInteractiveNumberWithUnits', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumberWithUnits/directives/' +
                'number-with-units-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', '$uibModal', 'NumberWithUnitsObjectFactory',
                'NumberWithUnitsRulesService', 'NUMBER_WITH_UNITS_PARSING_ERRORS',
                'CurrentInteractionService', function ($scope, $attrs, $uibModal, NumberWithUnitsObjectFactory, NumberWithUnitsRulesService, NUMBER_WITH_UNITS_PARSING_ERRORS, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.answer = '';
                    ctrl.labelForFocusTarget = $attrs.labelForFocusTarget || null;
                    var errorMessage = '';
                    // Label for errors caused whilst parsing number with units.
                    var FORM_ERROR_TYPE = 'NUMBER_WITH_UNITS_FORMAT_ERROR';
                    ctrl.NUMBER_WITH_UNITS_FORM_SCHEMA = {
                        type: 'unicode',
                        ui_config: {}
                    };
                    ctrl.getWarningText = function () {
                        return errorMessage;
                    };
                    try {
                        NumberWithUnitsObjectFactory.createCurrencyUnits();
                    }
                    catch (parsingError) { }
                    $scope.$watch('$ctrl.answer', function (newValue) {
                        try {
                            var numberWithUnits = NumberWithUnitsObjectFactory.fromRawInputString(newValue);
                            errorMessage = '';
                            ctrl.NumberWithUnitsForm.answer.$setValidity(FORM_ERROR_TYPE, true);
                        }
                        catch (parsingError) {
                            errorMessage = parsingError.message;
                            ctrl.NumberWithUnitsForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                        }
                    });
                    ctrl.submitAnswer = function (answer) {
                        try {
                            var numberWithUnits = NumberWithUnitsObjectFactory.fromRawInputString(answer);
                            CurrentInteractionService.onSubmit(numberWithUnits, NumberWithUnitsRulesService);
                        }
                        catch (parsingError) {
                            errorMessage = parsingError.message;
                            ctrl.NumberWithUnitsForm.answer.$setValidity(FORM_ERROR_TYPE, false);
                        }
                    };
                    ctrl.isAnswerValid = function () {
                        if (ctrl.NumberWithUnitsForm === undefined) {
                            return true;
                        }
                        return (!ctrl.NumberWithUnitsForm.$invalid &&
                            ctrl.answer !== '');
                    };
                    var submitAnswerFn = function () {
                        ctrl.submitAnswer(ctrl.answer);
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswerFn, ctrl.isAnswerValid);
                    ctrl.showHelp = function () {
                        $uibModal.open({
                            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumberWithUnits/directives/' +
                                'number-with-units-help-modal.directive.html'),
                            backdrop: true,
                            controller: [
                                '$scope', '$uibModalInstance',
                                function ($scope, $uibModalInstance) {
                                    $scope.close = function () {
                                        $uibModalInstance.close();
                                    };
                                }
                            ]
                        }).result.then(function () { });
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/directives/oppia-response-number-with-units.directive.ts":
/*!**********************************************************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/directives/oppia-response-number-with-units.directive.ts ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumberWithUnits response.
 */
__webpack_require__(/*! domain/objects/NumberWithUnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseNumberWithUnits', [
    'HtmlEscaperService', 'NumberWithUnitsObjectFactory',
    'UrlInterpolationService', function (HtmlEscaperService, NumberWithUnitsObjectFactory, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumberWithUnits/directives/' +
                'number-with-units-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.answer = NumberWithUnitsObjectFactory.fromDict(answer).toString();
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumberWithUnits/directives/oppia-short-response-number-with-units.directive.ts":
/*!****************************************************************************************************************!*\
  !*** ./extensions/interactions/NumberWithUnits/directives/oppia-short-response-number-with-units.directive.ts ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumberWithUnits short response.
 */
__webpack_require__(/*! domain/objects/NumberWithUnitsObjectFactory.ts */ "./core/templates/dev/head/domain/objects/NumberWithUnitsObjectFactory.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseNumberWithUnits', [
    'HtmlEscaperService', 'NumberWithUnitsObjectFactory',
    'UrlInterpolationService', function (HtmlEscaperService, NumberWithUnitsObjectFactory, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumberWithUnits/directives/' +
                'number-with-units-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.answer = NumberWithUnitsObjectFactory.fromDict(answer).toString();
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumericInput/NumericInput.ts":
/*!**************************************************************!*\
  !*** ./extensions/interactions/NumericInput/NumericInput.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for NumericInput interaction.
 */
__webpack_require__(/*! interactions/NumericInput/directives/numeric-input-rules.service.ts */ "./extensions/interactions/NumericInput/directives/numeric-input-rules.service.ts");
__webpack_require__(/*! interactions/NumericInput/directives/numeric-input-validation.service.ts */ "./extensions/interactions/NumericInput/directives/numeric-input-validation.service.ts");
__webpack_require__(/*! interactions/NumericInput/directives/oppia-interactive-numeric-input.directive.ts */ "./extensions/interactions/NumericInput/directives/oppia-interactive-numeric-input.directive.ts");
__webpack_require__(/*! interactions/NumericInput/directives/oppia-response-numeric-input.directive.ts */ "./extensions/interactions/NumericInput/directives/oppia-response-numeric-input.directive.ts");
__webpack_require__(/*! interactions/NumericInput/directives/oppia-short-response-numeric-input.directive.ts */ "./extensions/interactions/NumericInput/directives/oppia-short-response-numeric-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/NumericInput/directives/numeric-input-rules.service.ts":
/*!****************************************************************************************!*\
  !*** ./extensions/interactions/NumericInput/directives/numeric-input-rules.service.ts ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
angular.module('oppia').factory('NumericInputRulesService', [function () {
        return {
            Equals: function (answer, inputs) {
                return answer === inputs.x;
            },
            IsLessThan: function (answer, inputs) {
                return answer < inputs.x;
            },
            IsGreaterThan: function (answer, inputs) {
                return answer > inputs.x;
            },
            IsLessThanOrEqualTo: function (answer, inputs) {
                return answer <= inputs.x;
            },
            IsGreaterThanOrEqualTo: function (answer, inputs) {
                return answer >= inputs.x;
            },
            IsInclusivelyBetween: function (answer, inputs) {
                // TODO(wxy): have frontend validation at creation time to check that
                // inputs.a <= inputs.b
                return answer >= inputs.a && answer <= inputs.b;
            },
            IsWithinTolerance: function (answer, inputs) {
                return answer >= inputs.x - inputs.tol &&
                    answer <= inputs.x + inputs.tol;
            }
        };
    }]);


/***/ }),

/***/ "./extensions/interactions/NumericInput/directives/numeric-input-validation.service.ts":
/*!*********************************************************************************************!*\
  !*** ./extensions/interactions/NumericInput/directives/numeric-input-validation.service.ts ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var NumericInputValidationService = /** @class */ (function () {
    function NumericInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    NumericInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        return [];
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    NumericInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        var warningsList = [];
        warningsList = warningsList.concat(this.getCustomizationArgsWarnings(customizationArgs));
        /*
        Store an answer range for every rule, then check for redundant
        ranges. A range is an object of the form:
        {
          lb: float, lower bound
          ub: float, upper bound
          lbi: bool, is lower bound inclusive
          ubi: bool, is upper bound inclusive
        }
        */
        var setLowerAndUpperBounds = function (range, lb, ub, lbi, ubi) {
            range.lb = lb;
            range.ub = ub;
            range.lbi = lbi;
            range.ubi = ubi;
        };
        var isEnclosedBy = function (ra, rb) {
            // Checks if range ra is enclosed by range rb.
            var lowerBoundConditionIsSatisfied = (rb.lb < ra.lb) || (rb.lb === ra.lb && (!ra.lbi || rb.lbi));
            var upperBoundConditionIsSatisfied = (rb.ub > ra.ub) || (rb.ub === ra.ub && (!ra.ubi || rb.ubi));
            return lowerBoundConditionIsSatisfied &&
                upperBoundConditionIsSatisfied;
        };
        var ranges = [];
        for (var i = 0; i < answerGroups.length; i++) {
            var rules = answerGroups[i].rules;
            for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                var range = {
                    answerGroupIndex: i + 1,
                    ruleIndex: j + 1,
                    lb: null,
                    ub: null,
                    lbi: false,
                    ubi: false,
                };
                switch (rule.type) {
                    case 'Equals':
                        var x = rule.inputs.x;
                        setLowerAndUpperBounds(range, x, x, true, true);
                        break;
                    case 'IsInclusivelyBetween':
                        var a = rule.inputs.a;
                        var b = rule.inputs.b;
                        setLowerAndUpperBounds(range, a, b, true, true);
                        break;
                    case 'IsGreaterThan':
                        var x = rule.inputs.x;
                        setLowerAndUpperBounds(range, x, Infinity, false, false);
                        break;
                    case 'IsGreaterThanOrEqualTo':
                        var x = rule.inputs.x;
                        setLowerAndUpperBounds(range, x, Infinity, true, false);
                        break;
                    case 'IsLessThan':
                        var x = rule.inputs.x;
                        setLowerAndUpperBounds(range, -Infinity, x, false, false);
                        break;
                    case 'IsLessThanOrEqualTo':
                        var x = rule.inputs.x;
                        setLowerAndUpperBounds(range, -Infinity, x, false, true);
                        break;
                    case 'IsWithinTolerance':
                        var x = rule.inputs.x;
                        var tol = rule.inputs.tol;
                        setLowerAndUpperBounds(range, x - tol, x + tol, true, true);
                        break;
                    default:
                }
                for (var k = 0; k < ranges.length; k++) {
                    if (isEnclosedBy(range, ranges[k])) {
                        warningsList.push({
                            type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                            message: ('Rule ' + (j + 1) + ' from answer group ' +
                                (i + 1) + ' will never be matched because it ' +
                                'is made redundant by rule ' + ranges[k].ruleIndex +
                                ' from answer group ' + ranges[k].answerGroupIndex + '.')
                        });
                    }
                }
                ranges.push(range);
            }
        }
        warningsList = warningsList.concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
        return warningsList;
    };
    var _a;
    NumericInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], NumericInputValidationService);
    return NumericInputValidationService;
}());
exports.NumericInputValidationService = NumericInputValidationService;
angular.module('oppia').factory('NumericInputValidationService', static_1.downgradeInjectable(NumericInputValidationService));


/***/ }),

/***/ "./extensions/interactions/NumericInput/directives/oppia-interactive-numeric-input.directive.ts":
/*!******************************************************************************************************!*\
  !*** ./extensions/interactions/NumericInput/directives/oppia-interactive-numeric-input.directive.ts ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumericInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/NumericInput/directives/numeric-input-rules.service.ts */ "./extensions/interactions/NumericInput/directives/numeric-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
angular.module('oppia').directive('oppiaInteractiveNumericInput', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumericInput/directives/' +
                'numeric-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'FocusManagerService', 'NumericInputRulesService',
                'WindowDimensionsService', 'CurrentInteractionService',
                function ($attrs, FocusManagerService, NumericInputRulesService, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.answer = '';
                    ctrl.labelForFocusTarget = $attrs.labelForFocusTarget || null;
                    ctrl.NUMERIC_INPUT_FORM_SCHEMA = {
                        type: 'float',
                        ui_config: {}
                    };
                    var isAnswerValid = function () {
                        return (ctrl.answer !== undefined &&
                            ctrl.answer !== null && ctrl.answer !== '');
                    };
                    ctrl.submitAnswer = function (answer) {
                        if (isAnswerValid()) {
                            CurrentInteractionService.onSubmit(answer, NumericInputRulesService);
                        }
                    };
                    var submitAnswerFn = function () {
                        ctrl.submitAnswer(ctrl.answer);
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswerFn, isAnswerValid);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumericInput/directives/oppia-response-numeric-input.directive.ts":
/*!***************************************************************************************************!*\
  !*** ./extensions/interactions/NumericInput/directives/oppia-response-numeric-input.directive.ts ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumericInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseNumericInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumericInput/directives/' +
                'numeric-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    // If the answer is an integer, omit the fractional part.
                    if (ctrl.answer % 1 === 0) {
                        ctrl.answer = Math.round(ctrl.answer);
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/NumericInput/directives/oppia-short-response-numeric-input.directive.ts":
/*!*********************************************************************************************************!*\
  !*** ./extensions/interactions/NumericInput/directives/oppia-short-response-numeric-input.directive.ts ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the NumericInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseNumericInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/NumericInput/directives/' +
                'numeric-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    // If the answer is an integer, omit the fractional part.
                    if (ctrl.answer % 1 === 0) {
                        ctrl.answer = Math.round(ctrl.answer);
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/PencilCodeEditor.ts":
/*!**********************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/PencilCodeEditor.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for PencilCodeEditor interaction.
 */
__webpack_require__(/*! interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts */ "./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/directives/pencil-code-editor-validation.service.ts */ "./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-validation.service.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/directives/oppia-interactive-pencil-code-editor.directive.ts */ "./extensions/interactions/PencilCodeEditor/directives/oppia-interactive-pencil-code-editor.directive.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/directives/oppia-response-pencil-code-editor.directive.ts */ "./extensions/interactions/PencilCodeEditor/directives/oppia-response-pencil-code-editor.directive.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/directives/oppia-short-response-pencil-code-editor.directive.ts */ "./extensions/interactions/PencilCodeEditor/directives/oppia-short-response-pencil-code-editor.directive.ts");


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/directives/oppia-interactive-pencil-code-editor.directive.ts":
/*!***************************************************************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/directives/oppia-interactive-pencil-code-editor.directive.ts ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the PencilCodeEditor interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts */ "./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
angular.module('oppia').directive('oppiaInteractivePencilCodeEditor', [
    'HtmlEscaperService', 'UrlInterpolationService', 'EVENT_NEW_CARD_AVAILABLE',
    function (HtmlEscaperService, UrlInterpolationService, EVENT_NEW_CARD_AVAILABLE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getLastAnswer: '&lastAnswer'
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/PencilCodeEditor/directives/' +
                'pencil-code-editor-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', '$element', '$timeout', '$uibModal',
                'FocusManagerService', 'PencilCodeEditorRulesService',
                'CurrentInteractionService',
                function ($scope, $attrs, $element, $timeout, $uibModal, FocusManagerService, PencilCodeEditorRulesService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.interactionIsActive = (ctrl.getLastAnswer() === null);
                    ctrl.initialCode = ctrl.interactionIsActive ?
                        HtmlEscaperService.escapedJsonToObj($attrs.initialCodeWithValue) :
                        ctrl.getLastAnswer().code;
                    var iframeDiv = $element.find('.pencil-code-editor-iframe').get(0);
                    var pce = new PencilCodeEmbed(iframeDiv);
                    pce.beginLoad(ctrl.initialCode);
                    $scope.$on(EVENT_NEW_CARD_AVAILABLE, function () {
                        ctrl.interactionIsActive = false;
                        pce.hideMiddleButton();
                        pce.hideToggleButton();
                        pce.setReadOnly();
                    });
                    pce.on('load', function () {
                        // Hides the error console at the bottom right, and prevents it
                        // from showing up even if the code has an error. Also, hides the
                        // turtle, and redefines say() to also write the text on the
                        // screen.
                        pce.setupScript([{
                                code: [
                                    'window.onerror = function() {',
                                    '  return true;',
                                    '};',
                                    'debug.hide();',
                                    'window.removeEventListener("error", debug)',
                                    '',
                                    'ht();',
                                    '',
                                    'oldsay = window.say',
                                    'say = function(x) {',
                                    '  write(x);',
                                    '  oldsay(x);',
                                    '};'
                                ].join('\n'),
                                type: 'text/javascript'
                            }]);
                        pce.showEditor();
                        pce.hideToggleButton();
                        if (ctrl.interactionIsActive) {
                            pce.setEditable();
                        }
                        else {
                            pce.hideMiddleButton();
                            pce.setReadOnly();
                        }
                        // Pencil Code automatically takes the focus on load, so we clear
                        // it.
                        FocusManagerService.clearFocus();
                    });
                    ctrl.reset = function () {
                        $uibModal.open({
                            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/PencilCodeEditor/directives/' +
                                'pencil-code-reset-confirmation.directive.html'),
                            backdrop: 'static',
                            keyboard: false,
                            controller: [
                                '$scope', '$uibModalInstance',
                                function ($scope, $uibModalInstance) {
                                    $scope.cancel = function () {
                                        $uibModalInstance.dismiss();
                                    };
                                    $scope.resetCode = function () {
                                        $uibModalInstance.close();
                                    };
                                }
                            ]
                        }).result.then(function () {
                            pce.setCode(ctrl.initialCode);
                        });
                    };
                    var getNormalizedCode = function () {
                        // Converts tabs to spaces.
                        return pce.getCode().replace(/\t/g, '  ');
                    };
                    var errorIsHappening = false;
                    var hasSubmittedAnswer = false;
                    pce.on('startExecute', function () {
                        hasSubmittedAnswer = false;
                    });
                    pce.on('execute', function () {
                        if (errorIsHappening || hasSubmittedAnswer) {
                            return;
                        }
                        pce.eval('document.body.innerHTML', function (pencilCodeHtml) {
                            var normalizedCode = getNormalizedCode();
                            // Get all the divs, and extract their textual content.
                            var output = $.map($(pencilCodeHtml).filter('div'), function (elem) {
                                return $(elem).text();
                            }).join('\n');
                            hasSubmittedAnswer = true;
                            CurrentInteractionService.onSubmit({
                                code: normalizedCode,
                                output: output || '',
                                evaluation: '',
                                error: ''
                            }, PencilCodeEditorRulesService);
                        }, true);
                    });
                    pce.on('error', function (error) {
                        if (hasSubmittedAnswer) {
                            return;
                        }
                        var normalizedCode = getNormalizedCode();
                        errorIsHappening = true;
                        hasSubmittedAnswer = true;
                        CurrentInteractionService.onSubmit({
                            code: normalizedCode,
                            output: '',
                            evaluation: '',
                            error: error.message
                        }, PencilCodeEditorRulesService);
                        $timeout(function () {
                            errorIsHappening = false;
                        }, 1000);
                    });
                    CurrentInteractionService.registerCurrentInteraction(null, null);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/directives/oppia-response-pencil-code-editor.directive.ts":
/*!************************************************************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/directives/oppia-response-pencil-code-editor.directive.ts ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the PencilCodeEditor response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponsePencilCodeEditor', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/PencilCodeEditor/directives/' +
                'pencil-code-editor-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answerCode = HtmlEscaperService.escapedJsonToObj($attrs.answer).code;
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/directives/oppia-short-response-pencil-code-editor.directive.ts":
/*!******************************************************************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/directives/oppia-short-response-pencil-code-editor.directive.ts ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the PencilCodeEditor short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! filters/string-utility-filters/truncate-at-first-line.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponsePencilCodeEditor', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/PencilCodeEditor/directives/' +
                'pencil-code-editor-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answerCode = HtmlEscaperService.escapedJsonToObj($attrs.answer).code;
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts":
/*!*************************************************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-rules.service.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! filters/string-utility-filters/normalize-whitespace.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace.filter.ts");
__webpack_require__(/*! filters/string-utility-filters/normalize-whitespace-punctuation-and-case.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace-punctuation-and-case.filter.ts");
__webpack_require__(/*! services/CodeNormalizerService.ts */ "./core/templates/dev/head/services/CodeNormalizerService.ts");
angular.module('oppia').factory('PencilCodeEditorRulesService', [
    '$filter', 'CodeNormalizerService',
    function ($filter, CodeNormalizerService) {
        return {
            CodeEquals: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedExpectedCode = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode === normalizedExpectedCode;
            },
            CodeContains: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedSnippet = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode.indexOf(normalizedSnippet) !== -1;
            },
            CodeDoesNotContain: function (answer, inputs) {
                var normalizedCode = CodeNormalizerService.getNormalizedCode(answer.code);
                var normalizedSnippet = CodeNormalizerService.getNormalizedCode(inputs.x);
                return normalizedCode.indexOf(normalizedSnippet) === -1;
            },
            OutputEquals: function (answer, inputs) {
                var normalizedOutput = $filter('normalizeWhitespace')(answer.output);
                var normalizedExpectedOutput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedOutput === normalizedExpectedOutput;
            },
            OutputRoughlyEquals: function (answer, inputs) {
                var normalizedOutput = $filter('normalizeWhitespacePunctuationAndCase')(answer.output);
                var normalizedExpectedOutput = $filter('normalizeWhitespacePunctuationAndCase')(inputs.x);
                return normalizedOutput === normalizedExpectedOutput;
            },
            ResultsInError: function (answer) {
                return !!(answer.error.trim());
            },
            ErrorContains: function (answer, inputs) {
                var normalizedError = $filter('normalizeWhitespace')(answer.error);
                var normalizedSnippet = $filter('normalizeWhitespace')(inputs.x);
                return normalizedError.indexOf(normalizedSnippet) !== -1;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-validation.service.ts":
/*!******************************************************************************************************!*\
  !*** ./extensions/interactions/PencilCodeEditor/directives/pencil-code-editor-validation.service.ts ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var PencilCodeEditorValidationService = /** @class */ (function () {
    function PencilCodeEditorValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    PencilCodeEditorValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        // TODO(juansaba): Implement customization args validations.
        return [];
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    PencilCodeEditorValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        return this.getCustomizationArgsWarnings(customizationArgs).concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
    };
    var _a;
    PencilCodeEditorValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], PencilCodeEditorValidationService);
    return PencilCodeEditorValidationService;
}());
exports.PencilCodeEditorValidationService = PencilCodeEditorValidationService;
angular.module('oppia').factory('PencilCodeEditorValidationService', static_1.downgradeInjectable(PencilCodeEditorValidationService));


/***/ }),

/***/ "./extensions/interactions/SetInput/SetInput.ts":
/*!******************************************************!*\
  !*** ./extensions/interactions/SetInput/SetInput.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for SetInput interaction.
 */
__webpack_require__(/*! interactions/SetInput/directives/set-input-rules.service.ts */ "./extensions/interactions/SetInput/directives/set-input-rules.service.ts");
__webpack_require__(/*! interactions/SetInput/directives/set-input-validation.service.ts */ "./extensions/interactions/SetInput/directives/set-input-validation.service.ts");
__webpack_require__(/*! interactions/SetInput/directives/oppia-interactive-set-input.directive.ts */ "./extensions/interactions/SetInput/directives/oppia-interactive-set-input.directive.ts");
__webpack_require__(/*! interactions/SetInput/directives/oppia-response-set-input.directive.ts */ "./extensions/interactions/SetInput/directives/oppia-response-set-input.directive.ts");
__webpack_require__(/*! interactions/SetInput/directives/oppia-short-response-set-input.directive.ts */ "./extensions/interactions/SetInput/directives/oppia-short-response-set-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/SetInput/directives/oppia-interactive-set-input.directive.ts":
/*!**********************************************************************************************!*\
  !*** ./extensions/interactions/SetInput/directives/oppia-interactive-set-input.directive.ts ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the SetInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/SetInput/directives/set-input-rules.service.ts */ "./extensions/interactions/SetInput/directives/set-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
angular.module('oppia').directive('oppiaInteractiveSetInput', [
    'UrlInterpolationService', function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/SetInput/directives/' +
                'set-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', '$translate', 'SetInputRulesService',
                'WindowDimensionsService', 'CurrentInteractionService',
                function ($attrs, $translate, SetInputRulesService, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.schema = {
                        type: 'list',
                        items: {
                            type: 'unicode'
                        },
                        ui_config: {
                            // TODO(mili): Translate this in the HTML.
                            add_element_text: $translate.instant('I18N_INTERACTIONS_SET_INPUT_ADD_ITEM')
                        }
                    };
                    // Adds an input field by default
                    ctrl.answer = [''];
                    var hasDuplicates = function (answer) {
                        for (var i = 0; i < answer.length; i++) {
                            for (var j = 0; j < i; j++) {
                                if (angular.equals(answer[i], answer[j])) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    var hasBlankOption = function (answer) {
                        return answer.some(function (element) {
                            return (element === '');
                        });
                    };
                    ctrl.submitAnswer = function (answer) {
                        if (hasDuplicates(answer)) {
                            ctrl.errorMessage = ('I18N_INTERACTIONS_SET_INPUT_DUPLICATES_ERROR');
                        }
                        else {
                            ctrl.errorMessage = '';
                            CurrentInteractionService.onSubmit(answer, SetInputRulesService);
                        }
                    };
                    ctrl.isAnswerValid = function () {
                        return (ctrl.answer.length > 0 &&
                            !hasBlankOption(ctrl.answer));
                    };
                    var submitAnswerFn = function () {
                        ctrl.submitAnswer(ctrl.answer);
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswerFn, ctrl.isAnswerValid);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/SetInput/directives/oppia-response-set-input.directive.ts":
/*!*******************************************************************************************!*\
  !*** ./extensions/interactions/SetInput/directives/oppia-response-set-input.directive.ts ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Set Input response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseSetInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/SetInput/directives/' +
                'set-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/SetInput/directives/oppia-short-response-set-input.directive.ts":
/*!*************************************************************************************************!*\
  !*** ./extensions/interactions/SetInput/directives/oppia-short-response-set-input.directive.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the Set Input short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseSetInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/SetInput/directives/' +
                'set-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    var _answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                    ctrl.displayedAnswer = (_answer.length > 0 ? _answer.join(', ') :
                        'I18N_INTERACTIONS_SET_INPUT_NO_ANSWER');
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/SetInput/directives/set-input-rules.service.ts":
/*!********************************************************************************!*\
  !*** ./extensions/interactions/SetInput/directives/set-input-rules.service.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
angular.module('oppia').factory('SetInputRulesService', [function () {
        return {
            Equals: function (answer, inputs) {
                return answer.length === inputs.x.length && inputs.x.every(function (val) {
                    return answer.indexOf(val) >= 0;
                });
            },
            IsSubsetOf: function (answer, inputs) {
                return answer.length < inputs.x.length && answer.every(function (val) {
                    return inputs.x.indexOf(val) >= 0;
                });
            },
            IsSupersetOf: function (answer, inputs) {
                return answer.length > inputs.x.length && inputs.x.every(function (val) {
                    return answer.indexOf(val) >= 0;
                });
            },
            HasElementsIn: function (answer, inputs) {
                return inputs.x.some(function (val) {
                    return answer.indexOf(val) >= 0;
                });
            },
            HasElementsNotIn: function (answer, inputs) {
                return answer.some(function (val) {
                    return inputs.x.indexOf(val) === -1;
                });
            },
            OmitsElementsIn: function (answer, inputs) {
                return inputs.x.some(function (val) {
                    return answer.indexOf(val) === -1;
                });
            },
            IsDisjointFrom: function (answer, inputs) {
                return inputs.x.every(function (val) {
                    return answer.indexOf(val) === -1;
                });
            }
        };
    }]);


/***/ }),

/***/ "./extensions/interactions/SetInput/directives/set-input-validation.service.ts":
/*!*************************************************************************************!*\
  !*** ./extensions/interactions/SetInput/directives/set-input-validation.service.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Validator service for the interaction.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var base_interaction_validation_service_1 = __webpack_require__(/*! interactions/base-interaction-validation.service */ "./extensions/interactions/base-interaction-validation.service.ts");
var SetInputValidationService = /** @class */ (function () {
    function SetInputValidationService(baseInteractionValidationServiceInstance) {
        this.baseInteractionValidationServiceInstance = baseInteractionValidationServiceInstance;
    }
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    SetInputValidationService.prototype.getCustomizationArgsWarnings = function (customizationArgs) {
        // TODO(juansaba): Implement customization args validations.
        return [];
    };
    // TODO(#7176): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'customizationArgs' is a dict with possible underscore_cased
    // keys which give tslint errors against underscore_casing in favor of
    // camelCasing.
    SetInputValidationService.prototype.getAllWarnings = function (stateName, customizationArgs, answerGroups, defaultOutcome) {
        return this.getCustomizationArgsWarnings(customizationArgs).concat(this.baseInteractionValidationServiceInstance.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
    };
    var _a;
    SetInputValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [typeof (_a = typeof base_interaction_validation_service_1.baseInteractionValidationService !== "undefined" && base_interaction_validation_service_1.baseInteractionValidationService) === "function" ? _a : Object])
    ], SetInputValidationService);
    return SetInputValidationService;
}());
exports.SetInputValidationService = SetInputValidationService;
angular.module('oppia').factory('SetInputValidationService', static_1.downgradeInjectable(SetInputValidationService));


/***/ }),

/***/ "./extensions/interactions/TextInput/TextInput.ts":
/*!********************************************************!*\
  !*** ./extensions/interactions/TextInput/TextInput.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for TextInput interaction.
 */
__webpack_require__(/*! interactions/TextInput/text-input-prediction.service.ts */ "./extensions/interactions/TextInput/text-input-prediction.service.ts");
__webpack_require__(/*! interactions/TextInput/directives/text-input-rules.service.ts */ "./extensions/interactions/TextInput/directives/text-input-rules.service.ts");
__webpack_require__(/*! interactions/TextInput/directives/text-input-validation.service.ts */ "./extensions/interactions/TextInput/directives/text-input-validation.service.ts");
__webpack_require__(/*! interactions/TextInput/directives/oppia-interactive-text-input.directive.ts */ "./extensions/interactions/TextInput/directives/oppia-interactive-text-input.directive.ts");
__webpack_require__(/*! interactions/TextInput/directives/oppia-response-text-input.directive.ts */ "./extensions/interactions/TextInput/directives/oppia-response-text-input.directive.ts");
__webpack_require__(/*! interactions/TextInput/directives/oppia-short-response-text-input.directive.ts */ "./extensions/interactions/TextInput/directives/oppia-short-response-text-input.directive.ts");


/***/ }),

/***/ "./extensions/interactions/TextInput/directives/oppia-interactive-text-input.directive.ts":
/*!************************************************************************************************!*\
  !*** ./extensions/interactions/TextInput/directives/oppia-interactive-text-input.directive.ts ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the TextInput interaction.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! interactions/TextInput/directives/text-input-rules.service.ts */ "./extensions/interactions/TextInput/directives/text-input-rules.service.ts");
__webpack_require__(/*! pages/exploration-player-page/services/current-interaction.service.ts */ "./core/templates/dev/head/pages/exploration-player-page/services/current-interaction.service.ts");
__webpack_require__(/*! services/contextual/WindowDimensionsService.ts */ "./core/templates/dev/head/services/contextual/WindowDimensionsService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
__webpack_require__(/*! services/stateful/FocusManagerService.ts */ "./core/templates/dev/head/services/stateful/FocusManagerService.ts");
angular.module('oppia').directive('oppiaInteractiveTextInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/TextInput/directives/' +
                'text-input-interaction.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$attrs', 'FocusManagerService', 'TextInputRulesService',
                'WindowDimensionsService', 'CurrentInteractionService',
                function ($attrs, FocusManagerService, TextInputRulesService, WindowDimensionsService, CurrentInteractionService) {
                    var ctrl = this;
                    ctrl.placeholder = HtmlEscaperService.escapedJsonToObj($attrs.placeholderWithValue);
                    ctrl.rows = (HtmlEscaperService.escapedJsonToObj($attrs.rowsWithValue));
                    ctrl.answer = '';
                    ctrl.labelForFocusTarget = $attrs.labelForFocusTarget || null;
                    ctrl.schema = {
                        type: 'unicode',
                        ui_config: {}
                    };
                    if (ctrl.placeholder) {
                        ctrl.schema.ui_config.placeholder = ctrl.placeholder;
                    }
                    if (ctrl.rows && ctrl.rows !== 1) {
                        ctrl.schema.ui_config.rows = ctrl.rows;
                    }
                    ctrl.submitAnswer = function (answer) {
                        if (!answer) {
                            return;
                        }
                        CurrentInteractionService.onSubmit(answer, TextInputRulesService);
                    };
                    var submitAnswerFn = function () {
                        ctrl.submitAnswer(ctrl.answer);
                    };
                    var validityCheckFn = function () {
                        return ctrl.answer.length > 0;
                    };
                    CurrentInteractionService.registerCurrentInteraction(submitAnswerFn, validityCheckFn);
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/TextInput/directives/oppia-response-text-input.directive.ts":
/*!*********************************************************************************************!*\
  !*** ./extensions/interactions/TextInput/directives/oppia-response-text-input.directive.ts ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the TextInput response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaResponseTextInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/TextInput/directives/' +
                'text-input-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/TextInput/directives/oppia-short-response-text-input.directive.ts":
/*!***************************************************************************************************!*\
  !*** ./extensions/interactions/TextInput/directives/oppia-short-response-text-input.directive.ts ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for the TextInput short response.
 *
 * IMPORTANT NOTE: The naming convention for customization args that are passed
 * into the directive is: the name of the parameter, followed by 'With',
 * followed by the name of the arg.
 */
__webpack_require__(/*! filters/string-utility-filters/truncate-at-first-line.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/truncate-at-first-line.filter.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/HtmlEscaperService.ts */ "./core/templates/dev/head/services/HtmlEscaperService.ts");
angular.module('oppia').directive('oppiaShortResponseTextInput', [
    'HtmlEscaperService', 'UrlInterpolationService',
    function (HtmlEscaperService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {},
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/TextInput/directives/' +
                'text-input-short-response.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$attrs', function ($attrs) {
                    var ctrl = this;
                    ctrl.answer = HtmlEscaperService.escapedJsonToObj($attrs.answer);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/TextInput/directives/text-input-rules.service.ts":
/*!**********************************************************************************!*\
  !*** ./extensions/interactions/TextInput/directives/text-input-rules.service.ts ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Rules service for the interaction.
 */
__webpack_require__(/*! filters/string-utility-filters/normalize-whitespace.filter.ts */ "./core/templates/dev/head/filters/string-utility-filters/normalize-whitespace.filter.ts");
angular.module('oppia').factory('TextInputRulesService', [
    '$filter', function ($filter) {
        return {
            Equals: function (answer, inputs) {
                var normalizedAnswer = $filter('normalizeWhitespace')(answer);
                var normalizedInput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedAnswer.toLowerCase() === normalizedInput.toLowerCase();
            },
            FuzzyEquals: function (answer, inputs) {
                var normalizedAnswer = $filter('normalizeWhitespace')(answer);
                var answerString = normalizedAnswer.toLowerCase();
                var normalizedInput = $filter('normalizeWhitespace')(inputs.x);
                var inputString = normalizedInput.toLowerCase();
                if (inputString === answerString) {
                    return true;
                }
                var editDistance = [];
                for (var i = 0; i <= inputString.length; i++) {
                    editDistance.push([i]);
                }
                for (var j = 1; j <= answerString.length; j++) {
                    editDistance[0].push(j);
                }
                for (var i = 1; i <= inputString.length; i++) {
                    for (var j = 1; j <= answerString.length; j++) {
                        if (inputString.charAt(i - 1) === answerString.charAt(j - 1)) {
                            editDistance[i][j] = editDistance[i - 1][j - 1];
                        }
                        else {
                            editDistance[i][j] = Math.min(editDistance[i - 1][j - 1], editDistance[i][j - 1], editDistance[i - 1][j]) + 1;
                        }
                    }
                }
                return editDistance[inputString.length][answerString.length] === 1;
            },
            CaseSensitiveEquals: function (answer, inputs) {
                var normalizedAnswer = $filter('normalizeWhitespace')(answer);
                var normalizedInput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedAnswer === normalizedInput;
            },
            StartsWith: function (answer, inputs) {
                var normalizedAnswer = $filter('normalizeWhitespace')(answer);
                var normalizedInput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedAnswer.toLowerCase().indexOf(normalizedInput.toLowerCase()) === 0;
            },
            Contains: function (answer, inputs) {
                var normalizedAnswer = $filter('normalizeWhitespace')(answer);
                var normalizedInput = $filter('normalizeWhitespace')(inputs.x);
                return normalizedAnswer.toLowerCase().indexOf(normalizedInput.toLowerCase()) !== -1;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/TextInput/directives/text-input-validation.service.ts":
/*!***************************************************************************************!*\
  !*** ./extensions/interactions/TextInput/directives/text-input-validation.service.ts ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Validator service for the interaction.
 */
__webpack_require__(/*! interactions/base-interaction-validation.service.ts */ "./extensions/interactions/base-interaction-validation.service.ts");
angular.module('oppia').factory('TextInputValidationService', [
    'baseInteractionValidationService', 'INTERACTION_SPECS', 'WARNING_TYPES',
    function (baseInteractionValidationService, INTERACTION_SPECS, WARNING_TYPES) {
        return {
            getCustomizationArgsWarnings: function (customizationArgs) {
                var warningsList = [];
                baseInteractionValidationService.requireCustomizationArguments(customizationArgs, ['placeholder', 'rows']);
                var placeholder = customizationArgs.placeholder.value;
                if (!angular.isString(placeholder)) {
                    warningsList.push({
                        type: WARNING_TYPES.ERROR,
                        message: ('Placeholder text must be a string.')
                    });
                }
                var isInt = function (n) {
                    return angular.isNumber(n) && n % 1 === 0;
                };
                var rows = customizationArgs.rows.value;
                if (isInt(rows)) {
                    var textSpecs = INTERACTION_SPECS.TextInput;
                    var customizationArgSpecs = textSpecs.customization_arg_specs;
                    var rowsSpecs = customizationArgSpecs[1];
                    var minRows = rowsSpecs.schema.validators[0].min_value;
                    var maxRows = rowsSpecs.schema.validators[1].max_value;
                    if (rows < minRows || rows > maxRows) {
                        warningsList.push({
                            type: WARNING_TYPES.ERROR,
                            message: ('Number of rows must be between ' + minRows + ' and ' +
                                maxRows + '.')
                        });
                    }
                }
                else {
                    warningsList.push({
                        type: WARNING_TYPES.ERROR,
                        message: ('Number of rows must be integral.')
                    });
                }
                return warningsList;
            },
            getAllWarnings: function (stateName, customizationArgs, answerGroups, defaultOutcome) {
                return this.getCustomizationArgsWarnings(customizationArgs).concat(baseInteractionValidationService.getAllOutcomeWarnings(answerGroups, defaultOutcome, stateName));
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/TextInput/text-input-prediction.service.ts":
/*!****************************************************************************!*\
  !*** ./extensions/interactions/TextInput/text-input-prediction.service.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview TextInput interaction prediction functions.
 *
 * IMPORTANT NOTE: The prediction function uses the classifier data
 * of trained model (text classifier model) for inference. These functions
 * must be changed if there are any changes in corresponding classifier training
 * function on Oppia-ml.
 */
__webpack_require__(/*! classifiers/svm-prediction.service.ts */ "./extensions/classifiers/svm-prediction.service.ts");
__webpack_require__(/*! classifiers/text-input.tokenizer.ts */ "./extensions/classifiers/text-input.tokenizer.ts");
__webpack_require__(/*! classifiers/count-vectorizer.service.ts */ "./extensions/classifiers/count-vectorizer.service.ts");
__webpack_require__(/*! interactions/interactions-extension.constants.ajs.ts */ "./extensions/interactions/interactions-extension.constants.ajs.ts");
angular.module('oppia').factory('TextInputPredictionService', [
    'CountVectorizerService', 'SVMPredictionService',
    'TextInputTokenizer', 'TEXT_INPUT_PREDICTION_SERVICE_THRESHOLD', function (CountVectorizerService, SVMPredictionService, TextInputTokenizer, TEXT_INPUT_PREDICTION_SERVICE_THRESHOLD) {
        return {
            predict: function (classifierData, textInput) {
                var cvVocabulary = classifierData.cv_vocabulary;
                var svmData = classifierData.SVM;
                // Tokenize the text input.
                textInput = textInput.toLowerCase();
                var textInputTokens = TextInputTokenizer.generateTokens(textInput);
                var textVector = CountVectorizerService.vectorize(textInputTokens, cvVocabulary);
                var predictionResult = SVMPredictionService.predict(svmData, textVector);
                if (predictionResult.predictionConfidence >
                    TEXT_INPUT_PREDICTION_SERVICE_THRESHOLD) {
                    return predictionResult.predictionLabel;
                }
                return -1;
            }
        };
    }
]);


/***/ }),

/***/ "./extensions/interactions/base-interaction-validation.service.ts":
/*!************************************************************************!*\
  !*** ./extensions/interactions/base-interaction-validation.service.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Base validation service for interactions.
 */
var static_1 = __webpack_require__(/*! @angular/upgrade/static */ "./node_modules/@angular/upgrade/bundles/upgrade-static.umd.js");
var core_1 = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var app_constants_1 = __webpack_require__(/*! app.constants */ "./core/templates/dev/head/app.constants.ts");
var baseInteractionValidationService = /** @class */ (function () {
    function baseInteractionValidationService() {
    }
    // 'argNames' is an array of top-level customization argument names (such
    // as 'chocies') used to verify the basic structure of the input
    // customization arguments object.
    baseInteractionValidationService.prototype.requireCustomizationArguments = function (customizationArguments, argNames) {
        var missingArgs = [];
        for (var i = 0; i < argNames.length; i++) {
            if (!customizationArguments.hasOwnProperty(argNames[i])) {
                missingArgs.push(argNames[i]);
            }
        }
        if (missingArgs.length > 0) {
            if (missingArgs.length === 1) {
                throw 'Expected customization arguments to have property: ' +
                    missingArgs[0];
            }
            else {
                throw 'Expected customization arguments to have properties: ' +
                    missingArgs.join(', ');
            }
        }
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'answerGroups' is an answer group domain object and can be
    // typed after AnswerGroupObjectFactory.ts is upgraded.
    baseInteractionValidationService.prototype.getAnswerGroupWarnings = function (answerGroups, stateName) {
        var partialWarningsList = [];
        // This does not check the default outcome.
        for (var i = 0; i < answerGroups.length; i++) {
            if (answerGroups[i].outcome.isConfusing(stateName)) {
                partialWarningsList.push({
                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                    message: ('Please specify what Oppia should do in answer group ' +
                        String(i + 1) + '.')
                });
            }
            if (answerGroups[i].outcome.dest === stateName &&
                answerGroups[i].outcome.labelledAsCorrect) {
                partialWarningsList.push({
                    type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                    message: ('In answer group ' + String(i + 1) + ', self-loops should ' +
                        'not be labelled as correct.')
                });
            }
        }
        return partialWarningsList;
    };
    baseInteractionValidationService.prototype.getDefaultOutcomeWarnings = function (defaultOutcome, stateName) {
        var partialWarningsList = [];
        if (defaultOutcome && defaultOutcome.isConfusing(stateName)) {
            partialWarningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: ('Please add feedback for the user in the [All other answers] ' +
                    'rule.')
            });
        }
        if (defaultOutcome && defaultOutcome.dest === stateName &&
            defaultOutcome.labelledAsCorrect) {
            partialWarningsList.push({
                type: app_constants_1.AppConstants.WARNING_TYPES.ERROR,
                message: ('In the [All other answers] group, self-loops should not be ' +
                    'labelled as correct.')
            });
        }
        return partialWarningsList;
    };
    // TODO(#7165): Replace 'any' with the exact type. This has been kept as
    // 'any' because 'answerGroups' is an answer group domain object and can be
    // typed after AnswerGroupObjectFactory.ts is upgraded.
    baseInteractionValidationService.prototype.getAllOutcomeWarnings = function (answerGroups, defaultOutcome, stateName) {
        return (this.getAnswerGroupWarnings(answerGroups, stateName).concat(this.getDefaultOutcomeWarnings(defaultOutcome, stateName)));
    };
    baseInteractionValidationService = __decorate([
        core_1.Injectable({
            providedIn: 'root'
        })
    ], baseInteractionValidationService);
    return baseInteractionValidationService;
}());
exports.baseInteractionValidationService = baseInteractionValidationService;
angular.module('oppia').factory('baseInteractionValidationService', static_1.downgradeInjectable(baseInteractionValidationService));


/***/ }),

/***/ "./extensions/interactions/interactions-extension.constants.ajs.ts":
/*!*************************************************************************!*\
  !*** ./extensions/interactions/interactions-extension.constants.ajs.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Constants for interactions extensions.
 */
// TODO(#7092): Delete this file once migration is complete and these AngularJS
// equivalents of the Angular constants are no longer needed.
var interactions_extension_constants_1 = __webpack_require__(/*! interactions/interactions-extension.constants */ "./extensions/interactions/interactions-extension.constants.ts");
// Minimum confidence required for a predicted answer group to be shown to user.
// Generally a threshold of 0.7-0.8 is assumed to be a good one in practice,
// however value need not be in those bounds.
angular.module('oppia').constant('CODE_REPL_PREDICTION_SERVICE_THRESHOLD', interactions_extension_constants_1.InteractionsExtensionsConstants.CODE_REPL_PREDICTION_SERVICE_THRESHOLD);
angular.module('oppia').constant('GRAPH_INPUT_LEFT_MARGIN', interactions_extension_constants_1.InteractionsExtensionsConstants.GRAPH_INPUT_LEFT_MARGIN);
// Gives the staff-lines human readable values.
angular.module('oppia').constant('NOTE_NAMES_TO_MIDI_VALUES', interactions_extension_constants_1.InteractionsExtensionsConstants.NOTE_NAMES_TO_MIDI_VALUES);
// Minimum confidence required for a predicted answer group to be shown to user.
// Generally a threshold of 0.7-0.8 is assumed to be a good one in practice,
// however value need not be in those bounds.
angular.module('oppia').constant('TEXT_INPUT_PREDICTION_SERVICE_THRESHOLD', interactions_extension_constants_1.InteractionsExtensionsConstants.TEXT_INPUT_PREDICTION_SERVICE_THRESHOLD);


/***/ }),

/***/ "./extensions/interactions/interactionsRequires.ts":
/*!*********************************************************!*\
  !*** ./extensions/interactions/interactionsRequires.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for all the interactions.
 */
__webpack_require__(/*! interactions/CodeRepl/CodeRepl.ts */ "./extensions/interactions/CodeRepl/CodeRepl.ts");
__webpack_require__(/*! interactions/Continue/Continue.ts */ "./extensions/interactions/Continue/Continue.ts");
__webpack_require__(/*! interactions/DragAndDropSortInput/DragAndDropSortInput.ts */ "./extensions/interactions/DragAndDropSortInput/DragAndDropSortInput.ts");
__webpack_require__(/*! interactions/EndExploration/EndExploration.ts */ "./extensions/interactions/EndExploration/EndExploration.ts");
__webpack_require__(/*! interactions/FractionInput/FractionInput.ts */ "./extensions/interactions/FractionInput/FractionInput.ts");
__webpack_require__(/*! interactions/GraphInput/GraphInput.ts */ "./extensions/interactions/GraphInput/GraphInput.ts");
__webpack_require__(/*! interactions/ImageClickInput/ImageClickInput.ts */ "./extensions/interactions/ImageClickInput/ImageClickInput.ts");
__webpack_require__(/*! interactions/InteractiveMap/InteractiveMap.ts */ "./extensions/interactions/InteractiveMap/InteractiveMap.ts");
__webpack_require__(/*! interactions/ItemSelectionInput/ItemSelectionInput.ts */ "./extensions/interactions/ItemSelectionInput/ItemSelectionInput.ts");
__webpack_require__(/*! interactions/LogicProof/LogicProof.ts */ "./extensions/interactions/LogicProof/LogicProof.ts");
__webpack_require__(/*! interactions/MathExpressionInput/MathExpressionInput.ts */ "./extensions/interactions/MathExpressionInput/MathExpressionInput.ts");
__webpack_require__(/*! interactions/MultipleChoiceInput/MultipleChoiceInput.ts */ "./extensions/interactions/MultipleChoiceInput/MultipleChoiceInput.ts");
__webpack_require__(/*! interactions/MusicNotesInput/MusicNotesInput.ts */ "./extensions/interactions/MusicNotesInput/MusicNotesInput.ts");
__webpack_require__(/*! interactions/NumberWithUnits/NumberWithUnits.ts */ "./extensions/interactions/NumberWithUnits/NumberWithUnits.ts");
__webpack_require__(/*! interactions/NumericInput/NumericInput.ts */ "./extensions/interactions/NumericInput/NumericInput.ts");
__webpack_require__(/*! interactions/PencilCodeEditor/PencilCodeEditor.ts */ "./extensions/interactions/PencilCodeEditor/PencilCodeEditor.ts");
__webpack_require__(/*! interactions/SetInput/SetInput.ts */ "./extensions/interactions/SetInput/SetInput.ts");
__webpack_require__(/*! interactions/TextInput/TextInput.ts */ "./extensions/interactions/TextInput/TextInput.ts");


/***/ }),

/***/ "./extensions/interactions/uiLeafletRequires.ts":
/*!******************************************************!*\
  !*** ./extensions/interactions/uiLeafletRequires.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Loads scripts needed for ui-leaflet.
 */
__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'static/leaflet-1.4.0/leaflet.js'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'static/angular-ui-leaflet-1.0.3/ui-leaflet.min.no-header.js'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'static/angular-simple-logger-0.1.7/angular-simple-logger.min.js'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));


/***/ }),

/***/ "./extensions/objects/objectComponentsRequires.ts":
/*!********************************************************!*\
  !*** ./extensions/objects/objectComponentsRequires.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2019 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Requires for all the object templates.
 */
__webpack_require__(/*! objects/templates/boolean-editor.directive.ts */ "./extensions/objects/templates/boolean-editor.directive.ts");
__webpack_require__(/*! objects/templates/code-string-editor.directive.ts */ "./extensions/objects/templates/code-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/coord-two-dim-editor.directive.ts */ "./extensions/objects/templates/coord-two-dim-editor.directive.ts");
__webpack_require__(/*! objects/templates/drag-and-drop-html-string-editor.directive.ts */ "./extensions/objects/templates/drag-and-drop-html-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/drag-and-drop-positive-int-editor.directive.ts */ "./extensions/objects/templates/drag-and-drop-positive-int-editor.directive.ts");
__webpack_require__(/*! objects/templates/filepath-editor.directive.ts */ "./extensions/objects/templates/filepath-editor.directive.ts");
__webpack_require__(/*! objects/templates/fraction-editor.directive.ts */ "./extensions/objects/templates/fraction-editor.directive.ts");
__webpack_require__(/*! objects/templates/graph-editor.directive.ts */ "./extensions/objects/templates/graph-editor.directive.ts");
__webpack_require__(/*! objects/templates/graph-property-editor.directive.ts */ "./extensions/objects/templates/graph-property-editor.directive.ts");
__webpack_require__(/*! objects/templates/html-editor.directive.ts */ "./extensions/objects/templates/html-editor.directive.ts");
__webpack_require__(/*! objects/templates/image-with-regions-editor.directive.ts */ "./extensions/objects/templates/image-with-regions-editor.directive.ts");
__webpack_require__(/*! objects/templates/int-editor.directive.ts */ "./extensions/objects/templates/int-editor.directive.ts");
__webpack_require__(/*! objects/templates/list-of-sets-of-html-strings-editor.directive.ts */ "./extensions/objects/templates/list-of-sets-of-html-strings-editor.directive.ts");
__webpack_require__(/*! objects/templates/list-of-tabs-editor.directive.ts */ "./extensions/objects/templates/list-of-tabs-editor.directive.ts");
__webpack_require__(/*! objects/templates/list-of-unicode-string-editor.directive.ts */ "./extensions/objects/templates/list-of-unicode-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/logic-error-category-editor.directive.ts */ "./extensions/objects/templates/logic-error-category-editor.directive.ts");
__webpack_require__(/*! objects/templates/logic-question-editor.directive.ts */ "./extensions/objects/templates/logic-question-editor.directive.ts");
__webpack_require__(/*! objects/templates/math-latex-string-editor.directive.ts */ "./extensions/objects/templates/math-latex-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/music-phrase-editor.directive.ts */ "./extensions/objects/templates/music-phrase-editor.directive.ts");
__webpack_require__(/*! objects/templates/nonnegative-int-editor.directive.ts */ "./extensions/objects/templates/nonnegative-int-editor.directive.ts");
__webpack_require__(/*! objects/templates/normalized-string-editor.directive.ts */ "./extensions/objects/templates/normalized-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/number-with-units-editor.directive.ts */ "./extensions/objects/templates/number-with-units-editor.directive.ts");
__webpack_require__(/*! objects/templates/parameter-name-editor.directive.ts */ "./extensions/objects/templates/parameter-name-editor.directive.ts");
__webpack_require__(/*! objects/templates/real-editor.directive.ts */ "./extensions/objects/templates/real-editor.directive.ts");
__webpack_require__(/*! objects/templates/sanitized-url-editor.directive.ts */ "./extensions/objects/templates/sanitized-url-editor.directive.ts");
__webpack_require__(/*! objects/templates/set-of-html-string-editor.directive.ts */ "./extensions/objects/templates/set-of-html-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/set-of-unicode-string-editor.directive.ts */ "./extensions/objects/templates/set-of-unicode-string-editor.directive.ts");
__webpack_require__(/*! objects/templates/unicode-string-editor.directive.ts */ "./extensions/objects/templates/unicode-string-editor.directive.ts");


/***/ }),

/***/ "./extensions/objects/templates/boolean-editor.directive.ts":
/*!******************************************************************!*\
  !*** ./extensions/objects/templates/boolean-editor.directive.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for boolean editor.
 */
// The value for this editor is always editable.
angular.module('oppia').directive('booleanEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function (newValue) {
                        ctrl.localValue = {
                            label: newValue || false
                        };
                    }, true);
                    $scope.$watch('$ctrl.localValue.label', function (newValue) {
                        ctrl.value = newValue;
                    });
                }],
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/boolean-editor.directive.html'),
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/code-string-editor.directive.ts":
/*!**********************************************************************!*\
  !*** ./extensions/objects/templates/code-string-editor.directive.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for code string editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('codeStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getAlwaysEditable: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/code-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.alwaysEditable = ctrl.getAlwaysEditable();
                    ctrl.getWarningText = function () {
                        if (ctrl.localValue.label.indexOf('\t') !== -1) {
                            return 'Code may not contain tab characters.';
                        }
                        return '';
                    };
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function () {
                        ctrl.localValue = {
                            label: ctrl.value || ''
                        };
                    }, true);
                    $scope.$watch('$ctrl.localValue.label', function (newValue) {
                        ctrl.value = newValue;
                    });
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/coord-two-dim-editor.directive.ts":
/*!************************************************************************!*\
  !*** ./extensions/objects/templates/coord-two-dim-editor.directive.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for coord two dim editor.
 */
angular.module('oppia').directive('coordTwoDimEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.mapCenter = {
                        lat: ctrl.value[0],
                        lng: ctrl.value[1],
                        zoom: 0
                    };
                    ctrl.mapMarkers = {
                        mainMarker: {
                            lat: ctrl.value[0],
                            lng: ctrl.value[1],
                            focus: true,
                            draggable: true,
                            icon: {
                                iconUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon.png'),
                                // The size of the icon image in pixels.
                                iconSize: [25, 41],
                                // The coordinates of the "tip" of the icon.
                                iconAnchor: [12, 41],
                                shadowUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png'),
                                // The size of the shadow image in pixels.
                                shadowSize: [41, 41],
                                // The coordinates of the "tip" of the shadow.
                                shadowAnchor: [13, 41],
                                // The URL to a retina sized version of the icon image.
                                // Used for Retina screen devices.
                                iconRetinaUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-icon-2x.png'),
                                shadowRetinaUrl: UrlInterpolationService.getExtensionResourceUrl('/interactions/InteractiveMap/static/marker-shadow.png')
                            }
                        }
                    };
                    ctrl.mapEvents = {
                        map: {
                            enable: ['click'],
                            logic: 'emit'
                        },
                        markers: {
                            enable: ['dragend'],
                            logic: 'emit'
                        }
                    };
                    $scope.$on('leafletDirectiveMap.coordTwoDimEditor.click', function (evt, args) {
                        var newLat = args.leafletEvent.latlng.lat;
                        var newLng = args.leafletEvent.latlng.lng;
                        ctrl.value = [newLat, newLng];
                        updateMarker(newLat, newLng);
                    });
                    $scope.$on('leafletDirectiveMarker.coordTwoDimEditor.dragend', function (evt, args) {
                        ctrl.value = [args.model.lat, args.model.lng];
                    });
                    var updateMarker = function (lat, lng) {
                        ctrl.mapMarkers.mainMarker.lat = lat;
                        ctrl.mapMarkers.mainMarker.lng = lng;
                    };
                }],
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/coord-two-dim-editor.directive.html'),
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/drag-and-drop-html-string-editor.directive.ts":
/*!************************************************************************************!*\
  !*** ./extensions/objects/templates/drag-and-drop-html-string-editor.directive.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for drag and drop HTML string editor.
 */
angular.module('oppia').directive('dragAndDropHtmlStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/drag-and-drop-html-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.name = math.random().toString(36).substring(7);
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.choices = ctrl.initArgs.choices;
                    if (!ctrl.value || ctrl.value === '') {
                        ctrl.value = ctrl.choices[0].id;
                    }
                    ctrl.selectedItem = ctrl.value;
                    ctrl.selection = function (selectedItem) {
                        ctrl.value = selectedItem;
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/drag-and-drop-positive-int-editor.directive.ts":
/*!*************************************************************************************!*\
  !*** ./extensions/objects/templates/drag-and-drop-positive-int-editor.directive.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for drag and drop positive int editor.
 */
angular.module('oppia').directive('dragAndDropPositiveIntEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/drag_and_drop_positive_int-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    if (!parseInt(ctrl.value)) {
                        ctrl.value = 1;
                    }
                    if (!ctrl.selectedRank) {
                        ctrl.selectedRank = '';
                    }
                    ctrl.allowedRanks = [];
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.choices = ctrl.initArgs.choices;
                    for (var i = 0; i < ctrl.choices.length; i++) {
                        ctrl.allowedRanks.push(i + 1);
                    }
                    ctrl.selection = function (selectedRank) {
                        ctrl.value = parseInt(selectedRank);
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/filepath-editor.directive.ts":
/*!*******************************************************************!*\
  !*** ./extensions/objects/templates/filepath-editor.directive.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for filepath editor.
 */
// This directive can only be used in the context of an exploration.
__webpack_require__(/*! components/forms/custom-forms-directives/image-uploader.directive.ts */ "./core/templates/dev/head/components/forms/custom-forms-directives/image-uploader.directive.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
__webpack_require__(/*! services/AlertsService.ts */ "./core/templates/dev/head/services/AlertsService.ts");
__webpack_require__(/*! services/AssetsBackendApiService.ts */ "./core/templates/dev/head/services/AssetsBackendApiService.ts");
__webpack_require__(/*! services/ContextService.ts */ "./core/templates/dev/head/services/ContextService.ts");
__webpack_require__(/*! services/CsrfTokenService.ts */ "./core/templates/dev/head/services/CsrfTokenService.ts");
angular.module('oppia').directive('filepathEditor', [
    '$sce', 'AlertsService', 'AssetsBackendApiService',
    'ContextService', 'CsrfTokenService', 'UrlInterpolationService',
    function ($sce, AlertsService, AssetsBackendApiService, ContextService, CsrfTokenService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/filepath-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    var MODE_EMPTY = 1;
                    var MODE_UPLOADED = 2;
                    var MODE_SAVED = 3;
                    // We only use PNG format since that is what canvas can export to in
                    // all browsers.
                    // TODO(sll): See if we can add support for other image formats.
                    var OUTPUT_IMAGE_FORMAT = 'png';
                    var OUTPUT_IMAGE_MAX_WIDTH_PX = 490;
                    var CROP_BORDER_MARGIN_PX = 10;
                    var CROP_AREA_MIN_WIDTH_PX = 40;
                    var CROP_AREA_MIN_HEIGHT_PX = 40;
                    // Categorize mouse positions with respect to the crop area.
                    var MOUSE_TOP_LEFT = 1;
                    var MOUSE_TOP = 2;
                    var MOUSE_TOP_RIGHT = 3;
                    var MOUSE_RIGHT = 4;
                    var MOUSE_BOTTOM_RIGHT = 5;
                    var MOUSE_BOTTOM = 6;
                    var MOUSE_BOTTOM_LEFT = 7;
                    var MOUSE_LEFT = 8;
                    var MOUSE_INSIDE = 9;
                    // Define the cursors for the crop area.
                    var CROP_CURSORS = {};
                    CROP_CURSORS[MOUSE_TOP_LEFT] = 'nwse-resize';
                    CROP_CURSORS[MOUSE_TOP] = 'ns-resize';
                    CROP_CURSORS[MOUSE_TOP_RIGHT] = 'nesw-resize';
                    CROP_CURSORS[MOUSE_RIGHT] = 'ew-resize';
                    CROP_CURSORS[MOUSE_BOTTOM_RIGHT] = 'nwse-resize';
                    CROP_CURSORS[MOUSE_BOTTOM] = 'ns-resize';
                    CROP_CURSORS[MOUSE_BOTTOM_LEFT] = 'nesw-resize';
                    CROP_CURSORS[MOUSE_LEFT] = 'ew-resize';
                    CROP_CURSORS[MOUSE_INSIDE] = 'move';
                    /** Internal functions (not visible in the view) */
                    /**
                     * Resamples an image to the specified dimension.
                     *
                     * @param imageDataURI A DOMString containing the input image data URI.
                     * @param width The desired output width.
                     * @param height The desired output height.
                     * @return A DOMString containing the output image data URI.
                     */
                    var getResampledImageData = function (imageDataURI, width, height) {
                        // Create an Image object with the original data.
                        var img = new Image();
                        img.src = imageDataURI;
                        // Create a Canvas and draw the image on it, resampled.
                        var canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        var ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        return canvas.toDataURL('image/' + OUTPUT_IMAGE_FORMAT, 1);
                    };
                    /**
                     * Crops an image to the specified rectangular region.
                     *
                     * @param imageDataURI A DOMString containing the input image data URI.
                     * @param x The x coorinate of the top-left corner of the crop region.
                     * @param y The y coorinate of the top-left corner of the crop region.
                     * @param width The width of the crop region.
                     * @param height The height of the crop region.
                     * @return A DOMString containing the output image data URI.
                     */
                    var getCroppedImageData = function (imageDataURI, x, y, width, height) {
                        // Put the original image in a canvas.
                        var img = new Image();
                        img.src = imageDataURI;
                        var canvas = document.createElement('canvas');
                        canvas.width = x + width;
                        canvas.height = y + height;
                        var ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        // Get image data for a cropped selection.
                        var data = ctx.getImageData(x, y, width, height);
                        // Draw on a separate canvas and return the dataURL.
                        var cropCanvas = document.createElement('canvas');
                        cropCanvas.width = width;
                        cropCanvas.height = height;
                        var cropCtx = cropCanvas.getContext('2d');
                        cropCtx.putImageData(data, 0, 0);
                        return cropCanvas.toDataURL('image/' + OUTPUT_IMAGE_FORMAT, 1);
                    };
                    var convertImageDataToImageFile = function (dataURI) {
                        // Convert base64/URLEncoded data component to raw binary data
                        // held in a string.
                        var byteString = atob(dataURI.split(',')[1]);
                        // Separate out the mime component.
                        var mime = dataURI.split(',')[0].split(':')[1].split(';')[0];
                        // Write the bytes of the string to a typed array.
                        var ia = new Uint8Array(byteString.length);
                        for (var i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        var blob = new Blob([ia], { type: mime });
                        if (blob.type.match('image') &&
                            blob.size > 0) {
                            return blob;
                        }
                        else {
                            return null;
                        }
                    };
                    var getEventCoorindatesRelativeToImageContainer = function (e) {
                        // Even though the event listeners are added to the image container,
                        // the events seem to be reported with 'target' set to the deepest
                        // element where the event occurred. In other words, if the event
                        // occurred outside of the crop area, then the (x, y) reported will be
                        // the one with respect to the image container, but if the event
                        // occurs inside the crop area, then the (x, y) reported will be the
                        // one with respect to the crop area itself. So this function does
                        // normalization on the (x, y) values so that they are always reported
                        // with respect to the image container (makes calculations easier).
                        var x = e.offsetX;
                        var y = e.offsetY;
                        var containerClass = 'filepath-editor-image-crop-container';
                        var node = e.target;
                        while (!node.classList.contains(containerClass)) {
                            x += node.offsetLeft;
                            y += node.offsetTop;
                            node = node.offsetParent;
                        }
                        return { x: x, y: y };
                    };
                    var clamp = function (value, min, max) {
                        return Math.min(Math.max(min, value), max);
                    };
                    var handleMouseMoveWhileDraggingCropArea = function (x, y) {
                        var xDown = ctrl.lastMouseDownEventCoordinates.x;
                        var yDown = ctrl.lastMouseDownEventCoordinates.y;
                        var x1WhenDown = ctrl.cropAreaXWhenLastDown;
                        var y1WhenDown = ctrl.cropAreaYWhenLastDown;
                        // Calculate new position of the crop area.
                        var x1 = x1WhenDown + (x - xDown);
                        var y1 = y1WhenDown + (y - yDown);
                        // Correct for boundaries.
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var cropWidth = ctrl.cropArea.x2 - ctrl.cropArea.x1;
                        var cropHeight = ctrl.cropArea.y2 - ctrl.cropArea.y1;
                        x1 = clamp(x1, 0, dimensions.width - cropWidth);
                        y1 = clamp(y1, 0, dimensions.height - cropHeight);
                        // Update crop area coordinates.
                        ctrl.cropArea.x1 = x1;
                        ctrl.cropArea.y1 = y1;
                        ctrl.cropArea.x2 = x1 + cropWidth;
                        ctrl.cropArea.y2 = y1 + cropHeight;
                    };
                    var handleMouseMoveWhileResizingCropArea = function (x, y) {
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var direction = ctrl.cropAreaResizeDirection;
                        var adjustResizeLeft = function (x) {
                            // Update crop area x1 value, correcting for boundaries.
                            ctrl.cropArea.x1 = clamp(x, 0, ctrl.cropArea.x2 - CROP_AREA_MIN_WIDTH_PX);
                        };
                        var adjustResizeRight = function (x) {
                            // Update crop area x2 value, correcting for boundaries.
                            ctrl.cropArea.x2 = clamp(x, CROP_AREA_MIN_WIDTH_PX + ctrl.cropArea.x1, dimensions.width);
                        };
                        var adjustResizeTop = function (y) {
                            // Update crop area y1 value, correcting for boundaries.
                            ctrl.cropArea.y1 = clamp(y, 0, ctrl.cropArea.y2 - CROP_AREA_MIN_HEIGHT_PX);
                        };
                        var adjustResizeBottom = function (y) {
                            // Update crop area y2 value, correcting for boundaries.
                            ctrl.cropArea.y2 = clamp(y, CROP_AREA_MIN_HEIGHT_PX + ctrl.cropArea.y1, dimensions.height);
                        };
                        switch (direction) {
                            case MOUSE_TOP_LEFT:
                                adjustResizeTop(y);
                                adjustResizeLeft(x);
                                break;
                            case MOUSE_TOP:
                                adjustResizeTop(y);
                                break;
                            case MOUSE_TOP_RIGHT:
                                adjustResizeTop(y);
                                adjustResizeRight(x);
                                break;
                            case MOUSE_RIGHT:
                                adjustResizeRight(x);
                                break;
                            case MOUSE_BOTTOM_RIGHT:
                                adjustResizeBottom(y);
                                adjustResizeRight(x);
                                break;
                            case MOUSE_BOTTOM:
                                adjustResizeBottom(y);
                                break;
                            case MOUSE_BOTTOM_LEFT:
                                adjustResizeBottom(y);
                                adjustResizeLeft(x);
                                break;
                            case MOUSE_LEFT:
                                adjustResizeLeft(x);
                                break;
                        }
                    };
                    var updatePositionWithinCropArea = function (x, y) {
                        var margin = CROP_BORDER_MARGIN_PX;
                        var cx1 = ctrl.cropArea.x1;
                        var cy1 = ctrl.cropArea.y1;
                        var cx2 = ctrl.cropArea.x2;
                        var cy2 = ctrl.cropArea.y2;
                        var xOnLeftBorder = x > cx1 - margin && x < cx1 + margin;
                        var xOnRightBorder = x > cx2 - margin && x < cx2 + margin;
                        var yOnTopBorder = y > cy1 - margin && y < cy1 + margin;
                        var yOnBottomBorder = y > cy2 - margin && y < cy2 + margin;
                        var xInside = x > cx1 && x < cx2;
                        var yInside = y > cy1 && y < cy2;
                        // It is important to check the pointer position for corners first,
                        // since the conditions overlap. In other words, the pointer can be
                        // at the top border and at the top-right corner at the same time, in
                        // which case we want to recognize the corner.
                        if (xOnLeftBorder && yOnTopBorder) {
                            // Upper left corner.
                            ctrl.mousePositionWithinCropArea = MOUSE_TOP_LEFT;
                        }
                        else if (xOnRightBorder && yOnTopBorder) {
                            // Upper right corner.
                            ctrl.mousePositionWithinCropArea = MOUSE_TOP_RIGHT;
                        }
                        else if (xOnLeftBorder && yOnBottomBorder) {
                            // Lower left corner.
                            ctrl.mousePositionWithinCropArea = MOUSE_BOTTOM_LEFT;
                        }
                        else if (xOnRightBorder && yOnBottomBorder) {
                            // Lower right corner.
                            ctrl.mousePositionWithinCropArea = MOUSE_BOTTOM_RIGHT;
                        }
                        else if (yOnTopBorder) {
                            // Top border.
                            ctrl.mousePositionWithinCropArea = MOUSE_TOP;
                        }
                        else if (xOnLeftBorder) {
                            // Left border.
                            ctrl.mousePositionWithinCropArea = MOUSE_LEFT;
                        }
                        else if (xOnRightBorder) {
                            // Right border.
                            ctrl.mousePositionWithinCropArea = MOUSE_RIGHT;
                        }
                        else if (yOnBottomBorder) {
                            // Bottom border.
                            ctrl.mousePositionWithinCropArea = MOUSE_BOTTOM;
                        }
                        else if (xInside && yInside) {
                            // Inside the crop area.
                            ctrl.mousePositionWithinCropArea = MOUSE_INSIDE;
                        }
                        else {
                            ctrl.mousePositionWithinCropArea = null;
                        }
                    };
                    var getTrustedResourceUrlForImageFileName = function (imageFileName) {
                        var encodedFilepath = window.encodeURIComponent(imageFileName);
                        return $sce.trustAsResourceUrl(AssetsBackendApiService.getImageUrlForPreview(ctrl.entityType, ctrl.entityId, encodedFilepath));
                    };
                    /** Scope variables and functions (visibles to the view) */
                    // Reset the component each time the value changes
                    // (e.g. if this is part of an editable list).
                    $scope.$watch('$ctrl.value', function (newValue) {
                        if (newValue) {
                            ctrl.setSavedImageFilename(newValue, false);
                        }
                    });
                    ctrl.resetFilePathEditor = function () {
                        ctrl.data = {
                            mode: MODE_EMPTY,
                            metadata: {}
                        };
                        ctrl.imageResizeRatio = 1;
                    };
                    ctrl.validate = function (data) {
                        return data.mode === MODE_SAVED &&
                            data.metadata.savedImageFilename &&
                            data.metadata.savedImageFilename.length > 0;
                    };
                    ctrl.isUserCropping = function () {
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var cropWidth = ctrl.cropArea.x2 - ctrl.cropArea.x1;
                        var cropHeight = ctrl.cropArea.y2 - ctrl.cropArea.y1;
                        return cropWidth < dimensions.width || cropHeight < dimensions.height;
                    };
                    ctrl.onMouseMoveOnImageArea = function (e) {
                        e.preventDefault();
                        var coords = getEventCoorindatesRelativeToImageContainer(e);
                        if (ctrl.userIsDraggingCropArea) {
                            handleMouseMoveWhileDraggingCropArea(coords.x, coords.y);
                        }
                        else if (ctrl.userIsResizingCropArea) {
                            handleMouseMoveWhileResizingCropArea(coords.x, coords.y);
                        }
                        else {
                            updatePositionWithinCropArea(coords.x, coords.y);
                        }
                        ctrl.mouseLastKnownCoordinates = { x: coords.x, y: coords.y };
                    };
                    ctrl.onMouseDownOnCropArea = function (e) {
                        e.preventDefault();
                        var coords = getEventCoorindatesRelativeToImageContainer(e);
                        var position = ctrl.mousePositionWithinCropArea;
                        if (position === MOUSE_INSIDE) {
                            ctrl.lastMouseDownEventCoordinates = { x: coords.x, y: coords.y };
                            ctrl.cropAreaXWhenLastDown = ctrl.cropArea.x1;
                            ctrl.cropAreaYWhenLastDown = ctrl.cropArea.y1;
                            ctrl.userIsDraggingCropArea = true;
                        }
                        else if (position !== null) {
                            ctrl.lastMouseDownEventCoordinates = { x: coords.x, y: coords.y };
                            ctrl.userIsResizingCropArea = true;
                            ctrl.cropAreaResizeDirection = position;
                        }
                    };
                    ctrl.onMouseUpOnCropArea = function (e) {
                        e.preventDefault();
                        ctrl.userIsDraggingCropArea = false;
                        ctrl.userIsResizingCropArea = false;
                    };
                    ctrl.getMainContainerDynamicStyles = function () {
                        var width = OUTPUT_IMAGE_MAX_WIDTH_PX;
                        return 'width: ' + width + 'px';
                    };
                    ctrl.getImageContainerDynamicStyles = function () {
                        if (ctrl.data.mode === MODE_EMPTY) {
                            return 'border: 1px dotted #888';
                        }
                        else {
                            return 'border: none';
                        }
                    };
                    ctrl.getToolbarDynamicStyles = function () {
                        if (ctrl.isUserCropping()) {
                            return 'visibility: hidden';
                        }
                        else {
                            return 'visibility: visible';
                        }
                    };
                    ctrl.getCropButtonBarDynamicStyles = function () {
                        return 'left: ' + ctrl.cropArea.x2 + 'px;' +
                            'top: ' + ctrl.cropArea.y1 + 'px;';
                    };
                    ctrl.getCropAreaDynamicStyles = function () {
                        var cropWidth = ctrl.cropArea.x2 - ctrl.cropArea.x1;
                        var cropHeight = ctrl.cropArea.y2 - ctrl.cropArea.y1;
                        var position = ctrl.mousePositionWithinCropArea;
                        // Position, size, cursor and background.
                        var styles = {
                            left: ctrl.cropArea.x1 + 'px',
                            top: ctrl.cropArea.y1 + 'px',
                            width: cropWidth + 'px',
                            height: cropHeight + 'px',
                            cursor: CROP_CURSORS[position],
                            background: null
                        };
                        if (!styles.cursor) {
                            styles.cursor = 'default';
                        }
                        // Translucent background layer.
                        if (ctrl.isUserCropping()) {
                            var data = 'url(' + ctrl.data.metadata.uploadedImageData + ')';
                            styles.background = data + ' no-repeat';
                            var x = ctrl.cropArea.x1 + 3; // Add crop area border.
                            var y = ctrl.cropArea.y1 + 3; // Add crop area border.
                            styles['background-position'] = '-' + x + 'px -' + y + 'px';
                            var dimensions = ctrl.calculateTargetImageDimensions();
                            styles['background-size'] = dimensions.width + 'px ' +
                                dimensions.height + 'px';
                        }
                        return Object.keys(styles).map(function (key) {
                            return key + ': ' + styles[key];
                        }).join('; ');
                    };
                    ctrl.getUploadedImageDynamicStyles = function () {
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var w = dimensions.width;
                        var h = dimensions.height;
                        return 'width: ' + w + 'px; height: ' + h + 'px;';
                    };
                    ctrl.confirmCropImage = function () {
                        // Find coordinates of the cropped area within original image scale.
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var r = ctrl.data.metadata.originalWidth / dimensions.width;
                        var x1 = ctrl.cropArea.x1 * r;
                        var y1 = ctrl.cropArea.y1 * r;
                        var width = (ctrl.cropArea.x2 - ctrl.cropArea.x1) * r;
                        var height = (ctrl.cropArea.y2 - ctrl.cropArea.y1) * r;
                        // Generate new image data and file.
                        var newImageData = getCroppedImageData(ctrl.data.metadata.uploadedImageData, x1, y1, width, height);
                        var newImageFile = convertImageDataToImageFile(newImageData);
                        // Update image data.
                        ctrl.data.metadata.uploadedFile = newImageFile;
                        ctrl.data.metadata.uploadedImageData = newImageData;
                        ctrl.data.metadata.originalWidth = width;
                        ctrl.data.metadata.originalHeight = height;
                        // Re-calculate the dimensions of the base image and reset the
                        // coordinates of the crop area to the boundaries of the image.
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        ctrl.cropArea = {
                            x1: 0,
                            y1: 0,
                            x2: dimensions.width,
                            y2: dimensions.height
                        };
                    };
                    ctrl.cancelCropImage = function () {
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        ctrl.cropArea.x1 = 0;
                        ctrl.cropArea.y1 = 0;
                        ctrl.cropArea.x2 = dimensions.width;
                        ctrl.cropArea.y2 = dimensions.height;
                    };
                    ctrl.getImageSizeHelp = function () {
                        var imageWidth = ctrl.data.metadata.originalWidth;
                        if (ctrl.imageResizeRatio === 1 &&
                            imageWidth > OUTPUT_IMAGE_MAX_WIDTH_PX) {
                            return 'This image has been automatically downsized to ensure ' +
                                'that it will fit in the card.';
                        }
                        return null;
                    };
                    ctrl.isNoImageUploaded = function () {
                        return ctrl.data.mode === MODE_EMPTY;
                    };
                    ctrl.isImageUploaded = function () {
                        return ctrl.data.mode === MODE_UPLOADED;
                    };
                    ctrl.isImageSaved = function () {
                        return ctrl.data.mode === MODE_SAVED;
                    };
                    ctrl.getCurrentResizePercent = function () {
                        return Math.round(100 * ctrl.imageResizeRatio);
                    };
                    ctrl.decreaseResizePercent = function (amount) {
                        // Do not allow to decrease size below 10%.
                        ctrl.imageResizeRatio = Math.max(0.1, ctrl.imageResizeRatio - amount / 100);
                    };
                    ctrl.increaseResizePercent = function (amount) {
                        // Do not allow to increase size above 100% (only downsize allowed).
                        ctrl.imageResizeRatio = Math.min(1, ctrl.imageResizeRatio + amount / 100);
                    };
                    ctrl.calculateTargetImageDimensions = function () {
                        var width = ctrl.data.metadata.originalWidth;
                        var height = ctrl.data.metadata.originalHeight;
                        if (width > OUTPUT_IMAGE_MAX_WIDTH_PX) {
                            var aspectRatio = width / height;
                            width = OUTPUT_IMAGE_MAX_WIDTH_PX;
                            height = width / aspectRatio;
                        }
                        return {
                            width: Math.round(width * ctrl.imageResizeRatio),
                            height: Math.round(height * ctrl.imageResizeRatio)
                        };
                    };
                    ctrl.setUploadedFile = function (file) {
                        var reader = new FileReader();
                        reader.onload = function (e) {
                            var img = new Image();
                            img.onload = function () {
                                ctrl.data = {
                                    mode: MODE_UPLOADED,
                                    metadata: {
                                        uploadedFile: file,
                                        uploadedImageData: e.target.result,
                                        originalWidth: img.naturalWidth,
                                        originalHeight: img.naturalHeight
                                    }
                                };
                                var dimensions = ctrl.calculateTargetImageDimensions();
                                ctrl.cropArea = {
                                    x1: 0,
                                    y1: 0,
                                    x2: dimensions.width,
                                    y2: dimensions.height
                                };
                                $scope.$apply();
                            };
                            img.src = (e.target.result);
                        };
                        reader.readAsDataURL(file);
                    };
                    ctrl.setSavedImageFilename = function (filename, updateParent) {
                        ctrl.data = {
                            mode: MODE_SAVED,
                            metadata: {
                                savedImageFilename: filename,
                                savedImageUrl: getTrustedResourceUrlForImageFileName(filename)
                            }
                        };
                        if (updateParent) {
                            AlertsService.clearWarnings();
                            ctrl.value = filename;
                        }
                    };
                    ctrl.onFileChanged = function (file, filename) {
                        ctrl.setUploadedFile(file);
                        $scope.$apply();
                    };
                    ctrl.discardUploadedFile = function () {
                        ctrl.resetFilePathEditor();
                    };
                    ctrl.saveUploadedFile = function () {
                        AlertsService.clearWarnings();
                        if (!ctrl.data.metadata.uploadedFile) {
                            AlertsService.addWarning('No image file detected.');
                            return;
                        }
                        var dimensions = ctrl.calculateTargetImageDimensions();
                        var resampledImageData = getResampledImageData(ctrl.data.metadata.uploadedImageData, dimensions.width, dimensions.height);
                        var resampledFile = convertImageDataToImageFile(resampledImageData);
                        if (resampledFile === null) {
                            AlertsService.addWarning('Could not get resampled file.');
                            return;
                        }
                        var form = new FormData();
                        form.append('image', resampledFile);
                        form.append('payload', JSON.stringify({
                            filename: ctrl.generateImageFilename(dimensions.height, dimensions.width)
                        }));
                        var imageUploadUrlTemplate = '/createhandler/imageupload/' +
                            '<entity_type>/<entity_id>';
                        CsrfTokenService.getTokenAsync().then(function (token) {
                            form.append('csrf_token', token);
                            $.ajax({
                                url: UrlInterpolationService.interpolateUrl(imageUploadUrlTemplate, {
                                    entity_type: ctrl.entityType,
                                    entity_id: ctrl.entityId
                                }),
                                data: form,
                                processData: false,
                                contentType: false,
                                type: 'POST',
                                dataFilter: function (data) {
                                    // Remove the XSSI prefix.
                                    var transformedData = data.substring(5);
                                    return JSON.parse(transformedData);
                                },
                                dataType: 'text'
                            }).done(function (data) {
                                // Pre-load image before marking the image as saved.
                                var img = new Image();
                                img.onload = function () {
                                    ctrl.setSavedImageFilename(data.filename, true);
                                    $scope.$apply();
                                };
                                img.src = getTrustedResourceUrlForImageFileName(data.filename);
                            }).fail(function (data) {
                                // Remove the XSSI prefix.
                                var transformedData = data.responseText.substring(5);
                                var parsedResponse = JSON.parse(transformedData);
                                AlertsService.addWarning(parsedResponse.error || 'Error communicating with server.');
                                $scope.$apply();
                            });
                        });
                    };
                    ctrl.generateImageFilename = function (height, width) {
                        var date = new Date();
                        return 'img_' +
                            date.getFullYear() +
                            ('0' + (date.getMonth() + 1)).slice(-2) +
                            ('0' + date.getDate()).slice(-2) +
                            '_' +
                            ('0' + date.getHours()).slice(-2) +
                            ('0' + date.getMinutes()).slice(-2) +
                            ('0' + date.getSeconds()).slice(-2) +
                            '_' +
                            Math.random().toString(36).substr(2, 10) +
                            '_height_' + height +
                            '_width_' + width +
                            '.' + OUTPUT_IMAGE_FORMAT;
                    };
                    // This variable holds information about the image upload flow.
                    // It's always guaranteed to have the 'mode' and 'metadata' properties.
                    //
                    // See below a description of each mode.
                    //
                    // MODE_EMPTY:
                    //   The user has not uploaded an image yet.
                    //   In this mode, data.metadata will be an empty object:
                    //     {}
                    //
                    // MODE_UPLOADED:
                    //   The user has uploaded an image but it is not yet saved.
                    //   All the crop and resizing happens at this stage.
                    //   In this mode, data.metadata will contain the following info:
                    //     {
                    //       uploadedFile: <a File object>,
                    //       uploadedImageData: <binary data corresponding to the image>,
                    //       originalWidth: <original width of the uploaded image>,
                    //       originalHeight: <original height of the uploaded image>
                    //     }
                    //
                    // MODE_SAVED:
                    //   The user has saved the final image for use in Oppia.
                    //   At this stage, the user can click on the trash to start over.
                    //   In this mode, data.metadata will contain the following info:
                    //     {
                    //       savedImageFilename: <File name of the resource for the image>
                    //       savedImageUrl: <Trusted resource Url for the image>
                    //     }
                    ctrl.data = { mode: MODE_EMPTY, metadata: {} };
                    // Resizing properties.
                    ctrl.imageResizeRatio = 1;
                    // Cropping properties.
                    ctrl.cropArea = { x1: 0, y1: 0, x2: 0, y2: 0 };
                    ctrl.mousePositionWithinCropArea = null;
                    ctrl.mouseLastKnownCoordinates = { x: 0, y: 0 };
                    ctrl.lastMouseDownEventCoordinates = { x: 0, y: 0 };
                    ctrl.userIsDraggingCropArea = false;
                    ctrl.userIsResizingCropArea = false;
                    ctrl.cropAreaResizeDirection = null;
                    ctrl.entityId = ContextService.getEntityId();
                    ctrl.entityType = ContextService.getEntityType();
                    ctrl.resetFilePathEditor();
                    window.addEventListener('mouseup', function (e) {
                        e.preventDefault();
                        ctrl.userIsDraggingCropArea = false;
                        ctrl.userIsResizingCropArea = false;
                    }, false);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/fraction-editor.directive.ts":
/*!*******************************************************************!*\
  !*** ./extensions/objects/templates/fraction-editor.directive.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for fraction editor.
 */
angular.module('oppia').directive('fractionEditor', [
    'FractionObjectFactory', 'UrlInterpolationService',
    function (FractionObjectFactory, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/fraction-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    var errorMessage = '';
                    var fractionString = '0';
                    if (ctrl.value !== null) {
                        var defaultFraction = FractionObjectFactory.fromDict(ctrl.value);
                        fractionString = defaultFraction.toString();
                    }
                    ctrl.localValue = {
                        label: fractionString
                    };
                    $scope.$watch('$ctrl.localValue.label', function (newValue) {
                        try {
                            ctrl.value = FractionObjectFactory.fromRawInputString(newValue);
                            errorMessage = '';
                        }
                        catch (parsingError) {
                            errorMessage = parsingError.message;
                        }
                    });
                    ctrl.getWarningText = function () {
                        return errorMessage;
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/graph-editor.directive.ts":
/*!****************************************************************!*\
  !*** ./extensions/objects/templates/graph-editor.directive.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for graph editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('graphEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/graph-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.alwaysEditable = true;
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/graph-property-editor.directive.ts":
/*!*************************************************************************!*\
  !*** ./extensions/objects/templates/graph-property-editor.directive.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for graph property editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('graphPropertyEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/graph-property-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.alwaysEditable = true;
                    ctrl.graphProperties = [{
                            name: 'regular',
                            humanReadableName: 'regular'
                        }, {
                            name: 'acyclic',
                            humanReadableName: 'acyclic'
                        }, {
                            name: 'strongly_connected',
                            humanReadableName: 'strongly connected'
                        }, {
                            name: 'weakly_connected',
                            humanReadableName: 'weakly connected'
                        }];
                    ctrl.localValue = {
                        property: ctrl.graphProperties[0]
                    };
                    for (var i = 0; i < ctrl.graphProperties.length; i++) {
                        if (ctrl.graphProperties[i].name === ctrl.value) {
                            ctrl.localValue.property = ctrl.graphProperties[i];
                        }
                    }
                    $scope.$watch('$ctrl.localValue.property', function () {
                        ctrl.value = ctrl.localValue.property.name;
                    });
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/html-editor.directive.ts":
/*!***************************************************************!*\
  !*** ./extensions/objects/templates/html-editor.directive.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for HTML editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
//
// This directive is based on the UnicodeString directive.
angular.module('oppia').directive('htmlEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/html-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.schema = {
                        type: 'html'
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/image-with-regions-editor.directive.ts":
/*!*****************************************************************************!*\
  !*** ./extensions/objects/templates/image-with-regions-editor.directive.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for image with regions editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
// TODO(czx): Uniquify the labels of image regions
angular.module('oppia').directive('imageWithRegionsEditor', [
    'AssetsBackendApiService',
    'ContextService', 'UrlInterpolationService', 'ENTITY_TYPE',
    function (AssetsBackendApiService, ContextService, UrlInterpolationService, ENTITY_TYPE) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/image-with-regions-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$element', '$uibModal',
                function ($scope, $element, $uibModal) {
                    var ctrl = this;
                    ctrl.alwaysEditable = true;
                    // Dynamically defines the CSS style for the region rectangle.
                    ctrl.getRegionStyle = function (index) {
                        if (index === ctrl.selectedRegion) {
                            return 'fill: #00f; opacity: 0.5; stroke: #00d';
                        }
                        else {
                            return 'fill: white; opacity: 0.5; stroke: #ddd';
                        }
                    };
                    // Dynamically defines the CSS style for the region trash icon.
                    ctrl.getRegionTrashStyle = function (index) {
                        if (index === ctrl.selectedRegion) {
                            return 'fill: #eee; opacity: 0.7';
                        }
                        else {
                            return 'fill: #333; opacity: 0.7';
                        }
                    };
                    // Dynamically defines the CSS style for the region label.
                    ctrl.getRegionLabelStyle = function (index) {
                        var commonStyles = 'font-size: 14px; pointer-events: none;';
                        if (index === ctrl.selectedRegion) {
                            return commonStyles + ' fill: #eee; visibility: hidden;';
                        }
                        else {
                            return commonStyles + ' fill: #333; visibility: visible;';
                        }
                    };
                    // Dynamically defines the CSS style for the region label text input.
                    ctrl.getRegionLabelEditorStyle = function () {
                        if (ctrl.selectedRegion === null) {
                            return 'display: none';
                        }
                        var area = cornerAndDimensionsFromRegionArea(ctrl.value.labeledRegions[ctrl.selectedRegion].region.area);
                        return 'left: ' + (area.x + 6) + 'px; ' +
                            'top: ' + (area.y + 26) + 'px; ' +
                            'width: ' + (area.width - 12) + 'px;';
                    };
                    ctrl.initializeEditor = function () {
                        // All coordinates have origin at top-left,
                        // increasing in x to the right and increasing in y down
                        // Current mouse position in SVG coordinates
                        ctrl.mouseX = 0;
                        ctrl.mouseY = 0;
                        // Original mouse click position for rectangle drawing.
                        ctrl.originalMouseX = 0;
                        ctrl.originalMouseY = 0;
                        // Original position and dimensions for dragged rectangle.
                        ctrl.originalRectArea = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        };
                        // Coordinates for currently drawn rectangle (when user is dragging)
                        ctrl.rectX = 0;
                        ctrl.rectY = 0;
                        ctrl.rectWidth = 0;
                        ctrl.rectHeight = 0;
                        // Is user currently drawing a new region?
                        ctrl.userIsCurrentlyDrawing = false;
                        // Is user currently dragging an existing region?
                        ctrl.userIsCurrentlyDragging = false;
                        // Is user currently resizing an existing region?
                        ctrl.userIsCurrentlyResizing = false;
                        // The horizontal direction along which user resize occurs.
                        // 1 -> Left     -1 -> Right     0 -> No resize
                        ctrl.xDirection = 0;
                        // The vertical direction along which user resize occurs.
                        // 1 -> Top     -1 -> Bottom     0 -> No resize
                        ctrl.yDirection = 0;
                        // Flags to check whether the direction changes while resizing.
                        ctrl.yDirectionToggled = false;
                        ctrl.xDirectionToggled = false;
                        // A boolean that is set whenever the cursor moves out of the
                        // rectangular region while resizing.
                        ctrl.movedOutOfRegion = false;
                        // The region along borders that will display the resize cursor.
                        ctrl.resizableBorderWidthPx = 10;
                        // Dimensions of original image.
                        ctrl.originalImageWidth = 0;
                        ctrl.originalImageHeight = 0;
                        // Index of region currently hovered over.
                        ctrl.hoveredRegion = null;
                        // Index of region currently selected.
                        ctrl.selectedRegion = null;
                        // Message to displaye when there is an error.
                        ctrl.errorText = '';
                    };
                    ctrl.initializeEditor();
                    // Calculates the dimensions of the image, assuming that the width
                    // of the image is scaled down to fit the svg element if necessary.
                    var _calculateImageDimensions = function () {
                        var svgElement = $($element).find('.oppia-image-with-regions-editor-svg');
                        var displayedImageWidth = Math.min(svgElement.width(), ctrl.originalImageWidth);
                        var scalingRatio = displayedImageWidth / ctrl.originalImageWidth;
                        // Note that scalingRatio may be NaN if ctrl.originalImageWidth is
                        // zero.
                        var displayedImageHeight = (ctrl.originalImageWidth === 0 ? 0.0 :
                            ctrl.originalImageHeight * scalingRatio);
                        return {
                            width: displayedImageWidth,
                            height: displayedImageHeight
                        };
                    };
                    // Use these two functions to get the calculated image width and
                    // height.
                    ctrl.getImageWidth = function () {
                        return _calculateImageDimensions().width;
                    };
                    ctrl.getImageHeight = function () {
                        return _calculateImageDimensions().height;
                    };
                    ctrl.getPreviewUrl = function (imageUrl) {
                        return AssetsBackendApiService.getImageUrlForPreview(ENTITY_TYPE.EXPLORATION, ContextService.getExplorationId(), encodeURIComponent(imageUrl));
                    };
                    // Called when the image is changed to calculate the required
                    // width and height, especially for large images.
                    $scope.$watch('$ctrl.value.imagePath', function (newVal) {
                        if (newVal !== '') {
                            // Loads the image in hanging <img> tag so as to get the
                            // width and height.
                            $('<img/>').attr('src', ctrl.getPreviewUrl(newVal)).on('load', function () {
                                ctrl.originalImageWidth = this.width;
                                ctrl.originalImageHeight = this.height;
                                $scope.$apply();
                            });
                        }
                    });
                    var hasDuplicates = function (originalArray) {
                        var array = originalArray.slice(0).sort();
                        for (var i = 1; i < array.length; i++) {
                            if (array[i - 1] === array[i]) {
                                return true;
                            }
                        }
                        return false;
                    };
                    ctrl.regionLabelGetterSetter = function (index) {
                        return function (label) {
                            if (angular.isDefined(label)) {
                                ctrl.value.labeledRegions[index].label = label;
                                var labels = ctrl.value.labeledRegions.map(function (region) {
                                    return region.label;
                                });
                                if (hasDuplicates(labels)) {
                                    ctrl.errorText = 'Warning: Label "' + label + '" already ' +
                                        'exists! Please use a different label.';
                                }
                                else {
                                    ctrl.errorText = '';
                                }
                            }
                            return ctrl.value.labeledRegions[index].label;
                        };
                    };
                    var convertCoordsToFraction = function (coords, dimensions) {
                        return [coords[0] / dimensions[0], coords[1] / dimensions[1]];
                    };
                    // Convert to and from region area (which is stored as a fraction of
                    // image width and height) and actual width and height.
                    var regionAreaFromCornerAndDimensions = function (x, y, width, height) {
                        return [
                            convertCoordsToFraction([x, y], [ctrl.getImageWidth(), ctrl.getImageHeight()]),
                            convertCoordsToFraction([x + width, y + height], [ctrl.getImageWidth(), ctrl.getImageHeight()])
                        ];
                    };
                    var cornerAndDimensionsFromRegionArea = function (area) {
                        return {
                            x: area[0][0] * ctrl.getImageWidth(),
                            y: area[0][1] * ctrl.getImageHeight(),
                            width: (area[1][0] - area[0][0]) * ctrl.getImageWidth(),
                            height: (area[1][1] - area[0][1]) * ctrl.getImageHeight()
                        };
                    };
                    var resizeRegion = function () {
                        var labeledRegions = ctrl.value.labeledRegions;
                        var resizedRegion = labeledRegions[ctrl.selectedRegion].region;
                        var deltaX = ctrl.mouseX - ctrl.originalMouseX;
                        var deltaY = ctrl.mouseY - ctrl.originalMouseY;
                        var x = ctrl.originalRectArea.x;
                        var y = ctrl.originalRectArea.y;
                        var width = ctrl.originalRectArea.width;
                        var height = ctrl.originalRectArea.height;
                        var newWidth = width - ctrl.xDirection * deltaX;
                        var newHeight = height - ctrl.yDirection * deltaY;
                        // The distance between where the mouse was first clicked to
                        // initiate the resize action and the left-most x co-ordinate of
                        // rectangle.
                        var marginX = Math.abs(ctrl.originalRectArea.x - ctrl.originalMouseX);
                        // The distance between where the mouse was first clicked to
                        // initiate the resize action and the top-most y co-ordinate of
                        // rectangle.
                        var marginY = Math.abs(ctrl.originalRectArea.y - ctrl.originalMouseY);
                        if (newHeight <= 0 && !ctrl.yDirectionToggled) {
                            ctrl.yDirectionToggled = true;
                        }
                        else if (newHeight >= 0 && ctrl.yDirectionToggled) {
                            ctrl.yDirectionToggled = false;
                        }
                        if (ctrl.yDirection === 1) {
                            y += ctrl.yDirectionToggled ? (height + marginY) : deltaY;
                        }
                        else if (ctrl.yDirection === -1) {
                            y += ctrl.yDirectionToggled * (deltaY + marginY);
                        }
                        if (newWidth <= 0 && !ctrl.xDirectionToggled) {
                            ctrl.xDirectionToggled = true;
                        }
                        else if (newWidth >= 0 && ctrl.xDirectionToggled) {
                            ctrl.xDirectionToggled = false;
                        }
                        if (ctrl.xDirection === 1) {
                            x += ctrl.xDirectionToggled ? (width + marginX) : deltaX;
                        }
                        else if (ctrl.xDirection === -1) {
                            x += ctrl.xDirectionToggled * (deltaX + marginX);
                        }
                        // Whenever the direction changes the value of newHeight and
                        // newWidth computed is negative, hence the absolute value is taken.
                        resizedRegion.area = regionAreaFromCornerAndDimensions(x, y, Math.abs(newWidth), Math.abs(newHeight));
                    };
                    ctrl.onSvgMouseMove = function (evt) {
                        var svgElement = $($element).find('.oppia-image-with-regions-editor-svg');
                        ctrl.mouseX = evt.pageX - svgElement.offset().left;
                        ctrl.mouseY = evt.pageY - svgElement.offset().top;
                        if (ctrl.userIsCurrentlyDrawing) {
                            ctrl.rectX = Math.min(ctrl.originalMouseX, ctrl.mouseX);
                            ctrl.rectY = Math.min(ctrl.originalMouseY, ctrl.mouseY);
                            ctrl.rectWidth = Math.abs(ctrl.originalMouseX - ctrl.mouseX);
                            ctrl.rectHeight = Math.abs(ctrl.originalMouseY - ctrl.mouseY);
                        }
                        else if (ctrl.userIsCurrentlyDragging) {
                            var labeledRegions = ctrl.value.labeledRegions;
                            var draggedRegion = labeledRegions[ctrl.selectedRegion].region;
                            var deltaX = ctrl.mouseX - ctrl.originalMouseX;
                            var deltaY = ctrl.mouseY - ctrl.originalMouseY;
                            var newX1 = ctrl.originalRectArea.x + deltaX;
                            var newY1 = ctrl.originalRectArea.y + deltaY;
                            var newX2 = newX1 + ctrl.originalRectArea.width;
                            var newY2 = newY1 + ctrl.originalRectArea.height;
                            if (newX1 < 0) {
                                newX1 = 0;
                                newX2 = ctrl.originalRectArea.width;
                            }
                            if (newY1 < 0) {
                                newY1 = 0;
                                newY2 = ctrl.originalRectArea.height;
                            }
                            if (newX2 > ctrl.getImageWidth()) {
                                newX2 = ctrl.getImageWidth();
                                newX1 = newX2 - ctrl.originalRectArea.width;
                            }
                            if (newY2 > ctrl.getImageHeight()) {
                                newY2 = ctrl.getImageHeight();
                                newY1 = newY2 - ctrl.originalRectArea.height;
                            }
                            draggedRegion.area = regionAreaFromCornerAndDimensions(newX1, newY1, ctrl.originalRectArea.width, ctrl.originalRectArea.height);
                        }
                        else if (ctrl.userIsCurrentlyResizing) {
                            resizeRegion();
                        }
                    };
                    ctrl.onSvgMouseDown = function (evt) {
                        evt.preventDefault();
                        ctrl.originalMouseX = ctrl.mouseX;
                        ctrl.originalMouseY = ctrl.mouseY;
                        if (ctrl.hoveredRegion === null) {
                            ctrl.rectWidth = ctrl.rectHeight = 0;
                            ctrl.userIsCurrentlyDrawing = true;
                        }
                    };
                    ctrl.onSvgMouseUp = function () {
                        if (ctrl.hoveredRegion === null) {
                            ctrl.selectedRegion = null;
                        }
                        if (ctrl.yDirectionToggled) {
                            ctrl.yDirection = (ctrl.yDirection === 1) ? -1 : 1;
                        }
                        if (ctrl.xDirectionToggled) {
                            ctrl.xDirection = (ctrl.xDirection === 1) ? -1 : 1;
                        }
                        if (ctrl.movedOutOfRegion) {
                            ctrl.xDirection = 0;
                            ctrl.yDirection = 0;
                        }
                        if (ctrl.userIsCurrentlyDrawing) {
                            if (ctrl.rectWidth !== 0 && ctrl.rectHeight !== 0) {
                                var labels = ctrl.value.labeledRegions.map(function (region) {
                                    return region.label;
                                });
                                // Searches numbers starting from 1 to find a valid label
                                // that doesn't overlap with currently existing labels.
                                var newLabel = null;
                                for (var i = 1; i <= labels.length + 1; i++) {
                                    var candidateLabel = 'Region' + i.toString();
                                    if (labels.indexOf(candidateLabel) === -1) {
                                        newLabel = candidateLabel;
                                        break;
                                    }
                                }
                                var newRegion = {
                                    label: newLabel,
                                    region: {
                                        regionType: 'Rectangle',
                                        area: regionAreaFromCornerAndDimensions(ctrl.rectX, ctrl.rectY, ctrl.rectWidth, ctrl.rectHeight)
                                    }
                                };
                                ctrl.value.labeledRegions.push(newRegion);
                                ctrl.selectedRegion = (ctrl.value.labeledRegions.length - 1);
                            }
                        }
                        ctrl.userIsCurrentlyDrawing = false;
                        ctrl.userIsCurrentlyDragging = false;
                        ctrl.userIsCurrentlyResizing = false;
                        ctrl.movedOutOfRegion = false;
                        ctrl.yDirectionToggled = false;
                        ctrl.xDirectionToggled = false;
                    };
                    ctrl.onMouseoverRegion = function (index) {
                        if (ctrl.hoveredRegion === null) {
                            ctrl.hoveredRegion = index;
                        }
                        ctrl.movedOutOfRegion = false;
                    };
                    ctrl.onMouseMoveRegion = function () {
                        if (ctrl.userIsCurrentlyDragging ||
                            ctrl.userIsCurrentlyResizing) {
                            return;
                        }
                        var region = cornerAndDimensionsFromRegionArea(ctrl.value.labeledRegions[ctrl.hoveredRegion].region.area);
                        if (!ctrl.xDirectionToggled && !ctrl.yDirectionToggled) {
                            if (ctrl.mouseY <= region.y + ctrl.resizableBorderWidthPx) {
                                ctrl.yDirection = 1;
                            }
                            else if (ctrl.mouseY >= region.height + region.y -
                                ctrl.resizableBorderWidthPx) {
                                ctrl.yDirection = -1;
                            }
                            else {
                                ctrl.yDirection = 0;
                            }
                            if (ctrl.mouseX <= region.x + ctrl.resizableBorderWidthPx) {
                                ctrl.xDirection = 1;
                            }
                            else if (ctrl.mouseX >= region.width + region.x -
                                ctrl.resizableBorderWidthPx) {
                                ctrl.xDirection = -1;
                            }
                            else {
                                ctrl.xDirection = 0;
                            }
                        }
                    };
                    ctrl.onMouseoutRegion = function (index) {
                        if (ctrl.hoveredRegion === index) {
                            ctrl.hoveredRegion = null;
                        }
                        if (!ctrl.userIsCurrentlyResizing) {
                            ctrl.xDirection = 0;
                            ctrl.yDirection = 0;
                        }
                        ctrl.movedOutOfRegion = true;
                    };
                    ctrl.onMousedownRegion = function () {
                        if (ctrl.xDirection || ctrl.yDirection) {
                            ctrl.userIsCurrentlyResizing = true;
                        }
                        else {
                            ctrl.userIsCurrentlyDragging = true;
                        }
                        ctrl.selectedRegion = ctrl.hoveredRegion;
                        ctrl.originalRectArea = cornerAndDimensionsFromRegionArea(ctrl.value.labeledRegions[ctrl.hoveredRegion].region.area);
                    };
                    ctrl.regionLabelEditorMouseUp = function () {
                        ctrl.userIsCurrentlyDragging = false;
                        ctrl.userIsCurrentlyResizing = false;
                    };
                    ctrl.getCursorStyle = function () {
                        var xDirectionCursor = '';
                        var yDirectionCursor = '';
                        if (ctrl.xDirection || ctrl.yDirection) {
                            // User is resizing, so we figure out the direction.
                            if ((ctrl.xDirection === 1 && !ctrl.xDirectionToggled) ||
                                (ctrl.xDirection === -1 && ctrl.xDirectionToggled)) {
                                xDirectionCursor = 'w';
                            }
                            else if ((ctrl.xDirection === -1 && !ctrl.xDirectionToggled) ||
                                (ctrl.xDirection === 1 && ctrl.xDirectionToggled)) {
                                xDirectionCursor = 'e';
                            }
                            else {
                                xDirectionCursor = '';
                            }
                            if ((ctrl.yDirection === 1 && !ctrl.yDirectionToggled) ||
                                (ctrl.yDirection === -1 && ctrl.yDirectionToggled)) {
                                yDirectionCursor = 'n';
                            }
                            else if ((ctrl.yDirection === -1 && !ctrl.yDirectionToggled) ||
                                (ctrl.yDirection === 1 && ctrl.yDirectionToggled)) {
                                yDirectionCursor = 's';
                            }
                            else {
                                yDirectionCursor = '';
                            }
                            return yDirectionCursor + xDirectionCursor + '-resize';
                        }
                        else if (ctrl.hoveredRegion !== null) {
                            // User is not resizing but cursor is over a region.
                            return 'pointer';
                        }
                        return 'crosshair';
                    };
                    ctrl.resetEditor = function () {
                        $uibModal.open({
                            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/' +
                                'image-with-regions-reset-confirmation.directive.html'),
                            backdrop: 'static',
                            keyboard: false,
                            controller: [
                                '$scope', '$uibModalInstance',
                                function ($scope, $uibModalInstance) {
                                    $scope.cancel = function () {
                                        $uibModalInstance.dismiss();
                                    };
                                    $scope.confirmClear = function () {
                                        $uibModalInstance.close();
                                    };
                                }
                            ]
                        }).result.then(function () {
                            ctrl.value.imagePath = '';
                            ctrl.value.labeledRegions = [];
                            ctrl.initializeEditor();
                        });
                    };
                    ctrl.deleteRegion = function (index) {
                        if (ctrl.selectedRegion === index) {
                            ctrl.selectedRegion = null;
                        }
                        else if (ctrl.selectedRegion > index) {
                            ctrl.selectedRegion--;
                        }
                        if (ctrl.hoveredRegion === index) {
                            ctrl.hoveredRegion = null;
                        }
                        else if (ctrl.hoveredRegion > index) {
                            ctrl.hoveredRegion--;
                        }
                        ctrl.value.labeledRegions.splice(index, 1);
                    };
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/int-editor.directive.ts":
/*!**************************************************************!*\
  !*** ./extensions/objects/templates/int-editor.directive.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for int editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('intEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/int-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'int',
                        validators: [{
                                id: 'is_integer'
                            }]
                    };
                    if (!ctrl.value) {
                        ctrl.value = 0;
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/list-of-sets-of-html-strings-editor.directive.ts":
/*!***************************************************************************************!*\
  !*** ./extensions/objects/templates/list-of-sets-of-html-strings-editor.directive.ts ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for list of sets of html strings editor.
 */
angular.module('oppia').directive('listOfSetsOfHtmlStringsEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/' +
                'list-of-sets-of-html-strings-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    var errorMessage = '';
                    if (!ctrl.selectedRank) {
                        ctrl.selectedRank = '';
                    }
                    if (!ctrl.maxPrevIndex) {
                        ctrl.maxPrevIndex = 1;
                    }
                    ctrl.initValues = [];
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.choices = ctrl.initArgs.choices;
                    // Initialize the default values.
                    if (ctrl.value[0] === undefined || ctrl.value[0].length === 0) {
                        ctrl.value = [[]];
                        for (var i = 0; i < ctrl.choices.length; i++) {
                            ctrl.value[0].push(ctrl.choices[i].id);
                            ctrl.initValues.push(1);
                        }
                    }
                    else {
                        for (var i = 0; i < ctrl.choices.length; i++) {
                            for (var j = 0; j < ctrl.value.length; j++) {
                                var choice = ctrl.choices[i].id;
                                if (ctrl.value[j].indexOf(choice) !== -1) {
                                    ctrl.initValues.push(j + 1);
                                    ctrl.maxPrevIndex = math.max(ctrl.maxPrevIndex, j + 1);
                                    break;
                                }
                            }
                        }
                    }
                    if (ctrl.selectedRank !== '') {
                        ctrl.maxPrevIndex = math.max(parseInt(ctrl.selectedRank), ctrl.maxPrevIndex);
                    }
                    ctrl.allowedChoices = function () {
                        var allowedList = [];
                        for (var i = 0; i <= math.min(ctrl.maxPrevIndex, ctrl.choices.length - 1); i++) {
                            allowedList.push(i + 1);
                        }
                        return allowedList;
                    };
                    ctrl.selectedItem = function (choiceListIndex, selectedRankString) {
                        var choiceHtml = ctrl.choices[choiceListIndex].id;
                        var selectedRank = parseInt(selectedRankString) - 1;
                        errorMessage = '';
                        // Reorder the ctrl.choices array to make it consistent with the
                        // selected rank.
                        // ctrl.choices.splice(selectedRank, 0, ctrl.choices.splice(
                        // choiceListIndex, 1)[0]);
                        var choiceHtmlHasBeenAdded = false;
                        ctrl.maxPrevIndex = math.max(selectedRank + 1, ctrl.maxPrevIndex);
                        for (var i = 0; i < ctrl.value.length; i++) {
                            choiceHtmlHasBeenAdded = false;
                            var choiceHtmlIndex = ctrl.value[i].indexOf(choiceHtml);
                            if (choiceHtmlIndex > -1) {
                                if (i !== selectedRank) {
                                    ctrl.value[i].splice(choiceHtmlIndex, 1);
                                    if (ctrl.value[selectedRank] === undefined) {
                                        ctrl.value[selectedRank] = [choiceHtml];
                                    }
                                    else {
                                        ctrl.value[selectedRank].push(choiceHtml);
                                    }
                                }
                                choiceHtmlHasBeenAdded = true;
                                break;
                            }
                        }
                        for (var i = 0; i < ctrl.value.length; i++) {
                            if (ctrl.value[i].length === 0) {
                                if (i === ctrl.value.length - 1) {
                                    // If it is empty list at the last, pop it out.
                                    ctrl.value.pop();
                                }
                                else {
                                    // Continuity error.
                                    errorMessage = ('No choice(s) is assigned at position ' +
                                        String(i + 1) + '. Please assign some choice at this ' +
                                        'position.');
                                }
                            }
                        }
                        if (!choiceHtmlHasBeenAdded) {
                            if (ctrl.value[selectedRank] === undefined) {
                                ctrl.value[selectedRank] = [choiceHtml];
                            }
                            else {
                                ctrl.value[selectedRank].push(choiceHtml);
                            }
                        }
                    };
                    ctrl.getWarningText = function () {
                        return errorMessage;
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/list-of-tabs-editor.directive.ts":
/*!***********************************************************************!*\
  !*** ./extensions/objects/templates/list-of-tabs-editor.directive.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS-IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for list of tabs editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('listOfTabsEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/list-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'list',
                        items: {
                            type: 'dict',
                            properties: [{
                                    name: 'title',
                                    description: 'Tab title',
                                    schema: {
                                        type: 'unicode',
                                        validators: [{
                                                id: 'is_nonempty'
                                            }]
                                    }
                                }, {
                                    name: 'content',
                                    description: 'Tab content',
                                    schema: {
                                        type: 'html',
                                        ui_config: {
                                            hide_complex_extensions: true
                                        }
                                    }
                                }]
                        },
                        ui_config: {
                            add_element_text: 'Add new tab'
                        }
                    };
                    if (!ctrl.value) {
                        ctrl.value = [];
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/list-of-unicode-string-editor.directive.ts":
/*!*********************************************************************************!*\
  !*** ./extensions/objects/templates/list-of-unicode-string-editor.directive.ts ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for list of unicode string editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('listOfUnicodeStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/list-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'list',
                        items: {
                            type: 'unicode'
                        }
                    };
                    if (!ctrl.value) {
                        ctrl.value = [];
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/logic-error-category-editor.directive.ts":
/*!*******************************************************************************!*\
  !*** ./extensions/objects/templates/logic-error-category-editor.directive.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for logic error category editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('logicErrorCategoryEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/logic-error-category-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.alwaysEditable = true;
                    ctrl.errorCategories = [{
                            name: 'parsing',
                            humanReadable: 'Unparseable'
                        }, {
                            name: 'typing',
                            humanReadable: 'Ill-typed'
                        }, {
                            name: 'line',
                            humanReadable: 'Incorrect line'
                        }, {
                            name: 'layout',
                            humanReadable: 'Wrong indenting'
                        }, {
                            name: 'variables',
                            humanReadable: 'Variables error'
                        }, {
                            name: 'logic',
                            humanReadable: 'Invalid deduction'
                        }, {
                            name: 'target',
                            humanReadable: 'Target not proved'
                        }, {
                            name: 'mistake',
                            humanReadable: 'Unspecified'
                        }];
                    ctrl.localValue = {
                        category: ctrl.errorCategories[0]
                    };
                    for (var i = 0; i < ctrl.errorCategories.length; i++) {
                        if (ctrl.errorCategories[i].name === ctrl.value) {
                            ctrl.localValue.category = ctrl.errorCategories[i];
                        }
                    }
                    $scope.$watch('$ctrl.localValue.category', function () {
                        ctrl.value = ctrl.localValue.category.name;
                    });
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/logic-question-editor.directive.ts":
/*!*************************************************************************!*\
  !*** ./extensions/objects/templates/logic-question-editor.directive.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Directive for logic question editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
var shared_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/shared.ts */ "./extensions/interactions/LogicProof/static/js/shared.ts"));
var teacher_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/teacher.ts */ "./extensions/interactions/LogicProof/static/js/teacher.ts"));
var data_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/data.ts */ "./extensions/interactions/LogicProof/static/js/data.ts"));
var conversion_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/conversion.ts */ "./extensions/interactions/LogicProof/static/js/conversion.ts"));
var generatedDefaultData_ts_1 = __importDefault(__webpack_require__(/*! interactions/LogicProof/static/js/generatedDefaultData.ts */ "./extensions/interactions/LogicProof/static/js/generatedDefaultData.ts"));
angular.module('oppia').directive('logicQuestionEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/logic-question-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.alwaysEditable = true;
                    ctrl.localValue = {
                        assumptionsString: shared_ts_1.default.displayExpressionArray(ctrl.value.assumptions, data_ts_1.default.BASE_STUDENT_LANGUAGE.operators),
                        targetString: shared_ts_1.default.displayExpression(ctrl.value.results[0], data_ts_1.default.BASE_STUDENT_LANGUAGE.operators),
                        errorMessage: '',
                        proofString: ctrl.value.default_proof_string
                    };
                    // NOTE: we use ng-change rather than $watch because the latter runs in
                    // response to any change to the watched value, and we only want to
                    // respond to changes made by the user.
                    ctrl.changeAssumptions = function () {
                        ctrl.convertThenBuild('logicQuestionAssumptions', 'assumptionsString');
                    };
                    ctrl.changeTarget = function () {
                        ctrl.convertThenBuild('logicQuestionTarget', 'targetString');
                    };
                    ctrl.changeProof = function () {
                        ctrl.convertThenBuild('logicQuestionProof', 'proofString');
                    };
                    ctrl.convertThenBuild = function (elementID, nameOfString) {
                        var element = document.getElementById(elementID);
                        var cursorPosition = element.selectionEnd;
                        ctrl.localValue[nameOfString] =
                            conversion_ts_1.default.convertToLogicCharacters(ctrl.localValue[nameOfString]);
                        ctrl.buildQuestion();
                        // NOTE: angular will reset the position of the cursor after this
                        // function runs, so we need to delay our re-resetting.
                        setTimeout(function () {
                            element.selectionEnd = cursorPosition;
                        }, 2);
                    };
                    ctrl.buildQuestion = function () {
                        try {
                            var builtQuestion = angular.copy(teacher_ts_1.default.buildQuestion(ctrl.localValue.assumptionsString, ctrl.localValue.targetString, generatedDefaultData_ts_1.default.vocabulary));
                            ctrl.value = {
                                assumptions: builtQuestion.assumptions,
                                results: builtQuestion.results,
                                default_proof_string: ctrl.localValue.proofString
                            };
                            ctrl.localValue.errorMessage = '';
                        }
                        catch (err) {
                            ctrl.localValue.errorMessage = err.message;
                        }
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/math-latex-string-editor.directive.ts":
/*!****************************************************************************!*\
  !*** ./extensions/objects/templates/math-latex-string-editor.directive.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for math latex string editor.
 */
__webpack_require__(/*! directives/mathjax-bind.directive.ts */ "./core/templates/dev/head/directives/mathjax-bind.directive.ts");
__webpack_require__(/*! domain/utilities/UrlInterpolationService.ts */ "./core/templates/dev/head/domain/utilities/UrlInterpolationService.ts");
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('mathLatexStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getAlwaysEditable: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/math-latex-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.placeholderText = '\\frac{x}{y}';
                    ctrl.alwaysEditable = ctrl.getAlwaysEditable();
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function () {
                        ctrl.localValue = {
                            label: ctrl.value || ''
                        };
                    }, true);
                    if (ctrl.alwaysEditable) {
                        $scope.$watch('$ctrl.localValue.label', function (newValue) {
                            ctrl.value = newValue;
                        });
                    }
                    else {
                        ctrl.openEditor = function () {
                            ctrl.active = true;
                        };
                        ctrl.closeEditor = function () {
                            ctrl.active = false;
                        };
                        ctrl.replaceValue = function (newValue) {
                            ctrl.localValue = {
                                label: newValue
                            };
                            ctrl.value = newValue;
                            ctrl.closeEditor();
                        };
                        $scope.$on('externalSave', function () {
                            if (ctrl.active) {
                                ctrl.replaceValue(ctrl.localValue.label);
                                // The $scope.$apply() call is needed to propagate the replaced
                                // value.
                                $scope.$apply();
                            }
                        });
                        ctrl.closeEditor();
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/music-phrase-editor.directive.ts":
/*!***********************************************************************!*\
  !*** ./extensions/objects/templates/music-phrase-editor.directive.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2012 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for music phrase editor.
 */
// This directive is always editable.
angular.module('oppia').directive('musicPhraseEditor', [
    'AlertsService', 'UrlInterpolationService',
    function (AlertsService, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/music-phrase-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    // The maximum number of notes allowed in a music phrase.
                    var _MAX_NOTES_IN_PHRASE = 8;
                    ctrl.schema = {
                        type: 'list',
                        items: {
                            type: 'unicode',
                            choices: [
                                'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5',
                                'G5', 'A5'
                            ]
                        },
                        ui_config: {
                            add_element_text: 'Add Note '
                        },
                        validators: [{
                                id: 'has_length_at_most',
                                max_value: _MAX_NOTES_IN_PHRASE
                            }]
                    };
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function (newValue) {
                        // TODO(sll): Check that $ctrl.value is a list.
                        ctrl.localValue = [];
                        if (newValue) {
                            for (var i = 0; i < newValue.length; i++) {
                                ctrl.localValue.push(newValue[i].readableNoteName);
                            }
                        }
                    }, true);
                    $scope.$watch('$ctrl.localValue', function (newValue, oldValue) {
                        if (newValue && oldValue) {
                            if (newValue.length > _MAX_NOTES_IN_PHRASE) {
                                AlertsService.addWarning('There are too many notes on the staff.');
                            }
                            else {
                                var parentValues = [];
                                for (var i = 0; i < newValue.length; i++) {
                                    parentValues.push({
                                        readableNoteName: newValue[i],
                                        noteDuration: {
                                            num: 1,
                                            den: 1
                                        }
                                    });
                                }
                                ctrl.value = parentValues;
                            }
                        }
                    }, true);
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/nonnegative-int-editor.directive.ts":
/*!**************************************************************************!*\
  !*** ./extensions/objects/templates/nonnegative-int-editor.directive.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2012 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for non negative int editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('nonnegativeIntEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/nonnegative-int-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'int',
                        validators: [{
                                id: 'is_at_least',
                                min_value: 0
                            }, {
                                id: 'is_integer'
                            }]
                    };
                    if (!ctrl.value) {
                        ctrl.value = 0;
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/normalized-string-editor.directive.ts":
/*!****************************************************************************!*\
  !*** ./extensions/objects/templates/normalized-string-editor.directive.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for normalized string editor.
 */
// This is a copy of the UnicodeStringEditor.
angular.module('oppia').directive('normalizedStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getAlwaysEditable: '&',
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/unicode-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.alwaysEditable = ctrl.getAlwaysEditable();
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.largeInput = false;
                    $scope.$watch('$ctrl.initArgs', function (newValue) {
                        ctrl.largeInput = false;
                        if (newValue && newValue.largeInput) {
                            ctrl.largeInput = newValue.largeInput;
                        }
                    });
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function () {
                        ctrl.localValue = {
                            label: ctrl.value || ''
                        };
                    }, true);
                    if (ctrl.alwaysEditable) {
                        $scope.$watch('$ctrl.localValue.label', function (newValue) {
                            ctrl.value = newValue;
                        });
                    }
                    else {
                        ctrl.openEditor = function () {
                            ctrl.active = true;
                        };
                        ctrl.closeEditor = function () {
                            ctrl.active = false;
                        };
                        ctrl.replaceValue = function (newValue) {
                            ctrl.localValue = {
                                label: newValue
                            };
                            ctrl.value = newValue;
                            ctrl.closeEditor();
                        };
                        $scope.$on('externalSave', function () {
                            if (ctrl.active) {
                                ctrl.replaceValue(ctrl.localValue.label);
                                // The $scope.$apply() call is needed to propagate the replaced
                                // value.
                                $scope.$apply();
                            }
                        });
                        ctrl.closeEditor();
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/number-with-units-editor.directive.ts":
/*!****************************************************************************!*\
  !*** ./extensions/objects/templates/number-with-units-editor.directive.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for number with units editor.
 */
angular.module('oppia').directive('numberWithUnitsEditor', [
    'NumberWithUnitsObjectFactory', 'UrlInterpolationService',
    function (NumberWithUnitsObjectFactory, UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/number-with-units-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    var errorMessage = '';
                    var numberWithUnitsString = '';
                    if (ctrl.value !== null) {
                        var defaultNumberWithUnits = NumberWithUnitsObjectFactory.fromDict(ctrl.value);
                        numberWithUnitsString = defaultNumberWithUnits.toString();
                    }
                    ctrl.localValue = {
                        label: numberWithUnitsString
                    };
                    $scope.$watch('$ctrl.localValue.label', function (newValue) {
                        try {
                            var numberWithUnits = NumberWithUnitsObjectFactory.fromRawInputString(newValue);
                            ctrl.value = numberWithUnits;
                            errorMessage = '';
                        }
                        catch (parsingError) {
                            errorMessage = parsingError.message;
                        }
                    });
                    ctrl.getWarningText = function () {
                        return errorMessage;
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/parameter-name-editor.directive.ts":
/*!*************************************************************************!*\
  !*** ./extensions/objects/templates/parameter-name-editor.directive.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for parameter name editor.
 */
// NOTE TO DEVELOPERS: This editor requires ExplorationParamSpecsService to be
// available in the context in which it is used.
angular.module('oppia').directive('parameterNameEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/parameter-name-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [
                '$scope', '$attrs', 'ExplorationParamSpecsService',
                function ($scope, $attrs, ExplorationParamSpecsService) {
                    var ctrl = this;
                    ctrl.availableParamNames =
                        ExplorationParamSpecsService.savedMemento.getParamNames();
                    if (ctrl.availableParamNames.length === 0) {
                        ctrl.localValue = null;
                    }
                    else {
                        ctrl.localValue = ctrl.availableParamNames[0];
                    }
                    ctrl.validate = function () {
                        return (ctrl.availableParamNames.length === 0) ? false : true;
                    };
                    ctrl.SCHEMA = {
                        type: 'unicode',
                        choices: ctrl.availableParamNames
                    };
                    // Reset the component each time the value changes (e.g. if this is
                    // part of an editable list).
                    $scope.$watch('$ctrl.value', function (newValue) {
                        if (newValue) {
                            ctrl.localValue = newValue;
                        }
                    }, true);
                    $scope.$watch('$ctrl.localValue', function (newValue) {
                        ctrl.value = newValue;
                    });
                }
            ]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/real-editor.directive.ts":
/*!***************************************************************!*\
  !*** ./extensions/objects/templates/real-editor.directive.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for real editor.
 */
angular.module('oppia').directive('realEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/real-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.schema = {
                        type: 'float'
                    };
                    $scope.$watch('$ctrl.value', function () {
                        if (ctrl.value === '') {
                            // A new rule
                            ctrl.value = 0.0;
                        }
                    });
                    if (ctrl.value === '') {
                        ctrl.value = 0.0;
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/sanitized-url-editor.directive.ts":
/*!************************************************************************!*\
  !*** ./extensions/objects/templates/sanitized-url-editor.directive.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for sanitized URL editor.
 */
angular.module('oppia').directive('sanitizedUrlEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        // Editable URL directive.
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/sanitized-url-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'unicode',
                        validators: [{
                                id: 'is_nonempty'
                            }],
                        ui_config: {
                            placeholder: 'https://www.example.com'
                        }
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/set-of-html-string-editor.directive.ts":
/*!*****************************************************************************!*\
  !*** ./extensions/objects/templates/set-of-html-string-editor.directive.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2012 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for set of HTML string editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('setOfHtmlStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/set-of-html-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'list',
                        items: {
                            type: 'html'
                        }
                    };
                    if (!ctrl.value) {
                        ctrl.value = [];
                    }
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.choices = ctrl.initArgs.choices;
                    ctrl.selections = ctrl.choices.map(function (choice) {
                        return ctrl.value.indexOf(choice.id) !== -1;
                    });
                    // The following function is necessary to insert elements into the
                    // answer groups for the Item Selection Widget.
                    ctrl.toggleSelection = function (choiceListIndex) {
                        var choiceHtml = ctrl.choices[choiceListIndex].id;
                        var selectedChoicesIndex = ctrl.value.indexOf(choiceHtml);
                        if (selectedChoicesIndex > -1) {
                            ctrl.value.splice(selectedChoicesIndex, 1);
                        }
                        else {
                            ctrl.value.push(choiceHtml);
                        }
                    };
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/set-of-unicode-string-editor.directive.ts":
/*!********************************************************************************!*\
  !*** ./extensions/objects/templates/set-of-unicode-string-editor.directive.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for set of unicode string editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('setOfUnicodeStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/list-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: [function () {
                    var ctrl = this;
                    ctrl.SCHEMA = {
                        type: 'list',
                        items: {
                            type: 'unicode'
                        },
                        validators: [{
                                id: 'is_uniquified'
                            }]
                    };
                    if (!ctrl.value) {
                        ctrl.value = [];
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./extensions/objects/templates/unicode-string-editor.directive.ts":
/*!*************************************************************************!*\
  !*** ./extensions/objects/templates/unicode-string-editor.directive.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Directive for unicode string editor.
 */
// Every editor directive should implement an alwaysEditable option. There
// may be additional customization options for the editor that should be passed
// in via initArgs.
angular.module('oppia').directive('unicodeStringEditor', [
    'UrlInterpolationService',
    function (UrlInterpolationService) {
        return {
            restrict: 'E',
            scope: {},
            bindToController: {
                getAlwaysEditable: '&',
                getInitArgs: '&',
                value: '='
            },
            templateUrl: UrlInterpolationService.getExtensionResourceUrl('/objects/templates/unicode-string-editor.directive.html'),
            controllerAs: '$ctrl',
            controller: ['$scope', function ($scope) {
                    var ctrl = this;
                    ctrl.alwaysEditable = ctrl.getAlwaysEditable();
                    ctrl.initArgs = ctrl.getInitArgs();
                    ctrl.largeInput = false;
                    $scope.$watch('$ctrl.initArgs', function (newValue) {
                        ctrl.largeInput = false;
                        if (newValue && newValue.largeInput) {
                            ctrl.largeInput = newValue.largeInput;
                        }
                    });
                    // Reset the component each time the value changes (e.g. if this is part
                    // of an editable list).
                    $scope.$watch('$ctrl.value', function () {
                        ctrl.localValue = {
                            label: ctrl.value || ''
                        };
                    }, true);
                    if (ctrl.alwaysEditable) {
                        $scope.$watch('$ctrl.localValue.label', function (newValue) {
                            ctrl.value = newValue;
                        });
                    }
                    else {
                        ctrl.openEditor = function () {
                            ctrl.active = true;
                        };
                        ctrl.closeEditor = function () {
                            ctrl.active = false;
                        };
                        ctrl.replaceValue = function (newValue) {
                            ctrl.localValue = {
                                label: newValue
                            };
                            ctrl.value = newValue;
                            ctrl.closeEditor();
                        };
                        $scope.$on('externalSave', function () {
                            if (ctrl.active) {
                                ctrl.replaceValue(ctrl.localValue.label);
                                // The $scope.$apply() call is needed to propagate the replaced
                                // value.
                                $scope.$apply();
                            }
                        });
                        ctrl.closeEditor();
                    }
                }]
        };
    }
]);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/CodeRepl/static/code_repl.css":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./extensions/interactions/CodeRepl/static/code_repl.css ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".code-repl-input-box {\n  border: 1px solid #ccc;\n}\n.code-repl-language {\n  float: right;\n  font-size: 0.8em;\n  margin-top: 8px;\n}\n.code-repl-terminal {\n  background-color: #222;\n  color: white;\n  font-weight: bold;\n  max-height: 600px;\n}\n.code-repl-terminal-error {\n  background-color: #222;\n  color: red;\n  font-weight: bold;\n}\n.cm-s-preview.CodeMirror {\n  background-color: #eee;\n}\n.cm-s-preview .CodeMirror-linenumber {\n  /* Without this, Line-number in preview CodeRepl will be overlapped. */\n  white-space: nowrap;\n}\n.cm-s-preview .CodeMirror-code pre {\n  /* Without this, underscore characters are not visible. */\n  height: 1.04em;\n  width: 100%;\n}\n.cm-s-preview .CodeMirror-code .code-repl-noneditable-line {\n  background-color: #eee;\n  opacity: 0.8;\n}\n.CodeMirror-lines {\n  background-color: white;\n}\n.code-repl-container {\n  background: #fff;\n  padding: 8px;\n  width: 100%;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/ItemSelectionInput/static/item_selection_input.css":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./extensions/interactions/ItemSelectionInput/static/item_selection_input.css ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "/* The following is needed so that the radio button does not show. */\n.item-selection-input-radio-button {\n  display: none;\n}\n\n.item-selection-input-checkbox {\n  font-weight: normal;\n  margin: 2px;\n}\n\nmd-checkbox.item-selection-input-checkbox.md-default-theme .md-icon {\n  border-color: #0d48a1;\n  top: 2px;\n}\nmd-checkbox.item-selection-input-checkbox.md-default-theme.md-checked .md-icon {\n  background-color: rgba(102, 187, 106, 0.87);\n}\nmd-checkbox.item-selection-input-checkbox .md-label {\n  vertical-align: top;\n}\n\n.item-selection-input-form-container {\n  margin-top: -5px;\n}\n.item-selection-input-item {\n  background: none;\n  border: none;\n  color: #0d48a1;\n  margin: 0;\n  padding-left: 0;\n  text-align: left;\n  /* This is needed so that images stay bounded by the container in Firefox. */\n  width: 100%;\n}\n.item-selection-input-container {\n  padding-bottom: 5px;\n}\n\n.item-selection-input-container md-input-group.md-default-theme label {\n  border-bottom: 0px;\n}\n\n.item-selection-input-container img {\n  max-height: 200px;\n}\n\n.multiple-choice-option-container {\n  padding: 4px 0;\n}\n\n.multiple-choice-option {\n  background: none;\n  border: none;\n  color: #0D48A1;\n  text-align: left;\n  /* This is needed so that images stay bounded by the container in Firefox. */\n  width: 100%;\n}\n\n.multiple-choice-radio-button-container,\n.multiple-choice-content-container {\n  display: table-cell;\n}\n\n.multiple-choice-option:hover {\n  color: #115FD4;\n}\n\n.multiple-choice-option:hover .multiple-choice-inner-radio-button,\n.multiple-choice-option:focus .multiple-choice-inner-radio-button {\n  background-color: #115FD4;\n  border-radius: 50%;\n  display: block;\n  height: 8px;\n  margin: 2px;\n  width: 8px;\n}\n\n.multiple-choice-option:hover .multiple-choice-outer-adio-button {\n  border-color: #115FD4;\n}\n\n.multiple-choice-outer-radio-button {\n  border: 2px solid #0D48A1;\n  border-radius: 50%;\n  display: inline-block;\n  height: 16px;\n  margin-bottom: -7px;\n  margin-right: 12px;\n  width: 16px;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/LogicProof/static/logic_proof.css":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./extensions/interactions/LogicProof/static/logic_proof.css ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".logic-proof-input-box {\n  border: 1px solid #ccc;\n}\n.logic-proof-erroneous-line {\n  font-weight: bold;\n}\n.logic-proof-error-message {\n  color: red;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MultipleChoiceInput/static/multiple_choice_input.css ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".multiple-choice-option-container {\n  padding: 4px 0;\n}\n\n.multiple-choice-option {\n  background: none;\n  border: none;\n  color: #0D48A1;\n  text-align: left;\n  /* This is needed so that images stay bounded by the container in Firefox. */\n  /* This also limits the selection area of the option to the text and radio button. */\n  width: auto;\n}\n\n.multiple-choice-radio-button-container {\n  display: table-cell;\n}\n\n.multiple-choice-content-container {\n  display: table-cell;\n  vertical-align: top;\n}\n\n.multiple-choice-option:hover {\n  color: #115FD4;\n}\n\n.multiple-choice-option:hover .multiple-choice-inner-radio-button,\n.multiple-choice-option:focus .multiple-choice-inner-radio-button {\n  background-color: #115FD4;\n  border-radius: 50%;\n  display: block;\n  height: 8px;\n  margin: 2px;\n  width: 8px;\n}\n\n.multiple-choice-option:hover .multiple-choice-outer-radio-button,\n.multiple-choice-option:focus .multiple-choice-outer-radio-button {\n  border-color: #115FD4;\n}\n\n.multiple-choice-outer-radio-button {\n  border: 2px solid #0D48A1;\n  border-radius: 50%;\n  display: inline-block;\n  height: 16px;\n  margin-bottom: -7px;\n  margin-right: 12px;\n  width: 16px;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MusicNotesInput/static/music_notes_input.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./extensions/interactions/MusicNotesInput/static/music_notes_input.css ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "/* The container around the staff and noteChoices.\n * This keeps the note from dropping on top of the clef.\n */\n\n.oppia-music-input-valid-note-area {\n  position: relative;\n  float:left;\n  margin: 0 0 0 11.0784%;\n  width: 87.34525%;\n  height: 43%;\n  /* Hide valid note area until page loads */\n  visibility: hidden;\n}\n\n/* The box around staff */\n\n.oppia-music-input-staff {\n  clear: both;\n  background: transparent;\n  max-width: 673px;\n}\n\n/* The box around note choices */\n\n.oppia-music-input-note-choices {\n  clear: both;\n  float: right;\n  background: rgba(0, 0, 0, 0.04); /* Color of noteChoices box */\n  width: 5%;\n  padding: 2.3% 9% 5.83% 1.1%;\n  margin-bottom: 15px;\n  border: 0.2em solid #333;\n  -moz-border-radius: 11%;\n  -webkit-border-radius: 11%;\n  border-radius: 11%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n/* The invisible box around droppable staff */\n\n.oppia-music-input-staff {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  clear: both;\n  float: right;\n  width: 110.1%;\n  padding: 1.5% 0 3% 0;\n}\n\n/* The staff lines and ledger lines */\n\n.oppia-music-input-staff div.oppia-music-staff-position {\n  position: relative;\n  width: 100%;\n  margin: 0 0;\n  background: transparent;\n  color: transparent;\n  float: right;\n}\n\n.oppia-music-input-staff div.oppia-music-input-hovered {\n  background: #aaa;\n}\n\n.oppia-music-input-staff div.oppia-music-staff-line {\n  background: #000000;\n  height: 2px;\n  position: absolute;\n  width: 100%;\n}\n\n.oppia-music-input-staff {\n  background-image: url(/extensions/interactions/MusicNotesInput/static/images/treble_clef.png);\n  background-repeat: no-repeat;\n  background-position: 0.1% 62%;\n  background-size: 8.5% 89%;\n}\n\n/* Individual notes */\n\n.oppia-music-input-note-choices div {\n  width: 7.8%;\n  height: 9.2%;\n  position: relative;\n  background: transparent;\n}\n\n.oppia-music-input-note-choices div.oppia-music-input-natural-note {\n  float: left;\n  background-image: url(/extensions/interactions/MusicNotesInput/static/images/whole_note.png);\n  background-repeat: no-repeat;\n  background-size: 71%;\n  background-position: center;\n  position: absolute;\n}\n\n.oppia-music-input-staff .oppia-music-input-ledger-line {\n  position: absolute;\n  width: 8%;\n  padding-bottom: 0.35%;\n  background-color: #000000;\n}\n\n.oppia-music-input-on-staff {\n  position: absolute;\n  /* Maximum 14, otherwise it will be above\n     the tutorcard if viewport is less than 960 */\n  z-index: 14;\n}\n\n.oppia-music-input-control-buttons {\n  padding: 40% 0 5% 2%;\n}\n\n.oppia-music-input-btn {\n  padding: 6px 10px;\n}\n\n.oppia-music-input-play-btn {\n  margin-left: -55px;\n  margin-top: 0;\n}\n", ""]);


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvYmFzZV9jb21wb25lbnRzL0Jhc2VDb250ZW50RGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2Jhc2VfY29tcG9uZW50cy9XYXJuaW5nTG9hZGVyRGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2NvbXBvbmVudHMvYnV0dG9uLWRpcmVjdGl2ZXMvZXhwbG9yYXRpb24tZW1iZWQtYnV0dG9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvY29tcG9uZW50cy9jb21tb24tbGF5b3V0LWRpcmVjdGl2ZXMvY29tbW9uLWVsZW1lbnRzL2JhY2tncm91bmQtYmFubmVyLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9jb21wb25lbnRzL2NvbW1vbi1sYXlvdXQtZGlyZWN0aXZlcy9jb21tb24tZWxlbWVudHMvc2hhcmluZy1saW5rcy5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvY29tcG9uZW50cy9mb3Jtcy9jdXN0b20tZm9ybXMtZGlyZWN0aXZlcy9pbWFnZS11cGxvYWRlci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvY29tcG9uZW50cy9zdGF0ZS1lZGl0b3Ivc3RhdGUtZWRpdG9yLXByb3BlcnRpZXMtc2VydmljZXMvc3RhdGUtZWRpdG9yLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvY29tcG9uZW50cy9zdGF0ZS1lZGl0b3Ivc3RhdGUtZWRpdG9yLXByb3BlcnRpZXMtc2VydmljZXMvc3RhdGUtaW50ZXJhY3Rpb24taWQuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9jb21wb25lbnRzL3N0YXRlLWVkaXRvci9zdGF0ZS1lZGl0b3ItcHJvcGVydGllcy1zZXJ2aWNlcy9zdGF0ZS1wcm9wZXJ0eS5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2NvbXBvbmVudHMvc3VtbWFyeS10aWxlL2NvbGxlY3Rpb24tc3VtbWFyeS10aWxlLmNvbnN0YW50cy5hanMudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvY29tcG9uZW50cy9zdW1tYXJ5LXRpbGUvY29sbGVjdGlvbi1zdW1tYXJ5LXRpbGUuY29uc3RhbnRzLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2NvbXBvbmVudHMvc3VtbWFyeS10aWxlL2NvbGxlY3Rpb24tc3VtbWFyeS10aWxlLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9kb21haW4vY2xhc3NpZmllci9QcmVkaWN0aW9uUmVzdWx0T2JqZWN0RmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9kb21haW4vY29sbGVjdGlvbi9SZWFkT25seUNvbGxlY3Rpb25CYWNrZW5kQXBpU2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9kb21haW4vY3JlYXRvcl9kYXNoYm9hcmQvQ3JlYXRvckRhc2hib2FyZEJhY2tlbmRBcGlTZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2RvbWFpbi9vYmplY3RzL0ZyYWN0aW9uT2JqZWN0RmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9kb21haW4vb2JqZWN0cy9OdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2RvbWFpbi9vYmplY3RzL1VuaXRzT2JqZWN0RmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9kb21haW4vb2JqZWN0cy9vYmplY3RzLWRvbWFpbi5jb25zdGFudHMuYWpzLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2RvbWFpbi9zdWdnZXN0aW9uL1N1Z2dlc3Rpb25PYmplY3RGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2RvbWFpbi9zdWdnZXN0aW9uL1N1Z2dlc3Rpb25UaHJlYWRPYmplY3RGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2ZpbHRlcnMvcmVtb3ZlLWR1cGxpY2F0ZXMtaW4tYXJyYXkuZmlsdGVyLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy9ub3JtYWxpemUtd2hpdGVzcGFjZS1wdW5jdHVhdGlvbi1hbmQtY2FzZS5maWx0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvZmlsdGVycy9zdHJpbmctdXRpbGl0eS1maWx0ZXJzL25vcm1hbGl6ZS13aGl0ZXNwYWNlLmZpbHRlci50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9maWx0ZXJzL3N0cmluZy11dGlsaXR5LWZpbHRlcnMvdHJ1bmNhdGUtYXQtZmlyc3QtbGluZS5maWx0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvcGFnZXMvT3BwaWFGb290ZXJEaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvcGFnZXMvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS9jcmVhdG9yLWRhc2hib2FyZC1wYWdlLmNvbnN0YW50cy5hanMudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvcGFnZXMvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS9jcmVhdG9yLWRhc2hib2FyZC1wYWdlLmNvbnN0YW50cy50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9wYWdlcy9jcmVhdG9yLWRhc2hib2FyZC1wYWdlL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UuY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9wYWdlcy9jcmVhdG9yLWRhc2hib2FyZC1wYWdlL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UubW9kdWxlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL3BhZ2VzL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS5zY3JpcHRzLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL3BhZ2VzL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2Uvc3VnZ2VzdGlvbi1tb2RhbC1mb3ItY3JlYXRvci12aWV3L3N1Z2dlc3Rpb24tbW9kYWwtZm9yLWNyZWF0b3Itdmlldy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL3BhZ2VzL2V4cGxvcmF0aW9uLWVkaXRvci1wYWdlL2VkaXRvci10YWIvc2VydmljZXMvc29sdXRpb24tdmFsaWRpdHkuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9wYWdlcy9leHBsb3JhdGlvbi1lZGl0b3ItcGFnZS9mZWVkYmFjay10YWIvc2VydmljZXMvdGhyZWFkLXN0YXR1cy1kaXNwbGF5LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvcGFnZXMvZXhwbG9yYXRpb24tZWRpdG9yLXBhZ2UvZmVlZGJhY2stdGFiL3RocmVhZC10YWJsZS90aHJlYWQtdGFibGUuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2NvcmUvdGVtcGxhdGVzL2Rldi9oZWFkL3BhZ2VzL2V4cGxvcmF0aW9uLXBsYXllci1wYWdlL3NlcnZpY2VzL2N1cnJlbnQtaW50ZXJhY3Rpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9jb3JlL3RlbXBsYXRlcy9kZXYvaGVhZC9zZXJ2aWNlcy9Db2RlTm9ybWFsaXplclNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvc2VydmljZXMvU3VnZ2VzdGlvbk1vZGFsU2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2NsYXNzaWZpZXJzL2NsYXNzaWZpZXJzLWV4dGVuc2lvbi5jb25zdGFudHMuYWpzLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvY2xhc3NpZmllcnMvY2xhc3NpZmllcnMtZXh0ZW5zaW9uLmNvbnN0YW50cy50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2NsYXNzaWZpZXJzL2NvdW50LXZlY3Rvcml6ZXIuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2NsYXNzaWZpZXJzL3B5dGhvbi1wcm9ncmFtLnRva2VuaXplci50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2NsYXNzaWZpZXJzL3N2bS1wcmVkaWN0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9jbGFzc2lmaWVycy90ZXh0LWlucHV0LnRva2VuaXplci50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2NsYXNzaWZpZXJzL3dpbm5vd2luZy1wcmVwcm9jZXNzaW5nLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvQ29kZVJlcGwvQ29kZVJlcGwudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvQ29kZVJlcGwvY29kZS1yZXBsLXByZWRpY3Rpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzL2NvZGUtcmVwbC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0NvZGVSZXBsL2RpcmVjdGl2ZXMvY29kZS1yZXBsLXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWNvZGUtcmVwbC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvQ29kZVJlcGwvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1jb2RlLXJlcGwuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0NvZGVSZXBsL2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtY29kZS1yZXBsLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db2RlUmVwbC9zdGF0aWMvY29kZV9yZXBsLmNzcz9lMDllIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0NvbnRpbnVlL0NvbnRpbnVlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0NvbnRpbnVlL2RpcmVjdGl2ZXMvY29udGludWUtcnVsZXMuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzL2NvbnRpbnVlLXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzL29wcGlhLXJlc3BvbnNlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9EcmFnQW5kRHJvcFNvcnRJbnB1dC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9kaXJlY3RpdmVzL2RyYWctYW5kLWRyb3Atc29ydC1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0RyYWdBbmREcm9wU29ydElucHV0L2RpcmVjdGl2ZXMvZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWRyYWctYW5kLWRyb3Atc29ydC1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvRHJhZ0FuZERyb3BTb3J0SW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1kcmFnLWFuZC1kcm9wLXNvcnQtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0RyYWdBbmREcm9wU29ydElucHV0L2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9FbmRFeHBsb3JhdGlvbi9FbmRFeHBsb3JhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9FbmRFeHBsb3JhdGlvbi9kaXJlY3RpdmVzL2VuZC1leHBsb3JhdGlvbi1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0VuZEV4cGxvcmF0aW9uL2RpcmVjdGl2ZXMvZW5kLWV4cGxvcmF0aW9uLXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9FbmRFeHBsb3JhdGlvbi9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWVuZC1leHBsb3JhdGlvbi5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvRW5kRXhwbG9yYXRpb24vZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1lbmQtZXhwbG9yYXRpb24uZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0VuZEV4cGxvcmF0aW9uL2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtZW5kLWV4cGxvcmF0aW9uLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9GcmFjdGlvbklucHV0L0ZyYWN0aW9uSW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzL2ZyYWN0aW9uLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzL2ZyYWN0aW9uLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9GcmFjdGlvbklucHV0L2RpcmVjdGl2ZXMvb3BwaWEtaW50ZXJhY3RpdmUtZnJhY3Rpb24taW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0ZyYWN0aW9uSW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1mcmFjdGlvbi1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLWZyYWN0aW9uLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9HcmFwaElucHV0L0dyYXBoSW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL2dyYXBoLWRldGFpbC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9ncmFwaC1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9ncmFwaC1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL2dyYXBoLXV0aWxzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL2dyYXBoLXZpei5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWdyYXBoLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9HcmFwaElucHV0L2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtZ3JhcGgtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1zaG9ydC1yZXNwb25zZS1ncmFwaC1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvSW1hZ2VDbGlja0lucHV0L0ltYWdlQ2xpY2tJbnB1dC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvZGlyZWN0aXZlcy9pbWFnZS1jbGljay1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0ltYWdlQ2xpY2tJbnB1dC9kaXJlY3RpdmVzL2ltYWdlLWNsaWNrLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1pbnRlcmFjdGl2ZS1pbWFnZS1jbGljay1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvSW1hZ2VDbGlja0lucHV0L2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtaW1hZ2UtY2xpY2staW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0ltYWdlQ2xpY2tJbnB1dC9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLWltYWdlLWNsaWNrLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9JbnRlcmFjdGl2ZU1hcC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9kaXJlY3RpdmVzL2ludGVyYWN0aXZlLW1hcC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL2RpcmVjdGl2ZXMvaW50ZXJhY3RpdmUtbWFwLXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWludGVyYWN0aXZlLW1hcC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1pbnRlcmFjdGl2ZS1tYXAuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtaW50ZXJhY3RpdmUtbWFwLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvSXRlbVNlbGVjdGlvbklucHV0LnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzL2l0ZW0tc2VsZWN0aW9uLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvSXRlbVNlbGVjdGlvbklucHV0L2RpcmVjdGl2ZXMvaXRlbS1zZWxlY3Rpb24taW5wdXQtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWl0ZW0tc2VsZWN0aW9uLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1pdGVtLXNlbGVjdGlvbi1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvSXRlbVNlbGVjdGlvbklucHV0L2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtaXRlbS1zZWxlY3Rpb24taW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9zdGF0aWMvaXRlbV9zZWxlY3Rpb25faW5wdXQuY3NzPzI0YjEiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9Mb2dpY1Byb29mLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy9sb2dpYy1wcm9vZi1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy9sb2dpYy1wcm9vZi12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWxvZ2ljLXByb29mLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Mb2dpY1Byb29mL2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtbG9naWMtcHJvb2YuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy9vcHBpYS1zaG9ydC1yZXNwb25zZS1sb2dpYy1wcm9vZi5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9zdGF0aWMvanMvY29udmVyc2lvbi50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9kYXRhLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2dlbmVyYXRlZERlZmF1bHREYXRhLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2dlbmVyYXRlZFBhcnNlci50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9zaGFyZWQudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9zdGF0aWMvanMvc3R1ZGVudC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy90ZWFjaGVyLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2xvZ2ljX3Byb29mLmNzcz9lNGQ3Iiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL01hdGhFeHByZXNzaW9uSW5wdXQvTWF0aEV4cHJlc3Npb25JbnB1dC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NYXRoRXhwcmVzc2lvbklucHV0L2RpcmVjdGl2ZXMvbWF0aC1leHByZXNzaW9uLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzL21hdGgtZXhwcmVzc2lvbi1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLW1hdGgtZXhwcmVzc2lvbi1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzL29wcGlhLXJlc3BvbnNlLW1hdGgtZXhwcmVzc2lvbi1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLW1hdGgtZXhwcmVzc2lvbi1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTXVsdGlwbGVDaG9pY2VJbnB1dC9NdWx0aXBsZUNob2ljZUlucHV0LnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy9tdWx0aXBsZS1jaG9pY2UtaW5wdXQtcnVsZXMuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L2RpcmVjdGl2ZXMvbXVsdGlwbGUtY2hvaWNlLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L2RpcmVjdGl2ZXMvb3BwaWEtaW50ZXJhY3RpdmUtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L3N0YXRpYy9tdWx0aXBsZV9jaG9pY2VfaW5wdXQuY3NzPzA0MmEiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L011c2ljTm90ZXNJbnB1dC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy9tdXNpYy1ub3Rlcy1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9kaXJlY3RpdmVzL211c2ljLW5vdGVzLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy9tdXNpYy1waHJhc2UtcGxheWVyLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvb3BwaWEtaW50ZXJhY3RpdmUtbXVzaWMtbm90ZXMtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9kaXJlY3RpdmVzL29wcGlhLXJlc3BvbnNlLW11c2ljLW5vdGVzLWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1zaG9ydC1yZXNwb25zZS1tdXNpYy1ub3Rlcy1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L3N0YXRpYy9tdXNpY19ub3Rlc19pbnB1dC5jc3M/ZWZmMCIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvTnVtYmVyV2l0aFVuaXRzLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9kaXJlY3RpdmVzL251bWJlci13aXRoLXVuaXRzLXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTnVtYmVyV2l0aFVuaXRzL2RpcmVjdGl2ZXMvbnVtYmVyLXdpdGgtdW5pdHMtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLW51bWJlci13aXRoLXVuaXRzLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS1udW1iZXItd2l0aC11bml0cy5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTnVtYmVyV2l0aFVuaXRzL2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtbnVtYmVyLXdpdGgtdW5pdHMuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9OdW1lcmljSW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTnVtZXJpY0lucHV0L2RpcmVjdGl2ZXMvbnVtZXJpYy1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9kaXJlY3RpdmVzL251bWVyaWMtaW5wdXQtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLW51bWVyaWMtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9kaXJlY3RpdmVzL29wcGlhLXJlc3BvbnNlLW51bWVyaWMtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLW51bWVyaWMtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL1BlbmNpbENvZGVFZGl0b3IvUGVuY2lsQ29kZUVkaXRvci50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvb3BwaWEtaW50ZXJhY3RpdmUtcGVuY2lsLWNvZGUtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtcGVuY2lsLWNvZGUtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvb3BwaWEtc2hvcnQtcmVzcG9uc2UtcGVuY2lsLWNvZGUtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvcGVuY2lsLWNvZGUtZWRpdG9yLXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzL3BlbmNpbC1jb2RlLWVkaXRvci12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvU2V0SW5wdXQvU2V0SW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvU2V0SW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1pbnRlcmFjdGl2ZS1zZXQtaW5wdXQuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL1NldElucHV0L2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2Utc2V0LWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzL29wcGlhLXNob3J0LXJlc3BvbnNlLXNldC1pbnB1dC5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvU2V0SW5wdXQvZGlyZWN0aXZlcy9zZXQtaW5wdXQtcnVsZXMuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzL3NldC1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvVGV4dElucHV0L1RleHRJbnB1dC50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1pbnRlcmFjdGl2ZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1yZXNwb25zZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy9vcHBpYS1zaG9ydC1yZXNwb25zZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy90ZXh0LWlucHV0LXJ1bGVzLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvVGV4dElucHV0L2RpcmVjdGl2ZXMvdGV4dC1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvVGV4dElucHV0L3RleHQtaW5wdXQtcHJlZGljdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL2Jhc2UtaW50ZXJhY3Rpb24tdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9ucy1leHRlbnNpb24uY29uc3RhbnRzLmFqcy50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbnNSZXF1aXJlcy50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy91aUxlYWZsZXRSZXF1aXJlcy50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvb2JqZWN0Q29tcG9uZW50c1JlcXVpcmVzLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvYm9vbGVhbi1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvY29kZS1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2Nvb3JkLXR3by1kaW0tZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2RyYWctYW5kLWRyb3AtaHRtbC1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2RyYWctYW5kLWRyb3AtcG9zaXRpdmUtaW50LWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9maWxlcGF0aC1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvZnJhY3Rpb24tZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2dyYXBoLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9ncmFwaC1wcm9wZXJ0eS1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvaHRtbC1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvaW1hZ2Utd2l0aC1yZWdpb25zLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9pbnQtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2xpc3Qtb2Ytc2V0cy1vZi1odG1sLXN0cmluZ3MtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2xpc3Qtb2YtdGFicy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvbGlzdC1vZi11bmljb2RlLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvbG9naWMtZXJyb3ItY2F0ZWdvcnktZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL2xvZ2ljLXF1ZXN0aW9uLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9tYXRoLWxhdGV4LXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvbXVzaWMtcGhyYXNlLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9ub25uZWdhdGl2ZS1pbnQtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL25vcm1hbGl6ZWQtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy9udW1iZXItd2l0aC11bml0cy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvcGFyYW1ldGVyLW5hbWUtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL3JlYWwtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL3Nhbml0aXplZC11cmwtZWRpdG9yLmRpcmVjdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL29iamVjdHMvdGVtcGxhdGVzL3NldC1vZi1odG1sLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvb2JqZWN0cy90ZW1wbGF0ZXMvc2V0LW9mLXVuaWNvZGUtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9ucy9vYmplY3RzL3RlbXBsYXRlcy91bmljb2RlLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLnRzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0NvZGVSZXBsL3N0YXRpYy9jb2RlX3JlcGwuY3NzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9zdGF0aWMvaXRlbV9zZWxlY3Rpb25faW5wdXQuY3NzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2xvZ2ljX3Byb29mLmNzcyIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L3N0YXRpYy9tdWx0aXBsZV9jaG9pY2VfaW5wdXQuY3NzIiwid2VicGFjazovLy8uL2V4dGVuc2lvbnMvaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9zdGF0aWMvbXVzaWNfbm90ZXNfaW5wdXQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFRLG9CQUFvQjtBQUM1QjtBQUNB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Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhGQUF5QjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsaUVBQWU7QUFDcEMsaUNBQWlDLG1CQUFPLENBQUMscUhBQXlDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7Ozs7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUNBQW1DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlDQUF5QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLDJIQUFvRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztB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YjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLDhKQUErRDtBQUN2RSxtQkFBTyxDQUFDLHNHQUFtQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFx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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywwSEFBNkM7QUFDckQsbUJBQU8sQ0FBQywySUFBNEQ7QUFDcEUsbUJBQU8sQ0FBQyxvSEFBMEM7QUFDbEQsbUJBQU8sQ0FBQyxvSEFBMEM7QUFDbEQsbUJBQU8sQ0FBQywrSEFBc0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQSwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQyx5SUFBMkQ7QUFDbkUsbUJBQU8sQ0FBQywwSEFBNkM7QUFDckQsbUJBQU8sQ0FBQyxxSkFBaUU7QUFDekUsbUJBQU8sQ0FBQyw4S0FBdUU7QUFDL0UsbUJBQU8sQ0FBQyxnR0FBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxzR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxnSUFBZ0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLDBIQUE2QztBQUNyRCxtQkFBTyxDQUFDLDJJQUE0RDtBQUNwRSxtQkFBTyxDQUFDLGdHQUFnQztBQUN4QyxtQkFBTyxDQUFDLCtIQUFzRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywwSEFBNkM7QUFDckQsbUJBQU8sQ0FBQyxnR0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywyS0FDZ0M7QUFDeEMsbUJBQU8sQ0FBQyxxTEFDcUM7QUFDN0MsbUJBQU8sQ0FBQyx1TUFDOEM7QUFDdEQsbUJBQU8sQ0FBQyxpTUFDMkM7QUFDbkQsbUJBQU8sQ0FBQyw2TUFDaUQ7Ozs7Ozs7Ozs7OztBQ3pCekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGlFQUFlO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGlFQUFlO0FBQ3BDLDRDQUE0QyxtQkFBTyxDQUFDLDBIQUFrRDtBQUN0RyxzQkFBc0IsbUJBQU8sQ0FBQyxpRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywyS0FDZ0M7QUFDeEMsbUJBQU8sQ0FBQyxzS0FBbUU7QUFDM0UsbUJBQU8sQ0FBQywwR0FBcUM7QUFDN0MsbUJBQU8sQ0FBQyx3RkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxnR0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkNBQTJDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQUMsMEhBQTZDO0FBQ3JELG1CQUFPLENBQUMsZ0dBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQUMseUZBQW1DO0FBQzNDLG1CQUFPLENBQUMsMEhBQTZDO0FBQ3JELG1CQUFPLENBQUMsZ0dBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FB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O0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7QUNwcUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsZ0NBQWdDLG1CQUFPLENBQUMseUdBQTJDO0FBQ25GO0FBQ0EseUNBQXlDLGlLQUFpSyxnREFBZ0Qsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxpQ0FBaUMsR0FBRyxpREFBaUQsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxpQ0FBaUMsR0FBRywyQ0FBMkMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQix3RkFBd0YsMENBQTBDLEdBQUcsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsaUNBQWlDLEdBQUcsMkNBQTJDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxHQUFHLGdCQUFnQix3RkFBd0YsMENBQTBDLGdCQUFnQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGlDQUFpQyxHQUFHLGlEQUFpRCx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHVDQUF1QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsR0FBRyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxpQ0FBaUMsR0FBRyxpREFBaUQsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHVDQUF1QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQix3RkFBd0YsMENBQTBDLEdBQUcsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsZ0RBQWdELHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxHQUFHLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQix3RkFBd0YsMENBQTBDLGlDQUFpQyxHQUFHLGdEQUFnRCx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsR0FBRyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxpQ0FBaUMsR0FBRywrQ0FBK0Msd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isc0ZBQXNGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsaUNBQWlDLEdBQUcsaURBQWlELHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHNGQUFzRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isc0ZBQXNGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGlDQUFpQyxHQUFHLDJDQUEyQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHNGQUFzRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsR0FBRyxnQkFBZ0Isc0ZBQXNGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGlDQUFpQyxHQUFHLDJDQUEyQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHNGQUFzRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsR0FBRyxnQkFBZ0Isc0ZBQXNGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGlDQUFpQyxHQUFHLHdDQUF3QyxzQ0FBc0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsK0NBQStDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxHQUFHLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQix3RkFBd0YsMENBQTBDLGlDQUFpQyxHQUFHLCtDQUErQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHNGQUFzRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsR0FBRyxnQkFBZ0Isc0ZBQXNGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxpQ0FBaUMsR0FBRywrQ0FBK0MseUNBQXlDLEdBQUcscUNBQXFDLGdCQUFnQixzRkFBc0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLHNGQUFzRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxpQ0FBaUMsR0FBRywyQ0FBMkMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLGlGQUFpRix3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcsaURBQWlELG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxHQUFHLGdCQUFnQixpRkFBaUYsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0RBQWdELEdBQUcsMkNBQTJDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLGlEQUFpRCxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsR0FBRyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixrQkFBa0IsMENBQTBDLGdEQUFnRCxHQUFHLHFEQUFxRCx3Q0FBd0MsR0FBRyxpREFBaUQsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsMkNBQTJDLHlDQUF5QyxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsbUNBQW1DLGdCQUFnQixpRkFBaUYsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsaUNBQWlDLEdBQUcsK0NBQStDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixHQUFHLGlGQUFpRix3RkFBd0Ysa0JBQWtCLGtCQUFrQiwwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLGlGQUFpRix3RkFBd0YsR0FBRyxpRkFBaUYsd0ZBQXdGLGtCQUFrQixrQkFBa0IsMENBQTBDLGlDQUFpQyxHQUFHLCtDQUErQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLGlGQUFpRixpRkFBaUYsd0ZBQXdGLGtCQUFrQixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsbUNBQW1DLGdCQUFnQixpRkFBaUYsaUZBQWlGLHdGQUF3RixrQkFBa0IsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxpQ0FBaUMsR0FBRywrQ0FBK0Msd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixpRkFBaUYsaUZBQWlGLHdGQUF3RixrQkFBa0Isa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQixpRkFBaUYsaUZBQWlGLHdGQUF3RixrQkFBa0Isa0JBQWtCLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsMENBQTBDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyw2Q0FBNkMsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLGlGQUFpRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsK0NBQStDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixpRkFBaUYsd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixpRkFBaUYsd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsaUNBQWlDLEdBQUcsZ0RBQWdELHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixpRkFBaUYsd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixpRkFBaUYsd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsaUNBQWlDLEdBQUcsOENBQThDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0IsOEVBQThFLHdGQUF3RixnQkFBZ0Isd0ZBQXdGLEdBQUcsMENBQTBDLEVBQUUsR0FBRyx5Q0FBeUMsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3Riw4REFBOEQsRUFBRSxHQUFHLDhDQUE4QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLHFCQUFxQixPQUFPLHdGQUF3RixFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixnQkFBZ0IsOEVBQThFLHdGQUF3RixnQkFBZ0Isd0ZBQXdGLEdBQUcsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLHFCQUFxQixPQUFPLHdGQUF3RixFQUFFLHNCQUFzQixrQkFBa0Isd0ZBQXdGLGdCQUFnQixHQUFHLDhDQUE4Qyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RixxQkFBcUIsT0FBTyx3RkFBd0YsRUFBRSxzQkFBc0IsRUFBRSxHQUFHLHNDQUFzQyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQiw4RUFBOEUsd0ZBQXdGLGdCQUFnQix3RkFBd0YsR0FBRywwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RixxQkFBcUIsT0FBTyx3RkFBd0YsRUFBRSxzQkFBc0IsZ0JBQWdCLGdCQUFnQiw4RUFBOEUsd0ZBQXdGLGdCQUFnQix3RkFBd0YsR0FBRywwQ0FBMEMsa0JBQWtCLHdGQUF3RixnQkFBZ0IsR0FBRywrQ0FBK0Msd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQiwrRUFBK0Usd0ZBQXdGLGdCQUFnQix3RkFBd0YsR0FBRywwQ0FBMEMsRUFBRSxHQUFHLHNDQUFzQyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YscUJBQXFCLE9BQU8sd0ZBQXdGLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLGdCQUFnQiwrRUFBK0Usd0ZBQXdGLGdCQUFnQix3RkFBd0YsR0FBRywwQ0FBMEMsZ0JBQWdCLGdCQUFnQix3RkFBd0YscUJBQXFCLE9BQU8sd0ZBQXdGLEVBQUUsc0JBQXNCLGtCQUFrQix3RkFBd0YsZ0JBQWdCLEdBQUcsK0NBQStDLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDhEQUE4RCxFQUFFLEdBQUcsNkNBQTZDLEdBQUcseUNBQXlDLEdBQUcscUNBQXFDLGdCQUFnQiwrRUFBK0Usd0ZBQXdGLGdCQUFnQix3RkFBd0YsR0FBRywwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLCtFQUErRSx3RkFBd0YsZ0JBQWdCLHdGQUF3RixHQUFHLDBDQUEwQyxrQkFBa0Isd0ZBQXdGLGdCQUFnQixHQUFHLG1DQUFtQyx5Q0FBeUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvREFBb0Qsd0ZBQXdGLGdCQUFnQixHQUFHLGtDQUFrQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxvREFBb0Qsd0ZBQXdGLGdCQUFnQixHQUFHLHNDQUFzQyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsc0NBQXNDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsaUNBQWlDLEdBQUcsOENBQThDLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxvQkFBb0IsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0NBQWdDLHlEQUF5RCxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcseUNBQXlDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyw2Q0FBNkMsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsc0NBQXNDLEtBQUssNkNBQTZDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLDREQUE0RCxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsNkNBQTZDLElBQUksR0FBRyw4Q0FBOEMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx3Q0FBd0MsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxnQkFBZ0IsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxnQ0FBZ0MseURBQXlELEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx5Q0FBeUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLDZDQUE2QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyxzQ0FBc0MsS0FBSyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcsZ0RBQWdELEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx5Q0FBeUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLG1GQUFtRixHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcscUNBQXFDLElBQUksR0FBRyw4Q0FBOEMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQix3RkFBd0YsMENBQTBDLEdBQUcsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0NBQWdDLG1EQUFtRCxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRywwQ0FBMEMsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcscUNBQXFDLElBQUksR0FBRyw4Q0FBOEMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsb0JBQW9CLGdCQUFnQix3RkFBd0YsMENBQTBDLEdBQUcsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0JBQWdCLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsZ0NBQWdDLG1EQUFtRCxHQUFHLHFDQUFxQyxnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRywwQ0FBMEMsR0FBRyxxQ0FBcUMsZ0JBQWdCLGtGQUFrRix3RkFBd0YsR0FBRyx3RkFBd0Ysa0JBQWtCLDBDQUEwQyxFQUFFLEdBQUcscUNBQXFDLElBQUksR0FBRyw2Q0FBNkMsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHdDQUF3QyxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLG9CQUFvQixnQkFBZ0Isa0ZBQWtGLHdGQUF3RixHQUFHLHdGQUF3RixrQkFBa0IsMENBQTBDLGdCQUFnQixnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxnQ0FBZ0MseUNBQXlDLEdBQUcscUNBQXFDLGdCQUFnQixrRkFBa0Ysd0ZBQXdGLEdBQUcsd0ZBQXdGLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLDZEQUE2RCxHQUFHLHFDQUFxQyxnQkFBZ0Isd0ZBQXdGLDBDQUEwQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLGdCQUFnQix3RkFBd0YsMENBQTBDLEVBQUUsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLDZDQUE2Qyx5Q0FBeUMsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxtQ0FBbUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsZ0NBQWdDLDhFQUE4RSxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixrQkFBa0IsMENBQTBDLEVBQUUsR0FBRyxxREFBcUQsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdGQUF3RiwwQ0FBMEMsRUFBRSxHQUFHLDRHQUE0RyxHQUFHLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdGQUF3RixHQUFHLGlGQUFpRix3RkFBd0Ysa0JBQWtCLGtCQUFrQiwwQ0FBMEMsRUFBRSxHQUFHLHNDQUFzQyxJQUFJLGtCQUFrQixxWkFBcVoscUJBQXFCLGdDQUFnQywyQ0FBMkMsa0ZBQWtGLG1GQUFtRiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLEdBQUcseUZBQXlGLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHFGQUFxRixJQUFJLEdBQUcsc0NBQXNDLGtGQUFrRix5RkFBeUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxHQUFHLGlGQUFpRiw2RkFBNkYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxJQUFJLEdBQUcscUNBQXFDLGtGQUFrRix5RkFBeUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyxxRkFBcUYsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcsNkZBQTZGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDREQUE0RCxHQUFHLHFDQUFxQyxpRkFBaUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMsb0NBQW9DLEVBQUUsR0FBRyxzQ0FBc0MsSUFBSSxHQUFHLDRDQUE0QyxrRkFBa0YsbUZBQW1GLHFGQUFxRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxvQ0FBb0MsR0FBRyxnSEFBZ0gscUNBQXFDLEdBQUcsZ0dBQWdHLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyQ0FBMkMsR0FBRyxxQ0FBcUMsaUZBQWlGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLG9DQUFvQyxFQUFFLEdBQUcsaUdBQWlHLEdBQUcscUNBQXFDLHFGQUFxRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLGdKQUFnSixHQUFHLHFDQUFxQyxxRkFBcUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEVBQUUsR0FBRyxzREFBc0QsSUFBSSxHQUFHLGlEQUFpRCxrRkFBa0YsbUZBQW1GLHFGQUFxRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxvQ0FBb0MsR0FBRyxxSEFBcUgscUNBQXFDLEdBQUcsZ0dBQWdHLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyQ0FBMkMsR0FBRyxxQ0FBcUMsaUZBQWlGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLG9DQUFvQyxFQUFFLEdBQUcsc0dBQXNHLEdBQUcscUNBQXFDLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLHdHQUF3RyxHQUFHLHFDQUFxQyxtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEVBQUUsR0FBRyxrRkFBa0YsR0FBRyxxQ0FBcUMsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcscUlBQXFJLEdBQUcscUNBQXFDLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLHFDQUFxQyxJQUFJLEdBQUcsaURBQWlELGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyw0SEFBNEgscUNBQXFDLEdBQUcsa0ZBQWtGLG1GQUFtRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3Rix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLEdBQUcsbUZBQW1GLHdGQUF3Rix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDZDQUE2QyxHQUFHLHFDQUFxQyxtRkFBbUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcseUVBQXlFLEdBQUcscUNBQXFDLHFGQUFxRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxvR0FBb0csR0FBRyxxQ0FBcUMsa0ZBQWtGLHlHQUF5RyxHQUFHLHdGQUF3RiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxFQUFFLEdBQUcsd0dBQXdHLElBQUksR0FBRyxpREFBaUQsa0ZBQWtGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyx1RkFBdUYscUZBQXFGLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEdBQUcsZ0hBQWdILHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLGlGQUFpRixHQUFHLHFDQUFxQyxtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLDhHQUE4RyxHQUFHLHFDQUFxQyxtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLDBFQUEwRSxHQUFHLHFDQUFxQyxxRkFBcUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsd0VBQXdFLElBQUksR0FBRyxrREFBa0Qsa0ZBQWtGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxrRkFBa0YsbUZBQW1GLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsR0FBRyxtRkFBbUYsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsNEhBQTRILEdBQUcscUNBQXFDLHFGQUFxRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxzQ0FBc0MsSUFBSSxHQUFHLGtEQUFrRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNEhBQTRILHFDQUFxQyxHQUFHLGtGQUFrRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxHQUFHLHlGQUF5Rix3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwrSUFBK0ksR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLHNDQUFzQyxJQUFJLEdBQUcsOENBQThDLGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyw0SEFBNEgscUNBQXFDLEdBQUcsc0ZBQXNGLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLHdGQUF3Rix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHFGQUFxRixzQ0FBc0MsR0FBRyxxQ0FBcUMsaUZBQWlGLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEVBQUUsR0FBRyxzQ0FBc0MsSUFBSSxHQUFHLGtEQUFrRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNEhBQTRILHFDQUFxQyxHQUFHLGtGQUFrRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxHQUFHLG1GQUFtRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsNkNBQTZDLEdBQUcscUNBQXFDLG1GQUFtRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxzRUFBc0UsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLGdIQUFnSCxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsc0dBQXNHLElBQUksR0FBRyw4Q0FBOEMsa0ZBQWtGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLHdIQUF3SCxxQ0FBcUMsR0FBRyxrRkFBa0YsbUZBQW1GLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsR0FBRyxtRkFBbUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDZDQUE2QyxHQUFHLHFDQUFxQyxtRkFBbUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsc0VBQXNFLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyx3TEFBd0wsSUFBSSxHQUFHLDBDQUEwQyxrRkFBa0YsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx3SEFBd0gscUNBQXFDLHFDQUFxQyxHQUFHLHVGQUF1RixxRkFBcUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxvQ0FBb0MsR0FBRyxxSEFBcUgscUNBQXFDLHFDQUFxQyxnQkFBZ0IsZ0ZBQWdGLEdBQUcscUNBQXFDLGlGQUFpRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLG9DQUFvQyxFQUFFLEdBQUcsd0pBQXdKLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRywwSEFBMEgsSUFBSSxHQUFHLDBDQUEwQyxrRkFBa0YsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx3SEFBd0gscUNBQXFDLHFDQUFxQyxHQUFHLGtGQUFrRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxHQUFHLG1GQUFtRix3RkFBd0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQixvSUFBb0ksR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLHFDQUFxQyxJQUFJLEdBQUcsMENBQTBDLGtGQUFrRixpRkFBaUYsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNEhBQTRILHFDQUFxQyxHQUFHLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLHdIQUF3SCxxQ0FBcUMscUNBQXFDLEdBQUcsa0ZBQWtGLG1GQUFtRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3Rix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLEdBQUcseUZBQXlGLHdGQUF3Rix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLGtEQUFrRCxHQUFHLHFDQUFxQyxpRkFBaUYsMkdBQTJHLG9DQUFvQyxFQUFFLEdBQUcsOElBQThJLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLGtEQUFrRCxrRkFBa0YsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx3SEFBd0gscUNBQXFDLHFDQUFxQyxHQUFHLGtGQUFrRixzRkFBc0Ysd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcsbUZBQW1GLHFGQUFxRixtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEdBQUcscUhBQXFILHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQixxRUFBcUUsc0NBQXNDLEdBQUcscUNBQXFDLG1GQUFtRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcscURBQXFELEdBQUcscUNBQXFDLG1GQUFtRixtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLEVBQUUsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLDZDQUE2QyxrRkFBa0YsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx3SEFBd0gscUNBQXFDLHFDQUFxQyxHQUFHLGtGQUFrRixzRkFBc0Ysd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0Ysd0ZBQXdGLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcsbUZBQW1GLHFGQUFxRixtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEdBQUcsZ0hBQWdILHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQix5REFBeUQsc0NBQXNDLEdBQUcscUNBQXFDLG1GQUFtRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcsd0VBQXdFLEdBQUcscUNBQXFDLGlGQUFpRixtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEVBQUUsR0FBRyxzQ0FBc0MsSUFBSSxHQUFHLDBDQUEwQyxrRkFBa0YsbUZBQW1GLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMsR0FBRyxpRkFBaUYsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNEhBQTRILHFDQUFxQyxHQUFHLGlGQUFpRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyw0SEFBNEgscUNBQXFDLEdBQUcsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsd0hBQXdILHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsdUZBQXVGLElBQUksR0FBRyxHQUFHLG1DQUFtQyw0Q0FBNEMsa0ZBQWtGLGlGQUFpRiwyRkFBMkYsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsR0FBRyw4RkFBOEYsa0ZBQWtGLDJHQUEyRyxHQUFHLHNGQUFzRiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxHQUFHLGlGQUFpRiwyRkFBMkYsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLGdCQUFnQiwyREFBMkQsR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLDZDQUE2QywyRUFBMkUsR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLG1DQUFtQyxzREFBc0QsR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLHlFQUF5RSxJQUFJLEdBQUcsNkNBQTZDLGtGQUFrRixpRkFBaUYsMkZBQTJGLDJHQUEyRyxxQ0FBcUMscUNBQXFDLEdBQUcsa0ZBQWtGLHVGQUF1RixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyw4RkFBOEYsa0ZBQWtGLDJHQUEyRyxHQUFHLHNGQUFzRiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxHQUFHLGlGQUFpRiwwRkFBMEYsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxnQkFBZ0IsaURBQWlELEdBQUcscUNBQXFDLHFGQUFxRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyw2RUFBNkUsR0FBRyxxQ0FBcUMsaUZBQWlGLG9GQUFvRix3RkFBd0YscUZBQXFGLDJHQUEyRyxxQ0FBcUMsR0FBRywyR0FBMkcscUNBQXFDLHFDQUFxQyxvQ0FBb0MsRUFBRSxHQUFHLDhDQUE4QyxHQUFHLHFDQUFxQyxvRkFBb0Ysd0ZBQXdGLHFGQUFxRiwyR0FBMkcscUNBQXFDLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLHFJQUFxSSxHQUFHLHFDQUFxQyxxRkFBcUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsc0NBQXNDLElBQUksR0FBRyxpREFBaUQsa0ZBQWtGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyx1RkFBdUYscUZBQXFGLDJHQUEyRyxxQ0FBcUMsR0FBRyxxRkFBcUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsdURBQXVELEdBQUcscUNBQXFDLHFGQUFxRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcsb0ZBQW9GLEdBQUcscUNBQXFDLHFGQUFxRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxvRkFBb0YsSUFBSSxHQUFHLGdEQUFnRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsZ0hBQWdILHFDQUFxQyxHQUFHLDBGQUEwRixxRkFBcUYsMkdBQTJHLHFDQUFxQyxHQUFHLDJHQUEyRyxxQ0FBcUMscUNBQXFDLGdCQUFnQixpREFBaUQsR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLG9EQUFvRCw4Q0FBOEMsSUFBSSxHQUFHLHNDQUFzQyxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsMkhBQTJILHFDQUFxQyxHQUFHLDBGQUEwRixxRkFBcUYsMkdBQTJHLHFDQUFxQyxHQUFHLDJHQUEyRyxxQ0FBcUMscUNBQXFDLGdCQUFnQixxRUFBcUUsR0FBRyxxQ0FBcUMscUZBQXFGLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLCtDQUErQyxHQUFHLHFDQUFxQyxtRkFBbUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsa0NBQWtDLG9DQUFvQyxHQUFHLHFDQUFxQyxxRkFBcUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsbUhBQW1ILEdBQUcscUNBQXFDLHFGQUFxRiwyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLEdBQUcsK0JBQStCLDBDQUEwQyw4RkFBOEYsa0ZBQWtGLDJHQUEyRyxHQUFHLHdGQUF3RiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxHQUFHLGlGQUFpRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IsZ0JBQWdCLG1EQUFtRCxHQUFHLHFDQUFxQyxnRkFBZ0Ysa0ZBQWtGLDJHQUEyRyxHQUFHLHdGQUF3RiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxHQUFHLGlGQUFpRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IsRUFBRSxHQUFHLHVGQUF1RixHQUFHLHFDQUFxQyxnRkFBZ0Ysa0ZBQWtGLDJHQUEyRyxHQUFHLHdGQUF3RiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxHQUFHLGlGQUFpRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IsRUFBRSxHQUFHLDZDQUE2QyxJQUFJLEdBQUcsK0NBQStDLDhGQUE4RixrRkFBa0YsMkdBQTJHLEdBQUcsd0ZBQXdGLDJHQUEyRyw2Q0FBNkMscUNBQXFDLEdBQUcsaUZBQWlGLHlGQUF5RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixnQkFBZ0IsNERBQTRELEdBQUcscUNBQXFDLGdGQUFnRixrRkFBa0YsMkdBQTJHLEdBQUcsd0ZBQXdGLDJHQUEyRyw2Q0FBNkMscUNBQXFDLEdBQUcsaUZBQWlGLHlGQUF5RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixFQUFFLEdBQUcsbUZBQW1GLEdBQUcscUNBQXFDLGlGQUFpRixtRkFBbUYsbUZBQW1GLGdGQUFnRixrRkFBa0YsMkdBQTJHLEdBQUcsd0ZBQXdGLDJHQUEyRyw2Q0FBNkMscUNBQXFDLEdBQUcsaUZBQWlGLHlGQUF5RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixHQUFHLDJHQUEyRyxxQ0FBcUMscUNBQXFDLG9DQUFvQyxFQUFFLEdBQUcsMkVBQTJFLElBQUksR0FBRyxxQ0FBcUMsa0ZBQWtGLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsaUZBQWlGLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLHlGQUF5RiwyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHFIQUFxSCxJQUFJLEdBQUcsMENBQTBDLGtGQUFrRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLGlGQUFpRiw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxrRkFBa0YseUZBQXlGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxnQkFBZ0IsdUZBQXVGLEdBQUcscUNBQXFDLGdGQUFnRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLHlGQUF5RiwyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLEVBQUUsR0FBRyxpRkFBaUYsSUFBSSxHQUFHLG9EQUFvRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNEhBQTRILHFDQUFxQyxHQUFHLGlGQUFpRixrRkFBa0YsdUZBQXVGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsR0FBRyxvRkFBb0Ysd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMsNkNBQTZDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiw0RUFBNEUsR0FBRyxxQ0FBcUMsdUZBQXVGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLHVFQUF1RSxJQUFJLEdBQUcsb0RBQW9ELGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyw0SEFBNEgscUNBQXFDLEdBQUcsaUZBQWlGLGtGQUFrRixvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLG9GQUFvRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyw2Q0FBNkMscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLCtDQUErQyxHQUFHLHFDQUFxQyxtRkFBbUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsOERBQThELEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxnR0FBZ0csR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLHNDQUFzQyxJQUFJLEdBQUcsb0RBQW9ELGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyw0SEFBNEgscUNBQXFDLEdBQUcsdUZBQXVGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsbUZBQW1GLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHVFQUF1RSxHQUFHLHFDQUFxQyxtRkFBbUYsbUZBQW1GLHdGQUF3RiwyR0FBMkcsR0FBRyx5R0FBeUcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsRUFBRSxHQUFHLHlDQUF5QyxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsa0VBQWtFLEdBQUcscUNBQXFDLG1GQUFtRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcsc0NBQXNDLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxzQ0FBc0MsSUFBSSxHQUFHLGdEQUFnRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsd0hBQXdILHFDQUFxQyxHQUFHLGlGQUFpRix5RkFBeUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJEQUEyRCxHQUFHLHFDQUFxQyxtRkFBbUYsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsbUVBQW1FLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxvSEFBb0gsSUFBSSxHQUFHLGdEQUFnRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsd0hBQXdILHFDQUFxQyxHQUFHLHVGQUF1RixvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLG1GQUFtRixtRkFBbUYsd0ZBQXdGLDJHQUEyRyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQixzRUFBc0UsR0FBRyxxQ0FBcUMsbUZBQW1GLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLEVBQUUsR0FBRyx3RUFBd0UsR0FBRyxxQ0FBcUMsbUZBQW1GLG1GQUFtRix3RkFBd0YsMkdBQTJHLEdBQUcseUdBQXlHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLEVBQUUsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLGtEQUFrRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsdUhBQXVILHFDQUFxQyxHQUFHLGtGQUFrRixpRkFBaUYsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsK0ZBQStGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxHQUFHLGlGQUFpRiw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywrRkFBK0Ysb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHFEQUFxRCxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsa0RBQWtELEdBQUcscUNBQXFDLGtGQUFrRix5R0FBeUcsR0FBRyx3RkFBd0YsMkdBQTJHLDZDQUE2QyxxQ0FBcUMsRUFBRSxHQUFHLGdGQUFnRixHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsd0NBQXdDLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyx3REFBd0QsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLDhGQUE4RixHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsK0RBQStELEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxnRUFBZ0UsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLGdEQUFnRCxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsZ0ZBQWdGLElBQUksR0FBRyxrREFBa0Qsa0ZBQWtGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLHVIQUF1SCxxQ0FBcUMsR0FBRyxpRkFBaUYsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsK0ZBQStGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLHlEQUF5RCxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsZ0RBQWdELEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyx3Q0FBd0MseUNBQXlDLEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRywyQ0FBMkMsSUFBSSxHQUFHLG1EQUFtRCxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsdUhBQXVILHFDQUFxQyxHQUFHLGlGQUFpRiw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywrRkFBK0Ysb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxnQkFBZ0IseURBQXlELEdBQUcscUNBQXFDLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEVBQUUsR0FBRyxnREFBZ0QsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLHdDQUF3Qyx5Q0FBeUMsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLDJDQUEyQyxJQUFJLEdBQUcsdURBQXVELGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx1SEFBdUgscUNBQXFDLEdBQUcsaUZBQWlGLHFHQUFxRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQix1REFBdUQsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLDBDQUEwQyxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsc0VBQXNFLEdBQUcscUNBQXFDLGlGQUFpRixtRkFBbUYsZ0ZBQWdGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsK0ZBQStGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxvQ0FBb0MsRUFBRSxHQUFHLGdFQUFnRSxJQUFJLEdBQUcsd0RBQXdELGtGQUFrRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx1SEFBdUgscUNBQXFDLEdBQUcsaUZBQWlGLHFHQUFxRyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsMkdBQTJHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQix1REFBdUQsR0FBRyxxQ0FBcUMsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsRUFBRSxHQUFHLDBDQUEwQyxHQUFHLHFDQUFxQyxvRkFBb0YsNEdBQTRHLEdBQUcsMkdBQTJHLHFDQUFxQyxFQUFFLEdBQUcsc0VBQXNFLEdBQUcscUNBQXFDLGlGQUFpRixtRkFBbUYsZ0ZBQWdGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsK0ZBQStGLG9GQUFvRiw0R0FBNEcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsb0ZBQW9GLDRHQUE0RyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxvQ0FBb0MsRUFBRSxHQUFHLGdFQUFnRSxJQUFJLEdBQUcsR0FBRyxnQ0FBZ0MscURBQXFELGtGQUFrRixtRkFBbUYsMkdBQTJHLEdBQUcsMEhBQTBILHFDQUFxQyxHQUFHLGtGQUFrRix5RkFBeUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx5R0FBeUcscUNBQXFDLEdBQUcsdUZBQXVGLHFGQUFxRixtRkFBbUYsMkdBQTJHLHFDQUFxQyxvQ0FBb0MsR0FBRyxnSEFBZ0gscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLGlGQUFpRix5SEFBeUgsR0FBRyxxQ0FBcUMsbUZBQW1GLG1GQUFtRiwyR0FBMkcscUNBQXFDLHFDQUFxQyxFQUFFLEdBQUcscUNBQXFDLElBQUksR0FBRyxnREFBZ0Qsa0ZBQWtGLG1GQUFtRiwyR0FBMkcsR0FBRywwSEFBMEgscUNBQXFDLEdBQUcsa0ZBQWtGLHlGQUF5Rix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLG1GQUFtRiwyR0FBMkcscUNBQXFDLG9DQUFvQyxHQUFHLGdIQUFnSCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsaUZBQWlGLHdEQUF3RCxHQUFHLHFDQUFxQyxpRkFBaUYsbUZBQW1GLDJHQUEyRyxxQ0FBcUMsb0NBQW9DLEVBQUUsR0FBRyxpR0FBaUcsSUFBSSxHQUFHLDRDQUE0QyxrRkFBa0YsbUZBQW1GLDJHQUEyRyxHQUFHLDBIQUEwSCxxQ0FBcUMsR0FBRyxpRkFBaUYsa0ZBQWtGLHVIQUF1SCxHQUFHLG9GQUFvRiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyREFBMkQsR0FBRyxxQ0FBcUMsdUhBQXVILEVBQUUsR0FBRywwRkFBMEYsSUFBSSxHQUFHLDBCQUEwQixvQ0FBb0Msd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGtGQUFrRix5R0FBeUcsR0FBRyxzRkFBc0YsMkdBQTJHLDZDQUE2QyxxQ0FBcUMsbUVBQW1FLEdBQUcsa0NBQWtDLHdGQUF3RixlQUFlLGdCQUFnQiwrQ0FBK0MsdUNBQXVDLGtCQUFrQixrRkFBa0YseUdBQXlHLEdBQUcsb0ZBQW9GLDJHQUEyRyw2Q0FBNkMscUNBQXFDLGtEQUFrRCxHQUFHLDRDQUE0Qyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLHVDQUF1QyxrQkFBa0IsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLGdIQUFnSCxxQ0FBcUMsR0FBRyxtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyxxSEFBcUgscUNBQXFDLHFDQUFxQyx1RUFBdUUsR0FBRyxrQ0FBa0Msd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGdGQUFnRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLHNGQUFzRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixvRkFBb0YsR0FBRyxtQ0FBbUMsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyx1Q0FBdUMsa0JBQWtCLCtFQUErRSw2RkFBNkYsMkdBQTJHLHFDQUFxQyxHQUFHLDJHQUEyRyxHQUFHLG1GQUFtRiwyR0FBMkcscUNBQXFDLHFDQUFxQyxnRkFBZ0YsR0FBRyx1Q0FBdUMsd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixrRkFBa0YsaUZBQWlGLDZGQUE2RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxHQUFHLGtGQUFrRixtR0FBbUcsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsR0FBRyxpRkFBaUYsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLHlGQUF5RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsc0ZBQXNGLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixxQ0FBcUMscUNBQXFDLHFDQUFxQyxHQUFHLGtGQUFrRix5RkFBeUYsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsR0FBRyxpRkFBaUYsOEZBQThGLGdHQUFnRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLHlGQUF5RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsZ0dBQWdHLHdGQUF3RiwyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLDJHQUEyRyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixxQ0FBcUMscUNBQXFDLHFDQUFxQyw0RkFBNEYsR0FBRywwQ0FBMEMsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyxnSEFBZ0gscUNBQXFDLEdBQUcsaUZBQWlGLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLDRIQUE0SCxxQ0FBcUMsR0FBRyxpRkFBaUYsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsMkhBQTJILHFDQUFxQyxHQUFHLG1GQUFtRixxRkFBcUYsMkdBQTJHLG9DQUFvQyxHQUFHLCtHQUErRyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMsNkRBQTZELEdBQUcsdUNBQXVDLHdGQUF3RixHQUFHLHdGQUF3RixlQUFlLGdCQUFnQiwrQ0FBK0MsR0FBRywrQ0FBK0MsdUNBQXVDLGtCQUFrQixrRkFBa0YsMkZBQTJGLDJHQUEyRyxxQ0FBcUMsR0FBRyxrRkFBa0YsMkdBQTJHLEdBQUcsc0ZBQXNGLDJHQUEyRyw2Q0FBNkMscUNBQXFDLHFDQUFxQywwREFBMEQsR0FBRywwQ0FBMEMsd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixrRkFBa0YsMkdBQTJHLEdBQUcsMklBQTJJLHFDQUFxQyxHQUFHLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxvSUFBb0ksR0FBRyx1Q0FBdUMsd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGdGQUFnRixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFFQUFxRSxHQUFHLHlDQUF5Qyx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0IsaUZBQWlGLGtGQUFrRiwyR0FBMkcsR0FBRywySUFBMkkscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLHdGQUF3RiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsd0ZBQXdGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxvRkFBb0YsR0FBRyx3Q0FBd0Msd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLG1GQUFtRixxRkFBcUYsd0ZBQXdGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsb0NBQW9DLEdBQUcsZ0hBQWdILHFDQUFxQyw4REFBOEQsR0FBRyxxQ0FBcUMsd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixrRkFBa0YsMkdBQTJHLEdBQUcsb0lBQW9JLHFDQUFxQyxHQUFHLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGtGQUFrRiwyR0FBMkcsR0FBRyxvRkFBb0YsMkdBQTJHLDZDQUE2QyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLDRIQUE0SCxHQUFHLGtDQUFrQyx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0IsZ0ZBQWdGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLDJHQUEyRyxHQUFHLG9GQUFvRiwyR0FBMkcsNkNBQTZDLHFDQUFxQyxnQkFBZ0IsMkdBQTJHLHNCQUFzQixpRUFBaUUsR0FBRyx3Q0FBd0Msd0ZBQXdGLEdBQUcsd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyxHQUFHLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixrRkFBa0YsMkdBQTJHLEdBQUcsb0lBQW9JLHFDQUFxQyxHQUFHLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGtGQUFrRix3RkFBd0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGtGQUFrRiwyR0FBMkcsR0FBRyxvRkFBb0YsMkdBQTJHLDZDQUE2QyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyw0REFBNEQsR0FBRyx3Q0FBd0Msd0ZBQXdGLGVBQWUsZ0JBQWdCLCtDQUErQyx1Q0FBdUMsa0JBQWtCLGlGQUFpRixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyx3SEFBd0gscUNBQXFDLEdBQUcsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcsNkhBQTZILHFDQUFxQyxxQ0FBcUMsMERBQTBELEdBQUcsdUNBQXVDLHdGQUF3RixlQUFlLGdCQUFnQiwrQ0FBK0MsdUNBQXVDLGtCQUFrQixtRkFBbUYscUZBQXFGLDJHQUEyRyxvQ0FBb0MsR0FBRyxrSUFBa0kscUNBQXFDLDJFQUEyRSxHQUFHLDhDQUE4Qyx3RkFBd0YsR0FBRyx3RkFBd0YsR0FBRyx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLEdBQUcsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0Isa0ZBQWtGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLHlGQUF5Rix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMsR0FBRyxrRkFBa0YsaUZBQWlGLGtGQUFrRiwyR0FBMkcsR0FBRyxvRkFBb0YsMkdBQTJHLDZDQUE2QyxxQ0FBcUMsR0FBRyx5RkFBeUYsMkdBQTJHLHFDQUFxQyxxQ0FBcUMsR0FBRyxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcscUhBQXFILHFDQUFxQyxHQUFHLGtGQUFrRixrRkFBa0YsMkdBQTJHLEdBQUcsb0ZBQW9GLDJHQUEyRyw2Q0FBNkMscUNBQXFDLEdBQUcsa0ZBQWtGLG1GQUFtRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHFGQUFxRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcsaUZBQWlGLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGtGQUFrRix5RkFBeUYsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGdHQUFnRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLDZGQUE2RixHQUFHLGdEQUFnRCx3RkFBd0YsR0FBRyx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0Isa0ZBQWtGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLHlGQUF5Rix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMsR0FBRyxrRkFBa0YseUZBQXlGLDJHQUEyRyxxQ0FBcUMsR0FBRyxrRkFBa0YsbUZBQW1GLHFGQUFxRiwyR0FBMkcsb0NBQW9DLEdBQUcscUhBQXFILHFDQUFxQyxHQUFHLGtGQUFrRixrRkFBa0YsMkdBQTJHLEdBQUcsb0ZBQW9GLDJHQUEyRyw2Q0FBNkMscUNBQXFDLEdBQUcsa0ZBQWtGLG1GQUFtRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHFGQUFxRix3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHlHQUF5RyxxQ0FBcUMscUNBQXFDLEdBQUcsaUZBQWlGLDhGQUE4RixzRkFBc0YsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGtGQUFrRix5RkFBeUYsMkdBQTJHLEdBQUcsMkdBQTJHLHFDQUFxQyxHQUFHLGdHQUFnRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxxQ0FBcUMsZ0JBQWdCLDJHQUEyRyxzQkFBc0IscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHlHQUF5RyxHQUFHLG9EQUFvRCx3RkFBd0YsR0FBRyx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0IsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLCtGQUErRiwyR0FBMkcsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLGlGQUFpRiw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxrRkFBa0YseUZBQXlGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxzRkFBc0Ysd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxHQUFHLGdHQUFnRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdHQUFnRyxHQUFHLHNEQUFzRCx3RkFBd0YsR0FBRyx3RkFBd0YsZUFBZSxnQkFBZ0IsK0NBQStDLEdBQUcsK0NBQStDLHVDQUF1QyxrQkFBa0IsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsOEZBQThGLHNGQUFzRiwyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLGlHQUFpRywyR0FBMkcsR0FBRywyR0FBMkcsR0FBRywyR0FBMkcscUNBQXFDLEdBQUcsa0ZBQWtGLGlGQUFpRiw4RkFBOEYsc0ZBQXNGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxrRkFBa0YseUZBQXlGLDJHQUEyRyxHQUFHLDJHQUEyRyxxQ0FBcUMsR0FBRyxzRkFBc0Ysd0ZBQXdGLDJHQUEyRyxxQ0FBcUMsR0FBRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLHFDQUFxQyxHQUFHLGdHQUFnRyx3RkFBd0YsMkdBQTJHLHFDQUFxQyxHQUFHLHdGQUF3RiwyR0FBMkcscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGdCQUFnQiwyR0FBMkcsc0JBQXNCLGdCQUFnQiwyR0FBMkcsc0JBQXNCLDRHQUE0RztBQUM5eW1QO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVcsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVcsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVyxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QixFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHFCQUFxQixFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7QUNqdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQkFBTyxDQUFDLCtIQUFzRDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLCtDQUErQztBQUMvQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQyw0S0FBc0U7QUFDOUUsbUJBQU8sQ0FBQywwSEFBNkM7QUFDckQsbUJBQU8sQ0FBQyxzRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywwR0FBcUM7QUFDN0MsbUJBQU8sQ0FBQyx3RkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyw0RkFBOEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUE0Six1QkFBdUIsZUFBZSwyQkFBMkIscUJBQXFCLGdCQUFnQixzRUFBc0UsR0FBRyw0REFBNEQsZ0JBQWdCLDRCQUE0QixxQkFBcUIsR0FBRywwRUFBMEUsZ0JBQWdCLGlCQUFpQixvQ0FBb0MsNkNBQTZDLGdDQUFnQyx3QkFBd0IsNkJBQTZCLDRCQUE0QiwrQkFBK0IsdUJBQXVCLG1DQUFtQyxnQ0FBZ0MsMkJBQTJCLEdBQUcsZ0ZBQWdGLG1DQUFtQyxnQ0FBZ0MsMkJBQTJCLGdCQUFnQixpQkFBaUIsa0JBQWtCLHlCQUF5QixHQUFHLHVHQUF1Ryx1QkFBdUIsZ0JBQWdCLGdCQUFnQiw0QkFBNEIsdUJBQXVCLGlCQUFpQixHQUFHLDREQUE0RCxxQkFBcUIsR0FBRyx5REFBeUQsd0JBQXdCLGdCQUFnQix1QkFBdUIsZ0JBQWdCLEdBQUcsOEJBQThCLGtHQUFrRyxpQ0FBaUMsa0NBQWtDLDhCQUE4QixHQUFHLG1FQUFtRSxnQkFBZ0IsaUJBQWlCLHVCQUF1Qiw0QkFBNEIsR0FBRyx3RUFBd0UsZ0JBQWdCLGlHQUFpRyxpQ0FBaUMseUJBQXlCLGdDQUFnQyx1QkFBdUIsR0FBRyw2REFBNkQsdUJBQXVCLGNBQWMsMEJBQTBCLDhCQUE4QixHQUFHLGlDQUFpQyx1QkFBdUIsaUhBQWlILEdBQUcsd0NBQXdDLHlCQUF5QixHQUFHLDRCQUE0QixzQkFBc0IsR0FBRyxpQ0FBaUMsdUJBQXVCLGtCQUFrQixHQUFHIiwiZmlsZSI6ImNyZWF0b3JfZGFzaGJvYXJkLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuIFx0XHR2YXIgZXhlY3V0ZU1vZHVsZXMgPSBkYXRhWzJdO1xuXG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXTtcbiBcdFx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4gXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG4gXHRcdFx0fVxuIFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gXHRcdH1cbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGRhdGEpO1xuXG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHRcdC8vIGFkZCBlbnRyeSBtb2R1bGVzIGZyb20gbG9hZGVkIGNodW5rIHRvIGRlZmVycmVkIGxpc3RcbiBcdFx0ZGVmZXJyZWRNb2R1bGVzLnB1c2guYXBwbHkoZGVmZXJyZWRNb2R1bGVzLCBleGVjdXRlTW9kdWxlcyB8fCBbXSk7XG5cbiBcdFx0Ly8gcnVuIGRlZmVycmVkIG1vZHVsZXMgd2hlbiBhbGwgY2h1bmtzIHJlYWR5XG4gXHRcdHJldHVybiBjaGVja0RlZmVycmVkTW9kdWxlcygpO1xuIFx0fTtcbiBcdGZ1bmN0aW9uIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCkge1xuIFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0dmFyIGRlZmVycmVkTW9kdWxlID0gZGVmZXJyZWRNb2R1bGVzW2ldO1xuIFx0XHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuIFx0XHRcdGZvcih2YXIgaiA9IDE7IGogPCBkZWZlcnJlZE1vZHVsZS5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGRlcElkID0gZGVmZXJyZWRNb2R1bGVbal07XG4gXHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbZGVwSWRdICE9PSAwKSBmdWxmaWxsZWQgPSBmYWxzZTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYoZnVsZmlsbGVkKSB7XG4gXHRcdFx0XHRkZWZlcnJlZE1vZHVsZXMuc3BsaWNlKGktLSwgMSk7XG4gXHRcdFx0XHRyZXN1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IGRlZmVycmVkTW9kdWxlWzBdKTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHRyZXR1cm4gcmVzdWx0O1xuIFx0fVxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0Ly8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4gXHQvLyBQcm9taXNlID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0XCJjcmVhdG9yX2Rhc2hib2FyZFwiOiAwXG4gXHR9O1xuXG4gXHR2YXIgZGVmZXJyZWRNb2R1bGVzID0gW107XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wXCJdID0gd2luZG93W1wid2VicGFja0pzb25wXCJdIHx8IFtdO1xuIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbiBcdGpzb25wQXJyYXkucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrO1xuIFx0anNvbnBBcnJheSA9IGpzb25wQXJyYXkuc2xpY2UoKTtcbiBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gb2xkSnNvbnBGdW5jdGlvbjtcblxuXG4gXHQvLyBhZGQgZW50cnkgbW9kdWxlIHRvIGRlZmVycmVkIGxpc3RcbiBcdGRlZmVycmVkTW9kdWxlcy5wdXNoKFtcIi4vY29yZS90ZW1wbGF0ZXMvZGV2L2hlYWQvcGFnZXMvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS9jcmVhdG9yLWRhc2hib2FyZC1wYWdlLnNjcmlwdHMudHNcIixcInZlbmRvcnN+YWJvdXR+YWRtaW5+Y29sbGVjdGlvbl9lZGl0b3J+Y29sbGVjdGlvbl9wbGF5ZXJ+Y29tbXVuaXR5X2Rhc2hib2FyZH5jb250YWN0fmNyZWF0b3JfZGFzaGJvYXJ+Nzg1NmMwNWFcIixcInZlbmRvcnN+YWRtaW5+Y29sbGVjdGlvbl9lZGl0b3J+Y29sbGVjdGlvbl9wbGF5ZXJ+Y3JlYXRvcl9kYXNoYm9hcmR+ZXhwbG9yYXRpb25fZWRpdG9yfmV4cGxvcmF0aW9uX3B+N2Y4YmNjNjdcIixcInZlbmRvcnN+YWRtaW5+Y29sbGVjdGlvbl9lZGl0b3J+Y3JlYXRvcl9kYXNoYm9hcmR+ZXhwbG9yYXRpb25fZWRpdG9yfmV4cGxvcmF0aW9uX3BsYXllcn5wcmFjdGljZV9zZXN+OTg4Y2ZlYjFcIixcInZlbmRvcnN+Y3JlYXRvcl9kYXNoYm9hcmR+ZXhwbG9yYXRpb25fZWRpdG9yfmV4cGxvcmF0aW9uX3BsYXllcn5wcmFjdGljZV9zZXNzaW9ufnJldmlld190ZXN0fnNraWxsX2V+NjFiM2QxNWVcIixcImFib3V0fmFkbWlufmNvbGxlY3Rpb25fZWRpdG9yfmNvbGxlY3Rpb25fcGxheWVyfmNvbW11bml0eV9kYXNoYm9hcmR+Y29udGFjdH5jcmVhdG9yX2Rhc2hib2FyZH5kb25hdGV+ZTA2YTRhMTdcIixcImFkbWlufmNyZWF0b3JfZGFzaGJvYXJkfmV4cGxvcmF0aW9uX2VkaXRvcn5leHBsb3JhdGlvbl9wbGF5ZXJ+bW9kZXJhdG9yfnByYWN0aWNlX3Nlc3Npb25+cmV2aWV3X3Rlc3R+Yjk1ODBlZDBcIixcImFkbWlufmNyZWF0b3JfZGFzaGJvYXJkfmV4cGxvcmF0aW9uX2VkaXRvcn5leHBsb3JhdGlvbl9wbGF5ZXJ+bW9kZXJhdG9yfnByYWN0aWNlX3Nlc3Npb25+cmV2aWV3X3Rlc3R+ZDM1OTUxNTVcIixcImNvbGxlY3Rpb25fcGxheWVyfmNyZWF0b3JfZGFzaGJvYXJkfmxlYXJuZXJfZGFzaGJvYXJkfmxpYnJhcnl+cHJvZmlsZX5zdG9yeV92aWV3ZXJcIl0pO1xuIFx0Ly8gcnVuIGRlZmVycmVkIG1vZHVsZXMgd2hlbiByZWFkeVxuIFx0cmV0dXJuIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIEJhc2UgVHJhbnNjbHVzaW9uIENvbXBvbmVudC5cbiAqL1xucmVxdWlyZSgnYmFzZV9jb21wb25lbnRzL1dhcm5pbmdMb2FkZXJEaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL09wcGlhRm9vdGVyRGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vc2lkZWJhci9TaWRlYmFyU3RhdHVzU2VydmljZS50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9VcmxTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9zdGF0ZWZ1bC9CYWNrZ3JvdW5kTWFza1NlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnYmFzZUNvbnRlbnQnLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRyYW5zY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICBicmVhZGNydW1iOiAnP25hdmJhckJyZWFkY3J1bWInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICc/cGFnZUZvb3RlcicsXG4gICAgICAgICAgICAgICAgbmF2T3B0aW9uczogJz9uYXZPcHRpb25zJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9iYXNlX2NvbXBvbmVudHMvYmFzZV9jb250ZW50X2RpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRyb290U2NvcGUnLCAnQmFja2dyb3VuZE1hc2tTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnU2lkZWJhclN0YXR1c1NlcnZpY2UnLCAnVXJsU2VydmljZScsICdTSVRFX0ZFRURCQUNLX0ZPUk1fVVJMJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHJvb3RTY29wZSwgQmFja2dyb3VuZE1hc2tTZXJ2aWNlLCBTaWRlYmFyU3RhdHVzU2VydmljZSwgVXJsU2VydmljZSwgU0lURV9GRUVEQkFDS19GT1JNX1VSTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaWZyYW1lZCA9IFVybFNlcnZpY2UuaXNJZnJhbWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2l0ZUZlZWRiYWNrRm9ybVVybCA9IFNJVEVfRkVFREJBQ0tfRk9STV9VUkw7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNTaWRlYmFyU2hvd24gPSBTaWRlYmFyU3RhdHVzU2VydmljZS5pc1NpZGViYXJTaG93bjtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jbG9zZVNpZGViYXJPblN3aXBlID0gU2lkZWJhclN0YXR1c1NlcnZpY2UuY2xvc2VTaWRlYmFyO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzQmFja2dyb3VuZE1hc2tBY3RpdmUgPSBCYWNrZ3JvdW5kTWFza1NlcnZpY2UuaXNNYXNrQWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLkRFVl9NT0RFID0gJHJvb3RTY29wZS5ERVZfTU9ERTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5za2lwVG9NYWluQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYWluQ29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3BwaWEtbWFpbi1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1haW5Db250ZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdWYXJpYWJsZSBtYWluQ29udGVudEVsZW1lbnQgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkNvbnRlbnRFbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluQ29udGVudEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Db250ZW50RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB3YXJuaW5nX2xvYWRlci5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvQWxlcnRzU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCd3YXJuaW5nTG9hZGVyJywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9iYXNlX2NvbXBvbmVudHMvd2FybmluZ19sb2FkZXJfZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnQWxlcnRzU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKEFsZXJ0c1NlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLkFsZXJ0c1NlcnZpY2UgPSBBbGVydHNTZXJ2aWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VydmljZSBmb3IgdGhlICdlbWJlZCBleHBsb3JhdGlvbicgbW9kYWwuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL1NpdGVBbmFseXRpY3NTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdFeHBsb3JhdGlvbkVtYmVkQnV0dG9uU2VydmljZScsIFtcbiAgICAnJHVpYk1vZGFsJywgJ1NpdGVBbmFseXRpY3NTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoJHVpYk1vZGFsLCBTaXRlQW5hbHl0aWNzU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNob3dNb2RhbDogZnVuY3Rpb24gKGV4cGxvcmF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAkdWliTW9kYWwub3Blbih7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9jb21wb25lbnRzL2J1dHRvbi1kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4cGxvcmF0aW9uLWVtYmVkLWJ1dHRvbi5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBsb3JhdGlvbklkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGxvcmF0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICckc2NvcGUnLCAnJHVpYk1vZGFsSW5zdGFuY2UnLCAnJHdpbmRvdycsICdleHBsb3JhdGlvbklkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICR1aWJNb2RhbEluc3RhbmNlLCAkd2luZG93LCBleHBsb3JhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmV4cGxvcmF0aW9uSWQgPSBleHBsb3JhdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zZXJ2ZXJOYW1lID0gKCR3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgJHdpbmRvdy5sb2NhdGlvbi5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR1aWJNb2RhbEluc3RhbmNlLmRpc21pc3MoJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0VGV4dCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVEaXYgPSBldnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUoY29kZURpdi5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoY29kZURpdi5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFNpdGVBbmFseXRpY3NTZXJ2aWNlLnJlZ2lzdGVyT3BlbkVtYmVkSW5mb0V2ZW50KGV4cGxvcmF0aW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTUgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBiYWNrZ3JvdW5kIGJhbm5lci5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdiYWNrZ3JvdW5kQmFubmVyJywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldERpcmVjdGl2ZVRlbXBsYXRlVXJsKCcvY29tcG9uZW50cy9jb21tb24tbGF5b3V0LWRpcmVjdGl2ZXMvY29tbW9uLWVsZW1lbnRzLycgK1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWJhbm5lci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVCYW5uZXJGaWxlbmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFubmVyQS5zdmcnLCAnYmFubmVyQi5zdmcnLCAnYmFubmVyQy5zdmcnLCAnYmFubmVyRC5zdmcnXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYW5uZXJJbWFnZUZpbGVuYW1lID0gcG9zc2libGVCYW5uZXJGaWxlbmFtZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc2libGVCYW5uZXJGaWxlbmFtZXMubGVuZ3RoKV07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYmFubmVySW1hZ2VGaWxlVXJsID0gVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0U3RhdGljSW1hZ2VVcmwoJy9iYWNrZ3JvdW5kLycgKyBiYW5uZXJJbWFnZUZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNiBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIFNvY2lhbCBTaGFyaW5nIExpbmtzLlxuICovXG5yZXF1aXJlKCdjb21wb25lbnRzL2J1dHRvbi1kaXJlY3RpdmVzL2V4cGxvcmF0aW9uLWVtYmVkLWJ1dHRvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL1NpdGVBbmFseXRpY3NTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ3NoYXJpbmdMaW5rcycsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgbGF5b3V0VHlwZTogJ0AnLFxuICAgICAgICAgICAgICAgIGxheW91dEFsaWduVHlwZTogJ0AnLFxuICAgICAgICAgICAgICAgIHNoYXJlVHlwZTogJ0AnLFxuICAgICAgICAgICAgICAgIGdldEV4cGxvcmF0aW9uSWQ6ICcmZXhwbG9yYXRpb25JZCcsXG4gICAgICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbklkOiAnJmNvbGxlY3Rpb25JZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9jb21wb25lbnRzL2NvbW1vbi1sYXlvdXQtZGlyZWN0aXZlcy9jb21tb24tZWxlbWVudHMvJyArXG4gICAgICAgICAgICAgICAgJ3NoYXJpbmctbGlua3MuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHdpbmRvdycsICdIdG1sRXNjYXBlclNlcnZpY2UnLFxuICAgICAgICAgICAgICAgICdFeHBsb3JhdGlvbkVtYmVkQnV0dG9uU2VydmljZScsICdTaXRlQW5hbHl0aWNzU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0RFRkFVTFRfVFdJVFRFUl9TSEFSRV9NRVNTQUdFX0VESVRPUicsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCR3aW5kb3csIEh0bWxFc2NhcGVyU2VydmljZSwgRXhwbG9yYXRpb25FbWJlZEJ1dHRvblNlcnZpY2UsIFNpdGVBbmFseXRpY3NTZXJ2aWNlLCBERUZBVUxUX1RXSVRURVJfU0hBUkVfTUVTU0FHRV9FRElUT1IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnJlZ2lzdGVyU2hhcmVFdmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnNoYXJlVHlwZSA9PT0gJ2V4cGxvcmF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5leHBsb3JhdGlvbklkID0gY3RybC5nZXRFeHBsb3JhdGlvbklkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2aXR5VHlwZSA9ICdleHBsb3JlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYWN0aXZpdHlJZCA9IGN0cmwuZXhwbG9yYXRpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVnaXN0ZXJTaGFyZUV2ZW50ID0gKFNpdGVBbmFseXRpY3NTZXJ2aWNlLnJlZ2lzdGVyU2hhcmVFeHBsb3JhdGlvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2hvd0VtYmVkRXhwbG9yYXRpb25Nb2RhbCA9IChFeHBsb3JhdGlvbkVtYmVkQnV0dG9uU2VydmljZS5zaG93TW9kYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuc2hhcmVUeXBlID09PSAnY29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29sbGVjdGlvbklkID0gY3RybC5nZXRDb2xsZWN0aW9uSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYWN0aXZpdHlUeXBlID0gJ2NvbGxlY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hY3Rpdml0eUlkID0gY3RybC5jb2xsZWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlZ2lzdGVyU2hhcmVFdmVudCA9IChTaXRlQW5hbHl0aWNzU2VydmljZS5yZWdpc3RlclNoYXJlQ29sbGVjdGlvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdTaGFyaW5nTGlua3MgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgZWl0aGVyIGluIHRoZScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xsZWN0aW9uIHBsYXllciBvciB0aGUgZXhwbG9yYXRpb24gcGxheWVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZXJ2ZXJOYW1lID0gKCR3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgJHdpbmRvdy5sb2NhdGlvbi5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5lc2NhcGVkVHdpdHRlclRleHQgPSAoSHRtbEVzY2FwZXJTZXJ2aWNlLnVuZXNjYXBlZFN0clRvRXNjYXBlZFN0cihERUZBVUxUX1RXSVRURVJfU0hBUkVfTUVTU0FHRV9FRElUT1IpKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jbGFzc3Jvb21VcmwgPSBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRTdGF0aWNJbWFnZVVybCgnL2dlbmVyYWwvY2xhc3Nyb29tLnBuZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE2IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB1cGxvYWRpbmcgaW1hZ2VzLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9JZEdlbmVyYXRpb25TZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2ltYWdlVXBsb2FkZXInLCBbXG4gICAgJ0lkR2VuZXJhdGlvblNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChJZEdlbmVyYXRpb25TZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnQCcsXG4gICAgICAgICAgICAgICAgb25GaWxlQ2hhbmdlZDogJz0nLFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogJ0AnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnQCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9jb21wb25lbnRzL2Zvcm1zL2N1c3RvbS1mb3Jtcy1kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdpbWFnZS11cGxvYWRlci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25EcmFnRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkKCcuaW1hZ2UtdXBsb2FkZXItZHJvcC1hcmVhJykucmVtb3ZlQ2xhc3MoJ2ltYWdlLXVwbG9hZGVyLWlzLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlVXBsb2FkZWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSB8fCAhZmlsZS5zaXplIHx8ICFmaWxlLnR5cGUubWF0Y2goJ2ltYWdlLionKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdUaGlzIGZpbGUgaXMgbm90IHJlY29nbml6ZWQgYXMgYW4gaW1hZ2UuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuanBlZycpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhZmlsZS50eXBlLm1hdGNoKCdpbWFnZS5naWYnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuanBnJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFmaWxlLnR5cGUubWF0Y2goJ2ltYWdlLnBuZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgaW1hZ2UgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGZpbGUudHlwZS5tYXRjaCgvanAoZT8pZyQvKSAmJiAhZmlsZS5uYW1lLm1hdGNoKC9cXC5qcChlPylnJC8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUudHlwZS5tYXRjaCgvZ2lmJC8pICYmICFmaWxlLm5hbWUubWF0Y2goL1xcLmdpZiQvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlLnR5cGUubWF0Y2goL3BuZyQvKSAmJiAhZmlsZS5uYW1lLm1hdGNoKC9cXC5wbmckLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgaW1hZ2UgZm9ybWF0IGRvZXMgbm90IG1hdGNoIHRoZSBmaWxlbmFtZSBleHRlbnNpb24uJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgT05FX01CX0lOX0JZVEVTID0gMTA0ODU3NjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IE9ORV9NQl9JTl9CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gKGZpbGUuc2l6ZSAvIE9ORV9NQl9JTl9CWVRFUykudG9GaXhlZCgxKSArICcgTUInO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdUaGUgbWF4aW11bSBhbGxvd2VkIGZpbGUgc2l6ZSBpcyAxIE1CJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAoJyArIGN1cnJlbnRTaXplICsgJyBnaXZlbikuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICQoZWx0KS5iaW5kKCdkcm9wJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnRW5kKGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmVycm9yTWVzc2FnZSA9IHZhbGlkYXRlVXBsb2FkZWRGaWxlKGZpbGUsIGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NvcGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGZpcmUgdGhpcyBldmVudCBpZiB2YWxpZGF0aW9ucyBwYXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub25GaWxlQ2hhbmdlZChmaWxlLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQoZWx0KS5iaW5kKCdkcmFnb3ZlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmltYWdlLXVwbG9hZGVyLWRyb3AtYXJlYScpLmFkZENsYXNzKCdpbWFnZS11cGxvYWRlci1pcy1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkKGVsdCkuYmluZCgnZHJhZ2xlYXZlJywgb25EcmFnRW5kKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBhY2NpZGVudGFsbHkgZHJvcHMgYW4gaW1hZ2Ugb3V0c2lkZSBvZiB0aGUgaW1hZ2UtdXBsb2FkZXJcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBhcHBseWluZyBub3JtYWwgZHJhZy1hbmQtZHJvcFxuICAgICAgICAgICAgICAgIC8vIGxvZ2ljLCB3aGljaCBpcyB0byBsb2FkIHRoZSBpbWFnZSBpbiB0aGUgYnJvd3NlciB0YWIuXG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQod2luZG93KS5iaW5kKCdkcm9wJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdlIGdlbmVyYXRlIGEgcmFuZG9tIGNsYXNzIG5hbWUgdG8gZGlzdGluZ3Vpc2ggdGhpcyBpbnB1dCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJzIGluIHRoZSBET00uXG4gICAgICAgICAgICAgICAgc2NvcGUuZmlsZUlucHV0Q2xhc3NOYW1lID0gKCdpbWFnZS11cGxvYWRlci1maWxlLWlucHV0JyArIElkR2VuZXJhdGlvblNlcnZpY2UuZ2VuZXJhdGVOZXdJZCgpKTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UnLCAnLicgKyBzY29wZS5maWxlSW5wdXRDbGFzc05hbWUsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBldnQuY3VycmVudFRhcmdldC5maWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZXZ0LnRhcmdldC52YWx1ZS5zcGxpdCgvKFxcXFx8XFwvKS9nKS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZXJyb3JNZXNzYWdlID0gdmFsaWRhdGVVcGxvYWRlZEZpbGUoZmlsZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBmaXJlIHRoaXMgZXZlbnQgaWYgdmFsaWRhdGlvbnMgcGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm9uRmlsZUNoYW5nZWQoZmlsZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBzZXJ2aWNlIHRoYXQgbWFpbnRhaW5zIGEgcmVjb3JkIG9mIHRoZSBvYmplY3RzIGV4Y2x1c2l2ZSB0b1xuICogYSBzdGF0ZS5cbiAqL1xudmFyIGNsb25lRGVlcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBzb2x1dGlvbl92YWxpZGl0eV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwicGFnZXMvZXhwbG9yYXRpb24tZWRpdG9yLXBhZ2UvZWRpdG9yLXRhYi9zZXJ2aWNlcy9zb2x1dGlvbi12YWxpZGl0eS5zZXJ2aWNlXCIpO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgU3RhdGVFZGl0b3JTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlRWRpdG9yU2VydmljZShzb2x1dGlvblZhbGlkaXR5U2VydmljZSkge1xuICAgICAgICB0aGlzLnNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlID0gc29sdXRpb25WYWxpZGl0eVNlcnZpY2U7XG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZU5hbWVzID0gW107XG4gICAgICAgIHRoaXMuY29ycmVjdG5lc3NGZWVkYmFja0VuYWJsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmluUXVlc3Rpb25Nb2RlID0gbnVsbDtcbiAgICAgICAgLy8gQ3VycmVudGx5LCB0aGUgb25seSBwbGFjZSB3aGVyZSB0aGlzIGlzIHVzZWQgaW4gdGhlIHN0YXRlIGVkaXRvclxuICAgICAgICAvLyBpcyBpbiBzb2x1dGlvbiB2ZXJpZmljYXRpb24uIFNvLCBvbmNlIHRoZSBpbnRlcmFjdGlvbiBpcyBzZXQgaW4gdGhpc1xuICAgICAgICAvLyBzZXJ2aWNlLCB0aGUgZ2l2ZW4gc29sdXRpb25zIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgdmVyaWZpZWQgZm9yIHRoZSBzZXRcbiAgICAgICAgLy8gaW50ZXJhY3Rpb24uXG4gICAgICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgICAgICAvLyAnYW55JyBiZWNhdXNlIHRoZSByZXR1cm4gdHlwZSBpcyBhIGludGVyYWN0aW9uIGRvbWFpbiBvYmplY3Qgd2hpY2ggY2FuIGJlXG4gICAgICAgIC8vIHR5cGVkIG9uY2UgSW50ZXJhY3Rpb25PYmplY3RGYWN0b3J5IGlzIHVwZ3JhZGVkLlxuICAgICAgICB0aGlzLmludGVyYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXNjb25jZXB0aW9uc0J5U2tpbGwgPSB7fTtcbiAgICAgICAgdGhpcy5leHBsb3JhdGlvbklzV2hpdGVsaXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb2xpY2l0QW5zd2VyRGV0YWlscyA9IG51bGw7XG4gICAgfVxuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuZ2V0QWN0aXZlU3RhdGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVTdGF0ZU5hbWU7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLnNldEFjdGl2ZVN0YXRlTmFtZSA9IGZ1bmN0aW9uIChuZXdBY3RpdmVTdGF0ZU5hbWUpIHtcbiAgICAgICAgaWYgKG5ld0FjdGl2ZVN0YXRlTmFtZSA9PT0gJycgfHwgbmV3QWN0aXZlU3RhdGVOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGFjdGl2ZSBzdGF0ZSBuYW1lOiAnICsgbmV3QWN0aXZlU3RhdGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlTmFtZSA9IG5ld0FjdGl2ZVN0YXRlTmFtZTtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuaXNFeHBsb3JhdGlvbldoaXRlbGlzdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsb3JhdGlvbklzV2hpdGVsaXN0ZWQ7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLnVwZGF0ZUV4cGxvcmF0aW9uV2hpdGVsaXN0ZWRTdGF0dXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHBsb3JhdGlvbklzV2hpdGVsaXN0ZWQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuc2V0TWlzY29uY2VwdGlvbnNCeVNraWxsID0gZnVuY3Rpb24gKG5ld01pc2NvbmNlcHRpb25zQnlTa2lsbCkge1xuICAgICAgICB0aGlzLm1pc2NvbmNlcHRpb25zQnlTa2lsbCA9IG5ld01pc2NvbmNlcHRpb25zQnlTa2lsbDtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuZ2V0TWlzY29uY2VwdGlvbnNCeVNraWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taXNjb25jZXB0aW9uc0J5U2tpbGw7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLnNldEludGVyYWN0aW9uID0gZnVuY3Rpb24gKG5ld0ludGVyYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXdJbnRlcmFjdGlvbjtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuc2V0SW50ZXJhY3Rpb25JZCA9IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uLnNldElkKG5ld0lkKTtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuc2V0SW50ZXJhY3Rpb25BbnN3ZXJHcm91cHMgPSBmdW5jdGlvbiAobmV3QW5zd2VyR3JvdXBzKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24uc2V0QW5zd2VyR3JvdXBzKG5ld0Fuc3dlckdyb3Vwcyk7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLnNldEludGVyYWN0aW9uRGVmYXVsdE91dGNvbWUgPSBmdW5jdGlvbiAobmV3T3V0Y29tZSkge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uLnNldERlZmF1bHRPdXRjb21lKG5ld091dGNvbWUpO1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnbmV3QXJncycgaXMgYSBkaWN0IHdpdGggdW5kZXJzY29yZV9jYXNlZCBrZXlzIHdoaWNoXG4gICAgLy8gZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2YgY2FtZWxDYXNpbmcuXG4gICAgU3RhdGVFZGl0b3JTZXJ2aWNlLnByb3RvdHlwZS5zZXRJbnRlcmFjdGlvbkN1c3RvbWl6YXRpb25BcmdzID0gZnVuY3Rpb24gKG5ld0FyZ3MpIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbi5zZXRDdXN0b21pemF0aW9uQXJncyhuZXdBcmdzKTtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ3NvbHV0aW9uJyBpcyBhIHNvbHV0aW9uIGRvbWFpbiBvYmplY3Qgd2hpY2ggY2FuIGJlIHR5cGVkXG4gICAgLy8gb25jZSBTb2x1dGlvbk9iamVjdEZhY3RvcnkgaXMgdXBncmFkZWQuXG4gICAgU3RhdGVFZGl0b3JTZXJ2aWNlLnByb3RvdHlwZS5zZXRJbnRlcmFjdGlvblNvbHV0aW9uID0gZnVuY3Rpb24gKHNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24uc2V0U29sdXRpb24oc29sdXRpb24pO1xuICAgIH07XG4gICAgU3RhdGVFZGl0b3JTZXJ2aWNlLnByb3RvdHlwZS5zZXRJbnRlcmFjdGlvbkhpbnRzID0gZnVuY3Rpb24gKGhpbnRzKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24uc2V0SGludHMoaGludHMpO1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSB0aGUgcmV0dXJuIHR5cGUgaXMgYSBpbnRlcmFjdGlvbiBkb21haW4gb2JqZWN0IHdoaWNoIGNhbiBiZVxuICAgIC8vIHR5cGVkIG9uY2UgSW50ZXJhY3Rpb25PYmplY3RGYWN0b3J5IGlzIHVwZ3JhZGVkLlxuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuZ2V0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbG9uZURlZXBfMS5kZWZhdWx0KHRoaXMuaW50ZXJhY3Rpb24pO1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnY3VzdG9taXphdGlvbkFyZ3MnIGlzIGEgZGljdCB3aXRoIHVuZGVyc2NvcmVfY2FzZWQga2V5c1xuICAgIC8vIHdoaWNoIGdpdmUgdHNsaW50IGVycm9ycyBhZ2FpbnN0IHVuZGVyc2NvcmVfY2FzaW5nIGluIGZhdm9yIG9mIGNhbWVsQ2FzaW5nLlxuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuZ2V0QW5zd2VyQ2hvaWNlcyA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbklkLCBjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZXMgZm9yIG11bHRpcGxlIGNob2ljZSBpbnB1dCBhbmQgaW1hZ2UgY2xpY2sgaW5wdXQuXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbklkID09PSAnTXVsdGlwbGVDaG9pY2VJbnB1dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlLm1hcChmdW5jdGlvbiAodmFsLCBpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWw6IGluZCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHZhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnRlcmFjdGlvbklkID09PSAnSW1hZ2VDbGlja0lucHV0Jykge1xuICAgICAgICAgICAgdmFyIF9hbnN3ZXJDaG9pY2VzID0gW107XG4gICAgICAgICAgICB2YXIgaW1hZ2VXaXRoUmVnaW9ucyA9IGN1c3RvbWl6YXRpb25BcmdzLmltYWdlQW5kUmVnaW9ucy52YWx1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW1hZ2VXaXRoUmVnaW9ucy5sYWJlbGVkUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIF9hbnN3ZXJDaG9pY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB2YWw6IGltYWdlV2l0aFJlZ2lvbnMubGFiZWxlZFJlZ2lvbnNbal0ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpbWFnZVdpdGhSZWdpb25zLmxhYmVsZWRSZWdpb25zW2pdLmxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2Fuc3dlckNob2ljZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW50ZXJhY3Rpb25JZCA9PT0gJ0l0ZW1TZWxlY3Rpb25JbnB1dCcgfHxcbiAgICAgICAgICAgIGludGVyYWN0aW9uSWQgPT09ICdEcmFnQW5kRHJvcFNvcnRJbnB1dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB2YWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVFZGl0b3JTZXJ2aWNlLnByb3RvdHlwZS5zZXRJblF1ZXN0aW9uTW9kZSA9IGZ1bmN0aW9uIChuZXdNb2RlVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pblF1ZXN0aW9uTW9kZSA9IG5ld01vZGVWYWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuaXNJblF1ZXN0aW9uTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5RdWVzdGlvbk1vZGU7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLnNldENvcnJlY3RuZXNzRmVlZGJhY2tFbmFibGVkID0gZnVuY3Rpb24gKG5ld0NvcnJlY3RuZXNzRmVlZGJhY2tFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY29ycmVjdG5lc3NGZWVkYmFja0VuYWJsZWQgPSBuZXdDb3JyZWN0bmVzc0ZlZWRiYWNrRW5hYmxlZDtcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuZ2V0Q29ycmVjdG5lc3NGZWVkYmFja0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcnJlY3RuZXNzRmVlZGJhY2tFbmFibGVkO1xuICAgIH07XG4gICAgU3RhdGVFZGl0b3JTZXJ2aWNlLnByb3RvdHlwZS5zZXRTb2xpY2l0QW5zd2VyRGV0YWlscyA9IGZ1bmN0aW9uIChuZXdTb2xpY2l0QW5zd2VyRGV0YWlscykge1xuICAgICAgICB0aGlzLnNvbGljaXRBbnN3ZXJEZXRhaWxzID0gbmV3U29saWNpdEFuc3dlckRldGFpbHM7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLmdldFNvbGljaXRBbnN3ZXJEZXRhaWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2xpY2l0QW5zd2VyRGV0YWlscztcbiAgICB9O1xuICAgIFN0YXRlRWRpdG9yU2VydmljZS5wcm90b3R5cGUuc2V0U3RhdGVOYW1lcyA9IGZ1bmN0aW9uIChuZXdTdGF0ZU5hbWVzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVOYW1lcyA9IG5ld1N0YXRlTmFtZXM7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLmdldFN0YXRlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTmFtZXM7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLmlzQ3VycmVudFNvbHV0aW9uVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlLmlzU29sdXRpb25WYWxpZCh0aGlzLmFjdGl2ZVN0YXRlTmFtZSk7XG4gICAgfTtcbiAgICBTdGF0ZUVkaXRvclNlcnZpY2UucHJvdG90eXBlLmRlbGV0ZUN1cnJlbnRTb2x1dGlvblZhbGlkaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlLmRlbGV0ZVNvbHV0aW9uVmFsaWRpdHkodGhpcy5hY3RpdmVTdGF0ZU5hbWUpO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIFN0YXRlRWRpdG9yU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBzb2x1dGlvbl92YWxpZGl0eV9zZXJ2aWNlXzEuU29sdXRpb25WYWxpZGl0eVNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgc29sdXRpb25fdmFsaWRpdHlfc2VydmljZV8xLlNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIFN0YXRlRWRpdG9yU2VydmljZSk7XG4gICAgcmV0dXJuIFN0YXRlRWRpdG9yU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlRWRpdG9yU2VydmljZSA9IFN0YXRlRWRpdG9yU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1N0YXRlRWRpdG9yU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoU3RhdGVFZGl0b3JTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgZGF0YSBzZXJ2aWNlIHRoYXQgc3RvcmVzIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIGlkLlxuICovXG4vLyBUT0RPKHNsbCk6IEFkZCB2YWxpZGF0aW9uLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnU3RhdGVJbnRlcmFjdGlvbklkU2VydmljZScsIFtcbiAgICAnU3RhdGVQcm9wZXJ0eVNlcnZpY2UnLCBmdW5jdGlvbiAoU3RhdGVQcm9wZXJ0eVNlcnZpY2UpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShTdGF0ZVByb3BlcnR5U2VydmljZSk7XG4gICAgICAgIGNoaWxkLnNldHRlck1ldGhvZEtleSA9ICdzYXZlSW50ZXJhY3Rpb25JZCc7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhbG9uZSBzZXJ2aWNlcyBmb3IgdGhlIGdlbmVyYWwgc3RhdGUgZWRpdG9yIHBhZ2UuXG4gKi9cbnJlcXVpcmUoJ3NlcnZpY2VzL0FsZXJ0c1NlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1N0YXRlUHJvcGVydHlTZXJ2aWNlJywgW1xuICAgICdBbGVydHNTZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoQWxlcnRzU2VydmljZSkge1xuICAgICAgICAvLyBQdWJsaWMgYmFzZSBBUEkgZm9yIGRhdGEgc2VydmljZXMgY29ycmVzcG9uZGluZyB0byBzdGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIChpbnRlcmFjdGlvbiBpZCwgY29udGVudCwgZXRjLilcbiAgICAgICAgLy8gV0FSTklORzogVGhpcyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiB0aGUgc3RhdGVcbiAgICAgICAgLy8gZWRpdG9yLCBhbmQgZXZlcnkgdGltZSB0aGUgc3RhdGUgaXMgbG9hZGVkLCBzbyB0aGF0IHByb3BlciBiZWhhdmlvciBpc1xuICAgICAgICAvLyBtYWludGFpbmVkIGlmIGUuZy4gdGhlIHN0YXRlIGlzIHJlbmFtZWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoc3RhdGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRlck1ldGhvZEtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnU3RhdGUgcHJvcGVydHkgc2V0dGVyIG1ldGhvZCBrZXkgY2Fubm90IGJlIG51bGwuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhlIHN0YXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVOYW1lID0gc3RhdGVOYW1lO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSAod2hpY2ggbWF5IG5vdCBoYXZlIGJlZW4gc2F2ZWQgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgZnJvbnRlbmQgeWV0KS4gSW4gZ2VuZXJhbCwgdGhpcyB3aWxsIGJlIGJvdW5kIGRpcmVjdGx5IHRvIHRoZSBVSS5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXllZCA9IGFuZ3VsYXIuY29weSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIChzYXZlZC1pbi10aGUtZnJvbnRlbmQpIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS4gSGVyZSxcbiAgICAgICAgICAgICAgICAvLyAnc2F2ZWQnIG1lYW5zIHRoYXQgdGhpcyBpcyB0aGUgbGF0ZXN0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhc1xuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZWQgYnkgdGhlIGZyb250ZW5kIGNoYW5nZSBsaXN0LlxuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZWRNZW1lbnRvID0gYW5ndWxhci5jb3B5KHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgdmFsdWUgaGFzIGNoYW5nZWQgZnJvbSB0aGUgbWVtZW50by5cbiAgICAgICAgICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWFuZ3VsYXIuZXF1YWxzKHRoaXMuc2F2ZWRNZW1lbnRvLCB0aGlzLmRpc3BsYXllZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhlIHNldHRlciBtZXRob2QgaW4gRXhwbG9yYXRpb25TdGF0ZXNTZXJ2aWNlIGZvciB0aGlzXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eS4gVEhJUyBNVVNUIEJFIFNQRUNJRklFRCBCWSBTVUJDTEFTU0VTLlxuICAgICAgICAgICAgc2V0dGVyTWV0aG9kS2V5OiBudWxsLFxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIG5vcm1hbGl6ZWQgZm9ybS4gVEhJUyBDQU4gQkVcbiAgICAgICAgICAgIC8vIE9WRVJSSURERU4gQlkgU1VCQ0xBU1NFUy4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZG8gbm90aGluZy5cbiAgICAgICAgICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZXMgdGhlIGdpdmVuIHZhbHVlIGFuZCByZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgaXRcbiAgICAgICAgICAgIC8vIGlzIHZhbGlkIG9yIG5vdC4gVEhJUyBDQU4gQkUgT1ZFUlJJRERFTiBCWSBTVUJDTEFTU0VTLiBUaGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgdG8gYWx3YXlzIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgX2lzVmFsaWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVwZGF0ZXMgdGhlIG1lbWVudG8gdG8gdGhlIGRpc3BsYXllZCB2YWx1ZS5cbiAgICAgICAgICAgIHNhdmVEaXNwbGF5ZWRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRlck1ldGhvZEtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnU3RhdGUgcHJvcGVydHkgc2V0dGVyIG1ldGhvZCBrZXkgY2Fubm90IGJlIG51bGwuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWQgPSB0aGlzLl9ub3JtYWxpemUodGhpcy5kaXNwbGF5ZWQpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZCh0aGlzLmRpc3BsYXllZCkgfHwgIXRoaXMuaGFzQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZUZyb21NZW1lbnRvKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuZXF1YWxzKHRoaXMuZGlzcGxheWVkLCB0aGlzLnNhdmVkTWVtZW50bykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBbGVydHNTZXJ2aWNlLmNsZWFyV2FybmluZ3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVkTWVtZW50byA9IGFuZ3VsYXIuY29weSh0aGlzLmRpc3BsYXllZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gUmV2ZXJ0cyB0aGUgZGlzcGxheWVkIHZhbHVlIHRvIHRoZSBzYXZlZCBtZW1lbnRvLlxuICAgICAgICAgICAgcmVzdG9yZUZyb21NZW1lbnRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBhbmd1bGFyLmNvcHkodGhpcy5zYXZlZE1lbWVudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgZm9yIHN1bW1hcnkgdGlsZSBmb3IgY29sbGVjdGlvbnMuXG4gKi9cbi8vIFRPRE8oIzcwOTIpOiBEZWxldGUgdGhpcyBmaWxlIG9uY2UgbWlncmF0aW9uIGlzIGNvbXBsZXRlIGFuZCB0aGVzZSBBbmd1bGFySlNcbi8vIGVxdWl2YWxlbnRzIG9mIHRoZSBBbmd1bGFyIGNvbnN0YW50cyBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbnZhciBjb2xsZWN0aW9uX3N1bW1hcnlfdGlsZV9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJjb21wb25lbnRzL3N1bW1hcnktdGlsZS9jb2xsZWN0aW9uLXN1bW1hcnktdGlsZS5jb25zdGFudHNcIik7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnQ09MTEVDVElPTl9WSUVXRVJfVVJMJywgY29sbGVjdGlvbl9zdW1tYXJ5X3RpbGVfY29uc3RhbnRzXzEuQ29sbGVjdGlvblN1bW1hcnlUaWxlQ29uc3RhbnRzLkNPTExFQ1RJT05fVklFV0VSX1VSTCk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnQ09MTEVDVElPTl9FRElUT1JfVVJMJywgY29sbGVjdGlvbl9zdW1tYXJ5X3RpbGVfY29uc3RhbnRzXzEuQ29sbGVjdGlvblN1bW1hcnlUaWxlQ29uc3RhbnRzLkNPTExFQ1RJT05fRURJVE9SX1VSTCk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyBmb3Igc3VtbWFyeSB0aWxlIGZvciBjb2xsZWN0aW9ucy5cbiAqL1xudmFyIENvbGxlY3Rpb25TdW1tYXJ5VGlsZUNvbnN0YW50cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uU3VtbWFyeVRpbGVDb25zdGFudHMoKSB7XG4gICAgfVxuICAgIENvbGxlY3Rpb25TdW1tYXJ5VGlsZUNvbnN0YW50cy5DT0xMRUNUSU9OX1ZJRVdFUl9VUkwgPSAnL2NvbGxlY3Rpb24vPGNvbGxlY3Rpb25faWQ+JztcbiAgICBDb2xsZWN0aW9uU3VtbWFyeVRpbGVDb25zdGFudHMuQ09MTEVDVElPTl9FRElUT1JfVVJMID0gJy9jb2xsZWN0aW9uX2VkaXRvci9jcmVhdGUvPGNvbGxlY3Rpb25faWQ+JztcbiAgICByZXR1cm4gQ29sbGVjdGlvblN1bW1hcnlUaWxlQ29uc3RhbnRzO1xufSgpKTtcbmV4cG9ydHMuQ29sbGVjdGlvblN1bW1hcnlUaWxlQ29uc3RhbnRzID0gQ29sbGVjdGlvblN1bW1hcnlUaWxlQ29uc3RhbnRzO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTYgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTdW1tYXJ5IHRpbGUgZm9yIGNvbGxlY3Rpb25zLlxuICovXG5yZXF1aXJlKCdkb21haW4vbGVhcm5lcl9kYXNoYm9hcmQvTGVhcm5lckRhc2hib2FyZEljb25zRGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdmaWx0ZXJzL3N0cmluZy11dGlsaXR5LWZpbHRlcnMvdHJ1bmNhdGUtYW5kLWNhcGl0YWxpemUuZmlsdGVyLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9EYXRlVGltZUZvcm1hdFNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL1VzZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL3N1bW1hcnktdGlsZS9jb2xsZWN0aW9uLXN1bW1hcnktdGlsZS5jb25zdGFudHMuYWpzLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2NvbGxlY3Rpb25TdW1tYXJ5VGlsZScsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbklkOiAnJmNvbGxlY3Rpb25JZCcsXG4gICAgICAgICAgICAgICAgZ2V0Q29sbGVjdGlvblRpdGxlOiAnJmNvbGxlY3Rpb25UaXRsZScsXG4gICAgICAgICAgICAgICAgZ2V0T2JqZWN0aXZlOiAnJm9iamVjdGl2ZScsXG4gICAgICAgICAgICAgICAgZ2V0Tm9kZUNvdW50OiAnJm5vZGVDb3VudCcsXG4gICAgICAgICAgICAgICAgZ2V0TGFzdFVwZGF0ZWRNc2VjOiAnJmxhc3RVcGRhdGVkTXNlYycsXG4gICAgICAgICAgICAgICAgZ2V0VGh1bWJuYWlsSWNvblVybDogJyZ0aHVtYm5haWxJY29uVXJsJyxcbiAgICAgICAgICAgICAgICBnZXRUaHVtYm5haWxCZ0NvbG9yOiAnJnRodW1ibmFpbEJnQ29sb3InLFxuICAgICAgICAgICAgICAgIGlzTGlua2VkVG9FZGl0b3JQYWdlOiAnPT9pc0xpbmtlZFRvRWRpdG9yUGFnZScsXG4gICAgICAgICAgICAgICAgZ2V0Q2F0ZWdvcnk6ICcmY2F0ZWdvcnknLFxuICAgICAgICAgICAgICAgIGlzUGxheWxpc3RUaWxlOiAnJmlzUGxheWxpc3RUaWxlJyxcbiAgICAgICAgICAgICAgICBzaG93TGVhcm5lckRhc2hib2FyZEljb25zSWZQb3NzaWJsZTogKCcmc2hvd0xlYXJuZXJEYXNoYm9hcmRJY29uc0lmUG9zc2libGUnKSxcbiAgICAgICAgICAgICAgICBpc0NvbnRhaW5lck5hcnJvdzogJyZjb250YWluZXJJc05hcnJvdycsXG4gICAgICAgICAgICAgICAgaXNPd25lZEJ5Q3VycmVudFVzZXI6ICcmYWN0aXZpdHlJc093bmVkQnlDdXJyZW50VXNlcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldERpcmVjdGl2ZVRlbXBsYXRlVXJsKCcvY29tcG9uZW50cy9zdW1tYXJ5LXRpbGUvY29sbGVjdGlvbi1zdW1tYXJ5LXRpbGUuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnRGF0ZVRpbWVGb3JtYXRTZXJ2aWNlJywgJ1VzZXJTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnQUNUSVZJVFlfVFlQRV9DT0xMRUNUSU9OJywgJ0NPTExFQ1RJT05fVklFV0VSX1VSTCcsXG4gICAgICAgICAgICAgICAgJ0NPTExFQ1RJT05fRURJVE9SX1VSTCcsIGZ1bmN0aW9uIChEYXRlVGltZUZvcm1hdFNlcnZpY2UsIFVzZXJTZXJ2aWNlLCBBQ1RJVklUWV9UWVBFX0NPTExFQ1RJT04sIENPTExFQ1RJT05fVklFV0VSX1VSTCwgQ09MTEVDVElPTl9FRElUT1JfVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNMb2dnZWRJbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIFVzZXJTZXJ2aWNlLmdldFVzZXJJbmZvQXN5bmMoKS50aGVuKGZ1bmN0aW9uICh1c2VySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNMb2dnZWRJbiA9IHVzZXJJbmZvLmlzTG9nZ2VkSW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuREVGQVVMVF9FTVBUWV9USVRMRSA9ICdVbnRpdGxlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuQUNUSVZJVFlfVFlQRV9DT0xMRUNUSU9OID0gQUNUSVZJVFlfVFlQRV9DT0xMRUNUSU9OO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldExhc3RVcGRhdGVkRGF0ZXRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVRpbWVGb3JtYXRTZXJ2aWNlLmdldExvY2FsZUFiYnJldmlhdGVkRGF0ZXRpbWVTdHJpbmcoY3RybC5nZXRMYXN0VXBkYXRlZE1zZWMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q29sbGVjdGlvbkxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VXJsID0gKGN0cmwuaXNMaW5rZWRUb0VkaXRvclBhZ2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTExFQ1RJT05fRURJVE9SX1VSTCA6IENPTExFQ1RJT05fVklFV0VSX1VSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuaW50ZXJwb2xhdGVVcmwodGFyZ2V0VXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbl9pZDogY3RybC5nZXRDb2xsZWN0aW9uSWQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q29tcGxldGVUaHVtYm5haWxJY29uVXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldFN0YXRpY0ltYWdlVXJsKGN0cmwuZ2V0VGh1bWJuYWlsSWNvblVybCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRTdGF0aWNJbWFnZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRTdGF0aWNJbWFnZVVybCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNldEhvdmVyU3RhdGUgPSBmdW5jdGlvbiAoaG92ZXJTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jb2xsZWN0aW9uSXNDdXJyZW50bHlIb3ZlcmVkT3ZlciA9IGhvdmVyU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgZnJvbnRlbmQgaW5zdGFuY2VzIG9mIFByZWRpY3Rpb25cbiAqICAgICByZXN1bHQgZG9tYWluIG9iamVjdHMuXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBQcmVkaWN0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZWRpY3Rpb25SZXN1bHQobGFiZWwsIGNvbmZpZGVuY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWN0aW9uTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5wcmVkaWN0aW9uQ29uZmlkZW5jZSA9IGNvbmZpZGVuY2U7XG4gICAgfVxuICAgIFByZWRpY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVkaWN0aW9uTGFiZWw7XG4gICAgfTtcbiAgICBQcmVkaWN0aW9uUmVzdWx0LnByb3RvdHlwZS5nZXRDb25maWRlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVkaWN0aW9uQ29uZmlkZW5jZTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVkaWN0aW9uUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuUHJlZGljdGlvblJlc3VsdCA9IFByZWRpY3Rpb25SZXN1bHQ7XG52YXIgUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnkoKSB7XG4gICAgfVxuICAgIFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVOZXcgPSBmdW5jdGlvbiAobGFiZWwsIGNvbmZpZGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0aW9uUmVzdWx0KGxhYmVsLCBjb25maWRlbmNlKTtcbiAgICB9O1xuICAgIFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5KTtcbiAgICByZXR1cm4gUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5QcmVkaWN0aW9uUmVzdWx0T2JqZWN0RmFjdG9yeSA9IFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5O1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnknLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNiBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcnZpY2UgdG8gcmV0cmlldmUgcmVhZCBvbmx5IGluZm9ybWF0aW9uXG4gKiBhYm91dCBjb2xsZWN0aW9ucyBmcm9tIHRoZSBiYWNrZW5kLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG4vLyBUT0RPKGJoZW5uaW5nKTogRm9yIHByZXZpZXcgbW9kZSwgdGhpcyBzZXJ2aWNlIHNob3VsZCBiZSByZXBsYWNlZCBieSBhXG4vLyBzZXBhcmF0ZSBDb2xsZWN0aW9uRGF0YVNlcnZpY2UgaW1wbGVtZW50YXRpb24gd2hpY2ggcmV0dXJucyBhIGxvY2FsIGNvcHkgb2Zcbi8vIHRoZSBjb2xsZWN0aW9uIGluc3RlYWQuIFRoaXMgZmlsZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIG9uIHRoZSBwYWdlIGluIHRoYXRcbi8vIHNjZW5hcmlvLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnUmVhZE9ubHlDb2xsZWN0aW9uQmFja2VuZEFwaVNlcnZpY2UnLCBbXG4gICAgJyRodHRwJywgJyRxJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICAnQ09MTEVDVElPTl9EQVRBX1VSTF9URU1QTEFURScsXG4gICAgZnVuY3Rpb24gKCRodHRwLCAkcSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UsIENPTExFQ1RJT05fREFUQV9VUkxfVEVNUExBVEUpIHtcbiAgICAgICAgLy8gTWFwcyBwcmV2aW91c2x5IGxvYWRlZCBjb2xsZWN0aW9ucyB0byB0aGVpciBJRHMuXG4gICAgICAgIHZhciBfY29sbGVjdGlvbkNhY2hlID0gW107XG4gICAgICAgIHZhciBfY29sbGVjdGlvbkRldGFpbHNDYWNoZSA9IFtdO1xuICAgICAgICB2YXIgX2ZldGNoQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uSWQsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25EYXRhVXJsID0gVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuaW50ZXJwb2xhdGVVcmwoQ09MTEVDVElPTl9EQVRBX1VSTF9URU1QTEFURSwge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25faWQ6IGNvbGxlY3Rpb25JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaHR0cC5nZXQoY29sbGVjdGlvbkRhdGFVcmwpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBhbmd1bGFyLmNvcHkocmVzcG9uc2UuZGF0YS5jb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBfY2FjaGVDb2xsZWN0aW9uRGV0YWlscyhyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3JSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3JSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jYWNoZUNvbGxlY3Rpb25EZXRhaWxzID0gZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgIF9jb2xsZWN0aW9uRGV0YWlsc0NhY2hlW2RldGFpbHMuY29sbGVjdGlvbi5pZF0gPSB7XG4gICAgICAgICAgICAgICAgY2FuRWRpdDogZGV0YWlscy5jYW5fZWRpdCxcbiAgICAgICAgICAgICAgICB0aXRsZTogZGV0YWlscy5jb2xsZWN0aW9uLnRpdGxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9pc0NhY2hlZCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29sbGVjdGlvbkNhY2hlLmhhc093blByb3BlcnR5KGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyBhIGNvbGxlY3Rpb24gZnJvbSB0aGUgYmFja2VuZCBnaXZlbiBhIGNvbGxlY3Rpb24gSUQuIFRoaXNcbiAgICAgICAgICAgICAqIHJldHVybnMgYSBwcm9taXNlIG9iamVjdCB0aGF0IGFsbG93cyBhIHN1Y2Nlc3MgYW5kIHJlamVjdGlvbiBjYWxsYmFja3NcbiAgICAgICAgICAgICAqIHRvIGJlIHJlZ2lzdGVyZWQuIElmIHRoZSBjb2xsZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQgYW5kIGFcbiAgICAgICAgICAgICAqIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gdGhlIHByb21pc2Ugb2JqZWN0LCB0aGVcbiAgICAgICAgICAgICAqIHN1Y2Nlc3MgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIGNvbGxlY3Rpb24gcGFzc2VkIGluIGFzIGFcbiAgICAgICAgICAgICAqIHBhcmFtZXRlci4gSWYgc29tZXRoaW5nIGdvZXMgd3Jvbmcgd2hpbGUgdHJ5aW5nIHRvIGZldGNoIHRoZVxuICAgICAgICAgICAgICogY29sbGVjdGlvbiwgdGhlIHJlamVjdGlvbiBjYWxsYmFjayBpcyBjYWxsZWQgaW5zdGVhZCwgaWYgcHJlc2VudC4gVGhlXG4gICAgICAgICAgICAgKiByZWplY3Rpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIGFuZCB0aGVcbiAgICAgICAgICAgICAqIGNvbGxlY3Rpb24gSUQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZldGNoQ29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbGxlY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkcShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9mZXRjaENvbGxlY3Rpb24oY29sbGVjdGlvbklkLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmVoYXZlcyBpbiB0aGUgZXhhY3Qgc2FtZSB3YXkgYXMgZmV0Y2hDb2xsZWN0aW9uIChpbmNsdWRpbmcgY2FsbGJhY2tcbiAgICAgICAgICAgICAqIGJlaGF2aW9yIGFuZCByZXR1cm5pbmcgYSBwcm9taXNlIG9iamVjdCksIGV4Y2VwdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAgICAgICAgICAgICAqIGF0dGVtcHQgdG8gc2VlIHdoZXRoZXIgdGhlIGdpdmVuIGNvbGxlY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuIElmXG4gICAgICAgICAgICAgKiBpdCBoYXMgbm90IHlldCBiZWVuIGxvYWRlZCwgaXQgd2lsbCBmZXRjaCB0aGUgY29sbGVjdGlvbiBmcm9tIHRoZVxuICAgICAgICAgICAgICogYmFja2VuZC4gSWYgaXQgc3VjY2Vzc2Z1bGx5IHJldHJpZXZlcyB0aGUgY29sbGVjdGlvbiBmcm9tIHRoZSBiYWNrZW5kLFxuICAgICAgICAgICAgICogaXQgd2lsbCBzdG9yZSBpdCBpbiB0aGUgY2FjaGUgdG8gYXZvaWQgcmVxdWVzdHMgZnJvbSB0aGUgYmFja2VuZCBpblxuICAgICAgICAgICAgICogZnVydGhlciBmdW5jdGlvbiBjYWxscy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9hZENvbGxlY3Rpb246IGZ1bmN0aW9uIChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQ2FjaGVkKGNvbGxlY3Rpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhbmd1bGFyLmNvcHkoX2NvbGxlY3Rpb25DYWNoZVtjb2xsZWN0aW9uSWRdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZmV0Y2hDb2xsZWN0aW9uKGNvbGxlY3Rpb25JZCwgZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBmZXRjaGVkIGNvbGxlY3Rpb24gdG8gYXZvaWQgZnV0dXJlIGZldGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbGxlY3Rpb25DYWNoZVtjb2xsZWN0aW9uSWRdID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFuZ3VsYXIuY29weShjb2xsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbGxlY3Rpb25EZXRhaWxzOiBmdW5jdGlvbiAoY29sbGVjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jb2xsZWN0aW9uRGV0YWlsc0NhY2hlW2NvbGxlY3Rpb25JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb2xsZWN0aW9uRGV0YWlsc0NhY2hlW2NvbGxlY3Rpb25JZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignY29sbGVjdGlvbiBoYXMgbm90IGJlZW4gZmV0Y2hlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29sbGVjdGlvbiBpcyBzdG9yZWQgd2l0aGluIHRoZSBsb2NhbCBkYXRhXG4gICAgICAgICAgICAgKiBjYWNoZSBvciBpZiBpdCBuZWVkcyB0byBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgYmFja2VuZCB1cG9uIGEgbGFvZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNDYWNoZWQ6IGZ1bmN0aW9uIChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzQ2FjaGVkKGNvbGxlY3Rpb25JZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGluIHRoZSBjYWNoZSBnaXZlbiBieSB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAgICAgKiBjb2xsZWN0aW9uIElEIHdpdGggYSBuZXcgY29sbGVjdGlvbiBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhY2hlQ29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbGxlY3Rpb25JZCwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIF9jb2xsZWN0aW9uQ2FjaGVbY29sbGVjdGlvbklkXSA9IGFuZ3VsYXIuY29weShjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsZWFycyB0aGUgbG9jYWwgY29sbGVjdGlvbiBkYXRhIGNhY2hlLCBmb3JjaW5nIGFsbCBmdXR1cmUgbG9hZHMgdG9cbiAgICAgICAgICAgICAqIHJlLXJlcXVlc3QgdGhlIHByZXZpb3VzbHkgbG9hZGVkIGNvbGxlY3Rpb25zIGZyb20gdGhlIGJhY2tlbmQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNsZWFyQ29sbGVjdGlvbkNhY2hlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX2NvbGxlY3Rpb25DYWNoZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTUgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VydmljZSB0byByZXRyaWV2ZSBpbmZvcm1hdGlvbiBvZiBjcmVhdG9yIGRhc2hib2FyZCBmcm9tIHRoZVxuICogYmFja2VuZC5cbiAqL1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGh0dHBfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb24vaHR0cFwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3JlYXRvckRhc2hib2FyZEJhY2tlbmRBcGlTZXJ2aWNlKGh0dHApIHtcbiAgICAgICAgdGhpcy5odHRwID0gaHR0cDtcbiAgICB9XG4gICAgQ3JlYXRvckRhc2hib2FyZEJhY2tlbmRBcGlTZXJ2aWNlLnByb3RvdHlwZS5fZmV0Y2hEYXNoYm9hcmREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBIdHRwQ2xpZW50IHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgdGhlIHRvUHJvbWlzZSBjb252ZXJ0cyBpdCBpbnRvIGFcbiAgICAgICAgLy8gUHJvbWlzZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoJy9jcmVhdG9yZGFzaGJvYXJkaGFuZGxlci9kYXRhJykudG9Qcm9taXNlKCk7XG4gICAgfTtcbiAgICBDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2UucHJvdG90eXBlLmZldGNoRGFzaGJvYXJkRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoRGFzaGJvYXJkRGF0YSgpO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIENyZWF0b3JEYXNoYm9hcmRCYWNrZW5kQXBpU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBodHRwXzEuSHR0cENsaWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBodHRwXzEuSHR0cENsaWVudCkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2UpO1xuICAgIHJldHVybiBDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5DcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2UgPSBDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdDcmVhdG9yRGFzaGJvYXJkQmFja2VuZEFwaVNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKENyZWF0b3JEYXNoYm9hcmRCYWNrZW5kQXBpU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTcgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGYWN0b3J5IGZvciBjcmVhdGluZyBpbnN0YW5jZXMgb2YgRnJhY3Rpb25cbiAqIGRvbWFpbiBvYmplY3RzLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiZG9tYWluL29iamVjdHMvb2JqZWN0cy1kb21haW4uY29uc3RhbnRzXCIpO1xudmFyIEZyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyYWN0aW9uKGlzTmVnYXRpdmUsIHdob2xlTnVtYmVyLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGlzTmVnYXRpdmU7XG4gICAgICAgIHRoaXMud2hvbGVOdW1iZXIgPSB3aG9sZU51bWJlcjtcbiAgICAgICAgdGhpcy5udW1lcmF0b3IgPSBudW1lcmF0b3I7XG4gICAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBkZW5vbWluYXRvcjtcbiAgICB9XG4gICAgRnJhY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhY3Rpb25TdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMubnVtZXJhdG9yICE9PSAwKSB7XG4gICAgICAgICAgICBmcmFjdGlvblN0cmluZyArPSB0aGlzLm51bWVyYXRvciArICcvJyArIHRoaXMuZGVub21pbmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2hvbGVOdW1iZXIgIT09IDApIHtcbiAgICAgICAgICAgIGZyYWN0aW9uU3RyaW5nID0gdGhpcy53aG9sZU51bWJlciArICcgJyArIGZyYWN0aW9uU3RyaW5nO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZyYWN0aW9uYWwgcGFydCB3YXMgZW1wdHkgdGhlbiB0aGVyZSB3aWxsIGJlIGEgdHJhaWxpbmdcbiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICBmcmFjdGlvblN0cmluZyA9IGZyYWN0aW9uU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlICYmIGZyYWN0aW9uU3RyaW5nICE9PSAnJykge1xuICAgICAgICAgICAgZnJhY3Rpb25TdHJpbmcgPSAnLScgKyBmcmFjdGlvblN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhY3Rpb25TdHJpbmcgPT09ICcnID8gJzAnIDogZnJhY3Rpb25TdHJpbmc7XG4gICAgfTtcbiAgICBGcmFjdGlvbi5wcm90b3R5cGUudG9EaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNOZWdhdGl2ZTogdGhpcy5pc05lZ2F0aXZlLFxuICAgICAgICAgICAgd2hvbGVOdW1iZXI6IHRoaXMud2hvbGVOdW1iZXIsXG4gICAgICAgICAgICBudW1lcmF0b3I6IHRoaXMubnVtZXJhdG9yLFxuICAgICAgICAgICAgZGVub21pbmF0b3I6IHRoaXMuZGVub21pbmF0b3JcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEZyYWN0aW9uLnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG90YWxQYXJ0cyA9ICh0aGlzLndob2xlTnVtYmVyICogdGhpcy5kZW5vbWluYXRvcikgKyB0aGlzLm51bWVyYXRvcjtcbiAgICAgICAgdmFyIGZsb2F0VmFsID0gKHRvdGFsUGFydHMgLyB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSA/IC1mbG9hdFZhbCA6IGZsb2F0VmFsO1xuICAgIH07XG4gICAgRnJhY3Rpb24ucHJvdG90eXBlLmdldEludGVnZXJQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc05lZ2F0aXZlID8gLXRoaXMud2hvbGVOdW1iZXIgOiB0aGlzLndob2xlTnVtYmVyO1xuICAgIH07XG4gICAgRnJhY3Rpb24ucHJvdG90eXBlLmNvbnZlcnRUb1NpbXBsZXN0Rm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdjZCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geSA9PT0gMCA/IHggOiBnY2QoeSwgeCAlIHkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZyA9IGdjZCh0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgICAgIHZhciBudW1lcmF0b3IgPSB0aGlzLm51bWVyYXRvciAvIGc7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMuZGVub21pbmF0b3IgLyBnO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKHRoaXMuaXNOZWdhdGl2ZSwgdGhpcy53aG9sZU51bWJlciwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgfTtcbiAgICBGcmFjdGlvbi5wcm90b3R5cGUuaGFzTm9uemVyb0ludGVnZXJQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aG9sZU51bWJlciAhPT0gMDtcbiAgICB9O1xuICAgIEZyYWN0aW9uLnByb3RvdHlwZS5pc0ltcHJvcGVyRnJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbm9taW5hdG9yIDw9IHRoaXMubnVtZXJhdG9yO1xuICAgIH07XG4gICAgcmV0dXJuIEZyYWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuRnJhY3Rpb24gPSBGcmFjdGlvbjtcbnZhciBGcmFjdGlvbk9iamVjdEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJhY3Rpb25PYmplY3RGYWN0b3J5KCkge1xuICAgIH1cbiAgICBGcmFjdGlvbk9iamVjdEZhY3RvcnkucHJvdG90eXBlLmZyb21SYXdJbnB1dFN0cmluZyA9IGZ1bmN0aW9uIChyYXdJbnB1dCkge1xuICAgICAgICB2YXIgSU5WQUxJRF9DSEFSU19SRUdFWCA9IC9bXlxcZFxcc1xcLy1dL2c7XG4gICAgICAgIGlmIChJTlZBTElEX0NIQVJTX1JFR0VYLnRlc3QocmF3SW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5GUkFDVElPTl9QQVJTSU5HX0VSUk9SUy5JTlZBTElEX0NIQVJTKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgRlJBQ1RJT05fUkVHRVggPSAvXlxccyotP1xccyooKFxcZCpcXHMqXFxkK1xccypcXC9cXHMqXFxkKyl8XFxkKylcXHMqJC87XG4gICAgICAgIGlmICghRlJBQ1RJT05fUkVHRVgudGVzdChyYXdJbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkZSQUNUSU9OX1BBUlNJTkdfRVJST1JTLklOVkFMSURfRk9STUFUKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgd2hvbGVOdW1iZXIgPSAwO1xuICAgICAgICB2YXIgbnVtZXJhdG9yID0gMDtcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgcmF3SW5wdXQgPSByYXdJbnB1dC50cmltKCk7XG4gICAgICAgIGlmIChyYXdJbnB1dC5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgaXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5lZ2F0aXZlIGNoYXIgZnJvbSB0aGUgc3RyaW5nLlxuICAgICAgICAgICAgcmF3SW5wdXQgPSByYXdJbnB1dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsdGVyIHJlc3VsdCBmcm9tIHNwbGl0IHRvIHJlbW92ZSBlbXB0eSBzdHJpbmdzLlxuICAgICAgICB2YXIgbnVtYmVycyA9IHJhd0lucHV0LnNwbGl0KC9cXC98XFxzL2cpLmZpbHRlcihmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbXB0eSBzdHJpbmcgd2lsbCBldmFsdWF0ZSB0byBmYWxzZS5cbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChudW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgd2hvbGVOdW1iZXIgPSBwYXJzZUludChudW1iZXJzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1iZXJzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbnVtZXJhdG9yID0gcGFyc2VJbnQobnVtYmVyc1swXSk7XG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHBhcnNlSW50KG51bWJlcnNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbnVtYmVycy5sZW5ndGggPT0gM1xuICAgICAgICAgICAgd2hvbGVOdW1iZXIgPSBwYXJzZUludChudW1iZXJzWzBdKTtcbiAgICAgICAgICAgIG51bWVyYXRvciA9IHBhcnNlSW50KG51bWJlcnNbMV0pO1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUludChudW1iZXJzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkZSQUNUSU9OX1BBUlNJTkdfRVJST1JTLkRJVklTSU9OX0JZX1pFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oaXNOZWdhdGl2ZSwgd2hvbGVOdW1iZXIsIG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgIH07XG4gICAgRnJhY3Rpb25PYmplY3RGYWN0b3J5LnByb3RvdHlwZS5mcm9tRGljdCA9IGZ1bmN0aW9uIChmcmFjdGlvbkRpY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihmcmFjdGlvbkRpY3QuaXNOZWdhdGl2ZSwgZnJhY3Rpb25EaWN0Lndob2xlTnVtYmVyLCBmcmFjdGlvbkRpY3QubnVtZXJhdG9yLCBmcmFjdGlvbkRpY3QuZGVub21pbmF0b3IpO1xuICAgIH07XG4gICAgRnJhY3Rpb25PYmplY3RGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIEZyYWN0aW9uT2JqZWN0RmFjdG9yeSk7XG4gICAgcmV0dXJuIEZyYWN0aW9uT2JqZWN0RmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLkZyYWN0aW9uT2JqZWN0RmFjdG9yeSA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ0ZyYWN0aW9uT2JqZWN0RmFjdG9yeScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoRnJhY3Rpb25PYmplY3RGYWN0b3J5KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgZm9yIGNyZWF0aW5nIGluc3RhbmNlcyBvZiBOdW1iZXJXaXRoVW5pdHNcbiAqIGRvbWFpbiBvYmplY3RzLlxuICovXG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9GcmFjdGlvbk9iamVjdEZhY3RvcnkudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi9vYmplY3RzL1VuaXRzT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnZG9tYWluL29iamVjdHMvb2JqZWN0cy1kb21haW4uY29uc3RhbnRzLmFqcy50cycpO1xuLyogR3VpZGVsaW5lcyBmb3IgYWRkaW5nIG5ldyBjdXN0b20gY3VycmVuY3kgdW5pdHMgaW4gTnVtYmVyIHdpdGggVW5pdHNcbiAgaW50ZXJhY3Rpb246XG5cbiAgU2ltcGx5IGFkZCBjdXJyZW5jeSB1bml0IHRvIHRoZSBkaWN0IG9mIENVUlJFTkNZX1VOSVRTIGNvbnN0YW50IGFuZCBpdCB3aWxsXG4gIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGFsbG93ZWQgY3VzdG9tIHVuaXRzLiBGb2xsb3dpbmcgYXJlIHRoZSBrZXlzXG4gIHRvIGJlIGRlZmluZWQgd2l0aGluIHRoZSB1bml0IGRpY3Q6XG4gICAgbmFtZTogIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gY3VycmVuY3kgdW5pdC5cbiAgICBhbGlhc2VzOiBPdGhlciBhbGxvd2VkIGNhbm9uaWNhbCBmb3JtcyBvZiB0aGUgY3VycmVuY3kgdW5pdC5cbiAgICBmcm9udF91bml0czogQSBsaXN0IG9mIGFsbCB0aGUgY3VycmVuY3kgc3ltYm9scyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgZnJvbnRcbiAgICAgIChsaWtlLSAkLCBScywg4oK5KS4gS2VlcCBpdCBhbiBlbXB0eSBsaXN0IGlmIG5vIHN5bWJvbCBpcyBuZWVkZWQuXG4gICAgYmFzZV91bml0OiBEZWZpbmUgdGhlIHVuaXQgaW4gdGVybXMgb2YgYmFzZSB1bml0IG9ubHkgaWYgdGhlIGRlZmluZWQgY3VzdG9tXG4gICAgICB1bml0IGlzIGEgc3ViIHVuaXQgZWxzZSBhc3NpZ24gaXQgJ251bGwnIHZhbHVlLiovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5JywgW1xuICAgICdGcmFjdGlvbk9iamVjdEZhY3RvcnknLCAnVW5pdHNPYmplY3RGYWN0b3J5JywgJ0NVUlJFTkNZX1VOSVRTJyxcbiAgICAnTlVNQkVSX1dJVEhfVU5JVFNfUEFSU0lOR19FUlJPUlMnLCBmdW5jdGlvbiAoRnJhY3Rpb25PYmplY3RGYWN0b3J5LCBVbml0c09iamVjdEZhY3RvcnksIENVUlJFTkNZX1VOSVRTLCBOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUykge1xuICAgICAgICB2YXIgTnVtYmVyV2l0aFVuaXRzID0gZnVuY3Rpb24gKHR5cGUsIHJlYWwsIGZyYWN0aW9uT2JqLCB1bml0c09iaikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMucmVhbCA9IHJlYWw7XG4gICAgICAgICAgICB0aGlzLmZyYWN0aW9uID0gZnJhY3Rpb25PYmo7XG4gICAgICAgICAgICB0aGlzLnVuaXRzID0gdW5pdHNPYmoudW5pdHM7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlcldpdGhVbml0cy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyV2l0aFVuaXRzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICB2YXIgdW5pdHNTdHJpbmcgPSBVbml0c09iamVjdEZhY3RvcnkuZnJvbUxpc3QodGhpcy51bml0cykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh1bml0c1N0cmluZy5pbmNsdWRlcygnJCcpKSB7XG4gICAgICAgICAgICAgICAgdW5pdHNTdHJpbmcgPSB1bml0c1N0cmluZy5yZXBsYWNlKCckJywgJycpO1xuICAgICAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyArPSAnJCcgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdHNTdHJpbmcuaW5jbHVkZXMoJ1JzJykpIHtcbiAgICAgICAgICAgICAgICB1bml0c1N0cmluZyA9IHVuaXRzU3RyaW5nLnJlcGxhY2UoJ1JzJywgJycpO1xuICAgICAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyArPSAnUnMnICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXRzU3RyaW5nLmluY2x1ZGVzKCfigrknKSkge1xuICAgICAgICAgICAgICAgIHVuaXRzU3RyaW5nID0gdW5pdHNTdHJpbmcucmVwbGFjZSgn4oK5JywgJycpO1xuICAgICAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyArPSAn4oK5JyArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyArPSB0aGlzLnJlYWwgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJXaXRoVW5pdHNTdHJpbmcgKz0gdGhpcy5mcmFjdGlvbi50b1N0cmluZygpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyV2l0aFVuaXRzU3RyaW5nICs9IHVuaXRzU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyA9IG51bWJlcldpdGhVbml0c1N0cmluZy50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyV2l0aFVuaXRzU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXaXRoVW5pdHMucHJvdG90eXBlLnRvTWF0aGpzQ29tcGF0aWJsZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJXaXRoVW5pdHNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHZhciB1bml0c1N0cmluZyA9IFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tTGlzdCh0aGlzLnVuaXRzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdW5pdHNTdHJpbmcgPSBVbml0c09iamVjdEZhY3RvcnkudG9NYXRoanNDb21wYXRpYmxlU3RyaW5nKHVuaXRzU3RyaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyArPSB0aGlzLnJlYWwgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJXaXRoVW5pdHNTdHJpbmcgKz0gdGhpcy5mcmFjdGlvbi50b1N0cmluZygpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyV2l0aFVuaXRzU3RyaW5nICs9IHVuaXRzU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIG51bWJlcldpdGhVbml0c1N0cmluZyA9IG51bWJlcldpdGhVbml0c1N0cmluZy50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyV2l0aFVuaXRzU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXaXRoVW5pdHMucHJvdG90eXBlLnRvRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIHJlYWw6IHRoaXMucmVhbCxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbjogdGhpcy5mcmFjdGlvbi50b0RpY3QoKSxcbiAgICAgICAgICAgICAgICB1bml0czogdGhpcy51bml0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhhbmtpdGEyNDA3OTYpOiBSZW1vdmUgdGhlIGJyYWNrZXQgbm90YXRpb24gb25jZSBBbmd1bGFyMiBnZXRzIGluLlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbiAgICAgICAgTnVtYmVyV2l0aFVuaXRzWydjcmVhdGVDdXJyZW5jeVVuaXRzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGRvdC1ub3RhdGlvbiAqL1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBVbml0c09iamVjdEZhY3RvcnkuY3JlYXRlQ3VycmVuY3lVbml0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHBhcnNpbmdFcnJvcikgeyB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oYW5raXRhMjQwNzk2KTogUmVtb3ZlIHRoZSBicmFja2V0IG5vdGF0aW9uIG9uY2UgQW5ndWxhcjIgZ2V0cyBpbi5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZG90LW5vdGF0aW9uICovXG4gICAgICAgIE51bWJlcldpdGhVbml0c1snZnJvbVJhd0lucHV0U3RyaW5nJ10gPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uICovXG4gICAgICAgICAgICByYXdJbnB1dCA9IHJhd0lucHV0LnRyaW0oKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICAgICAgICB2YXIgcmVhbCA9IDAuMDtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgZnJhY3Rpb24gdmFsdWUuXG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25PYmogPSBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbVJhd0lucHV0U3RyaW5nKCcwLzEnKTtcbiAgICAgICAgICAgIHZhciB1bml0cyA9ICcnO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgICAgICB2YXIgdW5pdE9iaiA9IFtdO1xuICAgICAgICAgICAgLy8gQWxsb3cgdmFsaWRhdGlvbiBvbmx5IHdoZW4gcmF3SW5wdXQgaXMgbm90IG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgaWYgKHJhd0lucHV0ICE9PSAnJyAmJiByYXdJbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggZGlnaXQgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW5jeSB1bml0LlxuICAgICAgICAgICAgICAgIGlmIChyYXdJbnB1dC5tYXRjaCgvXlxcZC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmQgPSByYXdJbnB1dC5pbmRleE9mKHJhd0lucHV0Lm1hdGNoKC9bYS16KOKCuSRdL2kpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHZhbHVlIHdpdGggbm8gdW5pdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJhd0lucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmF3SW5wdXQuc3Vic3RyKDAsIGluZCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHMgPSByYXdJbnB1dC5zdWJzdHIoaW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhDVVJSRU5DWV9VTklUUyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDVVJSRU5DWV9VTklUU1trZXlzW2ldXS5mcm9udF91bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0cy5pbmRleE9mKENVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmZyb250X3VuaXRzW2pdKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE5VTUJFUl9XSVRIX1VOSVRTX1BBUlNJTkdfRVJST1JTLklOVkFMSURfQ1VSUkVOQ1lfRk9STUFUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydHNXaXRoQ29ycmVjdEN1cnJlbmN5VW5pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKENVUlJFTkNZX1VOSVRTKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmZyb250X3VuaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0lucHV0LnN0YXJ0c1dpdGgoQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0uZnJvbnRfdW5pdHNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0c1dpdGhDb3JyZWN0Q3VycmVuY3lVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoQ29ycmVjdEN1cnJlbmN5VW5pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUy5JTlZBTElEX0NVUlJFTkNZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kID0gcmF3SW5wdXQuaW5kZXhPZihyYXdJbnB1dC5tYXRjaCgvWzAtOV0vKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTlVNQkVSX1dJVEhfVU5JVFNfUEFSU0lOR19FUlJPUlMuSU5WQUxJRF9DVVJSRU5DWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPSByYXdJbnB1dC5zdWJzdHIoMCwgaW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0c1dpdGhDb3JyZWN0Q3VycmVuY3lVbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDVVJSRU5DWV9VTklUU1trZXlzW2ldXS5mcm9udF91bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0cyA9PT0gQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0uZnJvbnRfdW5pdHNbal0udHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0c1dpdGhDb3JyZWN0Q3VycmVuY3lVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoQ29ycmVjdEN1cnJlbmN5VW5pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUy5JTlZBTElEX0NVUlJFTkNZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9IHVuaXRzICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kMiA9IHJhd0lucHV0LmluZGV4T2YocmF3SW5wdXQuc3Vic3RyKGluZCkubWF0Y2goL1thLXooXS9pKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmQyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByYXdJbnB1dC5zdWJzdHIoaW5kLCBpbmQyIC0gaW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0cyArPSByYXdJbnB1dC5zdWJzdHIoaW5kMikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByYXdJbnB1dC5zdWJzdHIoaW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0cyA9IHVuaXRzLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVja2luZyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9bYS16XS9pKSB8fCB2YWx1ZS5tYXRjaCgvWypeJOKCuSgpI0BdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE5VTUJFUl9XSVRIX1VOSVRTX1BBUlNJTkdfRVJST1JTLklOVkFMSURfVkFMVUUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2ZyYWN0aW9uJztcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25PYmogPSBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbVJhd0lucHV0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAncmVhbCc7XG4gICAgICAgICAgICAgICAgICAgIHJlYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVja2luZyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gdW5pdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bml0cy5tYXRjaCgvW14wLTlhLXovKiBeKCnigrkkLV0vaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUy5JTlZBTElEX1VOSVRfQ0hBUlMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuaXRzT2JqID0gVW5pdHNPYmplY3RGYWN0b3J5LmZyb21SYXdJbnB1dFN0cmluZyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlcldpdGhVbml0cyh0eXBlLCByZWFsLCBmcmFjdGlvbk9iaiwgdW5pdHNPYmopO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPKGFua2l0YTI0MDc5Nik6IFJlbW92ZSB0aGUgYnJhY2tldCBub3RhdGlvbiBvbmNlIEFuZ3VsYXIyIGdldHMgaW4uXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuICAgICAgICBOdW1iZXJXaXRoVW5pdHNbJ2Zyb21EaWN0J10gPSBmdW5jdGlvbiAobnVtYmVyV2l0aFVuaXRzRGljdCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBkb3Qtbm90YXRpb24gKi9cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyV2l0aFVuaXRzKG51bWJlcldpdGhVbml0c0RpY3QudHlwZSwgbnVtYmVyV2l0aFVuaXRzRGljdC5yZWFsLCBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbURpY3QobnVtYmVyV2l0aFVuaXRzRGljdC5mcmFjdGlvbiksIFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tTGlzdChudW1iZXJXaXRoVW5pdHNEaWN0LnVuaXRzKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOdW1iZXJXaXRoVW5pdHM7XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xuLy8gVE9ETygjNzQwMyk6IENvbnZlcnQgdGhpcyB0byBwYXJ0aWFsIGltcG9ydHMuXG52YXIgbWF0aGpzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1hdGhqc1wiKSk7XG52YXIgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiZG9tYWluL29iamVjdHMvb2JqZWN0cy1kb21haW4uY29uc3RhbnRzXCIpO1xudmFyIFVuaXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuaXRzKHVuaXRzTGlzdCkge1xuICAgICAgICB0aGlzLnVuaXRzID0gdW5pdHNMaXN0O1xuICAgIH1cbiAgICBVbml0cy5wcm90b3R5cGUudG9EaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5pdHM6IHRoaXMudW5pdHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFVuaXRzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVuaXQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMudW5pdHNbaV07XG4gICAgICAgICAgICBpZiAoZC5leHBvbmVudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgKz0gZC51bml0ICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pdCArPSBkLnVuaXQgKyAnXicgKyBkLmV4cG9uZW50LnRvU3RyaW5nKCkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXQudHJpbSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuaXRzO1xufSgpKTtcbmV4cG9ydHMuVW5pdHMgPSBVbml0cztcbnZhciBVbml0c09iamVjdEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5pdHNPYmplY3RGYWN0b3J5KCkge1xuICAgIH1cbiAgICBVbml0c09iamVjdEZhY3RvcnkucHJvdG90eXBlLmlzdW5pdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgIHJldHVybiAhKCcvKigpICcuaW5jbHVkZXModW5pdCkpO1xuICAgIH07XG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5zdHJpbmdUb0xleGljYWwgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgKz0gJyMnO1xuICAgICAgICB2YXIgdW5pdExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHVuaXQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCcqLygpIyAnLmluY2x1ZGVzKHVuaXRzW2ldKSAmJiB1bml0ICE9PSAncGVyJykge1xuICAgICAgICAgICAgICAgIGlmICh1bml0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1bml0TGlzdC5sZW5ndGggPiAwKSAmJiB0aGlzLmlzdW5pdCh1bml0TGlzdC5zbGljZSgtMSkucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0TGlzdC5wdXNoKCcqJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5pdExpc3QucHVzaCh1bml0KTtcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISgnIyAnLmluY2x1ZGVzKHVuaXRzW2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdExpc3QucHVzaCh1bml0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdHNbaV0gPT09ICcgJyAmJiB1bml0ID09PSAncGVyJykge1xuICAgICAgICAgICAgICAgIHVuaXRMaXN0LnB1c2goJy8nKTtcbiAgICAgICAgICAgICAgICB1bml0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bml0ICs9IHVuaXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml0TGlzdDtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgdGhlIHJldHVybiB0eXBlIGlzIGEgbGlzdCB3aXRoIHZhcnlpbmcgZWxlbWVudCB0eXBlcy4gQW5cbiAgICAvLyBleGFjdCB0eXBlIG5lZWRzIHRvIGJlIGZvdW5kIGZvciBpdC5cbiAgICBVbml0c09iamVjdEZhY3RvcnkucHJvdG90eXBlLnVuaXRXaXRoTXVsdGlwbGllciA9IGZ1bmN0aW9uICh1bml0TGlzdCkge1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IDE7XG4gICAgICAgIHZhciB1bml0c1dpdGhNdWx0aXBsaWVyID0gW107XG4gICAgICAgIHZhciBwYXJlbnRoZXNpc1N0YWNrID0gW107XG4gICAgICAgIGZvciAodmFyIGluZCA9IDA7IGluZCA8IHVuaXRMaXN0Lmxlbmd0aDsgaW5kKyspIHtcbiAgICAgICAgICAgIGlmICh1bml0TGlzdFtpbmRdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gLW11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bml0TGlzdFtpbmRdID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdExpc3RbaW5kIC0gMV0gPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBlbGVtZW50IHdhcyBkaXZpc2lvbiB0aGVuIHdlIG5lZWQgdG8gaW52ZXJzZVxuICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsaWVyIHdoZW4gd2UgZmluZCBpdHMgY29ycmVzcG9uc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmQgZWxlbWVudCBvZiBwdXNoZWQgZWxlbWVudCBpcyB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2lzU3RhY2sucHVzaChbJygnLCAtMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgZWxlbWVudCB3YXMgbm90IGRpdmlzaW9uIHRoZW4gd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnZlcnQgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2lzU3RhY2sucHVzaChbJygnLCAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5pdExpc3RbaW5kXSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBwYXJlbnRoZXNpc1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSBwYXJzZUludChlbGVtWzFdKSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzdW5pdCh1bml0TGlzdFtpbmRdKSkge1xuICAgICAgICAgICAgICAgIHVuaXRzV2l0aE11bHRpcGxpZXIucHVzaChbdW5pdExpc3RbaW5kXSwgbXVsdGlwbGllcl0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIGVsZW1lbnQgd2FzIGRpdmlzaW9uIHRoZW4gd2UgbmVlZCB0byBpbnZlcnRcbiAgICAgICAgICAgICAgICAvLyBtdWx0aXBsaWVyLlxuICAgICAgICAgICAgICAgIGlmICh1bml0TGlzdFtpbmQgLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAtbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRzV2l0aE11bHRpcGxpZXI7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTY1KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICd1bml0RGljdCcgaXMgYSBkaWN0IHdpdGggdmFyeWluZyBlbGVtZW50IHR5cGVzLiBBblxuICAgIC8vIGV4YWN0IHR5cGUgbmVlZHMgdG8gYmUgZm91bmQgZm9yIGl0LCBPbmNlIHRoYXQgaXMgZm91bmQgdGhlIHJldHVybiB0eXBlXG4gICAgLy8gY2FuIGFsc28gYmUgdHlwZWQuXG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5jb252ZXJ0VW5pdERpY3RUb0xpc3QgPSBmdW5jdGlvbiAodW5pdERpY3QpIHtcbiAgICAgICAgdmFyIHVuaXRMaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB1bml0RGljdCkge1xuICAgICAgICAgICAgdW5pdExpc3QucHVzaCh7IHVuaXQ6IGtleSwgZXhwb25lbnQ6IHVuaXREaWN0W2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRMaXN0O1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAndW5pdHNXaXRoTXVsdGlwbGllcicgaXMgYSBkaWN0IHdpdGggdmFyeWluZyBlbGVtZW50IHR5cGVzLlxuICAgIC8vIEFuIGV4YWN0IHR5cGUgbmVlZHMgdG8gYmUgZm91bmQgZm9yIGl0LCBPbmNlIHRoYXQgaXMgZm91bmQgdGhlIHJldHVybiB0eXBlXG4gICAgLy8gY2FuIGFsc28gYmUgdHlwZWQuXG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS51bml0VG9MaXN0ID0gZnVuY3Rpb24gKHVuaXRzV2l0aE11bHRpcGxpZXIpIHtcbiAgICAgICAgdmFyIHVuaXREaWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pdHNXaXRoTXVsdGlwbGllci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSB1bml0c1dpdGhNdWx0aXBsaWVyW2ldWzBdO1xuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSB1bml0c1dpdGhNdWx0aXBsaWVyW2ldWzFdO1xuICAgICAgICAgICAgdmFyIGluZCA9IHVuaXQuaW5kZXhPZignXicpO1xuICAgICAgICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHBvd2VyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIHMgPSB1bml0LnN1YnN0cigwLCBpbmQpO1xuICAgICAgICAgICAgICAgIHBvd2VyID0gcGFyc2VJbnQodW5pdC5zdWJzdHIoaW5kICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHVuaXQ7XG4gICAgICAgICAgICAgICAgcG93ZXIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEocyBpbiB1bml0RGljdCkpIHtcbiAgICAgICAgICAgICAgICB1bml0RGljdFtzXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bml0RGljdFtzXSArPSBtdWx0aXBsaWVyICogcG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFVuaXREaWN0VG9MaXN0KHVuaXREaWN0KTtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ3VuaXRzJyBpcyBhIGxpc3Qgd2l0aCB2YXJ5aW5nIGVsZW1lbnQgdHlwZXMuIEFuIGV4YWN0XG4gICAgLy8gdHlwZSBuZWVkcyB0byBiZSBmb3VuZCBmb3IgaXQuXG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5mcm9tTGlzdCA9IGZ1bmN0aW9uICh1bml0c0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbml0cyh1bml0c0xpc3QpO1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSB0aGUgcmV0dXJuIHR5cGUgaXMgdG8gYmUgZGV0ZXJtaW5lZCBvbmNlICd1bml0VG9MaXN0JyBoYXNcbiAgICAvLyBkZXRlcm1pbmVkIHJldHVybiB0eXBlLlxuICAgIFVuaXRzT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUuZnJvbVN0cmluZ1RvTGlzdCA9IGZ1bmN0aW9uICh1bml0c1N0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy51bml0VG9MaXN0KHRoaXMudW5pdFdpdGhNdWx0aXBsaWVyKHRoaXMuc3RyaW5nVG9MZXhpY2FsKHVuaXRzU3RyaW5nKSkpO1xuICAgIH07XG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVDdXJyZW5jeVVuaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkNVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmJhc2VfdW5pdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEJhc2UgdW5pdCAobGlrZTogcnVwZWVzLCBkb2xsYXIgZXRjLikuXG4gICAgICAgICAgICAgICAgbWF0aGpzXzEuZGVmYXVsdC5jcmVhdGVVbml0KG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0ubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkNVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmFsaWFzZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN1YiB1bml0IChsaWtlOiBwYWlzZSwgY2VudHMgZXRjLikuXG4gICAgICAgICAgICAgICAgbWF0aGpzXzEuZGVmYXVsdC5jcmVhdGVVbml0KG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0ubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkNVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmJhc2VfdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUU1trZXlzW2ldXS5hbGlhc2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ3VuaXRzJyBpcyBhIGxpc3Qgd2l0aCB2YXJ5aW5nIGVsZW1lbnQgdHlwZXMuIEFuIGV4YWN0XG4gICAgLy8gdHlwZSBuZWVkcyB0byBiZSBmb3VuZCBmb3IgaXQuXG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS50b01hdGhqc0NvbXBhdGlibGVTdHJpbmcgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgLy8gTWFrZXMgdGhlIHVuaXRzIGNvbXBhdGlibGUgd2l0aCB0aGUgbWF0aC5qcyBhbGxvd2VkIGZvcm1hdC5cbiAgICAgICAgdW5pdHMgPSB1bml0cy5yZXBsYWNlKC9wZXIvZywgJy8nKTtcbiAgICAgICAgLy8gU3BlY2lhbCBzeW1ib2xzIG5lZWQgdG8gYmUgcmVwbGFjZWQgYXMgbWF0aC5qcyBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tXG4gICAgICAgIC8vIHVuaXRzIHN0YXJ0aW5nIHdpdGggc3BlY2lhbCBzeW1ib2xzLiBBbHNvLCBpdCBkb2Vzbid0IGFsbG93IHVuaXRzXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIGFzIGluIHRoZSBjYXNlIG9mIGN1cnJlbmN5IHVuaXRzLlxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUU1trZXlzW2ldXS5mcm9udF91bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh1bml0cy5pbmNsdWRlcyhvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkNVUlJFTkNZX1VOSVRTW2tleXNbaV1dLmZyb250X3VuaXRzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0cyA9IHVuaXRzLnJlcGxhY2Uob2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUU1trZXlzW2ldXS5mcm9udF91bml0c1tqXSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB1bml0cyA9IG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0ubmFtZSArIHVuaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUU1trZXlzW2ldXS5hbGlhc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzLmluY2x1ZGVzKG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0uYWxpYXNlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPSB1bml0cy5yZXBsYWNlKG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuQ1VSUkVOQ1lfVU5JVFNba2V5c1tpXV0uYWxpYXNlc1tqXSwgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUU1trZXlzW2ldXS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRzLnRyaW0oKTtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ3VuaXRzJyBpcyBhIGxpc3Qgd2l0aCB2YXJ5aW5nIGVsZW1lbnQgdHlwZXMuIEFuIGV4YWN0XG4gICAgLy8gdHlwZSBuZWVkcyB0byBiZSBmb3VuZCBmb3IgaXQuXG4gICAgVW5pdHNPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5mcm9tUmF3SW5wdXRTdHJpbmcgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ3VycmVuY3lVbml0cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzaW5nRXJyb3IpIHsgfVxuICAgICAgICB2YXIgY29tcGF0aWJsZVVuaXRzID0gdGhpcy50b01hdGhqc0NvbXBhdGlibGVTdHJpbmcodW5pdHMpO1xuICAgICAgICBpZiAoY29tcGF0aWJsZVVuaXRzICE9PSAnJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtYXRoanNfMS5kZWZhdWx0LnVuaXQoY29tcGF0aWJsZVVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVuaXRzKHRoaXMuZnJvbVN0cmluZ1RvTGlzdCh1bml0cykpO1xuICAgIH07XG4gICAgVW5pdHNPYmplY3RGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFVuaXRzT2JqZWN0RmFjdG9yeSk7XG4gICAgcmV0dXJuIFVuaXRzT2JqZWN0RmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlVuaXRzT2JqZWN0RmFjdG9yeSA9IFVuaXRzT2JqZWN0RmFjdG9yeTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1VuaXRzT2JqZWN0RmFjdG9yeScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoVW5pdHNPYmplY3RGYWN0b3J5KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyBmb3Igb2JqZWN0cyBkb21haW4uXG4gKi9cbi8vIFRPRE8oIzcwOTIpOiBEZWxldGUgdGhpcyBmaWxlIG9uY2UgbWlncmF0aW9uIGlzIGNvbXBsZXRlIGFuZCB0aGVzZSBBbmd1bGFySlNcbi8vIGVxdWl2YWxlbnRzIG9mIHRoZSBBbmd1bGFyIGNvbnN0YW50cyBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbnZhciBvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJkb21haW4vb2JqZWN0cy9vYmplY3RzLWRvbWFpbi5jb25zdGFudHNcIik7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnRlJBQ1RJT05fUEFSU0lOR19FUlJPUlMnLCBvYmplY3RzX2RvbWFpbl9jb25zdGFudHNfMS5PYmplY3RzRG9tYWluQ29uc3RhbnRzLkZSQUNUSU9OX1BBUlNJTkdfRVJST1JTKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmNvbnN0YW50KCdOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUycsIG9iamVjdHNfZG9tYWluX2NvbnN0YW50c18xLk9iamVjdHNEb21haW5Db25zdGFudHMuTlVNQkVSX1dJVEhfVU5JVFNfUEFSU0lOR19FUlJPUlMpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuY29uc3RhbnQoJ0NVUlJFTkNZX1VOSVRTJywgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cy5DVVJSRU5DWV9VTklUUyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBmcm9udGVuZCBpbnN0YW5jZXMgb2Ygc3VnZ2VzdGlvblxuICAgZG9tYWluIG9iamVjdHMuXG4gKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBTdWdnZXN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1Z2dlc3Rpb24oc3VnZ2VzdGlvblR5cGUsIHN1Z2dlc3Rpb25JZCwgdGFyZ2V0VHlwZSwgdGFyZ2V0SWQsIHN0YXR1cywgYXV0aG9yTmFtZSwgc3RhdGVOYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIGxhc3RVcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGlvblR5cGUgPSBzdWdnZXN0aW9uVHlwZTtcbiAgICAgICAgdGhpcy5zdWdnZXN0aW9uSWQgPSBzdWdnZXN0aW9uSWQ7XG4gICAgICAgIHRoaXMudGFyZ2V0VHlwZSA9IHRhcmdldFR5cGU7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuYXV0aG9yTmFtZSA9IGF1dGhvck5hbWU7XG4gICAgICAgIHRoaXMuc3RhdGVOYW1lID0gc3RhdGVOYW1lO1xuICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IGxhc3RVcGRhdGVkO1xuICAgIH1cbiAgICBTdWdnZXN0aW9uLnByb3RvdHlwZS5nZXRUaHJlYWRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbklkO1xuICAgIH07XG4gICAgcmV0dXJuIFN1Z2dlc3Rpb247XG59KCkpO1xuZXhwb3J0cy5TdWdnZXN0aW9uID0gU3VnZ2VzdGlvbjtcbnZhciBTdWdnZXN0aW9uT2JqZWN0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWdnZXN0aW9uT2JqZWN0RmFjdG9yeSgpIHtcbiAgICB9XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnc3VnZ2VzdGlvbkJhY2tlbmREaWN0JyBpcyBhIGRpY3Qgd2l0aCB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVGcm9tQmFja2VuZERpY3QgPSBmdW5jdGlvbiAoc3VnZ2VzdGlvbkJhY2tlbmREaWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3VnZ2VzdGlvbihzdWdnZXN0aW9uQmFja2VuZERpY3Quc3VnZ2VzdGlvbl90eXBlLCBzdWdnZXN0aW9uQmFja2VuZERpY3Quc3VnZ2VzdGlvbl9pZCwgc3VnZ2VzdGlvbkJhY2tlbmREaWN0LnRhcmdldF90eXBlLCBzdWdnZXN0aW9uQmFja2VuZERpY3QudGFyZ2V0X2lkLCBzdWdnZXN0aW9uQmFja2VuZERpY3Quc3RhdHVzLCBzdWdnZXN0aW9uQmFja2VuZERpY3QuYXV0aG9yX25hbWUsIHN1Z2dlc3Rpb25CYWNrZW5kRGljdC5jaGFuZ2Uuc3RhdGVfbmFtZSwgc3VnZ2VzdGlvbkJhY2tlbmREaWN0LmNoYW5nZS5uZXdfdmFsdWUsIHN1Z2dlc3Rpb25CYWNrZW5kRGljdC5jaGFuZ2Uub2xkX3ZhbHVlLCBzdWdnZXN0aW9uQmFja2VuZERpY3QubGFzdF91cGRhdGVkKTtcbiAgICB9O1xuICAgIFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5KTtcbiAgICByZXR1cm4gU3VnZ2VzdGlvbk9iamVjdEZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5TdWdnZXN0aW9uT2JqZWN0RmFjdG9yeSA9IFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5O1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnU3VnZ2VzdGlvbk9iamVjdEZhY3RvcnknLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBmcm9udGVuZCBpbnN0YW5jZXMgb2Ygc3VnZ2VzdGlvblxuICAgdGhyZWFkIGRvbWFpbiBvYmplY3RzLlxuICovXG5yZXF1aXJlKCdkb21haW4vc3VnZ2VzdGlvbi9TdWdnZXN0aW9uT2JqZWN0RmFjdG9yeS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnU3VnZ2VzdGlvblRocmVhZE9iamVjdEZhY3RvcnknLCBbXG4gICAgJ1N1Z2dlc3Rpb25PYmplY3RGYWN0b3J5JywgZnVuY3Rpb24gKFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5KSB7XG4gICAgICAgIHZhciBTdWdnZXN0aW9uVGhyZWFkID0gZnVuY3Rpb24gKHN0YXR1cywgc3ViamVjdCwgc3VtbWFyeSwgb3JpZ2luYWxBdXRob3JOYW1lLCBsYXN0VXBkYXRlZCwgbWVzc2FnZUNvdW50LCB0aHJlYWRJZCwgc3VnZ2VzdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxBdXRob3JOYW1lID0gb3JpZ2luYWxBdXRob3JOYW1lO1xuICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IGxhc3RVcGRhdGVkO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ291bnQgPSBtZXNzYWdlQ291bnQ7XG4gICAgICAgICAgICB0aGlzLnRocmVhZElkID0gdGhyZWFkSWQ7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3Rpb24gPSBzdWdnZXN0aW9uO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPKGFua2l0YTI0MDc5Nik6IFJlbW92ZSB0aGUgYnJhY2tldCBub3RhdGlvbiBvbmNlIEFuZ3VsYXIyIGdldHMgaW4uXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuICAgICAgICBTdWdnZXN0aW9uVGhyZWFkWydjcmVhdGVGcm9tQmFja2VuZERpY3RzJ10gPSBmdW5jdGlvbiAoXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uICovXG4gICAgICAgIHN1Z2dlc3Rpb25UaHJlYWRCYWNrZW5kRGljdCwgc3VnZ2VzdGlvbkJhY2tlbmREaWN0KSB7XG4gICAgICAgICAgICB2YXIgc3VnZ2VzdGlvbjtcbiAgICAgICAgICAgIGlmIChzdWdnZXN0aW9uQmFja2VuZERpY3Quc3VnZ2VzdGlvbl90eXBlID09PVxuICAgICAgICAgICAgICAgICdlZGl0X2V4cGxvcmF0aW9uX3N0YXRlX2NvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbiA9IFN1Z2dlc3Rpb25PYmplY3RGYWN0b3J5LmNyZWF0ZUZyb21CYWNrZW5kRGljdChzdWdnZXN0aW9uQmFja2VuZERpY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWdnZXN0aW9uVGhyZWFkKHN1Z2dlc3Rpb25UaHJlYWRCYWNrZW5kRGljdC5zdGF0dXMsIHN1Z2dlc3Rpb25UaHJlYWRCYWNrZW5kRGljdC5zdWJqZWN0LCBzdWdnZXN0aW9uVGhyZWFkQmFja2VuZERpY3Quc3VtbWFyeSwgc3VnZ2VzdGlvblRocmVhZEJhY2tlbmREaWN0Lm9yaWdpbmFsX2F1dGhvcl91c2VybmFtZSwgc3VnZ2VzdGlvblRocmVhZEJhY2tlbmREaWN0Lmxhc3RfdXBkYXRlZCwgc3VnZ2VzdGlvblRocmVhZEJhY2tlbmREaWN0Lm1lc3NhZ2VfY291bnQsIHN1Z2dlc3Rpb25UaHJlYWRCYWNrZW5kRGljdC50aHJlYWRfaWQsIHN1Z2dlc3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBTdWdnZXN0aW9uVGhyZWFkLnByb3RvdHlwZS5zZXRNZXNzYWdlcyA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICB9O1xuICAgICAgICBTdWdnZXN0aW9uVGhyZWFkLnByb3RvdHlwZS5pc1N1Z2dlc3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbi5zdGF0dXMgIT09ICdyZXZpZXcnO1xuICAgICAgICB9O1xuICAgICAgICBTdWdnZXN0aW9uVGhyZWFkLnByb3RvdHlwZS5nZXRTdWdnZXN0aW9uU3RhdGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbi5zdGF0ZU5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFN1Z2dlc3Rpb25UaHJlYWQucHJvdG90eXBlLmdldFN1Z2dlc3Rpb25TdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWdnZXN0aW9uLnN0YXR1cztcbiAgICAgICAgfTtcbiAgICAgICAgU3VnZ2VzdGlvblRocmVhZC5wcm90b3R5cGUuZ2V0UmVwbGFjZW1lbnRIdG1sRnJvbVN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWdnZXN0aW9uLm5ld1ZhbHVlLmh0bWw7XG4gICAgICAgIH07XG4gICAgICAgIFN1Z2dlc3Rpb25UaHJlYWQucHJvdG90eXBlLmlzU3VnZ2VzdGlvblRocmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBTdWdnZXN0aW9uVGhyZWFkLnByb3RvdHlwZS5nZXRTdWdnZXN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN1Z2dlc3Rpb25UaHJlYWQ7XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlbW92ZUR1cGxpY2F0ZXNJbkFycmF5IGZpbHRlciBmb3IgT3BwaWEuXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZpbHRlcigncmVtb3ZlRHVwbGljYXRlc0luQXJyYXknLCBbZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdCYWQgaW5wdXQgZm9yIHJlbW92ZUR1cGxpY2F0ZXNJbkFycmF5OiAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKHZhbCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmluZGV4T2YodmFsKSA9PT0gcG9zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfV0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBOb3JtYWxpemVXaGl0ZXNwYWNlUHVuY3R1YXRpb25BbmRDYXNlIGZpbHRlciBmb3IgT3BwaWEuXG4gKi9cbi8vIEZpbHRlciB0aGF0IHRha2VzIGEgc3RyaW5nLCB0cmltcyBhbmQgbm9ybWFsaXplcyBzcGFjZXMgd2l0aGluIGVhY2hcbi8vIGxpbmUsIGFuZCByZW1vdmVzIGJsYW5rIGxpbmVzLiBOb3RlIHRoYXQgYW55IHNwYWNlcyB3aG9zZSByZW1vdmFsIGRvZXMgbm90XG4vLyByZXN1bHQgaW4gdHdvIGFscGhhbnVtZXJpYyBcIndvcmRzXCIgYmVpbmcgam9pbmVkIHRvZ2V0aGVyIGFyZSBhbHNvIHJlbW92ZWQsXG4vLyBzbyBcImhlbGxvID8gXCIgYmVjb21lcyBcImhlbGxvP1wiLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlUHVuY3R1YXRpb25BbmRDYXNlJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNBbHBoYW51bWVyaWMgPSBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncXdlcnR5dWlvcGFzZGZnaGprbHp4Y3Zibm0wMTIzNDU2Nzg5Jy5pbmRleE9mKGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRMaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRMaW5lID0gaW5wdXRMaW5lc1tpXS50cmltKCkucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0TGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gaW5wdXRMaW5lLmNoYXJBdChqKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDAgJiYgaiA8IGlucHV0TGluZS5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxwaGFudW1lcmljKGlucHV0TGluZS5jaGFyQXQoaiAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FscGhhbnVtZXJpYyhpbnB1dExpbmUuY2hhckF0KGogKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBOb3JtYWxpemVXaGl0ZXNwYWNlIGZpbHRlciBmb3IgT3BwaWEuXG4gKi9cbnJlcXVpcmUoJ3NlcnZpY2VzL1V0aWxzU2VydmljZS50cycpO1xuLy8gRmlsdGVyIHRoYXQgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nLCBhbmRcbi8vIHJlcGxhY2VzIGludGVyaW9yIHdoaXRlc3BhY2Ugd2l0aCBhIHNpbmdsZSBzcGFjZSBjaGFyYWN0ZXIuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5maWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnLCBbXG4gICAgJ1V0aWxzU2VydmljZScsIGZ1bmN0aW9uIChVdGlsc1NlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzU2VydmljZS5pc1N0cmluZyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgc3RyaW5nLCBhbmRcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGludGVyaW9yIHdoaXRlc3BhY2Ugd2l0aCBhIHNpbmdsZSBzcGFjZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50cmltKCk7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUcnVuY2F0ZUF0Rmlyc3RMaW5lIGZpbHRlciBmb3IgT3BwaWEuXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZpbHRlcigndHJ1bmNhdGVBdEZpcnN0TGluZScsIFtmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IC8oXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NVxcdTIwMjhcXHUyMDI5XSkvZztcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGVuZGluZ3MgdGhlbiBzcGxpdCB1c2luZyB0aGUgbm9ybWFsaXplZCBkZWxpbWl0ZXIuXG4gICAgICAgICAgICB2YXIgbGluZXMgPSBpbnB1dC5yZXBsYWNlKHBhdHRlcm4sICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgZmlyc3ROb25lbXB0eUxpbmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIG90aGVyTm9uZW1wdHlMaW5lc0V4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uZW1wdHlMaW5lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vbmVtcHR5TGluZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTm9uZW1wdHlMaW5lc0V4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG90aGVyTm9uZW1wdHlMaW5lc0V4aXN0ID8gJy4uLicgOiAnJztcbiAgICAgICAgICAgIHJldHVybiAoZmlyc3ROb25lbXB0eUxpbmVJbmRleCAhPT0gLTEgP1xuICAgICAgICAgICAgICAgIGxpbmVzW2ZpcnN0Tm9uZW1wdHlMaW5lSW5kZXhdICsgc3VmZml4IDogJycpO1xuICAgICAgICB9O1xuICAgIH1dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgZm9vdGVyLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhRm9vdGVyJywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldERpcmVjdGl2ZVRlbXBsYXRlVXJsKCcvcGFnZXMvb3BwaWFfZm9vdGVyX2RpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyBmb3IgdGhlIGNyZWF0b3IgZGFzaGJvYXJkLlxuICovXG4vLyBUT0RPKCM3MDkyKTogRGVsZXRlIHRoaXMgZmlsZSBvbmNlIG1pZ3JhdGlvbiBpcyBjb21wbGV0ZSBhbmQgdGhlc2UgQW5ndWxhckpTXG4vLyBlcXVpdmFsZW50cyBvZiB0aGUgQW5ndWxhciBjb25zdGFudHMgYXJlIG5vIGxvbmdlciBuZWVkZWQuXG52YXIgY3JlYXRvcl9kYXNoYm9hcmRfcGFnZV9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJwYWdlcy9jcmVhdG9yLWRhc2hib2FyZC1wYWdlL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UuY29uc3RhbnRzXCIpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuY29uc3RhbnQoJ0VYUExPUkFUSU9OX0RST1BET1dOX1NUQVRTJywgY3JlYXRvcl9kYXNoYm9hcmRfcGFnZV9jb25zdGFudHNfMS5DcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzLkVYUExPUkFUSU9OX0RST1BET1dOX1NUQVRTKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmNvbnN0YW50KCdFWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTJywgY3JlYXRvcl9kYXNoYm9hcmRfcGFnZV9jb25zdGFudHNfMS5DcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzLkVYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuY29uc3RhbnQoJ0hVTUFOX1JFQURBQkxFX0VYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMnLCBjcmVhdG9yX2Rhc2hib2FyZF9wYWdlX2NvbnN0YW50c18xLkNyZWF0b3JEYXNoYm9hcmRDb25zdGFudHMuSFVNQU5fUkVBREFCTEVfRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnU1VCU0NSSVBUSU9OX1NPUlRfQllfS0VZUycsIGNyZWF0b3JfZGFzaGJvYXJkX3BhZ2VfY29uc3RhbnRzXzEuQ3JlYXRvckRhc2hib2FyZENvbnN0YW50cy5TVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmNvbnN0YW50KCdIVU1BTl9SRUFEQUJMRV9TVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTJywgY3JlYXRvcl9kYXNoYm9hcmRfcGFnZV9jb25zdGFudHNfMS5DcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzLkhVTUFOX1JFQURBQkxFX1NVQlNDUklQVElPTl9TT1JUX0JZX0tFWVMpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgZm9yIHRoZSBjcmVhdG9yIGRhc2hib2FyZC5cbiAqL1xudmFyIENyZWF0b3JEYXNoYm9hcmRDb25zdGFudHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3JlYXRvckRhc2hib2FyZENvbnN0YW50cygpIHtcbiAgICB9XG4gICAgQ3JlYXRvckRhc2hib2FyZENvbnN0YW50cy5FWFBMT1JBVElPTl9EUk9QRE9XTl9TVEFUUyA9IHtcbiAgICAgICAgT1BFTl9GRUVEQkFDSzogJ29wZW5fZmVlZGJhY2snXG4gICAgfTtcbiAgICBDcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzLkVYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMgPSB7XG4gICAgICAgIFRJVExFOiAndGl0bGUnLFxuICAgICAgICBSQVRJTkc6ICdyYXRpbmdzJyxcbiAgICAgICAgTlVNX1ZJRVdTOiAnbnVtX3ZpZXdzJyxcbiAgICAgICAgT1BFTl9GRUVEQkFDSzogJ251bV9vcGVuX3RocmVhZHMnLFxuICAgICAgICBMQVNUX1VQREFURUQ6ICdsYXN0X3VwZGF0ZWRfbXNlYydcbiAgICB9O1xuICAgIENyZWF0b3JEYXNoYm9hcmRDb25zdGFudHMuSFVNQU5fUkVBREFCTEVfRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUyA9IHtcbiAgICAgICAgVElUTEU6ICdJMThOX0RBU0hCT0FSRF9FWFBMT1JBVElPTlNfU09SVF9CWV9USVRMRScsXG4gICAgICAgIFJBVElORzogJ0kxOE5fREFTSEJPQVJEX0VYUExPUkFUSU9OU19TT1JUX0JZX0FWRVJBR0VfUkFUSU5HJyxcbiAgICAgICAgTlVNX1ZJRVdTOiAnSTE4Tl9EQVNIQk9BUkRfRVhQTE9SQVRJT05TX1NPUlRfQllfVE9UQUxfUExBWVMnLFxuICAgICAgICBPUEVOX0ZFRURCQUNLOiAnSTE4Tl9EQVNIQk9BUkRfRVhQTE9SQVRJT05TX1NPUlRfQllfT1BFTl9GRUVEQkFDSycsXG4gICAgICAgIExBU1RfVVBEQVRFRDogJ0kxOE5fREFTSEJPQVJEX0VYUExPUkFUSU9OU19TT1JUX0JZX0xBU1RfVVBEQVRFRCdcbiAgICB9O1xuICAgIENyZWF0b3JEYXNoYm9hcmRDb25zdGFudHMuU1VCU0NSSVBUSU9OX1NPUlRfQllfS0VZUyA9IHtcbiAgICAgICAgVVNFUk5BTUU6ICdzdWJzY3JpYmVyX3VzZXJuYW1lJyxcbiAgICAgICAgSU1QQUNUOiAnc3Vic2NyaWJlcl9pbXBhY3QnXG4gICAgfTtcbiAgICBDcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzLkhVTUFOX1JFQURBQkxFX1NVQlNDUklQVElPTl9TT1JUX0JZX0tFWVMgPSB7XG4gICAgICAgIFVTRVJOQU1FOiAnVXNlcm5hbWUnLFxuICAgICAgICBJTVBBQ1Q6ICdJbXBhY3QnXG4gICAgfTtcbiAgICByZXR1cm4gQ3JlYXRvckRhc2hib2FyZENvbnN0YW50cztcbn0oKSk7XG5leHBvcnRzLkNyZWF0b3JEYXNoYm9hcmRDb25zdGFudHMgPSBDcmVhdG9yRGFzaGJvYXJkQ29uc3RhbnRzO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBjcmVhdG9yIGRhc2hib2FyZC5cbiAqL1xucmVxdWlyZSgnYmFzZV9jb21wb25lbnRzL0Jhc2VDb250ZW50RGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL2NvbW1vbi1sYXlvdXQtZGlyZWN0aXZlcy9jb21tb24tZWxlbWVudHMvJyArXG4gICAgJ3NoYXJpbmctbGlua3MuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL2NvbW1vbi1sYXlvdXQtZGlyZWN0aXZlcy9jb21tb24tZWxlbWVudHMvJyArXG4gICAgJ2JhY2tncm91bmQtYmFubmVyLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnY29tcG9uZW50cy9zdW1tYXJ5LXRpbGUvY29sbGVjdGlvbi1zdW1tYXJ5LXRpbGUuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1lZGl0b3ItcGFnZS9mZWVkYmFjay10YWIvdGhyZWFkLXRhYmxlLycgK1xuICAgICd0aHJlYWQtdGFibGUuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zUmVxdWlyZXMudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvb2JqZWN0Q29tcG9uZW50c1JlcXVpcmVzLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL2VudGl0eS1jcmVhdGlvbi1zZXJ2aWNlcy9leHBsb3JhdGlvbi1jcmVhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL3JhdGluZ3MvcmF0aW5nLWNvbXB1dGF0aW9uL3JhdGluZy1jb21wdXRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vY3JlYXRvcl9kYXNoYm9hcmQvQ3JlYXRvckRhc2hib2FyZEJhY2tlbmRBcGlTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vc3VnZ2VzdGlvbi9TdWdnZXN0aW9uT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnZG9tYWluL3N1Z2dlc3Rpb24vU3VnZ2VzdGlvblRocmVhZE9iamVjdEZhY3RvcnkudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2Uvc3VnZ2VzdGlvbi1tb2RhbC1mb3ItY3JlYXRvci12aWV3LycgK1xuICAgICdzdWdnZXN0aW9uLW1vZGFsLWZvci1jcmVhdG9yLXZpZXcuc2VydmljZS50cycpO1xucmVxdWlyZSgncGFnZXMvZXhwbG9yYXRpb24tZWRpdG9yLXBhZ2UvZmVlZGJhY2stdGFiL3NlcnZpY2VzLycgK1xuICAgICd0aHJlYWQtc3RhdHVzLWRpc3BsYXkuc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvQWxlcnRzU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvRGF0ZVRpbWVGb3JtYXRTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9Vc2VyU2VydmljZS50cycpO1xucmVxdWlyZSgncGFnZXMvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS9jcmVhdG9yLWRhc2hib2FyZC1wYWdlLmNvbnN0YW50cy5hanMudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnY3JlYXRvckRhc2hib2FyZFBhZ2UnLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RGlyZWN0aXZlVGVtcGxhdGVVcmwoJy9wYWdlcy9jcmVhdG9yLWRhc2hib2FyZC1wYWdlL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGh0dHAnLCAnJGxvZycsICckcScsICckcm9vdFNjb3BlJywgJyR3aW5kb3cnLFxuICAgICAgICAgICAgICAgICdBbGVydHNTZXJ2aWNlJywgJ0NyZWF0b3JEYXNoYm9hcmRCYWNrZW5kQXBpU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0RhdGVUaW1lRm9ybWF0U2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0V4cGxvcmF0aW9uQ3JlYXRpb25TZXJ2aWNlJywgJ1JhdGluZ0NvbXB1dGF0aW9uU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ1N1Z2dlc3Rpb25Nb2RhbEZvckNyZWF0b3JEYXNoYm9hcmRTZXJ2aWNlJywgJ1N1Z2dlc3Rpb25PYmplY3RGYWN0b3J5JyxcbiAgICAgICAgICAgICAgICAnU3VnZ2VzdGlvblRocmVhZE9iamVjdEZhY3RvcnknLCAnVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2UnLFxuICAgICAgICAgICAgICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsICdVc2VyU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0FMTE9XRURfQ1JFQVRPUl9EQVNIQk9BUkRfRElTUExBWV9QUkVGUycsXG4gICAgICAgICAgICAgICAgJ0RFRkFVTFRfVFdJVFRFUl9TSEFSRV9NRVNTQUdFX0VESVRPUicsICdFWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTJyxcbiAgICAgICAgICAgICAgICAnRVhQTE9SQVRJT05fRFJPUERPV05fU1RBVFMnLCAnRkFUQUxfRVJST1JfQ09ERVMnLFxuICAgICAgICAgICAgICAgICdIVU1BTl9SRUFEQUJMRV9FWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTJyxcbiAgICAgICAgICAgICAgICAnSFVNQU5fUkVBREFCTEVfU1VCU0NSSVBUSU9OX1NPUlRfQllfS0VZUycsXG4gICAgICAgICAgICAgICAgJ1NVQlNDUklQVElPTl9TT1JUX0JZX0tFWVMnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkaHR0cCwgJGxvZywgJHEsICRyb290U2NvcGUsICR3aW5kb3csIEFsZXJ0c1NlcnZpY2UsIENyZWF0b3JEYXNoYm9hcmRCYWNrZW5kQXBpU2VydmljZSwgRGF0ZVRpbWVGb3JtYXRTZXJ2aWNlLCBFeHBsb3JhdGlvbkNyZWF0aW9uU2VydmljZSwgUmF0aW5nQ29tcHV0YXRpb25TZXJ2aWNlLCBTdWdnZXN0aW9uTW9kYWxGb3JDcmVhdG9yRGFzaGJvYXJkU2VydmljZSwgU3VnZ2VzdGlvbk9iamVjdEZhY3RvcnksIFN1Z2dlc3Rpb25UaHJlYWRPYmplY3RGYWN0b3J5LCBUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UsIFVzZXJTZXJ2aWNlLCBBTExPV0VEX0NSRUFUT1JfREFTSEJPQVJEX0RJU1BMQVlfUFJFRlMsIERFRkFVTFRfVFdJVFRFUl9TSEFSRV9NRVNTQUdFX0VESVRPUiwgRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUywgRVhQTE9SQVRJT05fRFJPUERPV05fU1RBVFMsIEZBVEFMX0VSUk9SX0NPREVTLCBIVU1BTl9SRUFEQUJMRV9FWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTLCBIVU1BTl9SRUFEQUJMRV9TVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTLCBTVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIEVYUF9QVUJMSVNIX1RFWFRTID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHQ6ICgnVGhpcyBleHBsb3JhdGlvbiBpcyBwcml2YXRlLiBQdWJsaXNoIGl0IHRvIHJlY2VpdmUgc3RhdGlzdGljcy4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtVGV4dDogJ1B1Ymxpc2ggdGhlIGV4cGxvcmF0aW9uIHRvIHJlY2VpdmUgc3RhdGlzdGljcy4nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyRGFzaGJvYXJkRGlzcGxheVByZWZlcmVuY2UgPSBBTExPV0VEX0NSRUFUT1JfREFTSEJPQVJEX0RJU1BMQVlfUFJFRlMuQ0FSRDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5ERUZBVUxUX0VNUFRZX1RJVExFID0gJ1VudGl0bGVkJztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5FWFBMT1JBVElPTl9EUk9QRE9XTl9TVEFUUyA9IEVYUExPUkFUSU9OX0RST1BET1dOX1NUQVRTO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLkVYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMgPSBFWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLkhVTUFOX1JFQURBQkxFX0VYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMgPSAoSFVNQU5fUkVBREFCTEVfRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUyk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuU1VCU0NSSVBUSU9OX1NPUlRfQllfS0VZUyA9IFNVQlNDUklQVElPTl9TT1JUX0JZX0tFWVM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuSFVNQU5fUkVBREFCTEVfU1VCU0NSSVBUSU9OX1NPUlRfQllfS0VZUyA9IChIVU1BTl9SRUFEQUJMRV9TVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5ERUZBVUxUX1RXSVRURVJfU0hBUkVfTUVTU0FHRV9EQVNIQk9BUkQgPSAoREVGQVVMVF9UV0lUVEVSX1NIQVJFX01FU1NBR0VfRURJVE9SKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5DcmVhdGVDb2xsZWN0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9hZGluZ01lc3NhZ2UgPSAnTG9hZGluZyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VySW5mb1Byb21pc2UgPSBVc2VyU2VydmljZS5nZXRVc2VySW5mb0FzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJJbmZvUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh1c2VySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5DcmVhdGVDb2xsZWN0aW9ucyA9IHVzZXJJbmZvLmNhbkNyZWF0ZUNvbGxlY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGFzaGJvYXJkRGF0YVByb21pc2UgPSAoQ3JlYXRvckRhc2hib2FyZEJhY2tlbmRBcGlTZXJ2aWNlLmZldGNoRGFzaGJvYXJkRGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgZGFzaGJvYXJkRGF0YVByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIHJlcXVpcmVkIGZvciBLYXJtYSB0ZXN0aW5nLiBUaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZ3VsYXIgSHR0cENsaWVudCByZXR1cm5zIGFuIE9ic2VydmFibGUgd2hpY2ggd2hlbiBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGEgcHJvbWlzZSBkb2VzIG5vdCBoYXZlIHRoZSAnZGF0YScga2V5IGJ1dCB0aGUgQW5ndWxhckpTXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb2NrcyBvZiBzZXJ2aWNlcyB1c2luZyBIdHRwQ2xpZW50IHVzZSAkaHR0cCB3aGljaCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb21pc2UgYW5kIHRoZSBjb250ZW50IGlzIGNvbnRhaW5lZCBpbiB0aGUgJ2RhdGEnIGtleS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBjaGVja3MgZm9yIHByZXNlbmNlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAncmVzcG9uc2UuZGF0YScgd2hpY2ggd291bGQgYmUgdGhlIGNhc2UgaW4gQW5ndWxhckpTIHRlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhc3NpZ25zICdyZXNwb25zZScgaWYgdGhlIGZvcm1lciBpcyBub3QgcHJlc2VudCB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNhc2Ugd2l0aCBIdHRwQ2xpZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmRhdGEgPyByZXNwb25zZS5kYXRhIDogcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmN1cnJlbnRTb3J0VHlwZSA9IEVYUExPUkFUSU9OU19TT1JUX0JZX0tFWVMuT1BFTl9GRUVEQkFDSztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3VycmVudFN1YnNjcmliZXJzU29ydFR5cGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNVQlNDUklQVElPTl9TT1JUX0JZX0tFWVMuVVNFUk5BTUU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmlzQ3VycmVudFNvcnREZXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaXNDdXJyZW50U3Vic2NyaXB0aW9uU29ydERlc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5leHBsb3JhdGlvbnNMaXN0ID0gcmVzcG9uc2VEYXRhLmV4cGxvcmF0aW9uc19saXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jb2xsZWN0aW9uc0xpc3QgPSByZXNwb25zZURhdGEuY29sbGVjdGlvbnNfbGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3Vic2NyaWJlcnNMaXN0ID0gcmVzcG9uc2VEYXRhLnN1YnNjcmliZXJzX2xpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhc2hib2FyZFN0YXRzID0gcmVzcG9uc2VEYXRhLmRhc2hib2FyZF9zdGF0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFzdFdlZWtTdGF0cyA9IHJlc3BvbnNlRGF0YS5sYXN0X3dlZWtfc3RhdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm15RXhwbG9yYXRpb25zVmlldyA9IHJlc3BvbnNlRGF0YS5kaXNwbGF5X3ByZWZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyT2ZDcmVhdGVkU3VnZ2VzdGlvbnMgPSAocmVzcG9uc2VEYXRhLnRocmVhZHNfZm9yX2NyZWF0ZWRfc3VnZ2VzdGlvbnNfbGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlck9mU3VnZ2VzdGlvbnNUb1JldmlldyA9IChyZXNwb25zZURhdGEudGhyZWFkc19mb3Jfc3VnZ2VzdGlvbnNfdG9fcmV2aWV3X2xpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubXlTdWdnZXN0aW9uc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZDcmVhdGVkU3VnZ2VzdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZURhdGEuY3JlYXRlZF9zdWdnZXN0aW9uc19saXN0Lmxlbmd0aCAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZDcmVhdGVkU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignTnVtYmVyIG9mIHN1Z2dlc3Rpb25zIGRvZXMgbm90IG1hdGNoIG51bWJlciBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWdnZXN0aW9uIHRocmVhZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1iZXJPZkNyZWF0ZWRTdWdnZXN0aW9uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gU3VnZ2VzdGlvbk9iamVjdEZhY3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVGcm9tQmFja2VuZERpY3QocmVzcG9uc2VEYXRhLmNyZWF0ZWRfc3VnZ2VzdGlvbnNfbGlzdFtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHJlYWREaWN0ID0gKHJlc3BvbnNlRGF0YS50aHJlYWRzX2Zvcl9jcmVhdGVkX3N1Z2dlc3Rpb25zX2xpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyZWFkRGljdC50aHJlYWRfaWQgPT09IHN1Z2dlc3Rpb24uZ2V0VGhyZWFkSWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Z2dlc3Rpb25UaHJlYWQgPSAoU3VnZ2VzdGlvblRocmVhZE9iamVjdEZhY3RvcnkuY3JlYXRlRnJvbUJhY2tlbmREaWN0cyh0aHJlYWREaWN0LCByZXNwb25zZURhdGEuY3JlYXRlZF9zdWdnZXN0aW9uc19saXN0W2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm15U3VnZ2VzdGlvbnNMaXN0LnB1c2goc3VnZ2VzdGlvblRocmVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mU3VnZ2VzdGlvbnNUb1JldmlldzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zdWdnZXN0aW9uc190b19yZXZpZXdfbGlzdC5sZW5ndGggIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mU3VnZ2VzdGlvbnNUb1Jldmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCdOdW1iZXIgb2Ygc3VnZ2VzdGlvbnMgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Z2dlc3Rpb24gdGhyZWFkcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bWJlck9mU3VnZ2VzdGlvbnNUb1JldmlldzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gU3VnZ2VzdGlvbk9iamVjdEZhY3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVGcm9tQmFja2VuZERpY3QocmVzcG9uc2VEYXRhLnN1Z2dlc3Rpb25zX3RvX3Jldmlld19saXN0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRocmVhZERpY3QgPSAocmVzcG9uc2VEYXRhLnRocmVhZHNfZm9yX3N1Z2dlc3Rpb25zX3RvX3Jldmlld19saXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocmVhZERpY3QudGhyZWFkX2lkID09PSBzdWdnZXN0aW9uLmdldFRocmVhZElkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWdnZXN0aW9uVGhyZWFkID0gKFN1Z2dlc3Rpb25UaHJlYWRPYmplY3RGYWN0b3J5LmNyZWF0ZUZyb21CYWNrZW5kRGljdHModGhyZWFkRGljdCwgcmVzcG9uc2VEYXRhLnN1Z2dlc3Rpb25zX3RvX3Jldmlld19saXN0W2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0LnB1c2goc3VnZ2VzdGlvblRocmVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5kYXNoYm9hcmRTdGF0cyAmJiBjdHJsLmxhc3RXZWVrU3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlbGF0aXZlQ2hhbmdlSW5Ub3RhbFBsYXlzID0gKGN0cmwuZGFzaGJvYXJkU3RhdHMudG90YWxfcGxheXMgLSAoY3RybC5sYXN0V2Vla1N0YXRzLnRvdGFsX3BsYXlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5leHBsb3JhdGlvbnNMaXN0Lmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29sbGVjdGlvbnNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZVRhYiA9ICdteUNvbGxlY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuZXhwbG9yYXRpb25zTGlzdC5sZW5ndGggPT09IDAgJiYgKGN0cmwubXlTdWdnZXN0aW9uc0xpc3QubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3VnZ2VzdGlvbnNUb1Jldmlld0xpc3QubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZVRhYiA9ICdzdWdnZXN0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZVRhYiA9ICdteUV4cGxvcmF0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRkFUQUxfRVJST1JfQ09ERVMuaW5kZXhPZihlcnJvclJlc3BvbnNlLnN0YXR1cykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnRzU2VydmljZS5hZGRXYXJuaW5nKCdGYWlsZWQgdG8gZ2V0IGRhc2hib2FyZCBkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkcS5hbGwoW3VzZXJJbmZvUHJvbWlzZSwgZGFzaGJvYXJkRGF0YVByb21pc2VdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9hZGluZ01lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0QXZlcmFnZVJhdGluZyA9IFJhdGluZ0NvbXB1dGF0aW9uU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbXB1dGVBdmVyYWdlUmF0aW5nO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNyZWF0ZU5ld0V4cGxvcmF0aW9uID0gKEV4cGxvcmF0aW9uQ3JlYXRpb25TZXJ2aWNlLmNyZWF0ZU5ld0V4cGxvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRMb2NhbGVBYmJyZXZpYXRlZERhdGV0aW1lU3RyaW5nID0gKERhdGVUaW1lRm9ybWF0U2VydmljZS5nZXRMb2NhbGVBYmJyZXZpYXRlZERhdGV0aW1lU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRIdW1hblJlYWRhYmxlU3RhdHVzID0gKFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlLmdldEh1bWFuUmVhZGFibGVTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVtcHR5RGFzaGJvYXJkSW1nVXJsID0gVXJsSW50ZXJwb2xhdGlvblNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0aWNJbWFnZVVybCgnL2dlbmVyYWwvZW1wdHlfZGFzaGJvYXJkLnN2ZycpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNhblJldmlld0FjdGl2ZVRocmVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0QWN0aXZlVGFiID0gZnVuY3Rpb24gKG5ld0FjdGl2ZVRhYk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYWN0aXZlVGFiID0gbmV3QWN0aXZlVGFiTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRFeHBsb3JhdGlvblVybCA9IGZ1bmN0aW9uIChleHBsb3JhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJy9jcmVhdGUvJyArIGV4cGxvcmF0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q29sbGVjdGlvblVybCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnL2NvbGxlY3Rpb25fZWRpdG9yL2NyZWF0ZS8nICsgY29sbGVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNldE15RXhwbG9yYXRpb25zVmlldyA9IGZ1bmN0aW9uIChuZXdWaWV3VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGh0dHAucG9zdCgnL2NyZWF0b3JkYXNoYm9hcmRoYW5kbGVyL2RhdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9wcmVmZXJlbmNlOiBuZXdWaWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubXlFeHBsb3JhdGlvbnNWaWV3ID0gbmV3Vmlld1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXNoYm9hcmREaXNwbGF5UHJlZmVyZW5jZSA9IG5ld1ZpZXdUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNoZWNrTW9iaWxlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHdpbmRvdy5pbm5lcldpZHRoIDwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zaG93VXNlcm5hbWVQb3BvdmVyID0gZnVuY3Rpb24gKHN1YnNjcmliZXJVc2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBvcG92ZXIgb24gdGhlIHN1YnNjcmlwdGlvbiBjYXJkIGlzIG9ubHkgc2hvd24gaWYgdGhlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHN1YnNjcmliZXIgdXNlcm5hbWUgaXMgZ3JlYXRlciB0aGFuIDEwIGFuZCB0aGUgdXNlciBob3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXIgdGhlIHRydW5jYXRlZCB1c2VybmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyVXNlcm5hbWUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21vdXNlZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC51cGRhdGVzR2l2ZW5TY3JlZW5XaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmNoZWNrTW9iaWxlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG1vYmlsZSB1c2VycywgdGhlIHZpZXcgb2YgdGhlIGNyZWF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwbG9yYXRpb24gbGlzdCBpcyBzaG93biBvbmx5IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNhcmQgdmlldyBhbmQgY2FuJ3QgYmUgc3dpdGNoZWQgdG8gbGlzdCB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubXlFeHBsb3JhdGlvbnNWaWV3ID0gKEFMTE9XRURfQ1JFQVRPUl9EQVNIQk9BUkRfRElTUExBWV9QUkVGUy5DQVJEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnB1Ymxpc2hUZXh0ID0gRVhQX1BVQkxJU0hfVEVYVFMuc21UZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNvbXB1dGVyIHVzZXJzIG9yIHVzZXJzIG9wZXJhdGluZyBpbiBsYXJnZXIgc2NyZWVuIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3JlYXRvciBleHBsb3JhdGlvbiBsaXN0IHdpbGwgY29tZSBiYWNrIHRvIGl0cyBwcmV2aW91c2x5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgdmlldyAoY2FyZCBvciBsaXN0KSB3aGVuIHJlc2l6ZWQgZnJvbSBtb2JpbGUgdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubXlFeHBsb3JhdGlvbnNWaWV3ID0gdXNlckRhc2hib2FyZERpc3BsYXlQcmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucHVibGlzaFRleHQgPSBFWFBfUFVCTElTSF9URVhUUy5kZWZhdWx0VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC51cGRhdGVzR2l2ZW5TY3JlZW5XaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykuYmluZCgncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51cGRhdGVzR2l2ZW5TY3JlZW5XaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZXRFeHBsb3JhdGlvbnNTb3J0aW5nT3B0aW9ucyA9IGZ1bmN0aW9uIChzb3J0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRUeXBlID09PSBjdHJsLmN1cnJlbnRTb3J0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaXNDdXJyZW50U29ydERlc2NlbmRpbmcgPSAhY3RybC5pc0N1cnJlbnRTb3J0RGVzY2VuZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3VycmVudFNvcnRUeXBlID0gc29ydFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0U3Vic2NyaXB0aW9uU29ydGluZ09wdGlvbnMgPSBmdW5jdGlvbiAoc29ydFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0VHlwZSA9PT0gY3RybC5jdXJyZW50U3Vic2NyaWJlcnNTb3J0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaXNDdXJyZW50U3Vic2NyaXB0aW9uU29ydERlc2NlbmRpbmcgPSAoIWN0cmwuaXNDdXJyZW50U3Vic2NyaXB0aW9uU29ydERlc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jdXJyZW50U3Vic2NyaWJlcnNTb3J0VHlwZSA9IHNvcnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNvcnRTdWJzY3JpcHRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIGFzIGEgY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBvcmRlckJ5YCwgc28gdGhhdCBzcGVjaWFsIGNhc2VzIGNhbiBiZSBoYW5kbGVkIHdoaWxlIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRpdHlbY3RybC5jdXJyZW50U3Vic2NyaWJlcnNTb3J0VHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5jdXJyZW50U3Vic2NyaWJlcnNTb3J0VHlwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVUJTQ1JJUFRJT05fU09SVF9CWV9LRVlTLklNUEFDVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZldGNoTWVzc2FnZXMgPSBmdW5jdGlvbiAodGhyZWFkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRodHRwLmdldCgnL3RocmVhZGhhbmRsZXIvJyArIHRocmVhZElkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGxUaHJlYWRzID0gY3RybC5teVN1Z2dlc3Rpb25zTGlzdC5jb25jYXQoY3RybC5zdWdnZXN0aW9uc1RvUmV2aWV3TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxUaHJlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxUaHJlYWRzW2ldLnRocmVhZElkID09PSB0aHJlYWRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVGhyZWFkc1tpXS5zZXRNZXNzYWdlcyhyZXNwb25zZS5kYXRhLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2xlYXJBY3RpdmVUaHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZVRocmVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0QWN0aXZlVGhyZWFkID0gZnVuY3Rpb24gKHRocmVhZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZmV0Y2hNZXNzYWdlcyh0aHJlYWRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwubXlTdWdnZXN0aW9uc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5teVN1Z2dlc3Rpb25zTGlzdFtpXS50aHJlYWRJZCA9PT0gdGhyZWFkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hY3RpdmVUaHJlYWQgPSBjdHJsLm15U3VnZ2VzdGlvbnNMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhblJldmlld0FjdGl2ZVRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuYWN0aXZlVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0W2ldLnRocmVhZElkID09PSB0aHJlYWRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hY3RpdmVUaHJlYWQgPSBjdHJsLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5SZXZpZXdBY3RpdmVUaHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2hvd1N1Z2dlc3Rpb25Nb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1Z2dlc3Rpb25Nb2RhbEZvckNyZWF0b3JEYXNoYm9hcmRTZXJ2aWNlLnNob3dTdWdnZXN0aW9uTW9kYWwoY3RybC5hY3RpdmVUaHJlYWQuc3VnZ2VzdGlvbi5zdWdnZXN0aW9uVHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRocmVhZDogY3RybC5hY3RpdmVUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnNUb1Jldmlld0xpc3Q6IGN0cmwuc3VnZ2VzdGlvbnNUb1Jldmlld0xpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJBY3RpdmVUaHJlYWQ6IGN0cmwuY2xlYXJBY3RpdmVUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuUmV2aWV3QWN0aXZlVGhyZWFkOiBjdHJsLmNhblJldmlld0FjdGl2ZVRocmVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc29ydEJ5RnVuY3Rpb24gPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCBhcyBhIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgb3JkZXJCeWAsIHNvIHRoYXQgc3BlY2lhbCBjYXNlcyBjYW4gYmUgaGFuZGxlZCB3aGlsZSBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHBsb3JhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRpdHlbY3RybC5jdXJyZW50U29ydFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eS5zdGF0dXMgPT09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmN1cnJlbnRTb3J0VHlwZSA9PT0gRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUy5USVRMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCBjdHJsLkRFRkFVTFRfRU1QVFlfVElUTEUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLmN1cnJlbnRTb3J0VHlwZSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQTE9SQVRJT05TX1NPUlRfQllfS0VZUy5MQVNUX1VQREFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuY3VycmVudFNvcnRUeXBlID09PSBFWFBMT1JBVElPTlNfU09SVF9CWV9LRVlTLlJBVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdmVyYWdlUmF0aW5nID0gY3RybC5nZXRBdmVyYWdlUmF0aW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IChhdmVyYWdlUmF0aW5nIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldENvbXBsZXRlVGh1bWJuYWlsSWNvblVybCA9IGZ1bmN0aW9uIChpY29uVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0U3RhdGljSW1hZ2VVcmwoaWNvblVybCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgZm9yIHRoZSBjb2xsZWN0aW9uIHBsYXllciBwYWdlLlxuICovXG5yZXF1aXJlKFwiY29yZS1qcy9lczcvcmVmbGVjdFwiKTtcbnJlcXVpcmUoXCJ6b25lLmpzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHBsYXRmb3JtX2Jyb3dzZXJfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGh0dHBfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb24vaHR0cFwiKTtcbi8vIFRoaXMgY29tcG9uZW50IGlzIG5lZWRlZCB0byBmb3JjZS1ib290c3RyYXAgQW5ndWxhciBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuLy8gYXBwLlxudmFyIFNlcnZpY2VCb290c3RyYXBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmljZUJvb3RzdHJhcENvbXBvbmVudCgpIHtcbiAgICB9XG4gICAgU2VydmljZUJvb3RzdHJhcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VydmljZS1ib290c3RyYXAnLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgICAgIH0pXG4gICAgXSwgU2VydmljZUJvb3RzdHJhcENvbXBvbmVudCk7XG4gICAgcmV0dXJuIFNlcnZpY2VCb290c3RyYXBDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0cy5TZXJ2aWNlQm9vdHN0cmFwQ29tcG9uZW50ID0gU2VydmljZUJvb3RzdHJhcENvbXBvbmVudDtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBjbGFzc2lmaWVyc19leHRlbnNpb25fY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiY2xhc3NpZmllcnMvY2xhc3NpZmllcnMtZXh0ZW5zaW9uLmNvbnN0YW50c1wiKTtcbnZhciBjb2xsZWN0aW9uX3N1bW1hcnlfdGlsZV9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJjb21wb25lbnRzL3N1bW1hcnktdGlsZS9jb2xsZWN0aW9uLXN1bW1hcnktdGlsZS5jb25zdGFudHNcIik7XG52YXIgaW50ZXJhY3Rpb25zX2V4dGVuc2lvbl9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zLWV4dGVuc2lvbi5jb25zdGFudHNcIik7XG52YXIgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiZG9tYWluL29iamVjdHMvb2JqZWN0cy1kb21haW4uY29uc3RhbnRzXCIpO1xudmFyIHNlcnZpY2VzX2NvbnN0YW50c18xID0gcmVxdWlyZShcInNlcnZpY2VzL3NlcnZpY2VzLmNvbnN0YW50c1wiKTtcbnZhciBjcmVhdG9yX2Rhc2hib2FyZF9wYWdlX2NvbnN0YW50c18xID0gcmVxdWlyZShcInBhZ2VzL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS5jb25zdGFudHNcIik7XG52YXIgQ3JlYXRvckRhc2hib2FyZFBhZ2VNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3JlYXRvckRhc2hib2FyZFBhZ2VNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8vIEVtcHR5IHBsYWNlaG9sZGVyIG1ldGhvZCB0byBzYXRpc2Z5IHRoZSBgQ29tcGlsZXJgLlxuICAgIENyZWF0b3JEYXNoYm9hcmRQYWdlTW9kdWxlLnByb3RvdHlwZS5uZ0RvQm9vdHN0cmFwID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENyZWF0b3JEYXNoYm9hcmRQYWdlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsXG4gICAgICAgICAgICAgICAgaHR0cF8xLkh0dHBDbGllbnRNb2R1bGVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBTZXJ2aWNlQm9vdHN0cmFwQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgU2VydmljZUJvb3RzdHJhcENvbXBvbmVudFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgY2xhc3NpZmllcnNfZXh0ZW5zaW9uX2NvbnN0YW50c18xLkNsYXNzaWZpZXJzRXh0ZW5zaW9uQ29uc3RhbnRzLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fc3VtbWFyeV90aWxlX2NvbnN0YW50c18xLkNvbGxlY3Rpb25TdW1tYXJ5VGlsZUNvbnN0YW50cyxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbnNfZXh0ZW5zaW9uX2NvbnN0YW50c18xLkludGVyYWN0aW9uc0V4dGVuc2lvbnNDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgb2JqZWN0c19kb21haW5fY29uc3RhbnRzXzEuT2JqZWN0c0RvbWFpbkNvbnN0YW50cyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlc19jb25zdGFudHNfMS5TZXJ2aWNlc0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICBjcmVhdG9yX2Rhc2hib2FyZF9wYWdlX2NvbnN0YW50c18xLkNyZWF0b3JEYXNoYm9hcmRDb25zdGFudHNcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBDcmVhdG9yRGFzaGJvYXJkUGFnZU1vZHVsZSk7XG4gICAgcmV0dXJuIENyZWF0b3JEYXNoYm9hcmRQYWdlTW9kdWxlO1xufSgpKTtcbnZhciBwbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWNcIik7XG52YXIgc3RhdGljXzIgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgYm9vdHN0cmFwRm4gPSBmdW5jdGlvbiAoZXh0cmFQcm92aWRlcnMpIHtcbiAgICB2YXIgcGxhdGZvcm1SZWYgPSBwbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfMS5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljKGV4dHJhUHJvdmlkZXJzKTtcbiAgICByZXR1cm4gcGxhdGZvcm1SZWYuYm9vdHN0cmFwTW9kdWxlKENyZWF0b3JEYXNoYm9hcmRQYWdlTW9kdWxlKTtcbn07XG52YXIgZG93bmdyYWRlZE1vZHVsZSA9IHN0YXRpY18yLmRvd25ncmFkZU1vZHVsZShib290c3RyYXBGbik7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnLCBbXG4gICAgJ2RuZExpc3RzJywgJ2hlYWRyb29tJywgJ2luZmluaXRlLXNjcm9sbCcsICduZ0FuaW1hdGUnLFxuICAgICduZ0F1ZGlvJywgJ25nQ29va2llcycsICduZ0ltZ0Nyb3AnLCAnbmdKb3lSaWRlJywgJ25nTWF0ZXJpYWwnLFxuICAgICduZ1Jlc291cmNlJywgJ25nU2FuaXRpemUnLCAnbmdUb3VjaCcsICdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJyxcbiAgICAndG9hc3RyJywgJ3VpLmJvb3RzdHJhcCcsICd1aS5zb3J0YWJsZScsICd1aS50cmVlJywgJ3VpLnZhbGlkYXRlJyxcbiAgICBkb3duZ3JhZGVkTW9kdWxlXG5dKVxuICAgIC8vIFRoaXMgZGlyZWN0aXZlIGlzIHRoZSBkb3duZ3JhZGVkIHZlcnNpb24gb2YgdGhlIEFuZ3VsYXIgY29tcG9uZW50IHRvXG4gICAgLy8gYm9vdHN0cmFwIHRoZSBBbmd1bGFyIDguXG4gICAgLmRpcmVjdGl2ZSgnc2VydmljZUJvb3RzdHJhcCcsIHN0YXRpY18xLmRvd25ncmFkZUNvbXBvbmVudCh7XG4gICAgY29tcG9uZW50OiBTZXJ2aWNlQm9vdHN0cmFwQ29tcG9uZW50XG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBzY3JpcHRzIGZvciB0aGUgY3JlYXRvciBkYXNoYm9hcmQuXG4gKi9cbi8vIFRoZSBtb2R1bGUgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBldmVyeXRoaW5nIGVsc2Ugc2luY2UgaXQgZGVmaW5lcyB0aGVcbi8vIG1haW4gbW9kdWxlIHRoZSBlbGVtZW50cyBhcmUgYXR0YWNoZWQgdG8uXG5yZXF1aXJlKCdwYWdlcy9jcmVhdG9yLWRhc2hib2FyZC1wYWdlL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UubW9kdWxlLnRzJyk7XG5yZXF1aXJlKCdBcHAudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2NyZWF0b3ItZGFzaGJvYXJkLXBhZ2UvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS5jb250cm9sbGVyLnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcnZpY2UgdG8gZGlzcGxheSBzdWdnZXN0aW9uIG1vZGFsIGluIGNyZWF0b3Igdmlldy5cbiAqL1xucmVxdWlyZSgnY29tcG9uZW50cy9jay1lZGl0b3ItaGVscGVycy9jay1lZGl0b3ItNC1ydGUuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL2NrLWVkaXRvci1oZWxwZXJzL2NrLWVkaXRvci00LXdpZGdldHMuaW5pdGlhbGl6ZXIudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL1N1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1N1Z2dlc3Rpb25Nb2RhbEZvckNyZWF0b3JEYXNoYm9hcmRTZXJ2aWNlJywgW1xuICAgICckaHR0cCcsICckbG9nJyxcbiAgICAnJHVpYk1vZGFsJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoJGh0dHAsICRsb2csICR1aWJNb2RhbCwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90ZW1wbGF0ZVVybCA9IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldERpcmVjdGl2ZVRlbXBsYXRlVXJsKCcvcGFnZXMvY3JlYXRvci1kYXNoYm9hcmQtcGFnZS9zdWdnZXN0aW9uLW1vZGFsLWZvci1jcmVhdG9yLXZpZXcvJyArXG4gICAgICAgICAgICAnc3VnZ2VzdGlvbi1tb2RhbC1mb3ItY3JlYXRvci12aWV3LmRpcmVjdGl2ZS5odG1sJyk7XG4gICAgICAgIHZhciBfc2hvd0VkaXRTdGF0ZUNvbnRlbnRTdWdnZXN0aW9uTW9kYWwgPSBmdW5jdGlvbiAoYWN0aXZlVGhyZWFkLCBzdWdnZXN0aW9uc1RvUmV2aWV3TGlzdCwgY2xlYXJBY3RpdmVUaHJlYWQsIGNhblJldmlld0FjdGl2ZVRocmVhZCkge1xuICAgICAgICAgICAgJHVpYk1vZGFsLm9wZW4oe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBfdGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgc2l6ZTogJ2xnJyxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25Jc0hhbmRsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVUaHJlYWQuaXNTdWdnZXN0aW9uSGFuZGxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlVGhyZWFkLmdldFN1Z2dlc3Rpb25TdGF0dXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVUaHJlYWQuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9sZENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVUaHJlYWQuc3VnZ2VzdGlvbi5vbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVRocmVhZC5zdWdnZXN0aW9uLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYW5SZXZpZXdBY3RpdmVUaHJlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5SZXZpZXdBY3RpdmVUaHJlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVRocmVhZC5zdWdnZXN0aW9uLnN0YXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVUaHJlYWQuc3VnZ2VzdGlvbi5zdWdnZXN0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICAgICAnJGxvZycsICckc2NvcGUnLCAnJHVpYk1vZGFsSW5zdGFuY2UnLCAnU3VnZ2VzdGlvbk1vZGFsU2VydmljZScsXG4gICAgICAgICAgICAgICAgICAgICdjYW5SZXZpZXdBY3RpdmVUaHJlYWQnLCAnZGVzY3JpcHRpb24nLCAnbmV3Q29udGVudCcsICdvbGRDb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXRlTmFtZScsICdzdWdnZXN0aW9uSXNIYW5kbGVkJywgJ3N1Z2dlc3Rpb25TdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAnc3VnZ2VzdGlvblR5cGUnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGxvZywgJHNjb3BlLCAkdWliTW9kYWxJbnN0YW5jZSwgU3VnZ2VzdGlvbk1vZGFsU2VydmljZSwgY2FuUmV2aWV3QWN0aXZlVGhyZWFkLCBkZXNjcmlwdGlvbiwgbmV3Q29udGVudCwgb2xkQ29udGVudCwgc3RhdGVOYW1lLCBzdWdnZXN0aW9uSXNIYW5kbGVkLCBzdWdnZXN0aW9uU3RhdHVzLCBzdWdnZXN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzTm90SGFuZGxlZCA9ICFzdWdnZXN0aW9uSXNIYW5kbGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNhblJlamVjdCA9ICRzY29wZS5pc05vdEhhbmRsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuQWNjZXB0ID0gJHNjb3BlLmlzTm90SGFuZGxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmlzTm90SGFuZGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWdnZXN0aW9uU3RhdHVzID09PSAoU3VnZ2VzdGlvbk1vZGFsU2VydmljZS5TVUdHRVNUSU9OX0FDQ0VQVEVEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZXJyb3JNZXNzYWdlID0gU3VnZ2VzdGlvbk1vZGFsU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLlNVR0dFU1RJT05fQUNDRVBURURfTVNHO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNTdWdnZXN0aW9uUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSBTdWdnZXN0aW9uTW9kYWxTZXJ2aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuU1VHR0VTVElPTl9SRUpFQ1RFRF9NU0c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5pc1N1Z2dlc3Rpb25SZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm9sZENvbnRlbnQgPSBvbGRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld0NvbnRlbnQgPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXRlTmFtZSA9IHN0YXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdWdnZXN0aW9uVHlwZSA9IHN1Z2dlc3Rpb25UeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbW1pdE1lc3NhZ2UgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXZpZXdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdW1tYXJ5TWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuUmV2aWV3QWN0aXZlVGhyZWFkID0gY2FuUmV2aWV3QWN0aXZlVGhyZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmctbW9kZWwgbmVlZHMgdG8gYmluZCB0byBhIHByb3BlcnR5IG9mIGFuIG9iamVjdCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNjb3BlICh0aGUgcHJvcGVydHkgY2Fubm90IHNpdCBkaXJlY3RseSBvbiB0aGUgc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2UgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzEyNjE4MzQyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3VnZ2VzdGlvbkRhdGEgPSB7IG5ld1N1Z2dlc3Rpb25IdG1sOiBuZXdDb250ZW50Lmh0bWwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdWdnZXN0aW9uRWRpdG9ySXNTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFjY2VwdFN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VnZ2VzdGlvbk1vZGFsU2VydmljZS5hY2NlcHRTdWdnZXN0aW9uKCR1aWJNb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogU3VnZ2VzdGlvbk1vZGFsU2VydmljZS5BQ1RJT05fQUNDRVBUX1NVR0dFU1RJT04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdE1lc3NhZ2U6ICRzY29wZS5jb21taXRNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZpZXdNZXNzYWdlOiAkc2NvcGUucmV2aWV3TWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVqZWN0U3VnZ2VzdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWdnZXN0aW9uTW9kYWxTZXJ2aWNlLnJlamVjdFN1Z2dlc3Rpb24oJHVpYk1vZGFsSW5zdGFuY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBTdWdnZXN0aW9uTW9kYWxTZXJ2aWNlLkFDVElPTl9SRUpFQ1RfU1VHR0VTVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0TWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2aWV3TWVzc2FnZTogJHNjb3BlLnJldmlld01lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdFN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN1Z2dlc3Rpb25FZGl0b3JJc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UuY2FuY2VsU3VnZ2VzdGlvbigkdWliTW9kYWxJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzRWRpdEJ1dHRvblNob3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoISRzY29wZS5pc05vdEhhbmRsZWQgJiYgJHNjb3BlLmlzU3VnZ2VzdGlvblJlamVjdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEkc2NvcGUuc3VnZ2VzdGlvbkVkaXRvcklzU2hvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5pc1Jlc3VibWl0QnV0dG9uU2hvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghJHNjb3BlLmlzTm90SGFuZGxlZCAmJiAkc2NvcGUuaXNTdWdnZXN0aW9uUmVqZWN0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN1Z2dlc3Rpb25FZGl0b3JJc1Nob3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNSZXN1Ym1pdEJ1dHRvbkRpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCRzY29wZS5zdW1tYXJ5TWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJHNjb3BlLnN1Z2dlc3Rpb25EYXRhLm5ld1N1Z2dlc3Rpb25IdG1sLnRyaW0oKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQuaHRtbC50cmltKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuY2VsRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnN1Z2dlc3Rpb25FZGl0b3JJc1Nob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlc3VibWl0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5jbG9zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogU3VnZ2VzdGlvbk1vZGFsU2VydmljZS5BQ1RJT05fUkVTVUJNSVRfU1VHR0VTVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3VnZ2VzdGlvbkh0bWw6ICRzY29wZS5zdWdnZXN0aW9uRGF0YS5uZXdTdWdnZXN0aW9uSHRtbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeU1lc3NhZ2U6ICRzY29wZS5zdW1tYXJ5TWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lOiAkc2NvcGUuc3RhdGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJHNjb3BlLnN1Z2dlc3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDb250ZW50OiAkc2NvcGUub2xkQ29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pLnJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgUkVTVUJNSVRfU1VHR0VTVElPTl9VUkxfVEVNUExBVEUgPSAoJy9zdWdnZXN0aW9uYWN0aW9uaGFuZGxlci9yZXN1Ym1pdC88c3VnZ2VzdGlvbl9pZD4nKTtcbiAgICAgICAgICAgICAgICB2YXIgSEFORExFX1NVR0dFU1RJT05fVVJMX1RFTVBMQVRFID0gKCcvc3VnZ2VzdGlvbmFjdGlvbmhhbmRsZXIvPHRhcmdldF90eXBlPi88dGFyZ2V0X2lkPi88c3VnZ2VzdGlvbl9pZD4nKTtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3Rpb24gPT09ICdyZXN1Ym1pdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN1Z2dlc3Rpb25UeXBlID09PSAnZWRpdF9leHBsb3JhdGlvbl9zdGF0ZV9jb250ZW50Jykge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5pbnRlcnBvbGF0ZVVybChSRVNVQk1JVF9TVUdHRVNUSU9OX1VSTF9URU1QTEFURSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbl9pZDogYWN0aXZlVGhyZWFkLnN1Z2dlc3Rpb24uc3VnZ2VzdGlvbklkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiByZXN1bHQuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeV9tZXNzYWdlOiByZXN1bHQuc3VtbWFyeU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQ6ICdlZGl0X3N0YXRlX3Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV9uYW1lOiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfbmFtZTogcmVzdWx0LnN0YXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRfdmFsdWU6IHJlc3VsdC5vbGRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld192YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sOiByZXN1bHQubmV3U3VnZ2VzdGlvbkh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5pbnRlcnBvbGF0ZVVybChIQU5ETEVfU1VHR0VTVElPTl9VUkxfVEVNUExBVEUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF90eXBlOiBhY3RpdmVUaHJlYWQuc3VnZ2VzdGlvbi50YXJnZXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2lkOiBhY3RpdmVUaHJlYWQuc3VnZ2VzdGlvbi50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25faWQ6IGFjdGl2ZVRocmVhZC5zdWdnZXN0aW9uLnN1Z2dlc3Rpb25JZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogcmVzdWx0LmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdF9tZXNzYWdlOiByZXN1bHQuY29tbWl0TWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmlld19tZXNzYWdlOiByZXN1bHQucmV2aWV3TWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkaHR0cC5wdXQodXJsLCBkYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWdnZXN0aW9uc1RvUmV2aWV3TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0W2ldID09PSBhY3RpdmVUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uc1RvUmV2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJBY3RpdmVUaHJlYWQoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ0Vycm9yIHJlc29sdmluZyBzdWdnZXN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNob3dTdWdnZXN0aW9uTW9kYWw6IGZ1bmN0aW9uIChzdWdnZXN0aW9uVHlwZSwgZXh0cmFQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGlvblR5cGUgPT09ICdlZGl0X2V4cGxvcmF0aW9uX3N0YXRlX2NvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaG93RWRpdFN0YXRlQ29udGVudFN1Z2dlc3Rpb25Nb2RhbChleHRyYVBhcmFtcy5hY3RpdmVUaHJlYWQsIGV4dHJhUGFyYW1zLnN1Z2dlc3Rpb25zVG9SZXZpZXdMaXN0LCBleHRyYVBhcmFtcy5jbGVhckFjdGl2ZVRocmVhZCwgZXh0cmFQYXJhbXMuY2FuUmV2aWV3QWN0aXZlVGhyZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcnZpY2UgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygc29sdXRpb24gdmFsaWRpdHkuXG4gKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBTb2x1dGlvblZhbGlkaXR5U2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb2x1dGlvblZhbGlkaXR5U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5zb2x1dGlvblZhbGlkaXRpZXMgPSB7fTtcbiAgICB9XG4gICAgU29sdXRpb25WYWxpZGl0eVNlcnZpY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoc3RhdGVOYW1lcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdGF0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25WYWxpZGl0aWVzW3N0YXRlTmFtZV0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlLnByb3RvdHlwZS5kZWxldGVTb2x1dGlvblZhbGlkaXR5ID0gZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zb2x1dGlvblZhbGlkaXRpZXNbc3RhdGVOYW1lXTtcbiAgICB9O1xuICAgIFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlLnByb3RvdHlwZS5vblJlbmFtZVN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlTmFtZSwgb2xkU3RhdGVOYW1lKSB7XG4gICAgICAgIHRoaXMuc29sdXRpb25WYWxpZGl0aWVzW25ld1N0YXRlTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5zb2x1dGlvblZhbGlkaXRpZXNbb2xkU3RhdGVOYW1lXTtcbiAgICAgICAgdGhpcy5kZWxldGVTb2x1dGlvblZhbGlkaXR5KG9sZFN0YXRlTmFtZSk7XG4gICAgfTtcbiAgICBTb2x1dGlvblZhbGlkaXR5U2VydmljZS5wcm90b3R5cGUudXBkYXRlVmFsaWRpdHkgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBzb2x1dGlvbklzVmFsaWQpIHtcbiAgICAgICAgdGhpcy5zb2x1dGlvblZhbGlkaXRpZXNbc3RhdGVOYW1lXSA9IHNvbHV0aW9uSXNWYWxpZDtcbiAgICB9O1xuICAgIFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlLnByb3RvdHlwZS5pc1NvbHV0aW9uVmFsaWQgPSBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnNvbHV0aW9uVmFsaWRpdGllcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb2x1dGlvblZhbGlkaXRpZXNbc3RhdGVOYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU29sdXRpb25WYWxpZGl0eVNlcnZpY2UucHJvdG90eXBlLmdldEFsbFZhbGlkaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbHV0aW9uVmFsaWRpdGllcztcbiAgICB9O1xuICAgIFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlKTtcbiAgICByZXR1cm4gU29sdXRpb25WYWxpZGl0eVNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5Tb2x1dGlvblZhbGlkaXR5U2VydmljZSA9IFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnU29sdXRpb25WYWxpZGl0eVNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFNvbHV0aW9uVmFsaWRpdHlTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcnZpY2UgdGhhdCBwcm92aWRlcyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gZGlzcGxheSB0aGVcbiAqIHN0YXR1cyBsYWJlbCBmb3IgYSB0aHJlYWQgaW4gdGhlIGZlZWRiYWNrIHRhYiBvZiB0aGUgZXhwbG9yYXRpb24gZWRpdG9yLlxuICovXG52YXIgY2xvbmVEZWVwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIikpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlKCkge1xuICAgICAgICB0aGlzLlNUQVRVU19DSE9JQ0VTID0gY2xvbmVEZWVwXzEuZGVmYXVsdChUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZV8xLl9TVEFUVVNfQ0hPSUNFUyk7XG4gICAgfVxuICAgIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlXzEgPSBUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZTtcbiAgICBUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZS5wcm90b3R5cGUuZ2V0TGFiZWxDbGFzcyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xhYmVsIGxhYmVsLWluZm8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2NvbXBsaW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xhYmVsIGxhYmVsLXN1Y2Nlc3MnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdsYWJlbCBsYWJlbC1kZWZhdWx0JztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2UucHJvdG90eXBlLmdldEh1bWFuUmVhZGFibGVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2VfMS5fU1RBVFVTX0NIT0lDRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZV8xLl9TVEFUVVNfQ0hPSUNFU1tpXS5pZCA9PT0gc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlXzEuX1NUQVRVU19DSE9JQ0VTW2ldLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgdmFyIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlXzE7XG4gICAgVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2UuX1NUQVRVU19DSE9JQ0VTID0gW3tcbiAgICAgICAgICAgIGlkOiAnb3BlbicsXG4gICAgICAgICAgICB0ZXh0OiAnT3BlbidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWQ6ICdmaXhlZCcsXG4gICAgICAgICAgICB0ZXh0OiAnRml4ZWQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGlkOiAnaWdub3JlZCcsXG4gICAgICAgICAgICB0ZXh0OiAnSWdub3JlZCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWQ6ICdjb21wbGltZW50JyxcbiAgICAgICAgICAgIHRleHQ6ICdDb21wbGltZW50J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZDogJ25vdF9hY3Rpb25hYmxlJyxcbiAgICAgICAgICAgIHRleHQ6ICdOb3QgQWN0aW9uYWJsZSdcbiAgICAgICAgfV07XG4gICAgVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2UgPSBUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlKTtcbiAgICByZXR1cm4gVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5UaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZSA9IFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnVGhyZWFkU3RhdHVzRGlzcGxheVNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgZGlzcGxheWluZyB0aGUgbGlzdCBvZiB0aHJlYWRzIGluIHRoZSBmZWVkYmFja1xuICogdGFiIG9mIHRoZSBleHBsb3JhdGlvbiBlZGl0b3IuXG4gKi9cbnJlcXVpcmUoJ2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy90cnVuY2F0ZS5maWx0ZXIudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2V4cGxvcmF0aW9uLWVkaXRvci1wYWdlL2ZlZWRiYWNrLXRhYi9zZXJ2aWNlcy8nICtcbiAgICAndGhyZWFkLXN0YXR1cy1kaXNwbGF5LnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0RhdGVUaW1lRm9ybWF0U2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCd0aHJlYWRUYWJsZScsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2tSb3c6ICc9JyxcbiAgICAgICAgICAgICAgICBnZXRUaHJlYWRzOiAnJnRocmVhZHMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldERpcmVjdGl2ZVRlbXBsYXRlVXJsKCcvcGFnZXMvZXhwbG9yYXRpb24tZWRpdG9yLXBhZ2UvZmVlZGJhY2stdGFiL3RocmVhZC10YWJsZS8nICtcbiAgICAgICAgICAgICAgICAndGhyZWFkLXRhYmxlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRzY29wZScsICdUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZScsICdEYXRlVGltZUZvcm1hdFNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsIFRocmVhZFN0YXR1c0Rpc3BsYXlTZXJ2aWNlLCBEYXRlVGltZUZvcm1hdFNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmdldExhYmVsQ2xhc3MgPSBUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZS5nZXRMYWJlbENsYXNzO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZ2V0SHVtYW5SZWFkYWJsZVN0YXR1cyA9IChUaHJlYWRTdGF0dXNEaXNwbGF5U2VydmljZS5nZXRIdW1hblJlYWRhYmxlU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmdldExvY2FsZUFiYnJldmlhdGVkRGF0ZXRpbWVTdHJpbmcgPSAoRGF0ZVRpbWVGb3JtYXRTZXJ2aWNlLmdldExvY2FsZUFiYnJldmlhdGVkRGF0ZXRpbWVTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRmFjaWxpdGF0ZXMgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBjdXJyZW50IGludGVyYWN0aW9uXG4gKiBhbmQgdGhlIHByb2dyZXNzIG5hdi4gVGhlIGZvcm1lciBob2xkcyBkYXRhIGFib3V0IHRoZSBsZWFybmVyJ3MgYW5zd2VyLFxuICogd2hpbGUgdGhlIGxhdHRlciBjb250YWlucyB0aGUgYWN0dWFsIFwiU3VibWl0XCIgYnV0dG9uIHdoaWNoIHRyaWdnZXJzIHRoZVxuICogYW5zd2VyIHN1Ym1pc3Npb24gcHJvY2Vzcy5cbiAqL1xucmVxdWlyZSgnY29tcG9uZW50cy9zdGF0ZS1lZGl0b3Ivc3RhdGUtZWRpdG9yLXByb3BlcnRpZXMtc2VydmljZXMvJyArXG4gICAgJ3N0YXRlLWVkaXRvci5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdjb21wb25lbnRzL3N0YXRlLWVkaXRvci9zdGF0ZS1lZGl0b3ItcHJvcGVydGllcy1zZXJ2aWNlcy8nICtcbiAgICAnc3RhdGUtaW50ZXJhY3Rpb24taWQuc2VydmljZS50cycpO1xucmVxdWlyZSgnY29tcG9uZW50cy9zdGF0ZS1lZGl0b3Ivc3RhdGUtZWRpdG9yLXByb3BlcnRpZXMtc2VydmljZXMvJyArXG4gICAgJ3N0YXRlLXByb3BlcnR5LnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0NvbnRleHRTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlJywgW1xuICAgICdDb250ZXh0U2VydmljZScsICdTdGF0ZUVkaXRvclNlcnZpY2UnLCAnU3RhdGVJbnRlcmFjdGlvbklkU2VydmljZScsIGZ1bmN0aW9uIChDb250ZXh0U2VydmljZSwgU3RhdGVFZGl0b3JTZXJ2aWNlLCBTdGF0ZUludGVyYWN0aW9uSWRTZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfc3VibWl0QW5zd2VyRm4gPSBudWxsO1xuICAgICAgICB2YXIgX29uU3VibWl0Rm4gPSBudWxsO1xuICAgICAgICB2YXIgX3ZhbGlkaXR5Q2hlY2tGbiA9IG51bGw7XG4gICAgICAgIHZhciBfcHJlc3VibWl0SG9va3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldE9uU3VibWl0Rm46IGZ1bmN0aW9uIChvblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBDb252ZXJzYXRpb25Ta2luRGlyZWN0aXZlIHNob3VsZCByZWdpc3RlciBpdHMgb25TdWJtaXRcbiAgICAgICAgICAgICAgICAgKiBjYWxsYmFjayBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihhbnN3ZXIsIGludGVyYWN0aW9uUnVsZXNTZXJ2aWNlKX0gb25TdWJtaXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfb25TdWJtaXRGbiA9IG9uU3VibWl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uOiBmdW5jdGlvbiAoc3VibWl0QW5zd2VyRm4sIHZhbGlkaXR5Q2hlY2tGbikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVhY2ggaW50ZXJhY3Rpb24gZGlyZWN0aXZlIHNob3VsZCBjYWxsIHJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uXG4gICAgICAgICAgICAgICAgICogd2hlbiB0aGUgaW50ZXJhY3Rpb24gZGlyZWN0aXZlIGlzIGZpcnN0IGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IHN1Ym1pdEFuc3dlckZuIC0gU2hvdWxkIGdyYWIgdGhlIGxlYXJuZXInc1xuICAgICAgICAgICAgICAgICAqICAgYW5zd2VyIGFuZCBwYXNzIGl0IHRvIG9uU3VibWl0LiBUaGUgaW50ZXJhY3Rpb24gY2FuIHBhc3MgaW5cbiAgICAgICAgICAgICAgICAgKiAgIG51bGwgaWYgaXQgZG9lcyBub3QgdXNlIHRoZSBwcm9ncmVzcyBuYXYncyBzdWJtaXQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICogICAoZXg6IE11bHRpcGxlQ2hvaWNlSW5wdXQpLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHZhbGlkaXR5Q2hlY2tGbiAtIFRoZSBwcm9ncmVzcyBuYXYgd2lsbCB1c2UgdGhpc1xuICAgICAgICAgICAgICAgICAqICAgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRvIGRpc2FibGUgdGhlIHN1Ym1pdCBidXR0b24uIElmIHRoZVxuICAgICAgICAgICAgICAgICAqICAgaW50ZXJhY3Rpb24gcGFzc2VzIGluIG51bGwsIHRoZSBzdWJtaXQgYnV0dG9uIHdpbGwgcmVtYWluXG4gICAgICAgICAgICAgICAgICogICBlbmFibGVkIChmb3IgdGhlIGVudGlyZSBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBpbnRlcmFjdGlvbikuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgX3N1Ym1pdEFuc3dlckZuID0gc3VibWl0QW5zd2VyRm4gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBfdmFsaWRpdHlDaGVja0ZuID0gdmFsaWRpdHlDaGVja0ZuIHx8IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJQcmVzdWJtaXRIb29rOiBmdW5jdGlvbiAoaG9va0ZuKSB7XG4gICAgICAgICAgICAgICAgLyogUmVnaXN0ZXIgYSBob29rIHRoYXQgd2lsbCBiZSBjYWxsZWQgcmlnaHQgYmVmb3JlIG9uU3VibWl0LlxuICAgICAgICAgICAgICAgICAqIEFsbCBob29rcyBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gd2lsbCBiZSBjbGVhcmVkIHJpZ2h0XG4gICAgICAgICAgICAgICAgICogYmVmb3JlIGxvYWRpbmcgdGhlIG5leHQgY2FyZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBfcHJlc3VibWl0SG9va3MucHVzaChob29rRm4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyUHJlc3VibWl0SG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvKiBDbGVhciBvdXQgYWxsIHRoZSBob29rcyBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24uIFNob3VsZFxuICAgICAgICAgICAgICAgICAqIGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyB0aGUgbmV4dCBjYXJkLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIF9wcmVzdWJtaXRIb29rcyA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU3VibWl0OiBmdW5jdGlvbiAoYW5zd2VyLCBpbnRlcmFjdGlvblJ1bGVzU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3ByZXN1Ym1pdEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcmVzdWJtaXRIb29rc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfb25TdWJtaXRGbihhbnN3ZXIsIGludGVyYWN0aW9uUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJtaXRBbnN3ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIHN0YXJ0cyB0aGUgYW5zd2VyIHN1Ym1pdCBwcm9jZXNzLCBpdCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgdGhlXG4gICAgICAgICAgICAgICAgICogbGVhcm5lciBwcmVzc2VzIHRoZSBcIlN1Ym1pdFwiIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoX3N1Ym1pdEFuc3dlckZuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsSW5mbyA9ICgnXFxuVW5kZWZpbmVkIHN1Ym1pdCBhbnN3ZXIgZGVidWcgbG9nczonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5JbnRlcmFjdGlvbiBJRDogJyArIFN0YXRlSW50ZXJhY3Rpb25JZFNlcnZpY2Uuc2F2ZWRNZW1lbnRvICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5FeHBsb3JhdGlvbiBJRDogJyArIENvbnRleHRTZXJ2aWNlLmdldEV4cGxvcmF0aW9uSWQoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuU3RhdGUgbmFtZTogJyArIFN0YXRlRWRpdG9yU2VydmljZS5nZXRBY3RpdmVTdGF0ZU5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgY3VycmVudCBpbnRlcmFjdGlvbiBkaWQgbm90ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIGEgX3N1Ym1pdEFuc3dlckZuLicgKyBhZGRpdGlvbmFsSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc3VibWl0QW5zd2VyRm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdWJtaXRCdXR0b25EaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8qIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIFN1Ym1pdCBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkIGJhc2VkIG9uXG4gICAgICAgICAgICAgICAgICogdGhlIHZhbGlkaXR5IG9mIHRoZSBjdXJyZW50IGFuc3dlci4gSWYgdGhlIGludGVyYWN0aW9uIGRvZXMgbm90IHBhc3NcbiAgICAgICAgICAgICAgICAgKiBpbiBhIF92YWxpZGl0eUNoZWNrRm4sIHRoZW4gX3ZhbGlkaXR5Q2hlY2tGbiB3aWxsIGJlIG51bGwgYW5kIGJ5XG4gICAgICAgICAgICAgICAgICogZGVmYXVsdCB3ZSBhc3N1bWUgdGhlIGFuc3dlciBpcyB2YWxpZCwgc28gdGhlIHN1Ym1pdCBidXR0b24gc2hvdWxkXG4gICAgICAgICAgICAgICAgICogbm90IGJlIGRpc2FibGVkLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChfdmFsaWRpdHlDaGVja0ZuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFfdmFsaWRpdHlDaGVja0ZuKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTZXJ2aWNlIGZvciBjb2RlIG5vcm1hbGl6YXRpb24uIFVzZWQgYnkgdGhlIGNvZGUgUkVQTFxuICogYW5kIHBlbmNpbCBjb2RlIGludGVyYWN0aW9ucy5cbiAqL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIENvZGVOb3JtYWxpemVyU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlTm9ybWFsaXplclNlcnZpY2UoKSB7XG4gICAgfVxuICAgIENvZGVOb3JtYWxpemVyU2VydmljZS5wcm90b3R5cGUucmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvZywgJycpO1xuICAgIH07XG4gICAgQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKyQvZywgJycpO1xuICAgIH07XG4gICAgQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmVJbnRlcm1lZGlhdGVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9O1xuICAgIENvZGVOb3JtYWxpemVyU2VydmljZS5wcm90b3R5cGUuZ2V0Tm9ybWFsaXplZENvZGUgPSBmdW5jdGlvbiAoY29kZVN0cmluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKlxuICAgICAgICAgKiBOb3JtYWxpemVzIGEgY29kZSBzdHJpbmcgKHdoaWNoIGlzIGFzc3VtZWQgbm90IHRvIGNvbnRhaW4gdGFiXG4gICAgICAgICAqIGNoYXJhY3RlcnMpLiBJbiBwYXJ0aWN1bGFyOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIFN0cmlwcyBvdXQgbGluZXMgdGhhdCBzdGFydCB3aXRoICcjJyAoY29tbWVudHMpLCBwb3NzaWJseSBwcmVjZWRlZCBieVxuICAgICAgICAgKiAgICAgd2hpdGVzcGFjZS5cbiAgICAgICAgICogLSBUcmltcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9uIGVhY2ggbGluZSwgYW5kIG5vcm1hbGl6ZXMgbXVsdGlwbGVcbiAgICAgICAgICogICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB3aXRoaW4gYSBzaW5nbGUgbGluZSBpbnRvIG9uZSBzcGFjZVxuICAgICAgICAgKiAgICAgY2hhcmFjdGVyLlxuICAgICAgICAgKiAtIFJlbW92ZXMgYmxhbmsgbmV3bGluZXMuXG4gICAgICAgICAqIC0gTWFrZSB0aGUgaW5kZW50YXRpb24gbGV2ZWwgZm91ciBzcGFjZXMuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPKHNsbCk6IEF1Z21lbnQgdGhpcyBmdW5jdGlvbiB0byBzdHJpcCBvdXQgY29tbWVudHMgdGhhdCBvY2N1ciBhdFxuICAgICAgICAvLyB0aGUgZW5kIG9mIGEgbGluZS4gSG93ZXZlciwgYmUgY2FyZWZ1bCB3aXRoIGxpbmVzIHdoZXJlICcjJyBpc1xuICAgICAgICAvLyBjb250YWluZWQgaW4gcXVvdGVzIG9yIHRoZSBjaGFyYWN0ZXIgaXMgZXNjYXBlZC5cbiAgICAgICAgdmFyIEZPVVJfU1BBQ0VTID0gJyAgICAnO1xuICAgICAgICAvLyBNYXBzIHRoZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lIHRvIGFuIGludFxuICAgICAgICAvLyBzcGVjaWZ5aW5nIHRoZSBkZXNpcmVkIGluZGVudGF0aW9uIGxldmVsLlxuICAgICAgICB2YXIgbnVtU3BhY2VzVG9EZXNpcmVkSW5kZW50TGV2ZWwgPSB7XG4gICAgICAgICAgICAwOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb2RlTGluZXMgPSB0aGlzLnJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlU3RyaW5nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBub3JtYWxpemVkQ29kZUxpbmVzID0gW107XG4gICAgICAgIGNvZGVMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UobGluZSkuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZSA9IF90aGlzLnJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZShsaW5lKTtcbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1TcGFjZXMgPSBsaW5lLmxlbmd0aCAtIF90aGlzLnJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlKGxpbmUpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ051bVNwYWNlcyA9IE9iamVjdC5rZXlzKG51bVNwYWNlc1RvRGVzaXJlZEluZGVudExldmVsKTtcbiAgICAgICAgICAgIHZhciBtYXhOdW1TcGFjZXMgPSBNYXRoLm1heC5hcHBseShudWxsLCBleGlzdGluZ051bVNwYWNlcyk7XG4gICAgICAgICAgICBpZiAobnVtU3BhY2VzID4gbWF4TnVtU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgbmV3IGluZGVudGF0aW9uIGxldmVsXG4gICAgICAgICAgICAgICAgbnVtU3BhY2VzVG9EZXNpcmVkSW5kZW50TGV2ZWxbbnVtU3BhY2VzXSA9IGV4aXN0aW5nTnVtU3BhY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc2V0IHdoZW4gdGhlIGluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IHNjb3BlLCBhbmQgYWxzbyBkb2VzIG5vdCBtYXRjaCBhbnkgcHJldmlvdXMgaW5kZW50YXRpb25cbiAgICAgICAgICAgIC8vIGxldmVsLiBUaGlzIGNhc2UgaXMgYWN0dWFsbHkgaW52YWxpZCwgYnV0IGZvciBub3csIHdlIHRha2UgdGhlXG4gICAgICAgICAgICAvLyBsYXJnZXN0IGluZGVudGF0aW9uIGxldmVsIHRoYXQgaXMgbGVzcyB0aGFuIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gVE9ETyhzbGwpOiBCYWQgaW5kZW50YXRpb24gc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBuZWFyZXIgdGhlXG4gICAgICAgICAgICAvLyBzb3VyY2UuXG4gICAgICAgICAgICB2YXIgaXNTaG9ydGZhbGxMaW5lID0gIW51bVNwYWNlc1RvRGVzaXJlZEluZGVudExldmVsLmhhc093blByb3BlcnR5KG51bVNwYWNlcykgJiZcbiAgICAgICAgICAgICAgICBudW1TcGFjZXMgPCBtYXhOdW1TcGFjZXM7XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgZXhpc3RpbmcgaW5kZW50YXRpb24gbGV2ZWxzIHRvIHRoZSByaWdodCBvZiB0aGlzIG9uZS5cbiAgICAgICAgICAgIGZvciAodmFyIGluZGVudExlbmd0aCBpbiBudW1TcGFjZXNUb0Rlc2lyZWRJbmRlbnRMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIoaW5kZW50TGVuZ3RoKSA+IG51bVNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbnVtU3BhY2VzVG9EZXNpcmVkSW5kZW50TGV2ZWxbaW5kZW50TGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTaG9ydGZhbGxMaW5lKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdOdW1TcGFjZXMgPSBPYmplY3Qua2V5cyhudW1TcGFjZXNUb0Rlc2lyZWRJbmRlbnRMZXZlbCk7XG4gICAgICAgICAgICAgICAgbnVtU3BhY2VzID0gTWF0aC5tYXguYXBwbHkobnVsbCwgZXhpc3RpbmdOdW1TcGFjZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRMaW5lID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNwYWNlc1RvRGVzaXJlZEluZGVudExldmVsW251bVNwYWNlc107IGkrKykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRMaW5lICs9IEZPVVJfU1BBQ0VTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZExpbmUgKz0gX3RoaXMucmVtb3ZlSW50ZXJtZWRpYXRlV2hpdGVzcGFjZShfdGhpcy5yZW1vdmVMZWFkaW5nV2hpdGVzcGFjZShsaW5lKSk7XG4gICAgICAgICAgICBub3JtYWxpemVkQ29kZUxpbmVzLnB1c2gobm9ybWFsaXplZExpbmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRDb2RlTGluZXMuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICBDb2RlTm9ybWFsaXplclNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pXG4gICAgXSwgQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlKTtcbiAgICByZXR1cm4gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlID0gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShDb2RlTm9ybWFsaXplclNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VydmljZSB0byBoYW5kbGUgY29tbW9uIGNvZGUgZm9yIHN1Z2dlc3Rpb24gbW9kYWwgZGlzcGxheS5cbiAqL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3VnZ2VzdGlvbk1vZGFsU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5TVUdHRVNUSU9OX0FDQ0VQVEVEX01TRyA9ICgnVGhpcyBzdWdnZXN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gYWNjZXB0ZWQuJyk7XG4gICAgICAgIHRoaXMuU1VHR0VTVElPTl9SRUpFQ1RFRF9NU0cgPSAoJ1RoaXMgc3VnZ2VzdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlamVjdGVkLicpO1xuICAgICAgICB0aGlzLlNVR0dFU1RJT05fSU5WQUxJRF9NU0cgPSAoJ1RoaXMgc3VnZ2VzdGlvbiB3YXMgbWFkZSBmb3IgYSBzdGF0ZSB0aGF0IG5vIGxvbmdlciBleGlzdHMuJyArXG4gICAgICAgICAgICAnIEl0IGNhbm5vdCBiZSBhY2NlcHRlZC4nKTtcbiAgICAgICAgdGhpcy5VTlNBVkVEX0NIQU5HRVNfTVNHID0gKCdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMgdG8gdGhpcyBleHBsb3JhdGlvbi4gUGxlYXNlIHNhdmUvZGlzY2FyZCB5b3VyICcgK1xuICAgICAgICAgICAgJ3Vuc2F2ZWQgY2hhbmdlcyBpZiB5b3Ugd2lzaCB0byBhY2NlcHQuJyk7XG4gICAgICAgIHRoaXMuQUNUSU9OX0FDQ0VQVF9TVUdHRVNUSU9OID0gJ2FjY2VwdCc7XG4gICAgICAgIHRoaXMuQUNUSU9OX1JFSkVDVF9TVUdHRVNUSU9OID0gJ3JlamVjdCc7XG4gICAgICAgIHRoaXMuQUNUSU9OX1JFU1VCTUlUX1NVR0dFU1RJT04gPSAncmVzdWJtaXQnO1xuICAgICAgICB0aGlzLlNVR0dFU1RJT05fQUNDRVBURUQgPSAnYWNjZXB0ZWQnO1xuICAgICAgICB0aGlzLlNVR0dFU1RJT05fUkVKRUNURUQgPSAncmVqZWN0ZWQnO1xuICAgIH1cbiAgICAvLyBUT0RPKFlhc2hKaXBrYXRlKTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBzaW5jZSAnJHVpYk1vZGFsSW5zdGFuY2UnIGlzIGEgQW5ndWxhckpTIG5hdGl2ZSBvYmplY3QgYW5kIGRvZXMgbm90XG4gICAgLy8gaGF2ZSBhIFRTIGludGVyZmFjZS5cbiAgICBTdWdnZXN0aW9uTW9kYWxTZXJ2aWNlLnByb3RvdHlwZS5hY2NlcHRTdWdnZXN0aW9uID0gZnVuY3Rpb24gKCR1aWJNb2RhbEluc3RhbmNlLCBwYXJhbURpY3QpIHtcbiAgICAgICAgJHVpYk1vZGFsSW5zdGFuY2UuY2xvc2UocGFyYW1EaWN0KTtcbiAgICB9O1xuICAgIC8vIFRPRE8oWWFzaEppcGthdGUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIHNpbmNlICckdWliTW9kYWxJbnN0YW5jZScgaXMgYSBBbmd1bGFySlMgbmF0aXZlIG9iamVjdCBhbmQgZG9lcyBub3RcbiAgICAvLyBoYXZlIGEgVFMgaW50ZXJmYWNlLlxuICAgIFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UucHJvdG90eXBlLnJlamVjdFN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAoJHVpYk1vZGFsSW5zdGFuY2UsIHBhcmFtRGljdCkge1xuICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5jbG9zZShwYXJhbURpY3QpO1xuICAgIH07XG4gICAgLy8gVE9ETyhZYXNoSmlwa2F0ZSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgc2luY2UgJyR1aWJNb2RhbEluc3RhbmNlJyBpcyBhIEFuZ3VsYXJKUyBuYXRpdmUgb2JqZWN0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGhhdmUgYSBUUyBpbnRlcmZhY2UuXG4gICAgU3VnZ2VzdGlvbk1vZGFsU2VydmljZS5wcm90b3R5cGUuY2FuY2VsU3VnZ2VzdGlvbiA9IGZ1bmN0aW9uICgkdWliTW9kYWxJbnN0YW5jZSkge1xuICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5kaXNtaXNzKCdjYW5jZWwnKTtcbiAgICB9O1xuICAgIFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pXG4gICAgXSwgU3VnZ2VzdGlvbk1vZGFsU2VydmljZSk7XG4gICAgcmV0dXJuIFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5TdWdnZXN0aW9uTW9kYWxTZXJ2aWNlID0gU3VnZ2VzdGlvbk1vZGFsU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1N1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFN1Z2dlc3Rpb25Nb2RhbFNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29uc3RhbnRzIGZvciBjbGFzc2ZpZXJzIGV4dGVuc2lvbnMuXG4gKi9cbi8vIFRPRE8oIzcwOTIpOiBEZWxldGUgdGhpcyBmaWxlIG9uY2UgbWlncmF0aW9uIGlzIGNvbXBsZXRlIGFuZCB0aGVzZSBBbmd1bGFySlNcbi8vIGVxdWl2YWxlbnRzIG9mIHRoZSBBbmd1bGFyIGNvbnN0YW50cyBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbnZhciBjbGFzc2lmaWVyc19leHRlbnNpb25fY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiY2xhc3NpZmllcnMvY2xhc3NpZmllcnMtZXh0ZW5zaW9uLmNvbnN0YW50c1wiKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmNvbnN0YW50KCdQeXRob25Qcm9ncmFtVG9rZW5UeXBlJywgY2xhc3NpZmllcnNfZXh0ZW5zaW9uX2NvbnN0YW50c18xLkNsYXNzaWZpZXJzRXh0ZW5zaW9uQ29uc3RhbnRzLlB5dGhvblByb2dyYW1Ub2tlblR5cGUpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgZm9yIGNsYXNzZmllcnMgZXh0ZW5zaW9ucy5cbiAqL1xudmFyIENsYXNzaWZpZXJzRXh0ZW5zaW9uQ29uc3RhbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsYXNzaWZpZXJzRXh0ZW5zaW9uQ29uc3RhbnRzKCkge1xuICAgIH1cbiAgICBDbGFzc2lmaWVyc0V4dGVuc2lvbkNvbnN0YW50cy5QeXRob25Qcm9ncmFtVG9rZW5UeXBlID0ge1xuICAgICAgICBDT01NRU5UOiAnQ09NTUVOVCcsXG4gICAgICAgIE5MOiAnTkwnLFxuICAgICAgICBTVFJJTkc6ICdTVFJJTkcnLFxuICAgICAgICBJTkRFTlQ6ICdJTkRFTlQnLFxuICAgICAgICBERURFTlQ6ICdERURFTlQnLFxuICAgICAgICBFTkRNQVJLRVI6ICdFTkRNQVJLRVInLFxuICAgICAgICBOVU1CRVI6ICdOVU1CRVInLFxuICAgICAgICBOQU1FOiAnTkFNRScsXG4gICAgICAgIE9QOiAnT1AnLFxuICAgICAgICBFUlJPUlRPS0VOOiAnRVJST1JUT0tFTidcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc2lmaWVyc0V4dGVuc2lvbkNvbnN0YW50cztcbn0oKSk7XG5leHBvcnRzLkNsYXNzaWZpZXJzRXh0ZW5zaW9uQ29uc3RhbnRzID0gQ2xhc3NpZmllcnNFeHRlbnNpb25Db25zdGFudHM7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZlY3Rvcml6ZXIgZnVuY3Rpb24gd2hpY2ggbWlycm9ycyB0aGUgQ291bnRWZWN0b3JpemVyIGZlYXR1cmVcbiAqIGV4dHJhY3RvciBvZiBza2xlYXJuLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgVmVjdG9yaXplciBmdW5jdGlvbiB1c2VzIHRoZSB2b2NhYnVsYXJ5IHRoYXQgd2FzXG4gKiBleHRyYWN0ZWQgZHVyaW5nIHRoZSB0cmFpbmluZy4gRHVyaW5nIHRyYWluaW5nIHNjaWtpdCdzXG4gKiBDb3VudFZlY3Rvcml6ZXIgY2xhc3MgaXMgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLiBJZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAqIGluIHNjaWtpdCdzIENvdW50VmVjdG9yaXplIGNsYXNzIHRoZW4gY29ycmVzcG9uZGluZyBjaGFuZ2VzIG11c3QgYmVcbiAqIHByb3BhZ2F0ZWQgaGVyZS5cbiAqL1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIENvdW50VmVjdG9yaXplclNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ291bnRWZWN0b3JpemVyU2VydmljZSgpIHtcbiAgICB9XG4gICAgQ291bnRWZWN0b3JpemVyU2VydmljZS5wcm90b3R5cGUudmVjdG9yaXplID0gZnVuY3Rpb24gKHRva2Vucywgdm9jYWJ1bGFyeSkge1xuICAgICAgICB2YXIgdmVjdG9yTGVuZ3RoID0gT2JqZWN0LmtleXModm9jYWJ1bGFyeSkubGVuZ3RoO1xuICAgICAgICB2YXIgdmVjdG9yID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVjdG9yTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlY3Rvci5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodm9jYWJ1bGFyeS5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB2ZWN0b3Jbdm9jYWJ1bGFyeVt0b2tlbl1dICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH07XG4gICAgQ291bnRWZWN0b3JpemVyU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSlcbiAgICBdLCBDb3VudFZlY3Rvcml6ZXJTZXJ2aWNlKTtcbiAgICByZXR1cm4gQ291bnRWZWN0b3JpemVyU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkNvdW50VmVjdG9yaXplclNlcnZpY2UgPSBDb3VudFZlY3Rvcml6ZXJTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnQ291bnRWZWN0b3JpemVyU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoQ291bnRWZWN0b3JpemVyU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTcgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUb2tlbml6ZXIgZm9yIFB5dGhvbiBjb2RlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgdG9rZW5pemVyIGlzIGJ1aWx0IHVzaW5nIFB5dGhvbidzIG93biB0b2tlbml6ZXIgbW9kdWxlLlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSBzaW1wbHkgdHJhbnNsYXRlZCBmcm9tIFB5dGhvbiBjb2RlIHRvIEpTIGNvZGUgYW5kIHRoZXlcbiAqIGJvdGggZG8gc2FtZSB0YXNrLiBUaGUgdW5uZWNlc3NhcnkgY29kZSBmcm9tIFB5dGhvbidzIHRva2VuaXplciBtb2R1bGVcbiAqIGhhcyBiZWVuIHJlbW92ZWQgYmVmb3JlIHRyYW5zbGF0aW5nIGl0IGludG8gSlMgYW5kIGNvZGUgcmVsZXZhbnQgdG9cbiAqIGdlbmVyYXRpbmcgdG9rZW5zIGhhcyBiZWVuIGtlcHQgaW50YWN0LiBJZiBQeXRob24gdmVyc2lvbiBjaGFuZ2VzIG9uIE9wcGlhLW1sXG4gKiB0aGVuIGNoYW5nZXMgaW4gUHl0aG9uJ3MgdG9rZW5pemVyIG1vZHVsZSBtdXN0IGJlIHByb3BhZ2F0ZWQgaGVyZS5cbiAqXG4gKiBQeXRob24ncyB0b2tlbml6ZXIgbW9kdWxlIGZvciBQeXRob24gdmVyc2lvbiAyLjc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi8yLjcvTGliL3Rva2VuaXplLnB5XG4gKi9cbnJlcXVpcmUoJ2NsYXNzaWZpZXJzL2NsYXNzaWZpZXJzLWV4dGVuc2lvbi5jb25zdGFudHMuYWpzLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdQeXRob25Qcm9ncmFtVG9rZW5pemVyJywgW1xuICAgICckbG9nJywgJ1B5dGhvblByb2dyYW1Ub2tlblR5cGUnLCBmdW5jdGlvbiAoJGxvZywgUHl0aG9uUHJvZ3JhbVRva2VuVHlwZSkge1xuICAgICAgICB2YXIgZ3JvdXBPZlJlZ0V4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnKCcgKyBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKHBhcmFtcywgJ3wnKSArICcpJztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlZ0V4TWF5QmVQcmVzZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwT2ZSZWdFeChwYXJhbXMpICsgJz8nO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVwZWF0ZWRSZWdFeCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cE9mUmVnRXgocGFyYW1zKSArICcqJztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSAnWyBcXFxcZlxcXFx0XSonO1xuICAgICAgICB2YXIgY29tbWVudCA9ICcjW15cXFxcclxcXFxuXSonO1xuICAgICAgICB2YXIgaWdub3JlID0gd2hpdGVzcGFjZSArIHJlcGVhdGVkUmVnRXgoJ1xcXFxcXFxcXFxcXHI/XFxcXG4nICsgd2hpdGVzcGFjZSkgKyByZWdFeE1heUJlUHJlc2VudChjb21tZW50KTtcbiAgICAgICAgdmFyIG5hbWUgPSAnW2EtekEtWl9dXFxcXHcqJztcbiAgICAgICAgdmFyIGhleG51bWJlciA9ICcwW3hYXVtcXFxcZGEtZkEtRl0rW2xMXT8nO1xuICAgICAgICB2YXIgb2N0bnVtYmVyID0gJygwW29PXVswLTddKyl8KDBbMC03XSopW2xMXT8nO1xuICAgICAgICB2YXIgYmlubnVtYmVyID0gJzBbYkJdWzAxXStbbExdPyc7XG4gICAgICAgIHZhciBkZWNudW1iZXIgPSAnWzEtOV1cXFxcZCpbbExdPyc7XG4gICAgICAgIHZhciBpbnRudW1iZXIgPSBncm91cE9mUmVnRXgoaGV4bnVtYmVyLCBiaW5udW1iZXIsIG9jdG51bWJlciwgZGVjbnVtYmVyKTtcbiAgICAgICAgdmFyIGV4cG9uZW50ID0gJ1tlRV1bLStdP1xcXFxkKyc7XG4gICAgICAgIHZhciBwb2ludGZsb2F0ID0gZ3JvdXBPZlJlZ0V4KCdcXFxcZCtcXFxcLlxcXFxkKicsICdcXFxcXFxcXGQrXFxcXFxcXFwuXFxcXFxcXFxkKicpICsgcmVnRXhNYXlCZVByZXNlbnQoZXhwb25lbnQpO1xuICAgICAgICB2YXIgZXhwZmxvYXQgPSAnXFxcXGQrJyArIGV4cG9uZW50O1xuICAgICAgICB2YXIgZmxvYXRudW1iZXIgPSBncm91cE9mUmVnRXgocG9pbnRmbG9hdCwgZXhwZmxvYXQpO1xuICAgICAgICB2YXIgaW1hZ251bWJlciA9IGdyb3VwT2ZSZWdFeCgnXFxcXGQrW2pKXScsIGZsb2F0bnVtYmVyICsgJ1tqSl0nKTtcbiAgICAgICAgdmFyIG51bSA9IGdyb3VwT2ZSZWdFeChpbWFnbnVtYmVyLCBmbG9hdG51bWJlciwgaW50bnVtYmVyKTtcbiAgICAgICAgLy8gVGFpbCBlbmQgb2YgJyBzdHJpbmcuXG4gICAgICAgIHZhciBzaW5nbGUgPSAnW15cXCdcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXCdcXFxcXFxcXF0qKSpcXCcnO1xuICAgICAgICAvLyBUYWlsIGVuZCBvZiBcIiBzdHJpbmcuXG4gICAgICAgIHZhciBkb3VibGVRdW90ZSA9ICdbXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSpcIic7XG4gICAgICAgIC8vIFRhaWwgZW5kIG9mICcnJyBzdHJpbmcuXG4gICAgICAgIHZhciBzaW5nbGUzID0gXCJbXidcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufCcoPyEnJykpW14nXFxcXFxcXFxdKikqJycnXCI7XG4gICAgICAgIC8vIFRhaWwgZW5kIG9mIFwiXCJcIiBzdHJpbmcuXG4gICAgICAgIHZhciBkb3VibGUzID0gJ1teXCJcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFwiKD8hXCJcIikpW15cIlxcXFxcXFxcXSopKlwiXCJcIic7XG4gICAgICAgIHZhciB0cmlwbGUgPSBncm91cE9mUmVnRXgoXCJbdVViQl0/W3JSXT8nJydcIiwgJ1t1VWJCXT9bclJdP1wiXCJcIicpO1xuICAgICAgICAvLyBzaW5nbGUtbGluZSAnIG9yIFwiIHN0cmluZy5cbiAgICAgICAgdmFyIHN0ciA9IGdyb3VwT2ZSZWdFeChcIlt1VWJCXT9bclJdPydbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKidcIiwgJ1t1VWJCXT9bclJdP1wiW15cXFxcblwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG5cIlxcXFxcXFxcXSopKlwiJyk7XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgbGVmdG1vc3QtdGhlbi1sb25nZXN0IG1hdGNoIHNlbWFudGljcywgYmUgc3VyZSB0byBwdXQgdGhlXG4gICAgICAgIC8vIGxvbmdlc3Qgb3BlcmF0b3JzIGZpcnN0IChlLmcuLCBpZiA9IGNhbWUgYmVmb3JlID09LCA9PSB3b3VsZCBnZXRcbiAgICAgICAgLy8gcmVjb2duaXplZCBhcyB0d28gaW5zdGFuY2VzIG9mID0pLlxuICAgICAgICB2YXIgb3BlcmF0b3IgPSBncm91cE9mUmVnRXgoJ1xcXFwqXFxcXCo9PycsICc+Pj0/JywgJzw8PT8nLCAnPD4nLCAnIT0nLCAnLy89PycsICdbK1xcXFwtKi8lJnxePTw+XT0/JywgJ34nKTtcbiAgICAgICAgdmFyIGJyYWNrZXQgPSAnWygpe31dJztcbiAgICAgICAgdmFyIHNwZWNpYWwgPSBncm91cE9mUmVnRXgoJ1xcXFxyP1xcXFxuJywgJ1s6Oy4sXFxcXGBAXScpO1xuICAgICAgICB2YXIgZnVubnkgPSBncm91cE9mUmVnRXgob3BlcmF0b3IsIGJyYWNrZXQsIHNwZWNpYWwpO1xuICAgICAgICB2YXIgcGxhaW50b2tlbiA9IGdyb3VwT2ZSZWdFeChudW0sIGZ1bm55LCBzdHIsIG5hbWUpO1xuICAgICAgICB2YXIgdG9rZW4gPSBpZ25vcmUgKyBwbGFpbnRva2VuO1xuICAgICAgICAvLyBGaXJzdCAob3Igb25seSkgbGluZSBvZiAnIG9yIFwiIHN0cmluZy5cbiAgICAgICAgdmFyIGNvbnRTdHIgPSBncm91cE9mUmVnRXgoXCJbdVViQl0/W3JSXT8nW15cXFxcbidcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFxcbidcXFxcXFxcXF0qKSonXCIgK1xuICAgICAgICAgICAgZ3JvdXBPZlJlZ0V4KFwiJ1wiLCAnXFxcXFxcXFxcXFxccj9cXFxcbicpLCAnW3VVYkJdP1tyUl0/XCJbXlxcXFxuXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFxcblwiXFxcXFxcXFxdKikqJyArXG4gICAgICAgICAgICBncm91cE9mUmVnRXgoJ1wiJywgJ1xcXFxcXFxcXFxcXHI/XFxcXG4nKSk7XG4gICAgICAgIHZhciBwc2V1ZG9leHRyYXMgPSBncm91cE9mUmVnRXgoJ1xcXFxcXFxcXFxcXHI/XFxcXG58XFxcXFonLCBjb21tZW50LCB0cmlwbGUpO1xuICAgICAgICB2YXIgcHNldWRvdG9rZW4gPSB3aGl0ZXNwYWNlICsgZ3JvdXBPZlJlZ0V4KHBzZXVkb2V4dHJhcywgbnVtLCBmdW5ueSwgY29udFN0ciwgbmFtZSk7XG4gICAgICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbiBvYmplY3QuXG4gICAgICAgIHZhciB0b2tlbnByb2cgPSBuZXcgUmVnRXhwKHRva2VuKTtcbiAgICAgICAgdmFyIHBzZXVkb3Byb2cgPSBuZXcgUmVnRXhwKHBzZXVkb3Rva2VuKTtcbiAgICAgICAgdmFyIHNpbmdsZTNwcm9nID0gbmV3IFJlZ0V4cChzaW5nbGUzKTtcbiAgICAgICAgdmFyIGRvdWJsZTNwcm9nID0gbmV3IFJlZ0V4cChkb3VibGUzKTtcbiAgICAgICAgdmFyIGVuZHByb2dzID0ge1xuICAgICAgICAgICAgXCInXCI6IG5ldyBSZWdFeHAoc2luZ2xlKSwgJ1wiJzogbmV3IFJlZ0V4cChkb3VibGVRdW90ZSksXG4gICAgICAgICAgICBcIicnJ1wiOiBzaW5nbGUzcHJvZywgJ1wiXCJcIic6IGRvdWJsZTNwcm9nLFxuICAgICAgICAgICAgXCJyJycnXCI6IHNpbmdsZTNwcm9nLCAnclwiXCJcIic6IGRvdWJsZTNwcm9nLFxuICAgICAgICAgICAgXCJ1JycnXCI6IHNpbmdsZTNwcm9nLCAndVwiXCJcIic6IGRvdWJsZTNwcm9nLFxuICAgICAgICAgICAgXCJ1cicnJ1wiOiBzaW5nbGUzcHJvZywgJ3VyXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcIlInJydcIjogc2luZ2xlM3Byb2csICdSXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcIlUnJydcIjogc2luZ2xlM3Byb2csICdVXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcInVSJycnXCI6IHNpbmdsZTNwcm9nLCAndVJcIlwiXCInOiBkb3VibGUzcHJvZyxcbiAgICAgICAgICAgIFwiVXInJydcIjogc2luZ2xlM3Byb2csICdVclwiXCJcIic6IGRvdWJsZTNwcm9nLFxuICAgICAgICAgICAgXCJVUicnJ1wiOiBzaW5nbGUzcHJvZywgJ1VSXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcImInJydcIjogc2luZ2xlM3Byb2csICdiXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcImJyJycnXCI6IHNpbmdsZTNwcm9nLCAnYnJcIlwiXCInOiBkb3VibGUzcHJvZyxcbiAgICAgICAgICAgIFwiQicnJ1wiOiBzaW5nbGUzcHJvZywgJ0JcIlwiXCInOiBkb3VibGUzcHJvZyxcbiAgICAgICAgICAgIFwiYlInJydcIjogc2luZ2xlM3Byb2csICdiUlwiXCJcIic6IGRvdWJsZTNwcm9nLFxuICAgICAgICAgICAgXCJCcicnJ1wiOiBzaW5nbGUzcHJvZywgJ0JyXCJcIlwiJzogZG91YmxlM3Byb2csXG4gICAgICAgICAgICBcIkJSJycnXCI6IHNpbmdsZTNwcm9nLCAnQlJcIlwiXCInOiBkb3VibGUzcHJvZyxcbiAgICAgICAgICAgIHI6IG51bGwsIFI6IG51bGwsIHU6IG51bGwsIFU6IG51bGwsXG4gICAgICAgICAgICBiOiBudWxsLCBCOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmlwbGVRdW90ZWQgPSBbXG4gICAgICAgICAgICBcIicnJ1wiLCAnXCJcIlwiJywgXCJyJycnXCIsICdyXCJcIlwiJywgXCJSJycnXCIsICdSXCJcIlwiJyxcbiAgICAgICAgICAgIFwidScnJ1wiLCAndVwiXCJcIicsIFwiVScnJ1wiLCAnVVwiXCJcIicsIFwidXInJydcIiwgJ3VyXCJcIlwiJywgXCJVcicnJ1wiLCAnVXJcIlwiXCInLFxuICAgICAgICAgICAgXCJ1UicnJ1wiLCAndVJcIlwiXCInLCBcIlVSJycnXCIsICdVUlwiXCJcIicsIFwiYicnJ1wiLCAnYlwiXCJcIicsIFwiQicnJ1wiLCAnQlwiXCJcIicsXG4gICAgICAgICAgICBcImJyJycnXCIsICdiclwiXCJcIicsIFwiQnInJydcIiwgJ0JyXCJcIlwiJywgXCJiUicnJ1wiLCAnYlJcIlwiXCInLCBcIkJSJycnXCIsICdCUlwiXCJcIidcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHNpbmdsZVF1b3RlZCA9IFtcbiAgICAgICAgICAgIFwiJ1wiLCAnXCInLCBcInInXCIsICdyXCInLCBcIlInXCIsICdSXCInLCBcInUnXCIsICd1XCInLCBcIlUnXCIsICdVXCInLCBcInVyJ1wiLFxuICAgICAgICAgICAgJ3VyXCInLCBcIlVyJ1wiLCAnVXJcIicsIFwidVInXCIsICd1UlwiJywgXCJVUidcIiwgJ1VSXCInLCBcImInXCIsICdiXCInLCBcIkInXCIsICdCXCInLFxuICAgICAgICAgICAgXCJicidcIiwgJ2JyXCInLCBcIkJyJ1wiLCAnQnJcIicsIFwiYlInXCIsICdiUlwiJywgXCJCUidcIiwgJ0JSXCInXG4gICAgICAgIF07XG4gICAgICAgIHZhciB0YWJzaXplID0gODtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRlVG9rZW5zOiBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbml6ZWRQcm9ncmFtID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGxudW0gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbmxldiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVlZCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVjaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXyc7XG4gICAgICAgICAgICAgICAgdmFyIG51bWNoYXJzID0gJzAxMjM0NTY3ODknO1xuICAgICAgICAgICAgICAgIHZhciBjb250c3RyID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRjb250ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBpbmRlbnRzID0gWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRwcm9nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHByb2dyYW1bbGNvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgbGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250c3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRU9GIGluIG11bHRpLWxpbmUgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kbWF0Y2ggPSBlbmRwcm9nLmV4ZWMobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kbWF0Y2ggJiYgZW5kbWF0Y2guaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGVuZG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvcyArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuU1RSSU5HLCB0b2tlbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRzdHIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkY29udCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmVlZGNvbnQgJiYgbGluZS5zbGljZSgtMikgIT09ICdcXFxcXFxuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUuc2xpY2UoLTMpICE9PSAnXFxcXFxcclxcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuRVJST1JUT0tFTiwgY29udHN0ciArIGxpbmVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250c3RyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHN0ciA9IGNvbnRzdHIgKyBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRsaW5lID0gY29udGxpbmUgKyBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVubGV2ID09PSAwICYmICFjb250aW51ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldyBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbcG9zXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lW3Bvc10gPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IChjb2x1bW4gLyB0YWJzaXplICsgMSkgKiB0YWJzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lW3Bvc10gPT09ICdcXGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgY29tbWVudHMgb3IgYmxhbmsgbGluZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCcjXFxyXFxuJykuaW5kZXhPZihsaW5lW3Bvc10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lW3Bvc10gPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudFRva2VuID0gbGluZS5zbGljZShwb3MpLnJlcGxhY2UoJ1xcXFxyXFxcXG4nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubFBvcyA9IHBvcyArIGNvbW1lbnRUb2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5DT01NRU5ULCBjb21tZW50VG9rZW5dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFtQeXRob25Qcm9ncmFtVG9rZW5UeXBlLk5MLCBsaW5lLnNsaWNlKG5sUG9zKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLkNPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IFB5dGhvblByb2dyYW1Ub2tlblR5cGUuTkw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLmxpbmVbcG9zXSA9PT0gJyMnID8gY29tbWVudCA6IG5sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZS5zbGljZShwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGluZGVudHMgb3IgZGVkZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPiBpbmRlbnRzWy0xXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudHMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5JTkRFTlQsIGxpbmUuc2xpY2UoMCwgcG9zKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbHVtbiA8IGluZGVudHNbLTFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudHMuaW5kZXhPZihjb2x1bW4pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbG9nLmVycm9yKCd1bmluZGVudCBkb2VzIG5vdCBtYXRjaCBhbnkgb3V0ZXIgaW5kZW50YXRpb24gbGV2ZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50cyA9IGluZGVudHMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5ERURFTlQsICcnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZWQgc3RhdGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy5lcnJvcignRU9GIGluIG11bHRpLWxpbmUgc3RhdGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2V1ZG9tYXRjaCA9IHBzZXVkb3Byb2cuZXhlYyhsaW5lLnNsaWNlKHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBmb3IgdG9rZW5zLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBzZXVkb21hdGNoICYmIHBzZXVkb21hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zICsgcHNldWRvbWF0Y2hbMF0uaW5kZXhPZihwc2V1ZG9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgcHNldWRvbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbCA9IGxpbmVbc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yZGluYXJ5IG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtY2hhcnMuaW5kZXhPZihpbml0aWFsKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWwgPT09ICcuJyAmJiB0b2tlbiAhPT0gJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuTlVNQkVSLCB0b2tlbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgnXFxyXFxuJy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuTkwsIHRva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluaXRpYWwgPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuLmVuZHN3aXRoKCdcXG4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFtQeXRob25Qcm9ncmFtVG9rZW5UeXBlLkNPTU1FTlQsIHRva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJpcGxlUXVvdGVkLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwcm9nID0gZW5kcHJvZ3NbdG9rZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRtYXRjaCA9IGVuZHByb2cuZXhlYyhsaW5lLnNsaWNlKHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgb24gb25lIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zICsgZW5kbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsaW5lLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFtQeXRob25Qcm9ncmFtVG9rZW5UeXBlLlNUUklORywgdG9rZW5dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGxpbmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHN0ciA9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2luZ2xlUXVvdGVkLmluZGV4T2YoaW5pdGlhbCkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZVF1b3RlZC5pbmRleE9mKHRva2VuLnNsaWNlKDAsIDIpKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlUXVvdGVkLmluZGV4T2YodG9rZW4uc2xpY2UoMCwgMykpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4uc2xpY2UoLTEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcHJvZyA9IChlbmRwcm9nc1tpbml0aWFsXSB8fCBlbmRwcm9nc1t0b2tlblsxXV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwcm9nc1t0b2tlblsyXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHN0ciA9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGNvbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuU1RSSU5HLCB0b2tlbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVjaGFycy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmRpbmFyeSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5OQU1FLCB0b2tlbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbml0aWFsID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWVkIHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnKFt7Jy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW5sZXYgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgnKV19Jy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW5sZXYgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZWRQcm9ncmFtLnB1c2goW1B5dGhvblByb2dyYW1Ub2tlblR5cGUuT1AsIHRva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFtQeXRob25Qcm9ncmFtVG9rZW5UeXBlLkVSUk9SVE9LRU4sIGxpbmVbcG9zXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBvcCByZW1haW5pbmcgaW5kZW50IGxldmVsc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGVudCBpbiBpbmRlbnRzLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5ERURFTlQsICcnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaChbUHl0aG9uUHJvZ3JhbVRva2VuVHlwZS5FTkRNQVJLRVIsICcnXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplZFByb2dyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTVk0gcHJlZGljdCBmdW5jdGlvbiBmb3IgU1ZDIGNsYXNzaWZpZXIgb2Ygc2tsZWFybi5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIHByZWRpY3QgZnVuY3Rpb24gdXNlcyBzdm0gZGF0YSB0aGF0IHdhcyBleHRyYWN0ZWRcbiAqIGFmdGVyIHRyYWluaW5nIG9mIGNsYXNzaWZpZXIgb24gT3BwaWEtbWwuIElmIHRoZXJlIGFyZSBhbnkgY2hhbmdlcyBpblxuICogZm9ybWF0IG9mIGV4dHJhY3RlZCBkYXRhIHRoZW4gY29ycmVzcG9uZGluZyBjaGFuZ2VzIG11c3QgYmUgcHJvcGFnYXRlZCBoZXJlLlxuICogT3BwaWEtbWwgdXNlcyBzY2lraXQncyBTVkMgY2xhc3MgZHVyaW5nIHRyYWluaW5nIGNsYXNzaWZpZXIgd2hpY2ggdXNlc1xuICogbGlic3ZtJ3MgaW1wbGVtZW50YXRpb24uIElmIHRoZXJlIGFyZSBhbnkgY2hhbmdlcyBpbiBmb2xsb3dpbmcgcGFydCBvZlxuICogY29kZSBpbiBsaWJzdm0gdGhlbiBjb3JyZXNwb25kaW5nIGNoYW5nZXMgbXVzdCBiZSBwcm9wYWdhdGVkIGhlcmUuXG4gKlxuICogbGlic3ZtJ3MgY29kZSBmb3IgcHJlZGljdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcm5hdWRzai9saWJzdm0vYmxvYi9tYXN0ZXIvc3ZtLmNwcCNMMjQ4MVxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCJkb21haW4vY2xhc3NpZmllci9QcmVkaWN0aW9uUmVzdWx0T2JqZWN0RmFjdG9yeVwiKTtcbnZhciBJS2VybmVsUGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElLZXJuZWxQYXJhbXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBJS2VybmVsUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuSUtlcm5lbFBhcmFtcyA9IElLZXJuZWxQYXJhbXM7XG52YXIgU1ZNUHJlZGljdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1ZNUHJlZGljdGlvblNlcnZpY2UocHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5wcmVkaWN0aW9uUmVzdWx0T2JqZWN0RmFjdG9yeSA9IHByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5O1xuICAgIH1cbiAgICBTVk1QcmVkaWN0aW9uU2VydmljZS5wcm90b3R5cGUua2VybmVsID0gZnVuY3Rpb24gKGtlcm5lbFBhcmFtcywgc3VwcG9ydFZlY3RvcnMsIGlucHV0KSB7XG4gICAgICAgIHZhciBrZXJuZWwgPSBrZXJuZWxQYXJhbXMua2VybmVsO1xuICAgICAgICB2YXIga3ZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoa2VybmVsID09PSAncmJmJykge1xuICAgICAgICAgICAgdmFyIGdhbW1hID0ga2VybmVsUGFyYW1zLmdhbW1hO1xuICAgICAgICAgICAgdmFyIHZlY3Rvckxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydFZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdygoc3VwcG9ydFZlY3RvcnNbaV1bal0gLSBpbnB1dFtqXSksIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrdmFsdWVzLnB1c2goTWF0aC5leHAoLWdhbW1hICogc3VtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2VybmVsID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgdmFyIHZlY3Rvckxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydFZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBzdXBwb3J0VmVjdG9yc1tpXVtqXSAqIGlucHV0W2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrdmFsdWVzLnB1c2goc3VtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga3ZhbHVlcztcbiAgICB9O1xuICAgIC8vIEZpbmQgbXVsdGljbGFzcyBwcm9iYWJpbGl0aWVzLlxuICAgIC8vIE5PVEU6IFRoaXMgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgYXMgaXQgaXMgZ2l2ZW4gaW4gTGliU1ZNLlxuICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGV4YWN0IGFwcHJvYWNoIHVzZWQsIHJlYWQgZm9sbG93aW5nIHBhcGVyOlxuICAgIC8vIGh0dHBzOi8vd3d3LmNzaWUubnR1LmVkdS50dy9+Y2psaW4vcGFwZXJzL3N2bXByb2Ivc3ZtcHJvYi5wZGZcbiAgICAvLyBBbHNvIHRha2UgYSBsb29rIGF0IGltcGxlbWVudGF0aW9uIGJ5IExpYlNWTTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXJuYXVkc2ovbGlic3ZtL2Jsb2IvbWFzdGVyL3N2bS5jcHAjTDE4MjlcbiAgICBTVk1QcmVkaWN0aW9uU2VydmljZS5wcm90b3R5cGUuY2FsY3VsYXRlTXVsdGljbGFzc1Byb2JhYmlsaXRpZXMgPSBmdW5jdGlvbiAobkNsYXNzZXMsIHBhaXJ3aXNlUHJvYikge1xuICAgICAgICB2YXIgUSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5DbGFzc2VzOyBpKyspIHtcbiAgICAgICAgICAgIFEucHVzaChbXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5DbGFzc2VzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBRW2ldLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFFwID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkNsYXNzZXM7IGkrKykge1xuICAgICAgICAgICAgUXAucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5DbGFzc2VzOyBpKyspIHtcbiAgICAgICAgICAgIFAucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4SXRlciA9IE1hdGgubWF4KDEwMCwgbkNsYXNzZXMpO1xuICAgICAgICB2YXIgZXBzID0gMC4wMDUgLyBuQ2xhc3NlcztcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuQ2xhc3NlczsgdCsrKSB7XG4gICAgICAgICAgICBQW3RdID0gMS4wIC8gbkNsYXNzZXM7XG4gICAgICAgICAgICBRW3RdW3RdID0gMC4wO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBRW3RdW3RdICs9IHBhaXJ3aXNlUHJvYltqXVt0XSAqIHBhaXJ3aXNlUHJvYltqXVt0XTtcbiAgICAgICAgICAgICAgICBRW3RdW2pdID0gUVtqXVt0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSB0ICsgMTsgaiA8IG5DbGFzc2VzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBRW3RdW3RdICs9IHBhaXJ3aXNlUHJvYltqXVt0XSAqIHBhaXJ3aXNlUHJvYltqXVt0XTtcbiAgICAgICAgICAgICAgICBRW3RdW2pdID0gLXBhaXJ3aXNlUHJvYltqXVt0XSAqIHBhaXJ3aXNlUHJvYlt0XVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlciA9IDA7XG4gICAgICAgIGZvciAoaXRlciA9IDA7IGl0ZXIgPCBtYXhJdGVyOyBpdGVyKyspIHtcbiAgICAgICAgICAgIHZhciBwUXAgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5DbGFzc2VzOyB0KyspIHtcbiAgICAgICAgICAgICAgICBRcFt0XSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuQ2xhc3NlczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIFFwW3RdICs9IFFbdF1bal0gKiBQW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwUXAgKz0gUFt0XSAqIFFwW3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1heEVycm9yID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbkNsYXNzZXM7IHQrKykge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IE1hdGguYWJzKFFwW3RdIC0gcFFwKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPiBtYXhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBtYXhFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhFcnJvciA8IGVwcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuQ2xhc3NlczsgdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSAoLVFwW3RdICsgcFFwKSAvIFFbdF1bdF07XG4gICAgICAgICAgICAgICAgUFt0XSArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHBRcCA9ICgocFFwICsgZGlmZiAqIChkaWZmICogUVt0XVt0XSArIDIgKiBRcFt0XSkpIC9cbiAgICAgICAgICAgICAgICAgICAgKDEgKyBkaWZmKSAvICgxICsgZGlmZikpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbkNsYXNzZXM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBRcFtqXSA9IChRcFtqXSArIGRpZmYgKiBRW3RdW2pdKSAvICgxICsgZGlmZik7XG4gICAgICAgICAgICAgICAgICAgIFBbal0gLz0gKDEgKyBkaWZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZXIgPj0gbWF4SXRlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeGNlZWRzIG1heEl0ZXIgaW4gY2FsY3VsYXRlTXVsdGljbGFzc1Byb2JhYmlsaXRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUDtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2NsYXNzaWZpZXJEYXRhJyBpcyBhIGRpY3Qgd2l0aCB1bmRlcnNjb3JlX2Nhc2VkIGtleXMgd2hpY2hcbiAgICAvLyBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZiBjYW1lbENhc2luZy4gU2FtZVxuICAgIC8vIGdvZXMgZm9yICdpbnB1dCcuXG4gICAgU1ZNUHJlZGljdGlvblNlcnZpY2UucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoY2xhc3NpZmllckRhdGEsIGlucHV0KSB7XG4gICAgICAgIHZhciBuU3VwcG9ydCA9IGNsYXNzaWZpZXJEYXRhLm5fc3VwcG9ydDtcbiAgICAgICAgdmFyIHN1cHBvcnRWZWN0b3JzID0gY2xhc3NpZmllckRhdGEuc3VwcG9ydF92ZWN0b3JzO1xuICAgICAgICB2YXIgZHVhbENvZWYgPSBjbGFzc2lmaWVyRGF0YS5kdWFsX2NvZWY7XG4gICAgICAgIHZhciBpbnRlcmNlcHQgPSBjbGFzc2lmaWVyRGF0YS5pbnRlcmNlcHQ7XG4gICAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NpZmllckRhdGEuY2xhc3NlcztcbiAgICAgICAgdmFyIGtlcm5lbFBhcmFtcyA9IGNsYXNzaWZpZXJEYXRhLmtlcm5lbF9wYXJhbXM7XG4gICAgICAgIHZhciBwcm9iQSA9IGNsYXNzaWZpZXJEYXRhLnByb2JBO1xuICAgICAgICB2YXIgcHJvYkIgPSBjbGFzc2lmaWVyRGF0YS5wcm9iQjtcbiAgICAgICAgdmFyIHN0YXJ0SW5kaWNlcyA9IFtdO1xuICAgICAgICBzdGFydEluZGljZXNbMF0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5TdXBwb3J0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGFydEluZGljZXNbaV0gPSBzdGFydEluZGljZXNbaSAtIDFdICsgblN1cHBvcnRbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwb3J0VmVjdG9yc1swXS5sZW5ndGggIT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCB2ZWN0b3IgYW5kIGlucHV0IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRGltZW5zaW9uIG9mIHN1cHBvcnQgdmVjdG9ycyBhbmQgZ2l2ZW4gaW5wdXQgaXMgZGlmZmVyZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQga2VybmVsIHZhbHVlcyBmb3Igc3VwcG9ydFZlY3RvcnMgYW5kIGdpdmVuIGlucHV0LiBBc3N1bWVzIHRoYXRcbiAgICAgICAgLy8gaW5wdXQgaGFzIHNhbWUgZGltZW5zaW9uIGFuZCBkYXRhIHR5cGUgYXMgYW55IG9mIHRoZSBzdXBwb3J0VmVjdG9ycy5cbiAgICAgICAgdmFyIGt2YWx1ZXMgPSB0aGlzLmtlcm5lbChrZXJuZWxQYXJhbXMsIHN1cHBvcnRWZWN0b3JzLCBpbnB1dCk7XG4gICAgICAgIHZhciB2b3RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZvdGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaXJ3aXNlUHJvYiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXJ3aXNlUHJvYi5wdXNoKFtdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHBhaXJ3aXNlUHJvYltpXS5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpID0gc3RhcnRJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzaiA9IHN0YXJ0SW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgY2kgPSBuU3VwcG9ydFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgY2ogPSBuU3VwcG9ydFtqXTtcbiAgICAgICAgICAgICAgICB2YXIgbWluUHJvYiA9IDFlLTc7XG4gICAgICAgICAgICAgICAgdmFyIGNvZWYxID0gZHVhbENvZWZbaiAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBjb2VmMiA9IGR1YWxDb2VmW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2k7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0ga3ZhbHVlc1tzaSArIGtdICogY29lZjFbc2kgKyBrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjajsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBrdmFsdWVzW3NqICsga10gKiBjb2VmMltzaiArIGtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBsaWJzdm0gc3Vic3RyYWN0cyB0aGUgaW50ZXJjZXB0IGZyb20gc3VtIGluIGl0cyBwcmVkaWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24uIEhlcmUgaW50ZXJjZXB0IGlzIGFkZGVkIGJlY2F1c2Ugc2NpLWtpdCBuZWdhdGVzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBiZWZvcmUgcGFzc2luZyBpdCBvbiB0byBsaWJzdm0gZm9yIHByZWRpY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gRm9yIG1vcmUgaW5mbyBzZWUgZ2l0aHViIGZvbGxvd2luZyBpc3N1ZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3BwaWEvb3BwaWEvaXNzdWVzLzQxNjZcbiAgICAgICAgICAgICAgICBzdW0gKz0gaW50ZXJjZXB0W3BdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXBwcm9hY2ggdG8gY2FsY3VsYXRlIHBhaXJ3aXNlIHByb2JhYmlsaXRpZXMgd2FzXG4gICAgICAgICAgICAgICAgLy8gcHJvcG9zZWQgYnkgcGxhdHQuIEZvciBtb3JlIGluZm8gb24gTGliU1ZNJ3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAvLyBvZiBwbGF0dCBzY2FsaW5nLCByZWFkIGZvbGxvd2luZyBwYXBlcjpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5jc2llLm50dS5lZHUudHcvfmNqbGluL3BhcGVycy9wbGF0dHByb2IucGRmXG4gICAgICAgICAgICAgICAgLy8gQWxzbyB0YWtlIGEgbG9vayBhdCBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb24gYnkgTGliU1ZNOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcm5hdWRzai9saWJzdm0vYmxvYi9tYXN0ZXIvc3ZtLmNwcCNMMjU1MlxuICAgICAgICAgICAgICAgIHZhciBmID0gcHJvYkFbcF0gKiBzdW0gKyBwcm9iQltwXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvYiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGYgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9iID0gTWF0aC5leHAoLWYpIC8gKDEgKyBNYXRoLmV4cCgtZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvYiA9IDEgLyAoMSArIE1hdGguZXhwKGYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvYiA9IE1hdGgubWluKE1hdGgubWF4KHByb2IsIG1pblByb2IpLCAxIC0gbWluUHJvYik7XG4gICAgICAgICAgICAgICAgcGFpcndpc2VQcm9iW2ldW2pdID0gcHJvYjtcbiAgICAgICAgICAgICAgICBwYWlyd2lzZVByb2Jbal1baV0gPSAxIC0gcHJvYjtcbiAgICAgICAgICAgICAgICBwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2JhYmlsaXRpZXMgPSB0aGlzLmNhbGN1bGF0ZU11bHRpY2xhc3NQcm9iYWJpbGl0aWVzKGNsYXNzZXMubGVuZ3RoLCBwYWlyd2lzZVByb2IpO1xuICAgICAgICB2YXIgbWF4UHJvYklkeCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHByb2JhYmlsaXRpZXNbaV0gPiBwcm9iYWJpbGl0aWVzW21heFByb2JJZHhdKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJvYklkeCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWRpY3RlZExhYmVsID0gY2xhc3Nlc1ttYXhQcm9iSWR4XTtcbiAgICAgICAgdmFyIHByZWRpY3Rpb24gPSB0aGlzLnByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5LmNyZWF0ZU5ldyhwcmVkaWN0ZWRMYWJlbCwgcHJvYmFiaWxpdGllc1ttYXhQcm9iSWR4XSk7XG4gICAgICAgIHJldHVybiBwcmVkaWN0aW9uO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIFNWTVByZWRpY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIFByZWRpY3Rpb25SZXN1bHRPYmplY3RGYWN0b3J5XzEuUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgUHJlZGljdGlvblJlc3VsdE9iamVjdEZhY3RvcnlfMS5QcmVkaWN0aW9uUmVzdWx0T2JqZWN0RmFjdG9yeSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBTVk1QcmVkaWN0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIFNWTVByZWRpY3Rpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU1ZNUHJlZGljdGlvblNlcnZpY2UgPSBTVk1QcmVkaWN0aW9uU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1NWTVByZWRpY3Rpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShTVk1QcmVkaWN0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTcgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUb2tlbml6ZXIgZm9yIFRleHRJbnB1dC5cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIGEgc2ltcGxlIHRva2VuaXplciBmb3IgdG9rZW5pemluZyB0ZXh0IGlucHV0LiBUaGUgcGFyYW1ldGVyXG4gKiBuX2dyYW1zIGlzIHVzZWQgZm9yIGRlY2lkaW5nIGlmIHdlIG5lZWQgdG8gYWRkIG5fZ3JhbSB0b2tlbnMgb3RoZXIgdGhhblxuICogdGhlIHVuaWdyYW0gdG9rZW5zLiBBcyBvZiBub3csIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gdW5pZ3JhbXMgYnV0IGlmXG4gKiBuZWVkZWQgaW4gdGhlIGZ1dHVyZSwgdGhpcyB0b2tlbml6ZXIgc2hvdWxkIGJlIGFibGUgdG8gZ2VuZXJhdGUgbi1ncmFtc1xuICogYWxzby5cbiAqXG4gKiBGb3IgcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2Npa2l0LWxlYXJuL3NjaWtpdC1sZWFybi9cbiAqICAgICBibG9iL21hc3Rlci9za2xlYXJuL2ZlYXR1cmVfZXh0cmFjdGlvbi90ZXh0LnB5I0w1NDFcbiAqL1xuLy8gVE9ETyhhbm1vbCk6IEFkZCBmdW5jdGlvbmFsaXR5IHRvIGFkZCBuX2dyYW1zLCByZW1vdmUgc3RvcCB3b3Jkcy5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1RleHRJbnB1dFRva2VuaXplcicsIFtmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0ZVRva2VuczogZnVuY3Rpb24gKHRleHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbml6ZWRUZXh0SW5wdXQ7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmVnZXhwIHNlbGVjdCB0b2tlbnMgb2YgMiBvciBtb3JlIGFscGhhbnVtZXJpY1xuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlcnMgKHB1bmN0dWF0aW9uIGlzIGNvbXBsZXRlbHkgaWdub3JlZCBhbmQgYWx3YXlzIHRyZWF0ZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBhIHRva2VuIHNlcGFyYXRvcikuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuUGF0dGVybiA9ICdcXFxcYlxcXFx3XFxcXHcrXFxcXGInO1xuICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHRva2VuUGF0dGVybiwgJ2cnKTtcbiAgICAgICAgICAgICAgICB0b2tlbml6ZWRUZXh0SW5wdXQgPSB0ZXh0SW5wdXQubWF0Y2gocmVnZXhwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5pemVkVGV4dElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE3IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgV2lubm93aW5nIHByZXByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgcHJlcHJvY2Vzc2luZyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIGFjY29yZGluZyB0b1xuICogd2lubm93aW5nIHByZXByb2Nlc3NpbmcgZnVuY3Rpb25zIHVzZWQgb24gT3BwaWEtbWwuIFRoZXNlIGZ1bmN0aW9uc1xuICogYXJlIHNpbXBsZSB0cmFuc2xhdGlvbiBvZiBQeXRob24gY29kZSB0byBKUyBjb2RlIGFuZCB0aGV5IGJvdGggZG8gZXhhY3RcbiAqIHNhbWUgdGFzay5cbiAqL1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlKCkge1xuICAgIH1cbiAgICBXaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZV8xID0gV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2U7XG4gICAgV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2UuZ2VuZXJhdGVIYXNoVmFsdWUgPSBmdW5jdGlvbiAodG9rZW5zLCB0b2tlblRvSWQpIHtcbiAgICAgICAgdmFyIGhhc2hWYWwgPSAwO1xuICAgICAgICB2YXIgbiA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYmFzZSA9IE1hdGgucG93KE9iamVjdC5rZXlzKHRva2VuVG9JZCkubGVuZ3RoLCBuKTtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBoYXNoVmFsICs9IHRva2VuVG9JZFt0b2tlbl0gKiBiYXNlO1xuICAgICAgICAgICAgYmFzZSAvPSBPYmplY3Qua2V5cyh0b2tlblRvSWQpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYXNoVmFsO1xuICAgIH07XG4gICAgV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2UucHJvdG90eXBlLmdldEtHcmFtSGFzaGVzID0gZnVuY3Rpb24gKHRva2VucywgdG9rZW5Ub0lkLCBLKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCBwb3NzaWJsZSBrLWdyYW0gaGFzaGVzIGZyb20gdG9rZW5zLlxuICAgICAgICB2YXIga0dyYW1IYXNoZXMgPSBbXTtcbiAgICAgICAgdmFyIGtUb2tlbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIEsgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGtUb2tlbnMgPSB0b2tlbnMuc2xpY2UoaSwgaSArIEspO1xuICAgICAgICAgICAga0dyYW1IYXNoZXMucHVzaChXaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZV8xLmdlbmVyYXRlSGFzaFZhbHVlKGtUb2tlbnMsIHRva2VuVG9JZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrR3JhbUhhc2hlcztcbiAgICB9O1xuICAgIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlLnByb3RvdHlwZS5nZXRGaW5nZXJwcmludEZyb21IYXNoZXMgPSBmdW5jdGlvbiAoa0dyYW1IYXNoZXMsIFQsIEspIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgZmluZ2VycHJpbnQgb2YgYSBkb2N1bWVudCBmcm9tIGl0cyBrLWdyYW0gaGFzaGVzLlxuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IFQgLSBLICsgMTtcbiAgICAgICAgdmFyIGZpbmdlcnByaW50SGFzaGVzSW5kZXggPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga0dyYW1IYXNoZXMubGVuZ3RoIC0gd2luZG93U2l6ZSArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd0hhc2hlcyA9IGtHcmFtSGFzaGVzLnNsaWNlKGksIGkgKyB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHZhciBtaW5IYXNoVmFsdWUgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB3aW5kb3dIYXNoZXMpO1xuICAgICAgICAgICAgdmFyIG1pbkhhc2hJbmRleCA9IGkgKyB3aW5kb3dIYXNoZXMuaW5kZXhPZihtaW5IYXNoVmFsdWUpO1xuICAgICAgICAgICAgZmluZ2VycHJpbnRIYXNoZXNJbmRleC5hZGQobWluSGFzaEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmluZ2VycHJpbnQgPSBbXTtcbiAgICAgICAgZmluZ2VycHJpbnRIYXNoZXNJbmRleC5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoSW5kZXgpIHtcbiAgICAgICAgICAgIGZpbmdlcnByaW50LnB1c2goW2tHcmFtSGFzaGVzW2hhc2hJbmRleF0sIGhhc2hJbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmdlcnByaW50O1xuICAgIH07XG4gICAgdmFyIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlXzE7XG4gICAgV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2UgPSBXaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlKTtcbiAgICByZXR1cm4gV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5XaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZSA9IFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnV2lubm93aW5nUHJlcHJvY2Vzc2luZ1NlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBDb2RlUmVwbCBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvZGVSZXBsL3N0YXRpYy9jb2RlX3JlcGwuY3NzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvQ29kZVJlcGwvY29kZS1yZXBsLXByZWRpY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvZGVSZXBsL2RpcmVjdGl2ZXMvY29kZS1yZXBsLXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzL2NvZGUtcmVwbC12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWNvZGUtcmVwbC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1yZXNwb25zZS1jb2RlLXJlcGwuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvQ29kZVJlcGwvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtc2hvcnQtcmVzcG9uc2UtY29kZS1yZXBsLmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTcgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb2RlUmVwbCBpbnRlcmFjdGlvbiBwcmVkaWN0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIHByZWRpY3Rpb24gZnVuY3Rpb24gdXNlcyB0aGUgY2xhc3NpZmllciBkYXRhXG4gKiBvZiB0cmFpbmVkIG1vZGVsIChjb2RlIGNsYXNzaWZpZXIgbW9kZWwpIGZvciBpbmZlcmVuY2UuIFRoZXNlIGZ1bmN0aW9uc1xuICogbXVzdCBiZSBjaGFuZ2VkIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlcyBpbiBjb3JyZXNwb25kaW5nIGNsYXNzaWZpZXIgdHJhaW5pbmdcbiAqIGZ1bmN0aW9uIG9uIE9wcGlhLW1sLlxuICovXG5yZXF1aXJlKCdjbGFzc2lmaWVycy9jb3VudC12ZWN0b3JpemVyLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2NsYXNzaWZpZXJzL3B5dGhvbi1wcm9ncmFtLnRva2VuaXplci50cycpO1xucmVxdWlyZSgnY2xhc3NpZmllcnMvc3ZtLXByZWRpY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnY2xhc3NpZmllcnMvd2lubm93aW5nLXByZXByb2Nlc3Npbmcuc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9ucy1leHRlbnNpb24uY29uc3RhbnRzLmFqcy50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnQ29kZVJlcGxQcmVkaWN0aW9uU2VydmljZScsIFtcbiAgICAnQ291bnRWZWN0b3JpemVyU2VydmljZScsICdQeXRob25Qcm9ncmFtVG9rZW5UeXBlJyxcbiAgICAnUHl0aG9uUHJvZ3JhbVRva2VuaXplcicsICdTVk1QcmVkaWN0aW9uU2VydmljZScsXG4gICAgJ1dpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlJyxcbiAgICAnQ09ERV9SRVBMX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQnLCBmdW5jdGlvbiAoQ291bnRWZWN0b3JpemVyU2VydmljZSwgUHl0aG9uUHJvZ3JhbVRva2VuVHlwZSwgUHl0aG9uUHJvZ3JhbVRva2VuaXplciwgU1ZNUHJlZGljdGlvblNlcnZpY2UsIFdpbm5vd2luZ1ByZXByb2Nlc3NpbmdTZXJ2aWNlLCBDT0RFX1JFUExfUFJFRElDVElPTl9TRVJWSUNFX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBUaGUgc3RyaW5nIHdpdGggd2hpY2ggYWxsIHRoZSB2YXJpYWJsZSBhbmQgbWV0aG9kIG5hbWVzIG5lZWQgdG8gYmVcbiAgICAgICAgLy8gcmVwbGFjZWQuXG4gICAgICAgIHZhciBUT0tFTl9OQU1FX1ZBUiA9ICdWJztcbiAgICAgICAgLy8gVGhlIHN0cmluZyB3aXRoIHdoaWNoIGFsbCB1bmtub3duIHRva2VucyAodG9rZW5zIHdoaWNoIGFyZSBpZ25vcmVkXG4gICAgICAgIC8vIGJlY2F1c2UgdGhleSBhcHBlYXIgcmFyZWx5IGluIGEgcHJvZ3JhbSkgd2lsbCBiZSByZXBsYWNlZC5cbiAgICAgICAgdmFyIFRPS0VOX05BTUVfVU5LID0gJ1VOSyc7XG4gICAgICAgIC8vIExpc3Qgb2YgcHl0aG9uIGtleXdvcmRzLlxuICAgICAgICB2YXIgS1dfTElTVCA9IFtcbiAgICAgICAgICAgICdhbmQnLCAnYXMnLCAnYXNzZXJ0JywgJ2JyZWFrJywgJ2NsYXNzJywgJ2NvbnRpbnVlJywgJ2RlZicsICdkZWwnLFxuICAgICAgICAgICAgJ2VsaWYnLCAnZWxzZScsICdleGNlcHQnLCAnZXhlYycsICdmaW5hbGx5JywgJ2ZvcicsICdmcm9tJywgJ2dsb2JhbCcsXG4gICAgICAgICAgICAnaWYnLCAnaW1wb3J0JywgJ2luJywgJ2lzJywgJ2xhbWJkYScsICdub3QnLCAnb3InLCAncGFzcycsICdwcmludCcsXG4gICAgICAgICAgICAncmFpc2UnLCAncmV0dXJuJywgJ3RyeScsICd3aGlsZScsICd3aXRoJywgJ3lpZWxkJ1xuICAgICAgICBdO1xuICAgICAgICB2YXIgcHJlZGljdGlvblNlcnZpY2UgPSB7XG4gICAgICAgICAgICBnZXRUb2tlbml6ZWRQcm9ncmFtOiBmdW5jdGlvbiAocHJvZ3JhbVRva2VucywgdG9rZW5Ub0lkKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW5pemUgUHl0aG9uIHByb2dyYW1zIGluIGRhdGFzZXQgZm9yIHdpbm5vd2luZy5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5pemVkUHJvZ3JhbSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbVRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwcm9ncmFtVG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5JZCA9IHRva2VuWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5OYW1lID0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLk5MIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLkNPTU1FTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLk5BTUUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEtXX0xJU1QuaW5kZXhPZih0b2tlbk5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFRPS0VOX05BTUVfVkFSKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblRvSWQuaGFzT3duUHJvcGVydHkodG9rZW5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaCh0b2tlbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFRPS0VOX05BTUVfVU5LKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5pemVkUHJvZ3JhbTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUb2tlbml6ZWRQcm9ncmFtRm9yQ1Y6IGZ1bmN0aW9uIChwcm9ncmFtVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW5pemUgUHl0aG9uIHByb2dyYW1zIGluIGRhdGFzZXQgZm9yIHdpbm5vd2luZy5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5pemVkUHJvZ3JhbSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbVRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwcm9ncmFtVG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5JZCA9IHRva2VuWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5OYW1lID0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLk5MIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLkNPTU1FTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbklkID09PSBQeXRob25Qcm9ncmFtVG9rZW5UeXBlLk5BTUUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEtXX0xJU1QuaW5kZXhPZih0b2tlbk5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVkUHJvZ3JhbS5wdXNoKFRPS0VOX05BTUVfVkFSKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplZFByb2dyYW0ucHVzaCh0b2tlbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbml6ZWRQcm9ncmFtO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGNKYWNjYXJkSW5kZXg6IGZ1bmN0aW9uIChtdWx0aXNldEEsIG11bHRpc2V0Qikge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBqYWNjYXJkIGluZGV4IGJldHdlZW4gdHdvIG11bHRpc2V0cy5cbiAgICAgICAgICAgICAgICBtdWx0aXNldEEuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA+IHkgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbXVsdGlzZXRCLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPiB5ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBzbWFsbFNldCA9ICgobXVsdGlzZXRBLmxlbmd0aCA8IG11bHRpc2V0Qi5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlzZXRBLnNsaWNlKCkgOiBtdWx0aXNldEIuc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHVuaW9uU2V0ID0gKChtdWx0aXNldEEubGVuZ3RoIDwgbXVsdGlzZXRCLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXNldEIuc2xpY2UoKSA6IG11bHRpc2V0QS5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgc21hbGxTZXQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB1bmlvblNldC5sZW5ndGggJiYgZWxlbSA+IHVuaW9uU2V0W2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdW5pb25TZXQubGVuZ3RoIHx8IGVsZW0gPCB1bmlvblNldFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhRWxlbWVudHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtID09PSB1bmlvblNldFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1bmlvblNldCA9IHVuaW9uU2V0LmNvbmNhdChleHRyYUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodW5pb25TZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblNldCA9IFtdO1xuICAgICAgICAgICAgICAgIG11bHRpc2V0QS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IG11bHRpc2V0Qi5sZW5ndGggJiYgZWxlbSA+IG11bHRpc2V0QltpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbXVsdGlzZXRCLmxlbmd0aCAmJiBlbGVtID09PSBtdWx0aXNldEJbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25TZXQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY29lZmYgPSBpbnRlcnNlY3Rpb25TZXQubGVuZ3RoIC8gdW5pb25TZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2VmZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQcm9ncmFtU2ltaWxhcml0eTogZnVuY3Rpb24gKGZpbmdlcnByaW50QSwgZmluZ2VycHJpbnRCKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gcHJvZ3JhbXMnIGZpbmdlcnByaW50cy5cbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlzZXRBID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpc2V0QiA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50QS5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpc2V0QS5wdXNoKGhhc2hbMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50Qi5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpc2V0Qi5wdXNoKGhhc2hbMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWN0aW9uU2VydmljZS5jYWxjSmFjY2FyZEluZGV4KG11bHRpc2V0QSwgbXVsdGlzZXRCKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kTmVhcmVzdE5laWdoYm9yc0luZGV4ZXM6IGZ1bmN0aW9uIChrbm5EYXRhLCBwcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBpbmRleCBvZiBuZWFyZXN0IG5laWdoYm9yIHByb2dyYW1zIHRvIGdpdmVuIHByb2dyYW0uXG4gICAgICAgICAgICAgICAgdmFyIEsgPSBrbm5EYXRhLks7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSBrbm5EYXRhLlQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmdlcnByaW50RGF0YSA9IGtubkRhdGEuZmluZ2VycHJpbnRfZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5Ub0lkID0ga25uRGF0YS50b2tlbl90b19pZDtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0ga25uRGF0YS50b3A7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBwcm9ncmFtIHRva2VucyB1c2luZyBweXRob24gcHJvZ3JhbSB0b2tlbml6ZXIuXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW1MaW5lcyA9IHByb2dyYW0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIC8vIEVtcHR5IGxpbmVzIGluIGJldHdlZW4gcHJvZ3JhbSBjYXVzZXMgcGFyc2VyIHRvIHRoaW5rIHRoYXQgcHJvZ3JhbVxuICAgICAgICAgICAgICAgIC8vIGhhcyBlbmRlZCB3aGljaCBsZWFkcyB0byBnZW5lcmF0aW9uIG9mIHdyb25nIHNldCBvZiB0b2tlbnMuXG4gICAgICAgICAgICAgICAgcHJvZ3JhbUxpbmVzID0gcHJvZ3JhbUxpbmVzLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZS50cmltKCkubGVuZ3RoICE9PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBweXRob25Qcm9ncmFtVG9rZW5zID0gUHl0aG9uUHJvZ3JhbVRva2VuaXplci5nZW5lcmF0ZVRva2Vucyhwcm9ncmFtTGluZXMpO1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwcm9ncmFtIHRva2VucyBmb3Igd2lubm93aW5nIHByZXByb2Nlc3NpbmcuIFRoaXMgcmVtb3Zlc1xuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHRva2VucyBhbmQgbm9ybWFsaXplcyB2YXJpYWJsZSBhbmQgbWV0aG9kIG5hbWUgdG9rZW5zLlxuICAgICAgICAgICAgICAgIHZhciB0b2tlbml6ZWRQcm9ncmFtID0gcHJlZGljdGlvblNlcnZpY2UuZ2V0VG9rZW5pemVkUHJvZ3JhbShweXRob25Qcm9ncmFtVG9rZW5zLCB0b2tlblRvSWQpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgay1ncmFtIGhhc2hlcyBmcm9tIG5vcm1hbGl6ZWQgcHJvZ3JhbSB0b2tlbnMuXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW1IYXNoZXMgPSBXaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZS5nZXRLR3JhbUhhc2hlcyh0b2tlbml6ZWRQcm9ncmFtLCB0b2tlblRvSWQsIEspO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgZmluZ2VycHJpbnQgZnJvbSBrLWdyYW0gaGFzaGVzIG9mIHByb2dyYW0uXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW1GaW5nZXJwcmludCA9IChXaW5ub3dpbmdQcmVwcm9jZXNzaW5nU2VydmljZS5nZXRGaW5nZXJwcmludEZyb21IYXNoZXMocHJvZ3JhbUhhc2hlcywgVCwgSykpO1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bHRlIHNpbWlsYXJpdHkgb2YgdGhlIGlucHV0IHByb2dyYW0gd2l0aCBldmVyeSBwcm9ncmFtIGluXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NpZmllciBkYXRhIGZvciBrIG5lYXJlc3QgbmVpZ2hib3IgY2xhc3NpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgdmFyIHNpbWlsYXJpdHlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmluZ2VycHJpbnREYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmluZ2VycHJpbnRBID0gZmluZ2VycHJpbnREYXRhW2luZGV4XS5maW5nZXJwcmludDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpbWlsYXJpdHkgPSBwcmVkaWN0aW9uU2VydmljZS5nZXRQcm9ncmFtU2ltaWxhcml0eShmaW5nZXJwcmludEEsIHByb2dyYW1GaW5nZXJwcmludCk7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHlMaXN0LnB1c2goW3BhcnNlSW50KGluZGV4KSwgc2ltaWxhcml0eV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFNvcnQgdGhlIHByb2dyYW1zIGFjY29yZGluZyB0byB0aGVpciBzaW1pbGFpcnkgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbnB1dCBwcm9ncmFtLlxuICAgICAgICAgICAgICAgIHNpbWlsYXJpdHlMaXN0LnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhbMV0gPiB5WzFdID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZWFyZXN0TmVpZ2hib3JzSW5kZXhlcyA9IHNpbWlsYXJpdHlMaXN0LnNsaWNlKDAsIHRvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lYXJlc3ROZWlnaGJvcnNJbmRleGVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWRpY3Q6IGZ1bmN0aW9uIChjbGFzc2lmaWVyRGF0YSwgYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHB5dGhvbiBjb2RlIGZyb20gdGhlIGlucHV0IGFuc3dlci5cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IGFuc3dlci5jb2RlO1xuICAgICAgICAgICAgICAgIHZhciBrbm5EYXRhID0gY2xhc3NpZmllckRhdGEuS05OO1xuICAgICAgICAgICAgICAgIHZhciBzdm1EYXRhID0gY2xhc3NpZmllckRhdGEuU1ZNO1xuICAgICAgICAgICAgICAgIHZhciBjdlZvY2FidWxhcnkgPSBjbGFzc2lmaWVyRGF0YS5jdl92b2NhYnVsYXJ5O1xuICAgICAgICAgICAgICAgIHZhciBmaW5nZXJwcmludERhdGEgPSBrbm5EYXRhLmZpbmdlcnByaW50X2RhdGE7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGtubkRhdGEudG9wO1xuICAgICAgICAgICAgICAgIHZhciBvY2N1cnJlbmNlID0ga25uRGF0YS5vY2N1cnJlbmNlO1xuICAgICAgICAgICAgICAgIHZhciBuZWFyZXN0TmVpZ2hib3JzSW5kZXhlcyA9IChwcmVkaWN0aW9uU2VydmljZS5maW5kTmVhcmVzdE5laWdoYm9yc0luZGV4ZXMoa25uRGF0YSwgcHJvZ3JhbSkpO1xuICAgICAgICAgICAgICAgIHZhciBuZWFyZXNOZWlnaGJvcnNDbGFzc2VzID0gW107XG4gICAgICAgICAgICAgICAgLy8gRmluZCBjbGFzc2VzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcHJvZ3JhbXMuXG4gICAgICAgICAgICAgICAgbmVhcmVzdE5laWdoYm9yc0luZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbmVpZ2hib3JbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRDbGFzc1Byb3BlcnR5TmFtZSA9ICdjbGFzcyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW1pbGFyaXR5ID0gbmVpZ2hib3JbMV07XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc05laWdoYm9yc0NsYXNzZXMucHVzaChbZmluZ2VycHJpbnREYXRhW2luZGV4XVtvdXRwdXRDbGFzc1Byb3BlcnR5TmFtZV0sIHNpbWlsYXJpdHldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBDb3VudCBob3cgbWFueSB0aW1lcyBhIGNsYXNzIGFwcGVhcnMgaW4gbmVhcmVzdCBuZWlnaGJvcnMuXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzQ291bnQgPSB7fTtcbiAgICAgICAgICAgICAgICBuZWFyZXNOZWlnaGJvcnNDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRDbGFzcyA9IG5laWdoYm9yWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NDb3VudC5oYXNPd25Qcm9wZXJ0eShvdXRwdXRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzQ291bnRbb3V0cHV0Q2xhc3NdICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0NvdW50W291dHB1dENsYXNzXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB3aW5uaW5nIGNsYXNzLlxuICAgICAgICAgICAgICAgIHZhciBjbGFzc0NvdW50QXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjbGFzc0NvdW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzQ291bnRBcnJheS5wdXNoKFtwYXJzZUludChrKSwgY2xhc3NDb3VudFtrXV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNsYXNzQ291bnRBcnJheS5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4WzFdID4geVsxXSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZGljdGVkQ2xhc3MgPSBjbGFzc0NvdW50QXJyYXlbMF1bMF07XG4gICAgICAgICAgICAgICAgdmFyIHByZWRpY3RlZENsYXNzT2NjdXJyZW5jZSA9IGNsYXNzQ291bnRBcnJheVswXVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZGljdGlvbiA9IHByZWRpY3RlZENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWN0ZWRDbGFzc09jY3VycmVuY2UgPj0gb2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NDb3VudEFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWN0ZWRDbGFzc09jY3VycmVuY2UgIT09IGNsYXNzQ291bnRBcnJheVsxXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgc2Vjb25kIG1vc3QgbGlrZWx5IHByZWRpY3Rpb24gZG9lcyBub3QgaGF2ZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXJyZW5jZSBjb3VudC4gSWYgaXQgZG9lcywgdGhlbiB3ZSBhc3N1bWUgdGhhdCBLTk4gaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgS05OIGZhaWxzIHRvIHByZWRpY3QgdGhlbiB1c2UgU1ZNIHRvIHByZWRpY3QgdGhlIG91dHB1dCBjbGFzcy5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHByb2dyYW0gdG9rZW5zIHVzaW5nIHB5dGhvbiBwcm9ncmFtIHRva2VuaXplci5cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbUxpbmVzID0gcHJvZ3JhbS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgbGluZXMgaW4gYmV0d2VlbiBwcm9ncmFtIGNhdXNlcyBwYXJzZXIgdG8gdGhpbmsgdGhhdCBwcm9ncmFtXG4gICAgICAgICAgICAgICAgLy8gaGFzIGVuZGVkIHdoaWNoIGxlYWRzIHRvIGdlbmVyYXRpb24gb2Ygd3Jvbmcgc2V0IG9mIHRva2Vucy5cbiAgICAgICAgICAgICAgICBwcm9ncmFtTGluZXMgPSBwcm9ncmFtTGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHB5dGhvblByb2dyYW1Ub2tlbnMgPSBQeXRob25Qcm9ncmFtVG9rZW5pemVyLmdlbmVyYXRlVG9rZW5zKHByb2dyYW1MaW5lcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuaXplZFByb2dyYW0gPSBwcmVkaWN0aW9uU2VydmljZS5nZXRUb2tlbml6ZWRQcm9ncmFtRm9yQ1YocHl0aG9uUHJvZ3JhbVRva2Vucyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW1WZWN0b3IgPSBDb3VudFZlY3Rvcml6ZXJTZXJ2aWNlLnZlY3Rvcml6ZSh0b2tlbml6ZWRQcm9ncmFtLCBjdlZvY2FidWxhcnkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVkaWN0aW9uUmVzdWx0ID0gU1ZNUHJlZGljdGlvblNlcnZpY2UucHJlZGljdChzdm1EYXRhLCBwcm9ncmFtVmVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljdGlvblJlc3VsdC5wcmVkaWN0aW9uQ29uZmlkZW5jZSA+XG4gICAgICAgICAgICAgICAgICAgIENPREVfUkVQTF9QUkVESUNUSU9OX1NFUlZJQ0VfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWN0aW9uUmVzdWx0LnByZWRpY3Rpb25MYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJlZGljdGlvblNlcnZpY2U7XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJ1bGVzIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnZmlsdGVycy9zdHJpbmctdXRpbGl0eS1maWx0ZXJzL25vcm1hbGl6ZS13aGl0ZXNwYWNlLmZpbHRlci50cycpO1xucmVxdWlyZSgnc2VydmljZXMvQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdDb2RlUmVwbFJ1bGVzU2VydmljZScsIFtcbiAgICAnJGZpbHRlcicsICdDb2RlTm9ybWFsaXplclNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uICgkZmlsdGVyLCBDb2RlTm9ybWFsaXplclNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIENvZGVFcXVhbHM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQ29kZSA9IENvZGVOb3JtYWxpemVyU2VydmljZS5nZXROb3JtYWxpemVkQ29kZShhbnN3ZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFeHBlY3RlZENvZGUgPSBDb2RlTm9ybWFsaXplclNlcnZpY2UuZ2V0Tm9ybWFsaXplZENvZGUoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQ29kZSA9PT0gbm9ybWFsaXplZEV4cGVjdGVkQ29kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb2RlQ29udGFpbnM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQ29kZSA9IENvZGVOb3JtYWxpemVyU2VydmljZS5nZXROb3JtYWxpemVkQ29kZShhbnN3ZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRTbmlwcGV0ID0gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLmdldE5vcm1hbGl6ZWRDb2RlKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZENvZGUuaW5kZXhPZihub3JtYWxpemVkU25pcHBldCkgIT09IC0xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENvZGVEb2VzTm90Q29udGFpbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRDb2RlID0gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLmdldE5vcm1hbGl6ZWRDb2RlKGFuc3dlci5jb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFNuaXBwZXQgPSBDb2RlTm9ybWFsaXplclNlcnZpY2UuZ2V0Tm9ybWFsaXplZENvZGUoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQ29kZS5pbmRleE9mKG5vcm1hbGl6ZWRTbmlwcGV0KSA9PT0gLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgT3V0cHV0Q29udGFpbnM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkT3V0cHV0ID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkU25pcHBldCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRPdXRwdXQuaW5kZXhPZihub3JtYWxpemVkU25pcHBldCkgIT09IC0xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE91dHB1dEVxdWFsczogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRPdXRwdXQgPSAkZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlJykoYW5zd2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFeHBlY3RlZE91dHB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRPdXRwdXQgPT09IG5vcm1hbGl6ZWRFeHBlY3RlZE91dHB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSZXN1bHRzSW5FcnJvcjogZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIShhbnN3ZXIuZXJyb3IudHJpbSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBFcnJvckNvbnRhaW5zOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEVycm9yID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlci5lcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRTbmlwcGV0ID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEVycm9yLmluZGV4T2Yobm9ybWFsaXplZFNuaXBwZXQpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvZGVSZXBsVmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLnJlcXVpcmVDdXN0b21pemF0aW9uQXJndW1lbnRzKGN1c3RvbWl6YXRpb25BcmdzLCBbXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnLFxuICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICdwcmVDb2RlJyxcbiAgICAgICAgICAgICdwb3N0Q29kZSdcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IGN1c3RvbWl6YXRpb25BcmdzLmxhbmd1YWdlLnZhbHVlO1xuICAgICAgICBpZiAoISh0eXBlb2YgbGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgbmFtZSBtdXN0IGJlIGEgc3RyaW5nLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGN1c3RvbWl6YXRpb25BcmdzLnBsYWNlaG9sZGVyLnZhbHVlO1xuICAgICAgICBpZiAoISh0eXBlb2YgcGxhY2Vob2xkZXIgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxhY2Vob2xkZXIgdGV4dCBtdXN0IGJlIGEgc3RyaW5nLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVDb2RlID0gY3VzdG9taXphdGlvbkFyZ3MucHJlQ29kZS52YWx1ZTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHByZUNvZGUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhlIHByZS1jb2RlIHRleHQgbXVzdCBiZSBhIHN0cmluZy4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zdENvZGUgPSBjdXN0b21pemF0aW9uQXJncy5wb3N0Q29kZS52YWx1ZTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHBvc3RDb2RlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBwb3N0LWNvZGUgdGV4dCBtdXN0IGJlIGEgc3RyaW5nLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpLmNvbmNhdCh0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UuZ2V0QWxsT3V0Y29tZVdhcm5pbmdzKGFuc3dlckdyb3VwcywgZGVmYXVsdE91dGNvbWUsIHN0YXRlTmFtZSkpO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIENvZGVSZXBsVmFsaWRhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIENvZGVSZXBsVmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuQ29kZVJlcGxWYWxpZGF0aW9uU2VydmljZSA9IENvZGVSZXBsVmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShDb2RlUmVwbFZhbGlkYXRpb25TZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIENvZGVSZXBsIGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2NvZGVtaXJyb3JSZXF1aXJlcy50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvZGVSZXBsL2RpcmVjdGl2ZXMvY29kZS1yZXBsLXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2V4cGxvcmF0aW9uLXBsYXllci1wYWdlL3NlcnZpY2VzL2N1cnJlbnQtaW50ZXJhY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9jb250ZXh0dWFsL1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVDb2RlUmVwbCcsIFtcbiAgICAnQ29kZVJlcGxSdWxlc1NlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICAnRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFJyxcbiAgICBmdW5jdGlvbiAoQ29kZVJlcGxSdWxlc1NlcnZpY2UsIEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UsIEVWRU5UX05FV19DQVJEX0FWQUlMQUJMRSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBnZXRMYXN0QW5zd2VyOiAnJmxhc3RBbnN3ZXInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdjb2RlLXJlcGwtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRhdHRycycsICdXaW5kb3dEaW1lbnNpb25zU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgV2luZG93RGltZW5zaW9uc1NlcnZpY2UsIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgPSAoY3RybC5nZXRMYXN0QW5zd2VyKCkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKEVWRU5UX05FV19DQVJEX0FWQUlMQUJMRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxhbmd1YWdlID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmxhbmd1YWdlV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5wbGFjZWhvbGRlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5wbGFjZWhvbGRlcldpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucHJlQ29kZSA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5wcmVDb2RlV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5wb3N0Q29kZSA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5wb3N0Q29kZVdpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjdHJsLnByZUNvZGUgZW5kcyB3aXRoIGEgbmV3bGluZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwucHJlQ29kZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnByZUNvZGUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnByZUNvZGUuc2xpY2UoLTEpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5wcmVDb2RlICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjdHJsLnBsYWNlaG9sZGVyIGVuZHMgd2l0aCBhIG5ld2xpbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnBsYWNlaG9sZGVyLnNsaWNlKC0xKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucGxhY2Vob2xkZXIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgY29kZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIHVzZXIgYW5kIHRoZSBzdGRvdXQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGlvbiB1bnRpbCBzZW5kaW5nIHRoZW0gYmFjayB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNvZGUgPSAoY3RybC5wcmVDb2RlICsgY3RybC5wbGFjZWhvbGRlciArIGN0cmwucG9zdENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5vdXRwdXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29kZSA9IGN0cmwuZ2V0TGFzdEFuc3dlcigpLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm91dHB1dCA9IGN0cmwuZ2V0TGFzdEFuc3dlcigpLm91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHJsLmluaXRDb2RlRWRpdG9yID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKGN0cmwuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgdWktY29kZW1pcnJvciBkaXNwbGF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldE9wdGlvbignbGluZU51bWJlcnMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oJ2luZGVudFdpdGhUYWJzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9uKCdpbmRlbnRVbml0JywgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9uKCdtb2RlJywgJ3B5dGhvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldE9wdGlvbignZXh0cmFLZXlzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSBBcnJheShjbS5nZXRPcHRpb24oJ2luZGVudFVuaXQnKSArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzcGFjZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kU2VsZWN0aW9uUG9zID0gY20uZ2V0RG9jKCkuZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtLmdldERvYygpLnNldEN1cnNvcihlbmRTZWxlY3Rpb25Qb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldE9wdGlvbigndGhlbWUnLCAncHJldmlldyBkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0aGUgdGV4dGFyZWEgYmVpbmcgZ3JleWVkLW91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdE1hcmtlcnMoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNvZGUgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzLCB0aGUgZWRpdG9yIGRvZXMgbm90IHNob3cgdXAgY29ycmVjdGx5IG9uIHNtYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY3JlZW5zIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gdGhlIHN1cHBsZW1lbnRhbCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ3Nob3dJbnRlcmFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdE1hcmtlcnMoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmZpZ3VyZSBTa3VscHQuXG4gICAgICAgICAgICAgICAgICAgIFNrLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG91dHB1dCBmdW5jdGlvbiBpcyBjYWxsZWQgY29udGludW91c2x5IHRocm91Z2hvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVudGltZSBvZiB0aGUgc2NyaXB0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3V0cHV0ICs9IG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYSBidWlsdGluIG1vZHVsZSBpcyBpbXBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTay5idWlsdGluRmlsZXMuZmlsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb3JyZXNwb25kaW5nIG1vZHVsZSBpcyBub3QgcHJlc2VudCB0aGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmFsIG9mIHRoaXMgYmxvY2sgYWxzbyByZXN1bHRzIGluIGZhaWx1cmUgb2YgaW1wb3J0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbW9kdWxlICcgKyBuYW1lICsgJyBub3QgZm91bmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzLmZpbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRNc2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbmRSZXNwb25zZSgnJywgJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjTGltaXQ6IDEwMDAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnJ1bkFuZFN1Ym1pdENvZGUgPSBmdW5jdGlvbiAoY29kZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJ1bkNvZGUoY29kZUlucHV0LCBmdW5jdGlvbiAoZXZhbHVhdGlvbiwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zZW5kUmVzcG9uc2UoZXZhbHVhdGlvbiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0QW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ydW5BbmRTdWJtaXRDb2RlKGN0cmwuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucnVuQ29kZSA9IGZ1bmN0aW9uIChjb2RlSW5wdXQsIG9uRmluaXNoUnVuQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29kZSA9IGNvZGVJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3V0cHV0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcHJvZ3JhbSBhc3luY2hyb25vdXNseSB1c2luZyBTa3VscHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2suaW1wb3J0TWFpbldpdGhCb2R5KCc8c3RkaW4+JywgZmFsc2UsIGNvZGVJbnB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCBldmFsdWF0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZXZhbHVhdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZnVsbEVycm9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmluaXNoUnVuQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5pc2hSdW5DYWxsYmFjaygnJywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBTay5idWlsdGluLlRpbWVMaW1pdEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmV2YWx1YXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5mdWxsRXJyb3IgPSBTdHJpbmcoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmluaXNoUnVuQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmluaXNoUnVuQ2FsbGJhY2soJycsIFN0cmluZyhlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdE1hcmtlcnMgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZWRpdG9yLmdldERvYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIC0xIGhlcmUgaXMgYmVjYXVzZSBwcmVwZW5kZWQgY29kZSBlbmRzIHdpdGggYSBuZXdsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZUNvZGVOdW1MaW5lcyA9IGN0cmwucHJlQ29kZS5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3N0Q29kZU51bUxpbmVzID0gY3RybC5wb3N0Q29kZS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxDb2RlTnVtTGluZXMgPSBjdHJsLmNvZGUuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyQ29kZU51bUxpbmVzID0gKGZ1bGxDb2RlTnVtTGluZXMgLSBwcmVDb2RlTnVtTGluZXMgLSBwb3N0Q29kZU51bUxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgcHJlLSBhbmQgcG9zdC0gY29kZSBhcyB1bmVkaXRhYmxlLCBhbmQgZ2l2ZSBpdCBzb21lIHN0eWxpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRvbWljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmVMZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZVJpZ2h0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwucHJlQ29kZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MubWFya1RleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogcHJlQ29kZU51bUxpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuZ3VsYXIuZXh0ZW5kKHt9LCBtYXJrT3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmVSaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVDb2RlTnVtTGluZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYWRkTGluZUNsYXNzKGksICd0ZXh0JywgJ2NvZGUtcmVwbC1ub25lZGl0YWJsZS1saW5lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwucG9zdENvZGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jLm1hcmtUZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogcHJlQ29kZU51bUxpbmVzICsgdXNlckNvZGVOdW1MaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2g6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGZ1bGxDb2RlTnVtTGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbWFya09wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdENvZGVOdW1MaW5lczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5hZGRMaW5lQ2xhc3MocHJlQ29kZU51bUxpbmVzICsgdXNlckNvZGVOdW1MaW5lcyArIGksICd0ZXh0JywgJ2NvZGUtcmVwbC1ub25lZGl0YWJsZS1saW5lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbmRSZXNwb25zZSA9IGZ1bmN0aW9uIChldmFsdWF0aW9uLCBlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGFicyB3aXRoIDIgc3BhY2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oc2xsKTogQ2hhbmdlIHRoZSBkZWZhdWx0IFB5dGhvbiBpbmRlbnRhdGlvbiB0byA0IHNwYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjdHJsLmNvZGUucmVwbGFjZSgvXFx0L2csICcgICcpIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogY3RybC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbjogY3RybC5ldmFsdWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyIHx8ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgQ29kZVJlcGxSdWxlc1NlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzLCB0aGUgZXJyb3IgbWVzc2FnZSBkaXNwbGF5ZWQgaW4gdGhlIHVzZXItZmFjaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlIHdpbGwgc29tZXRpbWVzIG5vdCB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oc3VibWl0QW5zd2VyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIENvZGVSZXBsIHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9zdGF0ZWZ1bC9Gb2N1c01hbmFnZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VDb2RlUmVwbCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0NvZGVSZXBsL2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ2NvZGUtcmVwbC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICckYXR0cnMnLCAnRm9jdXNNYW5hZ2VyU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRhdHRycywgRm9jdXNNYW5hZ2VyU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFuc3dlci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvckZvY3VzTGFiZWwgPSBGb2N1c01hbmFnZXJTZXJ2aWNlLmdlbmVyYXRlRm9jdXNMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRm9jdXNNYW5hZ2VyU2VydmljZS5zZXRGb2N1cyhjdHJsLmVycm9yRm9jdXNMYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIENvZGVSZXBsIHNob3J0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZmlsdGVycy9zdHJpbmctdXRpbGl0eS1maWx0ZXJzL3RydW5jYXRlLWF0LWZpcnN0LWxpbmUuZmlsdGVyLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlQ29kZVJlcGwnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9Db2RlUmVwbC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdjb2RlLXJlcGwtc2hvcnQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2NvZGVfcmVwbC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vY29kZV9yZXBsLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vY29kZV9yZXBsLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIENvbnRpbnVlIGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvQ29udGludWUvZGlyZWN0aXZlcy9jb250aW51ZS1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvQ29udGludWUvZGlyZWN0aXZlcy9jb250aW51ZS12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvbnRpbnVlL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXJlc3BvbnNlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvbnRpbnVlL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXNob3J0LXJlc3BvbnNlLWNvbnRpbnVlLmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBDb250aW51ZVJ1bGVzU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250aW51ZVJ1bGVzU2VydmljZSgpIHtcbiAgICB9XG4gICAgQ29udGludWVSdWxlc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pXG4gICAgXSwgQ29udGludWVSdWxlc1NlcnZpY2UpO1xuICAgIHJldHVybiBDb250aW51ZVJ1bGVzU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkNvbnRpbnVlUnVsZXNTZXJ2aWNlID0gQ29udGludWVSdWxlc1NlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdDb250aW51ZVJ1bGVzU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoQ29udGludWVSdWxlc1NlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBDb250aW51ZVZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRpbnVlVmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBDb250aW51ZVZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLnJlcXVpcmVDdXN0b21pemF0aW9uQXJndW1lbnRzKGN1c3RvbWl6YXRpb25BcmdzLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgICAgIGlmIChjdXN0b21pemF0aW9uQXJncy5idXR0b25UZXh0LnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGJ1dHRvbiB0ZXh0IHNob3VsZCBub3QgYmUgZW1wdHkuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIENvbnRpbnVlVmFsaWRhdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEFsbFdhcm5pbmdzID0gZnVuY3Rpb24gKHN0YXRlTmFtZSwgY3VzdG9taXphdGlvbkFyZ3MsIGFuc3dlckdyb3VwcywgZGVmYXVsdE91dGNvbWUpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzTGlzdCA9IHRoaXMuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyhjdXN0b21pemF0aW9uQXJncyk7XG4gICAgICAgIGlmIChhbnN3ZXJHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ09ubHkgdGhlIGRlZmF1bHQgb3V0Y29tZSBpcyBuZWNlc3NhcnkgZm9yIGEgY29udGludWUnICtcbiAgICAgICAgICAgICAgICAgICAgJyBpbnRlcmFjdGlvbi4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWZhdWx0T3V0Y29tZSB8fCBkZWZhdWx0T3V0Y29tZS5pc0NvbmZ1c2luZyhzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUGxlYXNlIHNwZWNpZnkgd2hhdCBPcHBpYSBzaG91bGQgZG8gYWZ0ZXIgdGhlIGJ1dHRvbicgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGNsaWNrZWQuJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgQ29udGludWVWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgQ29udGludWVWYWxpZGF0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIENvbnRpbnVlVmFsaWRhdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5Db250aW51ZVZhbGlkYXRpb25TZXJ2aWNlID0gQ29udGludWVWYWxpZGF0aW9uU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ0NvbnRpbnVlVmFsaWRhdGlvblNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKENvbnRpbnVlVmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgQ29udGludWUgYnV0dG9uIGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0NvbnRpbnVlL2RpcmVjdGl2ZXMvY29udGludWUtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgncGFnZXMvZXhwbG9yYXRpb24tcGxheWVyLXBhZ2Uvc2VydmljZXMvY3VycmVudC1pbnRlcmFjdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9Db250ZXh0U2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9jb250ZXh0dWFsL1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVDb250aW51ZScsIFtcbiAgICAnQ29udGludWVSdWxlc1NlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoQ29udGludWVSdWxlc1NlcnZpY2UsIEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdjb250aW51ZS1pbnRlcmFjdGlvbi5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICckYXR0cnMnLCAnV2luZG93RGltZW5zaW9uc1NlcnZpY2UnLFxuICAgICAgICAgICAgICAgICdDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlJywgJ0NvbnRleHRTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGF0dHJzLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSwgQ29udGV4dFNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmJ1dHRvblRleHQgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYnV0dG9uVGV4dFdpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBERUZBVUxUX0JVVFRPTl9URVhUID0gJ0NvbnRpbnVlJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIERFRkFVTFRfSFVNQU5fUkVBREFCTEVfQU5TV0VSID0gJ1BsZWFzZSBjb250aW51ZS4nO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzSW5FZGl0b3JNb2RlID0gQ29udGV4dFNlcnZpY2UuaXNJbkV4cGxvcmF0aW9uRWRpdG9yTW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZWQgdG8gc2hvdyBcIihDb250aW51ZSlcIiB0byBpbmRpY2F0ZSBhICdjb250aW51ZScgYWN0aW9uIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsZWFybmVyIGJyb3dzZXMgdGhyb3VnaCB0aGUgaGlzdG9yeSBvZiB0aGUgZXhwbG9yYXRpb24sIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhcHBhcmVudGx5IGNhbiBiZSBtaXN0YWtlbiBmb3IgYSBidXR0b24vY29udHJvbC4gVGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dpbmcgbWFrZXMgdGhlIGxlYXJuZXIncyBcImFuc3dlclwiIGEgYml0IG1vcmUgY29udmVyc2F0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyBpZiB0aGV5IHdlcmUgY2hhdHRpbmcgd2l0aCBPcHBpYS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodW1hblJlYWRhYmxlQW5zd2VyID0gREVGQVVMVF9IVU1BTl9SRUFEQUJMRV9BTlNXRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5idXR0b25UZXh0ICE9PSBERUZBVUxUX0JVVFRPTl9URVhUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZUFuc3dlciA9IGN0cmwuYnV0dG9uVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoaHVtYW5SZWFkYWJsZUFuc3dlciwgQ29udGludWVSdWxlc1NlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uKGN0cmwuc3VibWl0QW5zd2VyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIENvbnRpbnVlIGJ1dHRvbiByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVJlc3BvbnNlQ29udGludWUnLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvQ29udGludWUvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnY29udGludWUtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ0h0bWxFc2NhcGVyU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRhdHRycywgSHRtbEVzY2FwZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIENvbnRpbnVlIGJ1dHRvbiBzaG9ydCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VDb250aW51ZScsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9Db250aW51ZS9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdjb250aW51ZS1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICckYXR0cnMnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGF0dHJzLCBIdG1sRXNjYXBlclNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIERyYWdBbmREcm9wU29ydElucHV0IGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRHJhZ0FuZERyb3BTb3J0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdkcmFnLWFuZC1kcm9wLXNvcnQtaW5wdXQtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRHJhZ0FuZERyb3BTb3J0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtaW50ZXJhY3RpdmUtZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0RyYWdBbmREcm9wU29ydElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXJlc3BvbnNlLWRyYWctYW5kLWRyb3Atc29ydC1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1kcmFnLWFuZC1kcm9wLXNvcnQtaW5wdXQuZGlyZWN0aXZlLnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJ1bGVzIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xuLy8gUnVsZXMgU2VydmljZSBmb3IgRHJhZ0FuZERyb3BTb3J0SW5wdXQgaW50ZXJhY3Rpb24uXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdEcmFnQW5kRHJvcFNvcnRJbnB1dFJ1bGVzU2VydmljZScsIFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGVja0VxdWFsaXR5ID0gZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuc3dlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhbnN3ZXJbaV0ubGVuZ3RoID09PSBpbnB1dHMueFtpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbnN3ZXJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMueFtpXS5pbmRleE9mKGFuc3dlcltpXVtqXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjaGVja0VxdWFsaXR5V2l0aEluY29ycmVjdFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgdmFyIG5vT2ZNaXNtYXRjaGVzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0aC5taW4oaW5wdXRzLngubGVuZ3RoLCBhbnN3ZXIubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRoLm1heChhbnN3ZXJbaV0ubGVuZ3RoLCBpbnB1dHMueFtpXS5sZW5ndGgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy54W2ldLmxlbmd0aCA+IGFuc3dlcltpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbnN3ZXJbaV0uaW5kZXhPZihpbnB1dHMueFtpXVtqXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9PZk1pc21hdGNoZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMueFtpXS5pbmRleE9mKGFuc3dlcltpXVtqXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9PZk1pc21hdGNoZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub09mTWlzbWF0Y2hlcyA9PT0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIElzRXF1YWxUb09yZGVyaW5nOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyLmxlbmd0aCA9PT0gaW5wdXRzLngubGVuZ3RoICYmIGNoZWNrRXF1YWxpdHkoYW5zd2VyLCBpbnB1dHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElzRXF1YWxUb09yZGVyaW5nV2l0aE9uZUl0ZW1BdEluY29ycmVjdFBvc2l0aW9uOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcXVhbGl0eVdpdGhJbmNvcnJlY3RQb3NpdGlvbnMoYW5zd2VyLCBpbnB1dHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEhhc0VsZW1lbnRYQXRQb3NpdGlvblk6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5zd2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuc3dlcltpXS5pbmRleE9mKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoaSArIDEpID09PSBpbnB1dHMueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSGFzRWxlbWVudFhCZWZvcmVFbGVtZW50WTogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZFggPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kWSA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5zd2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuc3dlcltpXS5pbmRleE9mKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kWCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhbnN3ZXJbaV0uaW5kZXhPZihpbnB1dHMueSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZFkgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRYIDwgaW5kWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgZHJhZyBhbmQgZHJvcCBzb3J0aW5nIGludGVyYWN0aW9uLlxuICovXG4vLyBUT0RPKCM3NDAzKTogQ29udmVydCB0aGlzIHRvIHBhcnRpYWwgaW1wb3J0cy5cbnZhciBtYXRoanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWF0aGpzXCIpKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyYWdBbmREcm9wU29ydElucHV0VmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLnJlcXVpcmVDdXN0b21pemF0aW9uQXJndW1lbnRzKGN1c3RvbWl6YXRpb25BcmdzLCBbJ2Nob2ljZXMnXSk7XG4gICAgICAgIHZhciBhcmVBbnlDaG9pY2VzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZUFueUNob2ljZXNEdXBsaWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWVuQ2hvaWNlcyA9IFtdO1xuICAgICAgICB2YXIgbnVtQ2hvaWNlcyA9IGN1c3RvbWl6YXRpb25BcmdzLmNob2ljZXMudmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQ2hvaWNlcyA8IDIpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhdCBsZWFzdCB0d28gY2hvaWNlcy4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNob2ljZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNob2ljZSA9IGN1c3RvbWl6YXRpb25BcmdzLmNob2ljZXMudmFsdWVbaV07XG4gICAgICAgICAgICBpZiAoY2hvaWNlLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcmVBbnlDaG9pY2VzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZW5DaG9pY2VzLmluZGV4T2YoY2hvaWNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhcmVBbnlDaG9pY2VzRHVwbGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuQ2hvaWNlcy5wdXNoKGNob2ljZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZUFueUNob2ljZXNFbXB0eSkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBjaG9pY2VzIGFyZSBub25lbXB0eS4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJlQW55Q2hvaWNlc0R1cGxpY2F0ZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY2hvaWNlcyBhcmUgdW5pcXVlLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIHNlZW5JdGVtcyA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgIHZhciBhcmVBbnlJdGVtc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmVBbnlJdGVtc0R1cGxpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdCh0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpKTtcbiAgICAgICAgdmFyIGNoZWNrUmVkdW5kYW5jeSA9IGZ1bmN0aW9uIChlYXJsaWVyUnVsZSwgbGF0ZXJSdWxlKSB7XG4gICAgICAgICAgICB2YXIgbm9PZk1pc21hdGNoZXMgPSAwO1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGVhcmxpZXJSdWxlLmlucHV0cy54O1xuICAgICAgICAgICAgdmFyIGFuc3dlciA9IGxhdGVyUnVsZS5pbnB1dHMueDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0aGpzXzEuZGVmYXVsdC5taW4oaW5wdXRzLmxlbmd0aCwgYW5zd2VyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0aGpzXzEuZGVmYXVsdC5tYXgoYW5zd2VyW2ldLmxlbmd0aCwgaW5wdXRzW2ldLmxlbmd0aCk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzW2ldLmxlbmd0aCA+IGFuc3dlcltpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbnN3ZXJbaV0uaW5kZXhPZihpbnB1dHNbaV1bal0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vT2ZNaXNtYXRjaGVzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzW2ldLmluZGV4T2YoYW5zd2VyW2ldW2pdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub09mTWlzbWF0Y2hlcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vT2ZNaXNtYXRjaGVzID09PSAxO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuc3dlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHMgPSBydWxlc1tqXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlckdyb3VwSW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICBydWxlSW5kZXg6IGogKyAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWVuSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhcmVBbnlJdGVtc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXJlQW55SXRlbXNEdXBsaWNhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChydWxlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSGFzRWxlbWVudFhCZWZvcmVFbGVtZW50WSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLnggPT09IGlucHV0cy55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICsgJyB3aWxsIG5ldmVyIGJlIG1hdGNoZWQgYmVjYXVzZSBib3RoIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZWxlY3RlZCBlbGVtZW50cyBhcmUgc2FtZS4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0lzRXF1YWxUb09yZGVyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNFcXVhbFRvT3JkZXJpbmdXaXRoT25lSXRlbUF0SW5jb3JyZWN0UG9zaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbnB1dHMueC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMueFtrXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlQW55SXRlbXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGlucHV0cy54W2tdLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0cy54W2tdW2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZUFueUl0ZW1zRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5JdGVtcy5pbmRleE9mKGl0ZW0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZUFueUl0ZW1zRHVwbGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmVBbnlJdGVtc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgZW5zdXJlIHRoZSBpdGVtcyBhcmUgbm9uZW1wdHkuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZUFueUl0ZW1zRHVwbGljYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVuc3VyZSB0aGUgaXRlbXMgYXJlIHVuaXF1ZS4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByYW5nZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhcmxpZXJSdWxlID0gYW5zd2VyR3JvdXBzW3Jhbmdlc1trXS5hbnN3ZXJHcm91cEluZGV4IC0gMV0uXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc1tyYW5nZXNba10ucnVsZUluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlYXJsaWVyUnVsZS50eXBlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lzRXF1YWxUb09yZGVyaW5nV2l0aE9uZUl0ZW1BdEluY29ycmVjdFBvc2l0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50eXBlID09PSAnSXNFcXVhbFRvT3JkZXJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZWR1bmRhbmN5KGVhcmxpZXJSdWxlLCBydWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArICcgd2lsbCBuZXZlciBiZSBtYXRjaGVkIGJlY2F1c2UgaXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXMgbWFkZSByZWR1bmRhbnQgYnkgcnVsZSAnICsgcmFuZ2VzW2tdLnJ1bGVJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGZyb20gYW5zd2VyIGdyb3VwICcgKyByYW5nZXNba10uYW5zd2VyR3JvdXBJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gRHJhZ0FuZERyb3BTb3J0SW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkRyYWdBbmREcm9wU29ydElucHV0VmFsaWRhdGlvblNlcnZpY2UgPSBEcmFnQW5kRHJvcFNvcnRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnRHJhZ0FuZERyb3BTb3J0SW5wdXRWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoRHJhZ0FuZERyb3BTb3J0SW5wdXRWYWxpZGF0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBEcmFnQW5kRHJvcFNvcnRJbnB1dCBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0RyYWdBbmREcm9wU29ydElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ2RyYWctYW5kLWRyb3Atc29ydC1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9VcmxTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVEcmFnQW5kRHJvcFNvcnRJbnB1dCcsIFtcbiAgICAnRHJhZ0FuZERyb3BTb3J0SW5wdXRSdWxlc1NlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJyxcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoRHJhZ0FuZERyb3BTb3J0SW5wdXRSdWxlc1NlcnZpY2UsIEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9EcmFnQW5kRHJvcFNvcnRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdkcmFnLWFuZC1kcm9wLXNvcnQtaW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ1VybFNlcnZpY2UnLCAnQ3VycmVudEludGVyYWN0aW9uU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRhdHRycywgVXJsU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2hvaWNlcyA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5jaG9pY2VzV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5saXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZGF0YU1heERlcHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbGxvd011bHRpcGxlSXRlbXNJblNhbWVQb3NpdGlvbiA9ICgkYXR0cnMuYWxsb3dNdWx0aXBsZUl0ZW1zSW5TYW1lUG9zaXRpb25XaXRoVmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFsbG93TXVsdGlwbGVJdGVtc0luU2FtZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhdGFNYXhEZXB0aCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhdGFNYXhEZXB0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBsaXN0IG9mIGRpY3RzIGZyb20gdGhlIGxpc3Qgb2YgY2hvaWNlcy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLmNob2ljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGlzdC5wdXNoKHsgdGl0bGU6IGN0cmwuY2hvaWNlc1tpXSwgaXRlbXM6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudHJlZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIGNvbG9yIG9mIHRoZSBwbGFjZWhvbGRlciBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHJhZ2dlZCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRlc3Qubm9kZXNTY29wZS4kY2hpbGROb2Rlc1Njb3BlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5lbGVtZW50cy5wbGFjZWhvbGRlclswXS5zdHlsZS5ib3JkZXJDb2xvciA9ICcjYWRkOGU2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZWxlbWVudHMucGxhY2Vob2xkZXJbMF0uc3R5bGUuYm9yZGVyQ29sb3IgPSAnIzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgbGlzdCBvZiBkaWN0cyB0byBsaXN0IG9mIGxpc3RzIHRvIG1ha2UgaXQgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgTGlzdE9mU2V0c09mSHRtbFN0cmluZ3Mgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnN3ZXJzLnB1c2goW2N0cmwubGlzdFtpXS50aXRsZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3RybC5saXN0W2ldLml0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlcnNbaV0ucHVzaChjdHJsLmxpc3RbaV0uaXRlbXNbal0udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoYW5zd2VycywgRHJhZ0FuZERyb3BTb3J0SW5wdXRSdWxlc1NlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uKGN0cmwuc3VibWl0QW5zd2VyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIERyYWdBbmREcm9wU29ydElucHV0IHJlc3BvbnNlLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFSZXNwb25zZURyYWdBbmREcm9wU29ydElucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvRHJhZ0FuZERyb3BTb3J0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNob29zZUl0ZW1UeXBlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLml0ZW10eXBlID0gJ2RyYWctYW5kLWRyb3AtcmVzcG9uc2UtaXRlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLml0ZW10eXBlID0gJ2RyYWctYW5kLWRyb3AtcmVzcG9uc2Utc3ViaXRlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pc0Fuc3dlckxlbmd0aEdyZWF0ZXJUaGFuWmVybyA9IChjdHJsLmFuc3dlci5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBEcmFnQW5kRHJvcFNvcnRJbnB1dCBzaG9ydCByZXNwb25zZS5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZURyYWdBbmREcm9wU29ydElucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvRHJhZ0FuZERyb3BTb3J0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnZHJhZy1hbmQtZHJvcC1zb3J0LWlucHV0LXNob3J0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNob29zZUl0ZW1UeXBlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLml0ZW10eXBlID0gJ2RyYWctYW5kLWRyb3AtcmVzcG9uc2UtaXRlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLml0ZW10eXBlID0gJ2RyYWctYW5kLWRyb3AtcmVzcG9uc2Utc3ViaXRlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pc0Fuc3dlckxlbmd0aEdyZWF0ZXJUaGFuWmVybyA9IChjdHJsLmFuc3dlci5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1aXJlcyBmb3IgRW5kRXhwbG9yYXRpb24gaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9FbmRFeHBsb3JhdGlvbi9kaXJlY3RpdmVzLycgK1xuICAgICdlbmQtZXhwbG9yYXRpb24tcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0VuZEV4cGxvcmF0aW9uL2RpcmVjdGl2ZXMvJyArXG4gICAgJ2VuZC1leHBsb3JhdGlvbi12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9FbmRFeHBsb3JhdGlvbi9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1lbmQtZXhwbG9yYXRpb24uZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRW5kRXhwbG9yYXRpb24vZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtZW5kLWV4cGxvcmF0aW9uLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0VuZEV4cGxvcmF0aW9uL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXNob3J0LXJlc3BvbnNlLWVuZC1leHBsb3JhdGlvbi5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgRW5kRXhwbG9yYXRpb25SdWxlc1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5kRXhwbG9yYXRpb25SdWxlc1NlcnZpY2UoKSB7XG4gICAgfVxuICAgIEVuZEV4cGxvcmF0aW9uUnVsZXNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIEVuZEV4cGxvcmF0aW9uUnVsZXNTZXJ2aWNlKTtcbiAgICByZXR1cm4gRW5kRXhwbG9yYXRpb25SdWxlc1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5FbmRFeHBsb3JhdGlvblJ1bGVzU2VydmljZSA9IEVuZEV4cGxvcmF0aW9uUnVsZXNTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnRW5kRXhwbG9yYXRpb25SdWxlc1NlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKEVuZEV4cGxvcmF0aW9uUnVsZXNTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgRW5kRXhwbG9yYXRpb25WYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRFeHBsb3JhdGlvblZhbGlkYXRpb25TZXJ2aWNlKGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlID0gYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZTtcbiAgICB9XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnY3VzdG9taXphdGlvbkFyZ3MnIGlzIGEgZGljdCB3aXRoIHBvc3NpYmxlIHVuZGVyc2NvcmVfY2FzZWRcbiAgICAvLyBrZXlzIHdoaWNoIGdpdmUgdHNsaW50IGVycm9ycyBhZ2FpbnN0IHVuZGVyc2NvcmVfY2FzaW5nIGluIGZhdm9yIG9mXG4gICAgLy8gY2FtZWxDYXNpbmcuXG4gICAgRW5kRXhwbG9yYXRpb25WYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydyZWNvbW1lbmRlZEV4cGxvcmF0aW9uSWRzJ10pO1xuICAgICAgICB2YXIgcmVjb21tZW5kZWRFeHBsb3JhdGlvbklkcyA9IChjdXN0b21pemF0aW9uQXJncy5yZWNvbW1lbmRlZEV4cGxvcmF0aW9uSWRzLnZhbHVlKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlY29tbWVuZGVkRXhwbG9yYXRpb25JZHMpKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTZXQgb2YgcmVjb21tZW5kZWQgZXhwbG9yYXRpb24gSURzIG11c3QgYmUgbGlzdC4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29tbWVuZGVkRXhwbG9yYXRpb25JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiByZWNvbW1lbmRlZEV4cGxvcmF0aW9uSWRzW2ldID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY29tbWVuZGVkIGV4cGxvcmF0aW9uIElEIG11c3QgYmUgYSBzdHJpbmcuJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBFbmRFeHBsb3JhdGlvblZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdCh0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpKTtcbiAgICAgICAgaWYgKGFuc3dlckdyb3Vwcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBtYWtlIHN1cmUgZW5kIGV4cGxvcmF0aW9uIGludGVyYWN0aW9ucyBkbyBub3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdoYXZlIGFueSBhbnN3ZXIgZ3JvdXBzLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIG1ha2Ugc3VyZSBlbmQgZXhwbG9yYXRpb24gaW50ZXJhY3Rpb25zIGRvIG5vdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2hhdmUgYSBkZWZhdWx0IG91dGNvbWUuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBFbmRFeHBsb3JhdGlvblZhbGlkYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBFbmRFeHBsb3JhdGlvblZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gRW5kRXhwbG9yYXRpb25WYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkVuZEV4cGxvcmF0aW9uVmFsaWRhdGlvblNlcnZpY2UgPSBFbmRFeHBsb3JhdGlvblZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnRW5kRXhwbG9yYXRpb25WYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoRW5kRXhwbG9yYXRpb25WYWxpZGF0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBFbmRFeHBsb3JhdGlvbiAnaW50ZXJhY3Rpb24nLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL2NvbGxlY3Rpb24vUmVhZE9ubHlDb2xsZWN0aW9uQmFja2VuZEFwaVNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0NvbnRleHRTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvVXJsU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYUludGVyYWN0aXZlRW5kRXhwbG9yYXRpb24nLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvRW5kRXhwbG9yYXRpb24vZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnZW5kLWV4cGxvcmF0aW9uLWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRodHRwJywgJyRhdHRycycsICckcScsICdVcmxTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnQ29udGV4dFNlcnZpY2UnLCAnUmVhZE9ubHlDb2xsZWN0aW9uQmFja2VuZEFwaVNlcnZpY2UnLFxuICAgICAgICAgICAgICAgICdQQUdFX0NPTlRFWFQnLCAnRVhQTE9SQVRJT05fRURJVE9SX1RBQl9DT05URVhUJyxcbiAgICAgICAgICAgICAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ0VYUExPUkFUSU9OX1NVTU1BUllfREFUQV9VUkxfVEVNUExBVEUnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkaHR0cCwgJGF0dHJzLCAkcSwgVXJsU2VydmljZSwgQ29udGV4dFNlcnZpY2UsIFJlYWRPbmx5Q29sbGVjdGlvbkJhY2tlbmRBcGlTZXJ2aWNlLCBQQUdFX0NPTlRFWFQsIEVYUExPUkFUSU9OX0VESVRPUl9UQUJfQ09OVEVYVCwgSHRtbEVzY2FwZXJTZXJ2aWNlLCBFWFBMT1JBVElPTl9TVU1NQVJZX0RBVEFfVVJMX1RFTVBMQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1dGhvclJlY29tbWVuZGVkRXhwbG9yYXRpb25JZHMgPSAoSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLnJlY29tbWVuZGVkRXhwbG9yYXRpb25JZHNXaXRoVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pc0lmcmFtZWQgPSBVcmxTZXJ2aWNlLmlzSWZyYW1lZCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzSW5FZGl0b3JQYWdlID0gKENvbnRleHRTZXJ2aWNlLmdldFBhZ2VDb250ZXh0KCkgPT09IChQQUdFX0NPTlRFWFQuRVhQTE9SQVRJT05fRURJVE9SKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNJbkVkaXRvclByZXZpZXdNb2RlID0gY3RybC5pc0luRWRpdG9yUGFnZSAmJiAoQ29udGV4dFNlcnZpY2UuZ2V0RWRpdG9yVGFiQ29udGV4dCgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgRVhQTE9SQVRJT05fRURJVE9SX1RBQl9DT05URVhULlBSRVZJRVcpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzSW5FZGl0b3JNYWluVGFiID0gY3RybC5pc0luRWRpdG9yUGFnZSAmJiAoQ29udGV4dFNlcnZpY2UuZ2V0RWRpdG9yVGFiQ29udGV4dCgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgRVhQTE9SQVRJT05fRURJVE9SX1RBQl9DT05URVhULkVESVRPUik7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY29sbGVjdGlvbklkID0gVXJsU2VydmljZS5nZXRDb2xsZWN0aW9uSWRGcm9tRXhwbG9yYXRpb25VcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY29sbGVjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkT25seUNvbGxlY3Rpb25CYWNrZW5kQXBpU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5sb2FkQ29sbGVjdGlvbihjdHJsLmNvbGxlY3Rpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q29sbGVjdGlvblRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaXNJbkVkaXRvclBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgYSBtZXNzYWdlIGlmIGFueSBhdXRob3ItcmVjb21tZW5kZWQgZXhwbG9yYXRpb25zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBsb3JhdGlvbklkID0gQ29udGV4dFNlcnZpY2UuZ2V0RXhwbG9yYXRpb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGh0dHAuZ2V0KEVYUExPUkFUSU9OX1NVTU1BUllfREFUQV9VUkxfVEVNUExBVEUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWRfZXhwX2lkczogSlNPTi5zdHJpbmdpZnkoYXV0aG9yUmVjb21tZW5kZWRFeHBsb3JhdGlvbklkcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRFeHBJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN1bW1hcmllcy5tYXAoZnVuY3Rpb24gKGV4cFN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRFeHBJZHMucHVzaChleHBTdW1tYXJ5LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlzc2luZ0V4cElkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvclJlY29tbWVuZGVkRXhwbG9yYXRpb25JZHMuZm9yRWFjaChmdW5jdGlvbiAoZXhwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kRXhwSWRzLmluZGV4T2YoZXhwSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0V4cElkcy5wdXNoKGV4cElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nRXhwSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RPZklkcyA9IG1pc3NpbmdFeHBJZHMuam9pbignXCIsIFwiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3JNZXNzYWdlID0gKCdXYXJuaW5nOiBleHBsb3JhdGlvbihzKSB3aXRoIHRoZSBJRHMgXCInICsgbGlzdE9mSWRzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIiB3aWxsICcgKyAnbm90IGJlIHNob3duIGFzIHJlY29tbWVuZGF0aW9ucyBiZWNhdXNlIHRoZXkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZWl0aGVyIGRvIG5vdCBleGlzdCwgb3IgYXJlIG5vdCBwdWJsaWNseSB2aWV3YWJsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgRW5kRXhwbG9yYXRpb24gcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VFbmRFeHBsb3JhdGlvbicsIFtmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJycsXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbZnVuY3Rpb24gKCkgeyB9XVxuICAgICAgICB9O1xuICAgIH1dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgRW5kRXhwbG9yYXRpb24gc2hvcnQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZUVuZEV4cGxvcmF0aW9uJywgW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7IH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBGcmFjdGlvbklucHV0IGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdmcmFjdGlvbi1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdmcmFjdGlvbi1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9GcmFjdGlvbklucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLWludGVyYWN0aXZlLWZyYWN0aW9uLWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ZyYWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtZnJhY3Rpb24taW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1mcmFjdGlvbi1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9GcmFjdGlvbk9iamVjdEZhY3RvcnkudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ0ZyYWN0aW9uSW5wdXRSdWxlc1NlcnZpY2UnLCBbXG4gICAgJ0ZyYWN0aW9uT2JqZWN0RmFjdG9yeScsXG4gICAgZnVuY3Rpb24gKEZyYWN0aW9uT2JqZWN0RmFjdG9yeSkge1xuICAgICAgICB2YXIgdG9GbG9hdCA9IGZ1bmN0aW9uIChmcmFjdGlvbkRpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbURpY3QoZnJhY3Rpb25EaWN0KS50b0Zsb2F0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBJc0VxdWl2YWxlbnRUbzogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvRmxvYXQoYW5zd2VyKSA9PT0gdG9GbG9hdChpbnB1dHMuZik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNFcXVpdmFsZW50VG9BbmRJblNpbXBsZXN0Rm9ybTogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbXBsZXN0Rm9ybSA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tRGljdChpbnB1dHMuZikuY29udmVydFRvU2ltcGxlc3RGb3JtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvRmxvYXQoYW5zd2VyKSA9PT0gdG9GbG9hdChpbnB1dHMuZikgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5lcXVhbHMoYW5zd2VyLCBzaW1wbGVzdEZvcm0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElzRXhhY3RseUVxdWFsVG86IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmV0dXJucyB0cnVlIGlmIGJvdGggYW5zd2VycyBhcmUgc3RydWN0dXJhbGx5IGVxdWFsLlxuICAgICAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLmVxdWFscyhhbnN3ZXIsIGlucHV0cy5mKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc0xlc3NUaGFuOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GbG9hdChhbnN3ZXIpIDwgdG9GbG9hdChpbnB1dHMuZik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNHcmVhdGVyVGhhbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvRmxvYXQoYW5zd2VyKSA+IHRvRmxvYXQoaW5wdXRzLmYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEhhc0ludGVnZXJQYXJ0RXF1YWxUbzogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuc3dlckZyYWN0aW9uID0gRnJhY3Rpb25PYmplY3RGYWN0b3J5LmZyb21EaWN0KGFuc3dlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlckZyYWN0aW9uLmdldEludGVnZXJQYXJ0KCkgPT09IGlucHV0cy54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEhhc051bWVyYXRvckVxdWFsVG86IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIubnVtZXJhdG9yID09PSBpbnB1dHMueDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBIYXNEZW5vbWluYXRvckVxdWFsVG86IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIuZGVub21pbmF0b3IgPT09IGlucHV0cy54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEhhc05vRnJhY3Rpb25hbFBhcnQ6IGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyLm51bWVyYXRvciA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBIYXNGcmFjdGlvbmFsUGFydEV4YWN0bHlFcXVhbFRvOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFuc3dlci5udW1lcmF0b3IgPT09IGlucHV0cy5mLm51bWVyYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICBhbnN3ZXIuZGVub21pbmF0b3IgPT09IGlucHV0cy5mLmRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgZnJhY3Rpb24gaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi9vYmplY3RzL0ZyYWN0aW9uT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2Jhc2UtaW50ZXJhY3Rpb24tdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdGcmFjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2UnLCBbXG4gICAgJ0ZyYWN0aW9uT2JqZWN0RmFjdG9yeScsICdiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZScsXG4gICAgJ1dBUk5JTkdfVFlQRVMnLFxuICAgIGZ1bmN0aW9uIChGcmFjdGlvbk9iamVjdEZhY3RvcnksIGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlLCBXQVJOSU5HX1RZUEVTKSB7XG4gICAgICAgIHZhciBnZXROb25JbnRlZ2VySW5wdXRXYXJuaW5nID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICsgJyBpcyBpbnZhbGlkOiBpbnB1dCBzaG91bGQgYmUgYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdpbnRlZ2VyLicpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5nczogZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEFsbFdhcm5pbmdzOiBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICAgICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkQmVJblNpbXBsZXN0Rm9ybSA9IGN1c3RvbWl6YXRpb25BcmdzLnJlcXVpcmVTaW1wbGVzdEZvcm0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93SW1wcm9wZXJGcmFjdGlvbiA9IGN1c3RvbWl6YXRpb25BcmdzLmFsbG93SW1wcm9wZXJGcmFjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsb3dOb256ZXJvSW50ZWdlclBhcnQgPSBjdXN0b21pemF0aW9uQXJncy5hbGxvd05vbnplcm9JbnRlZ2VyUGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QgPSB3YXJuaW5nc0xpc3QuY29uY2F0KHRoaXMuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyhjdXN0b21pemF0aW9uQXJncykpO1xuICAgICAgICAgICAgICAgIHZhciB0b0Zsb2F0ID0gZnVuY3Rpb24gKGZyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbURpY3QoZnJhY3Rpb24pLnRvRmxvYXQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0b3JlIGFuIGFuc3dlciByYW5nZSBmb3IgZXZlcnkgcnVsZSwgdGhlbiBjaGVjayBmb3IgcmVkdW5kYW50XG4gICAgICAgICAgICAgICAgICogcmFuZ2VzLiBBIHJhbmdlIGlzIGFuIG9iamVjdCBvZiB0aGUgZm9ybTpcbiAgICAgICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgICAgICogICBsYjogZmxvYXQsIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICAgICAgICogICB1YjogZmxvYXQsIHVwcGVyIGJvdW5kXG4gICAgICAgICAgICAgICAgICogICBsYmk6IGJvb2wsIGlzIGxvd2VyIGJvdW5kIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAqICAgdWJpOiBib29sLCBpcyB1cHBlciBib3VuZCBpbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNldExvd2VyQW5kVXBwZXJCb3VuZHMgPSBmdW5jdGlvbiAocmFuZ2UsIGxiLCB1YiwgbGJpLCB1YmkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubGIgPSBsYjtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudWIgPSB1YjtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubGJpID0gbGJpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS51YmkgPSB1Ymk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbmNsb3NlZEJ5ID0gZnVuY3Rpb24gKHJhLCByYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJhLmxiID09PSBudWxsICYmIHJhLnViID09PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJiLmxiID09PSBudWxsICYmIHJiLnViID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrcyBpZiByYW5nZSByYSBpcyBlbmNsb3NlZCBieSByYW5nZSByYi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyQm91bmRDb25kaXRpb25Jc1NhdGlzZmllZCA9IChyYi5sYiA8IHJhLmxiKSB8fCAocmIubGIgPT09IHJhLmxiICYmICghcmEubGJpIHx8IHJiLmxiaSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBwZXJCb3VuZENvbmRpdGlvbklzU2F0aXNmaWVkID0gKHJiLnViID4gcmEudWIpIHx8IChyYi51YiA9PT0gcmEudWIgJiYgKCFyYS51YmkgfHwgcmIudWJpKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb3dlckJvdW5kQ29uZGl0aW9uSXNTYXRpc2ZpZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyQm91bmRDb25kaXRpb25Jc1NhdGlzZmllZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRDaGVja1JhbmdlQ3JpdGVyaWEgPSBmdW5jdGlvbiAoZWFybGllclJ1bGUsIGxhdGVyUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGVhcmxpZXJSdWxlLnR5cGUgPT09ICdJc0V4YWN0bHlFcXVhbFRvJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXJSdWxlLnR5cGUgPT09ICdJc0V4YWN0bHlFcXVhbFRvJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlYXJsaWVyUnVsZS50eXBlID09PSAnSXNFeGFjdGx5RXF1YWxUbycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlclJ1bGUudHlwZSA9PT0gJ0lzRXF1aXZhbGVudFRvJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlYXJsaWVyUnVsZS50eXBlID09PSAnSXNFeGFjdGx5RXF1YWxUbycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlclJ1bGUudHlwZSA9PT0gJ0lzRXF1aXZhbGVudFRvQW5kSW5TaW1wbGVzdEZvcm0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkRGVub21pbmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbnN3ZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlckdyb3VwSW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJbmRleDogaiArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGJpOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Ymk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkRGVub21pbmF0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyR3JvdXBJbmRleDogaSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUluZGV4OiBqICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJ1bGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0lzRXhhY3RseUVxdWFsVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQmVJblNpbXBsZXN0Rm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uID0gcnVsZS5pbnB1dHMuZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbkluU2ltcGxlc3RGb3JtID0gRnJhY3Rpb25PYmplY3RGYWN0b3J5LmZyb21EaWN0KGZyYWN0aW9uKS5jb252ZXJ0VG9TaW1wbGVzdEZvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5lcXVhbHMoZnJhY3Rpb24sIGZyYWN0aW9uSW5TaW1wbGVzdEZvcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZCBiZWNhdXNlIGl0IGlzIG5vdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbiBzaW1wbGVzdCBmb3JtLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0ltcHJvcGVyRnJhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbiA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tRGljdChydWxlLmlucHV0cy5mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvbi5pc0ltcHJvcGVyRnJhY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdSdWxlICcgKyAoaiArIDEpICsgJyBmcm9tIGFuc3dlciBncm91cCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aWxsIG5ldmVyIGJlIG1hdGNoZWQgYmVjYXVzZSBpdCBpcyBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbXByb3BlciBmcmFjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd05vbnplcm9JbnRlZ2VyUGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uID0gRnJhY3Rpb25PYmplY3RGYWN0b3J5LmZyb21EaWN0KHJ1bGUuaW5wdXRzLmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uLmhhc05vbnplcm9JbnRlZ2VyUGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZCBiZWNhdXNlIGl0IGhhcyBhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vbiB6ZXJvIGludGVnZXIgcGFydCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0b0Zsb2F0KHJ1bGUuaW5wdXRzLmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRMb3dlckFuZFVwcGVyQm91bmRzKHJhbmdlLCBmLCBmLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNFcXVpdmFsZW50VG8nOiAvLyBmYWxsLXRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdJc0VxdWl2YWxlbnRUb0FuZEluU2ltcGxlc3RGb3JtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0b0Zsb2F0KHJ1bGUuaW5wdXRzLmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRMb3dlckFuZFVwcGVyQm91bmRzKHJhbmdlLCBmLCBmLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNHcmVhdGVyVGhhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gdG9GbG9hdChydWxlLmlucHV0cy5mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TG93ZXJBbmRVcHBlckJvdW5kcyhyYW5nZSwgZiwgSW5maW5pdHksIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0lzTGVzc1RoYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHRvRmxvYXQocnVsZS5pbnB1dHMuZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldExvd2VyQW5kVXBwZXJCb3VuZHMocmFuZ2UsIC1JbmZpbml0eSwgZiwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSGFzTnVtZXJhdG9yRXF1YWxUbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihydWxlLmlucHV0cy54KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goZ2V0Tm9uSW50ZWdlcklucHV0V2FybmluZyhpLCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSGFzSW50ZWdlclBhcnRFcXVhbFRvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd05vbnplcm9JbnRlZ2VyUGFydCAmJiBydWxlLmlucHV0cy54ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aWxsIG5ldmVyIGJlIG1hdGNoZWQgYmVjYXVzZSBpbnRlZ2VyIHBhcnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoYXMgdG8gYmUgemVybycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocnVsZS5pbnB1dHMueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKGdldE5vbkludGVnZXJJbnB1dFdhcm5pbmcoaSwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hhc0Rlbm9taW5hdG9yRXF1YWxUbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihydWxlLmlucHV0cy54KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goZ2V0Tm9uSW50ZWdlcklucHV0V2FybmluZyhpLCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuaW5wdXRzLnggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgKyAnIGlzIGludmFsaWQ6IGRlbm9taW5hdG9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkRGVub21pbmF0b3IuZGVub21pbmF0b3IgPSBydWxlLmlucHV0cy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdIYXNGcmFjdGlvbmFsUGFydEV4YWN0bHlFcXVhbFRvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuaW5wdXRzLmYud2hvbGVOdW1iZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGlzIGludmFsaWQgYXMgaW50ZWdlciBwYXJ0IHNob3VsZCBiZSB6ZXJvJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmlucHV0cy5mLmlzTmVnYXRpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBpbnZhbGlkIGFzIHNpZ24gc2hvdWxkIGJlIHBvc2l0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbXByb3BlckZyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbURpY3QocnVsZS5pbnB1dHMuZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb24uaXNJbXByb3BlckZyYWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFdBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgaW52YWxpZCBhcyBpbXByb3BlciBmcmFjdGlvbnMgYXJlIG5vdCBhbGxvd2VkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmFuZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW5jbG9zZWRCeShyYW5nZSwgcmFuZ2VzW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWFybGllclJ1bGUgPSBhbnN3ZXJHcm91cHNbcmFuZ2VzW2tdLmFuc3dlckdyb3VwSW5kZXggLSAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bGVzW3Jhbmdlc1trXS5ydWxlSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZENoZWNrUmFuZ2VDcml0ZXJpYShlYXJsaWVyUnVsZSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgKyAnIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZCBiZWNhdXNlIGl0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXMgbWFkZSByZWR1bmRhbnQgYnkgcnVsZSAnICsgcmFuZ2VzW2tdLnJ1bGVJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArIHJhbmdlc1trXS5hbnN3ZXJHcm91cEluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG1hdGNoZWREZW5vbWluYXRvcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZERlbm9taW5hdG9yc1trXS5kZW5vbWluYXRvciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnR5cGUgPT09ICdIYXNGcmFjdGlvbmFsUGFydEV4YWN0bHlFcXVhbFRvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZERlbm9taW5hdG9yc1trXS5kZW5vbWluYXRvciA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5wdXRzLmYuZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgKyAnIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZCBiZWNhdXNlIGl0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXMgbWFkZSByZWR1bmRhbnQgYnkgcnVsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZERlbm9taW5hdG9yc1trXS5ydWxlSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkRGVub21pbmF0b3JzW2tdLmFuc3dlckdyb3VwSW5kZXggKyAnLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWREZW5vbWluYXRvcnMucHVzaChtYXRjaGVkRGVub21pbmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UuZ2V0QWxsT3V0Y29tZVdhcm5pbmdzKGFuc3dlckdyb3VwcywgZGVmYXVsdE91dGNvbWUsIHN0YXRlTmFtZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIEZyYWN0aW9uSW5wdXQgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi9vYmplY3RzL0ZyYWN0aW9uT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ZyYWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnZnJhY3Rpb24taW5wdXQtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgncGFnZXMvZXhwbG9yYXRpb24tcGxheWVyLXBhZ2Uvc2VydmljZXMvY3VycmVudC1pbnRlcmFjdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvV2luZG93RGltZW5zaW9uc1NlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL3N0YXRlZnVsL0ZvY3VzTWFuYWdlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZUZyYWN0aW9uSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9GcmFjdGlvbklucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ2ZyYWN0aW9uLWlucHV0LWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRzY29wZScsICckYXR0cnMnLCAnRm9jdXNNYW5hZ2VyU2VydmljZScsICdGcmFjdGlvbklucHV0UnVsZXNTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnRnJhY3Rpb25PYmplY3RGYWN0b3J5JywgJ0ZSQUNUSU9OX1BBUlNJTkdfRVJST1JTJyxcbiAgICAgICAgICAgICAgICAnV2luZG93RGltZW5zaW9uc1NlcnZpY2UnLCAnQ3VycmVudEludGVyYWN0aW9uU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJGF0dHJzLCBGb2N1c01hbmFnZXJTZXJ2aWNlLCBGcmFjdGlvbklucHV0UnVsZXNTZXJ2aWNlLCBGcmFjdGlvbk9iamVjdEZhY3RvcnksIEZSQUNUSU9OX1BBUlNJTkdfRVJST1JTLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubGFiZWxGb3JGb2N1c1RhcmdldCA9ICRhdHRycy5sYWJlbEZvckZvY3VzVGFyZ2V0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1aXJlU2ltcGxlc3RGb3JtID0gKCRhdHRycy5yZXF1aXJlU2ltcGxlc3RGb3JtV2l0aFZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsb3dJbXByb3BlckZyYWN0aW9uID0gKCRhdHRycy5hbGxvd0ltcHJvcGVyRnJhY3Rpb25XaXRoVmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWxsb3dOb256ZXJvSW50ZWdlclBhcnQgPSAoJGF0dHJzLmFsbG93Tm9uemVyb0ludGVnZXJQYXJ0V2l0aFZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmN1c3RvbVBsYWNlaG9sZGVyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmN1c3RvbVBsYWNlaG9sZGVyV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBMYWJlbCBmb3IgZXJyb3JzIGNhdXNlZCB3aGlsc3QgcGFyc2luZyBhIGZyYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgRk9STV9FUlJPUl9UWVBFID0gJ0ZSQUNUSU9OX0ZPUk1BVF9FUlJPUic7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuRlJBQ1RJT05fSU5QVVRfRk9STV9TQ0hFTUEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5pY29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aV9jb25maWc6IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0V2FybmluZ1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRGlzYWJsZXMgdGhlIGlucHV0IGJveCBpZiB0aGUgZGF0YSBlbnRlcmVkIGlzIG5vdCBhIHZhbGlkIHByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgYSBmcmFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICogRXhhbXBsZXMgb2YgdmFsaWQgcHJlZml4ZXM6XG4gICAgICAgICAgICAgICAgICAgICAqIC0tIDFcbiAgICAgICAgICAgICAgICAgICAgICogLS0gMSAyXG4gICAgICAgICAgICAgICAgICAgICAqIC0tIDEgMi9cbiAgICAgICAgICAgICAgICAgICAgICogLS0gMi9cbiAgICAgICAgICAgICAgICAgICAgICogLS0gMSAyLzNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmFuc3dlcicsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIElOVkFMSURfQ0hBUlNfUkVHRVggPSAvW15cXGRcXHNcXC8tXS9nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0cyBpbmNvbXBsZXRlIGZyYWN0aW9uIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHNlZSBleGFtcGxlcyBhYm92ZSBleGNlcHQgbGFzdCkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgUEFSVElBTF9GUkFDVElPTl9SRUdFWCA9IC9eXFxzKigtP1xccyooKFxcZCpcXHMqXFxkK1xccypcXC8/XFxzKil8XFxkKylcXHMqKT8kLztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2VwdHMgY29tcGxldGUgZnJhY3Rpb24gaW5wdXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEZSQUNUSU9OX1JFR0VYID0gL15cXHMqLT9cXHMqKChcXGQqXFxzKlxcZCtcXHMqXFwvXFxzKlxcZCspfFxcZCspXFxzKiQvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElOVkFMSURfQ0hBUlNfUkVHRVgudGVzdChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBGUkFDVElPTl9QQVJTSU5HX0VSUk9SUy5JTlZBTElEX0NIQVJTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuRnJhY3Rpb25JbnB1dEZvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEoRlJBQ1RJT05fUkVHRVgudGVzdChuZXdWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQQVJUSUFMX0ZSQUNUSU9OX1JFR0VYLnRlc3QobmV3VmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IEZSQUNUSU9OX1BBUlNJTkdfRVJST1JTLklOVkFMSURfRk9STUFUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuRnJhY3Rpb25JbnB1dEZvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuRnJhY3Rpb25JbnB1dEZvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zdWJtaXRBbnN3ZXIgPSBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbiA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tUmF3SW5wdXRTdHJpbmcoYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZVNpbXBsZXN0Rm9ybSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYW5ndWxhci5lcXVhbHMoZnJhY3Rpb24sIGZyYWN0aW9uLmNvbnZlcnRUb1NpbXBsZXN0Rm9ybSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAoJ1BsZWFzZSBlbnRlciBhbiBhbnN3ZXIgaW4gc2ltcGxlc3QgZm9ybSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoZS5nLiwgMS8zIGluc3RlYWQgb2YgMi82KS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5GcmFjdGlvbklucHV0Rm9ybS5hbnN3ZXIuJHNldFZhbGlkaXR5KEZPUk1fRVJST1JfVFlQRSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYWxsb3dJbXByb3BlckZyYWN0aW9uICYmIGZyYWN0aW9uLmlzSW1wcm9wZXJGcmFjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICgnUGxlYXNlIGVudGVyIGFuIGFuc3dlciB3aXRoIGEgXCJwcm9wZXJcIiBmcmFjdGlvbmFsIHBhcnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGUuZy4sIDEgMi8zIGluc3RlYWQgb2YgNS8zKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5GcmFjdGlvbklucHV0Rm9ybS5hbnN3ZXIuJHNldFZhbGlkaXR5KEZPUk1fRVJST1JfVFlQRSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY3RybC5hbGxvd05vbnplcm9JbnRlZ2VyUGFydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbi5oYXNOb256ZXJvSW50ZWdlclBhcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAoJ1BsZWFzZSBlbnRlciB5b3VyIGFuc3dlciBhcyBhIGZyYWN0aW9uIChlLmcuLCA1LzMgaW5zdGVhZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZiAxIDIvMykuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuRnJhY3Rpb25JbnB1dEZvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoZnJhY3Rpb24sIEZyYWN0aW9uSW5wdXRSdWxlc1NlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBwYXJzaW5nRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLkZyYWN0aW9uSW5wdXRGb3JtLmFuc3dlci4kc2V0VmFsaWRpdHkoRk9STV9FUlJPUl9UWVBFLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNBbnN3ZXJWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLkZyYWN0aW9uSW5wdXRGb3JtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFjdHJsLkZyYWN0aW9uSW5wdXRGb3JtLiRpbnZhbGlkICYmIGN0cmwuYW5zd2VyICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJtaXRBbnN3ZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyKGN0cmwuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5yZWdpc3RlckN1cnJlbnRJbnRlcmFjdGlvbihzdWJtaXRBbnN3ZXJGbiwgY3RybC5pc0Fuc3dlclZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIEZyYWN0aW9uSW5wdXQgcmVzcG9uc2UuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi9vYmplY3RzL0ZyYWN0aW9uT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VGcmFjdGlvbklucHV0JywgW1xuICAgICdGcmFjdGlvbk9iamVjdEZhY3RvcnknLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoRnJhY3Rpb25PYmplY3RGYWN0b3J5LCBIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvRnJhY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdmcmFjdGlvbi1pbnB1dC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tRGljdChhbnN3ZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgRnJhY3Rpb25JbnB1dCBzaG9ydCByZXNwb25zZS5cbiAqL1xucmVxdWlyZSgnZG9tYWluL29iamVjdHMvRnJhY3Rpb25PYmplY3RGYWN0b3J5LnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlRnJhY3Rpb25JbnB1dCcsIFtcbiAgICAnRnJhY3Rpb25PYmplY3RGYWN0b3J5JywgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEZyYWN0aW9uT2JqZWN0RmFjdG9yeSwgSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0ZyYWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnZnJhY3Rpb24taW5wdXQtc2hvcnQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBGcmFjdGlvbk9iamVjdEZhY3RvcnkuZnJvbURpY3QoYW5zd2VyKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBHcmFwaElucHV0IGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL2dyYXBoLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9HcmFwaElucHV0L2RpcmVjdGl2ZXMvZ3JhcGgtaW5wdXQtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1ncmFwaC1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9HcmFwaElucHV0L2RpcmVjdGl2ZXMvb3BwaWEtcmVzcG9uc2UtZ3JhcGgtaW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1ncmFwaC1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGV0YWlsIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIEdyYXBoRGV0YWlsU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaERldGFpbFNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuVkVSVEVYX1JBRElVUyA9IDY7XG4gICAgICAgIHRoaXMuRURHRV9XSURUSCA9IDM7XG4gICAgfVxuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4gdHlwZWRcbiAgICAvLyBhcyAnYW55JyBzaW5jZSAnZ3JhcGgnIGlzIGEgZGljdCB3aXRoICdhbnN3ZXInIHR5cGUgb2JqZWN0IHdoaWNoIGlzIGl0c2VsZlxuICAgIC8vIHR5cGVkICdhbnknLlxuICAgIEdyYXBoRGV0YWlsU2VydmljZS5wcm90b3R5cGUuZ2V0RGlyZWN0ZWRFZGdlQXJyb3dQb2ludHMgPSBmdW5jdGlvbiAoZ3JhcGgsIGluZGV4KSB7XG4gICAgICAgIHZhciBBUlJPV19XSURUSCA9IDU7XG4gICAgICAgIHZhciBBUlJPV19IRUlHSFQgPSAxMDtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlc1tpbmRleF07XG4gICAgICAgIHZhciBzcmNWZXJ0ZXggPSBncmFwaC52ZXJ0aWNlc1tlZGdlLnNyY107XG4gICAgICAgIHZhciBkc3RWZXJ0ZXggPSBncmFwaC52ZXJ0aWNlc1tlZGdlLmRzdF07XG4gICAgICAgIHZhciBkeCA9IGRzdFZlcnRleC54IC0gc3JjVmVydGV4Lng7XG4gICAgICAgIHZhciBkeSA9IGRzdFZlcnRleC55IC0gc3JjVmVydGV4Lnk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZHggLz0gbGVuZ3RoO1xuICAgICAgICBkeSAvPSBsZW5ndGg7XG4gICAgICAgIHZhciBlbmRYID0gZHN0VmVydGV4LnggLSA0ICogZHg7XG4gICAgICAgIHZhciBlbmRZID0gZHN0VmVydGV4LnkgLSA0ICogZHk7XG4gICAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICAgcmV0ICs9XG4gICAgICAgICAgICBlbmRYICsgJywnICtcbiAgICAgICAgICAgICAgICBlbmRZICsgJyAnO1xuICAgICAgICByZXQgKz1cbiAgICAgICAgICAgIChlbmRYIC0gQVJST1dfSEVJR0hUICogZHggKyBBUlJPV19XSURUSCAqIGR5KSArICcsJyArXG4gICAgICAgICAgICAgICAgKGVuZFkgLSBBUlJPV19IRUlHSFQgKiBkeSAtIEFSUk9XX1dJRFRIICogZHgpICsgJyAnO1xuICAgICAgICByZXQgKz1cbiAgICAgICAgICAgIChlbmRYIC0gQVJST1dfSEVJR0hUICogZHggLSBBUlJPV19XSURUSCAqIGR5KSArICcsJyArXG4gICAgICAgICAgICAgICAgKGVuZFkgLSBBUlJPV19IRUlHSFQgKiBkeSArIEFSUk9XX1dJRFRIICogZHgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiB0eXBlZFxuICAgIC8vIGFzICdhbnknIHNpbmNlICdncmFwaCcgaXMgYSBkaWN0IHdpdGggJ2Fuc3dlcicgdHlwZSBvYmplY3Qgd2hpY2ggaXMgaXRzZWxmXG4gICAgLy8gdHlwZWQgJ2FueScuXG4gICAgR3JhcGhEZXRhaWxTZXJ2aWNlLnByb3RvdHlwZS5nZXRFZGdlQ2VudHJlID0gZnVuY3Rpb24gKGdyYXBoLCBpbmRleCkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHNyY1ZlcnRleCA9IGdyYXBoLnZlcnRpY2VzW2VkZ2Uuc3JjXTtcbiAgICAgICAgdmFyIGRzdFZlcnRleCA9IGdyYXBoLnZlcnRpY2VzW2VkZ2UuZHN0XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IChzcmNWZXJ0ZXgueCArIGRzdFZlcnRleC54KSAvIDIuMCxcbiAgICAgICAgICAgIHk6IChzcmNWZXJ0ZXgueSArIGRzdFZlcnRleC55KSAvIDIuMFxuICAgICAgICB9O1xuICAgIH07XG4gICAgR3JhcGhEZXRhaWxTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIEdyYXBoRGV0YWlsU2VydmljZSk7XG4gICAgcmV0dXJuIEdyYXBoRGV0YWlsU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkdyYXBoRGV0YWlsU2VydmljZSA9IEdyYXBoRGV0YWlsU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ0dyYXBoRGV0YWlsU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoR3JhcGhEZXRhaWxTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJ1bGVzIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9ncmFwaC11dGlscy5zZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdHcmFwaElucHV0UnVsZXNTZXJ2aWNlJywgW1xuICAgICdHcmFwaFV0aWxzU2VydmljZScsIGZ1bmN0aW9uIChHcmFwaFV0aWxzU2VydmljZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGdyYXBoIC0gQSBncmFwaCBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdyYXBoIGlzIHN0cm9uZ2x5IGNvbm5lY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc1N0cm9uZ2x5Q29ubmVjdGVkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgICAgICAvLyBVc2VzIGRlcHRoIGZpcnN0IHNlYXJjaCBvbiBlYWNoIHZlcnRleCB0byB0cnkgYW5kIHZpc2l0IGV2ZXJ5IG90aGVyXG4gICAgICAgICAgICAvLyB2ZXJ0ZXggaW4gYm90aCB0aGUgbm9ybWFsIGFuZCBpbnZlcnRlZCBhZGphY2VuY3kgbGlzdHMuXG4gICAgICAgICAgICBpZiAoZ3JhcGgudmVydGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRqYWNlbmN5TGlzdHMgPSBHcmFwaFV0aWxzU2VydmljZS5jb25zdHJ1Y3RBZGphY2VuY3lMaXN0cyhncmFwaCwgR3JhcGhVdGlsc1NlcnZpY2UuR1JBUEhfQURKQUNFTkNZX01PREUuRElSRUNURUQpO1xuICAgICAgICAgICAgdmFyIGludmVydGVkQWRqYWNlbmN5TGlzdHMgPSBHcmFwaFV0aWxzU2VydmljZS5jb25zdHJ1Y3RBZGphY2VuY3lMaXN0cyhncmFwaCwgR3JhcGhVdGlsc1NlcnZpY2UuR1JBUEhfQURKQUNFTkNZX01PREUuSU5WRVJURUQpO1xuICAgICAgICAgICAgdmFyIGlzVmlzaXRlZCA9IGdyYXBoLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBHcmFwaFV0aWxzU2VydmljZS5tYXJrQWNjZXNzaWJsZSgwLCBhZGphY2VuY3lMaXN0cywgaXNWaXNpdGVkKTtcbiAgICAgICAgICAgIHZhciBpc0FueVZlcnRleFVucmVhY2hhYmxlID0gaXNWaXNpdGVkLnNvbWUoZnVuY3Rpb24gKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpc1Zpc2l0ZWRJblJldmVyc2UgPSBncmFwaC52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgR3JhcGhVdGlsc1NlcnZpY2UubWFya0FjY2Vzc2libGUoMCwgaW52ZXJ0ZWRBZGphY2VuY3lMaXN0cywgaXNWaXNpdGVkSW5SZXZlcnNlKTtcbiAgICAgICAgICAgIHZhciBpc0FueVZlcnRleFVucmVhY2hhYmxlSW5SZXZlcnNlID0gaXNWaXNpdGVkSW5SZXZlcnNlLnNvbWUoZnVuY3Rpb24gKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhaXNBbnlWZXJ0ZXhVbnJlYWNoYWJsZSAmJiAhaXNBbnlWZXJ0ZXhVbnJlYWNoYWJsZUluUmV2ZXJzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaCAtIEEgZ3JhcGggb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBncmFwaCBpcyB3ZWFrbHkgY29ubmVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzV2Vha2x5Q29ubmVjdGVkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZXMgYWRqYWNlbmN5IGxpc3RzIGFzc3VtaW5nIGdyYXBoIGlzIHVuZGlyZWN0ZWQsIHRoZW4gdXNlcyBkZXB0aFxuICAgICAgICAgICAgLy8gZmlyc3Qgc2VhcmNoIG9uIG5vZGUgMCB0byB0cnkgdG8gcmVhY2ggZXZlcnkgb3RoZXIgdmVydGV4XG4gICAgICAgICAgICBpZiAoZ3JhcGgudmVydGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRqYWNlbmN5TGlzdHMgPSBHcmFwaFV0aWxzU2VydmljZS5jb25zdHJ1Y3RBZGphY2VuY3lMaXN0cyhncmFwaCwgR3JhcGhVdGlsc1NlcnZpY2UuR1JBUEhfQURKQUNFTkNZX01PREUuVU5ESVJFQ1RFRCk7XG4gICAgICAgICAgICB2YXIgaXNWaXNpdGVkID0gZ3JhcGgudmVydGljZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEdyYXBoVXRpbHNTZXJ2aWNlLm1hcmtBY2Nlc3NpYmxlKDAsIGFkamFjZW5jeUxpc3RzLCBpc1Zpc2l0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmlzaXRlZC5ldmVyeShmdW5jdGlvbiAodmlzaXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdGVkID09PSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggLSBBIGdyYXBoIG9iamVjdC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ3JhcGggaXMgYWN5Y2xpYy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc0FjeWNsaWMgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vIFVzZXMgZGVwdGggZmlyc3Qgc2VhcmNoIHRvIGVuc3VyZSB0aGF0IHdlIG5ldmVyIGhhdmUgYW4gZWRnZSB0byBhblxuICAgICAgICAgICAgLy8gYW5jZXN0b3IgaW4gdGhlIHNlYXJjaCB0cmVlLlxuICAgICAgICAgICAgdmFyIGlzVmlzaXRlZCA9IGdyYXBoLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyYXBoVXRpbHNTZXJ2aWNlLkRGU19TVEFUVVMuVU5WSVNJVEVEO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWRqYWNlbmN5TGlzdHMgPSBHcmFwaFV0aWxzU2VydmljZS5jb25zdHJ1Y3RBZGphY2VuY3lMaXN0cyhncmFwaCwgR3JhcGhVdGlsc1NlcnZpY2UuR1JBUEhfQURKQUNFTkNZX01PREUuRElSRUNURUQpO1xuICAgICAgICAgICAgZm9yICh2YXIgc3RhcnRWZXJ0ZXggPSAwOyBzdGFydFZlcnRleCA8IGdyYXBoLnZlcnRpY2VzLmxlbmd0aDsgc3RhcnRWZXJ0ZXgrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc1Zpc2l0ZWRbc3RhcnRWZXJ0ZXhdID09PSBHcmFwaFV0aWxzU2VydmljZS5ERlNfU1RBVFVTLlVOVklTSVRFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoR3JhcGhVdGlsc1NlcnZpY2UuZmluZEN5Y2xlKHN0YXJ0VmVydGV4LCAtMSwgYWRqYWNlbmN5TGlzdHMsIGlzVmlzaXRlZCwgZ3JhcGguaXNEaXJlY3RlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGdyYXBoIC0gQSBncmFwaCBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdyYXBoIGlzIGFjeWNsaWMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaXNSZWd1bGFyID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgdGhhdCBldmVyeSB2ZXJ0ZXggaGFzIG91dGRlZ3JlZSBhbmQgaW5kZWdyZWUgZXF1YWwgdG8gdGhlIGZpcnN0XG4gICAgICAgICAgICBpZiAoZ3JhcGgudmVydGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRqYWNlbmN5TGlzdHMgPSBHcmFwaFV0aWxzU2VydmljZS5jb25zdHJ1Y3RBZGphY2VuY3lMaXN0cyhncmFwaCwgR3JhcGhVdGlsc1NlcnZpY2UuR1JBUEhfQURKQUNFTkNZX01PREUuRElSRUNURUQpO1xuICAgICAgICAgICAgdmFyIG91dGRlZ3JlZUNvdW50cyA9IGFkamFjZW5jeUxpc3RzLm1hcChmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGluZGVncmVlQ291bnRzID0gYWRqYWNlbmN5TGlzdHMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRqYWNlbmN5TGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZWdyZWVDb3VudHNbZGVzdGluYXRpb25dKys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhcmVJbmRlZ3JlZUNvdW50c0VxdWFsID0gaW5kZWdyZWVDb3VudHMuZXZlcnkoZnVuY3Rpb24gKGluZGVncmVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGVncmVlID09PSBpbmRlZ3JlZUNvdW50c1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFyZU91dGRlZ3JlZUNvdW50c0VxdWFsID0gb3V0ZGVncmVlQ291bnRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXRkZWdyZWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlID09PSBvdXRkZWdyZWVDb3VudHNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcmVJbmRlZ3JlZUNvdW50c0VxdWFsICYmIGFyZU91dGRlZ3JlZUNvdW50c0VxdWFsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNJc29tb3JwaGljID0gZnVuY3Rpb24gKGdyYXBoMSwgZ3JhcGgyKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGgxLnZlcnRpY2VzLmxlbmd0aCAhPT0gZ3JhcGgyLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhZGoxID0gR3JhcGhVdGlsc1NlcnZpY2UuY29uc3RydWN0QWRqYWNlbmN5TWF0cml4KGdyYXBoMSk7XG4gICAgICAgICAgICB2YXIgYWRqMiA9IEdyYXBoVXRpbHNTZXJ2aWNlLmNvbnN0cnVjdEFkamFjZW5jeU1hdHJpeChncmFwaDIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBmb3IgZXZlcnkgdmVydGV4IGZyb20gdGhlIGZpcnN0IGdyYXBoIHRoZXJlIGlzIGEgdmVydGV4IGluXG4gICAgICAgICAgICAvLyB0aGUgc2Vjb25kIGdyYXBoIHdpdGggdGhlIHNhbWUgc3VtIG9mIHdlaWdodHMgb2Ygb3V0Z29pbmcgZWRnZXNcbiAgICAgICAgICAgIHZhciBkZWdyZWVzMSA9IGFkajEubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldiArIGN1cjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBkZWdyZWVzMiA9IGFkajIubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldiArIGN1cjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnNvcnQoKTtcbiAgICAgICAgICAgIGlmICghYW5ndWxhci5lcXVhbHMoZGVncmVlczEsIGRlZ3JlZXMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgZXZlcnkgcGVybXV0YXRpb24gb2YgdmVjdGljZXMuXG4gICAgICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBncmFwaDIudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHBlcm11dGF0aW9uID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwZXJtdXRhdGlvbi5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBlcm11dGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvTGFiZWxzTWF0Y2ggPSAoIWdyYXBoMS5pc0xhYmVsZWQgJiYgIWdyYXBoMi5pc0xhYmVsZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoMi52ZXJ0aWNlcy5ldmVyeShmdW5jdGlvbiAodmVydGV4LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRleC5sYWJlbCA9PT0gZ3JhcGgxLnZlcnRpY2VzW3Blcm11dGF0aW9uW2luZGV4XV0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkb0xhYmVsc01hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoVXRpbHNTZXJ2aWNlLmFyZUFkamFjZW5jeU1hdHJpY2VzRXF1YWxXaXRoUGVybXV0YXRpb24oYWRqMSwgYWRqMiwgcGVybXV0YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZXJtdXRhdGlvbiA9IEdyYXBoVXRpbHNTZXJ2aWNlLm5leHRQZXJtdXRhdGlvbihwZXJtdXRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIYXNHcmFwaFByb3BlcnR5OiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLnAgPT09ICdzdHJvbmdseV9jb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cm9uZ2x5Q29ubmVjdGVkKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0cy5wID09PSAnd2Vha2x5X2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2Vha2x5Q29ubmVjdGVkKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0cy5wID09PSAnYWN5Y2xpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQWN5Y2xpYyhhbnN3ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dHMucCA9PT0gJ3JlZ3VsYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1JlZ3VsYXIoYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNJc29tb3JwaGljVG86IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0lzb21vcnBoaWMoYW5zd2VyLCBpbnB1dHMuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoSW5wdXRWYWxpZGF0aW9uU2VydmljZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSA9IGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2U7XG4gICAgICAgIHRoaXMuVkVSVElDRVNfTElNSVQgPSA1MDtcbiAgICB9XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnY3VzdG9taXphdGlvbkFyZ3MnIGlzIGEgZGljdCB3aXRoIHBvc3NpYmxlIHVuZGVyc2NvcmVfY2FzZWRcbiAgICAvLyBrZXlzIHdoaWNoIGdpdmUgdHNsaW50IGVycm9ycyBhZ2FpbnN0IHVuZGVyc2NvcmVfY2FzaW5nIGluIGZhdm9yIG9mXG4gICAgLy8gY2FtZWxDYXNpbmcuXG4gICAgR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLnJlcXVpcmVDdXN0b21pemF0aW9uQXJndW1lbnRzKGN1c3RvbWl6YXRpb25BcmdzLCBbJ2dyYXBoJywgJ2NhbkVkaXRFZGdlV2VpZ2h0JywgJ2NhbkVkaXRWZXJ0ZXhMYWJlbCddKTtcbiAgICAgICAgaWYgKGN1c3RvbWl6YXRpb25BcmdzLmdyYXBoLnZhbHVlLnZlcnRpY2VzLmxlbmd0aCA+IHRoaXMuVkVSVElDRVNfTElNSVQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogKCdUaGUgZ3JhcGggdXNlZCBpbiBjdXN0b21pemF0aW9uIGV4Y2VlZHMgc3VwcG9ydGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgb2YgJyArIHRoaXMuVkVSVElDRVNfTElNSVQgKyAnLicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1c3RvbWl6YXRpb25BcmdzLmdyYXBoLnZhbHVlLmlzV2VpZ2h0ZWQgJiZcbiAgICAgICAgICAgIGN1c3RvbWl6YXRpb25BcmdzLmNhbkVkaXRFZGdlV2VpZ2h0LnZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnVGhlIGxlYXJuZXIgY2Fubm90IGVkaXQgZWRnZSB3ZWlnaHRzIGZvciBhbiB1bndlaWdodGVkIGdyYXBoLicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1c3RvbWl6YXRpb25BcmdzLmdyYXBoLnZhbHVlLmlzTGFiZWxlZCAmJlxuICAgICAgICAgICAgY3VzdG9taXphdGlvbkFyZ3MuY2FuRWRpdFZlcnRleExhYmVsLnZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnVGhlIGxlYXJuZXIgY2Fubm90IGVkaXQgdmVydGV4IGxhYmVscyBmb3IgYW4gdW5sYWJlbGVkIGdyYXBoLicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FybmluZ3NMaXN0O1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnY3VzdG9taXphdGlvbkFyZ3MnIGlzIGEgZGljdCB3aXRoIHBvc3NpYmxlIHVuZGVyc2NvcmVfY2FzZWRcbiAgICAvLyBrZXlzIHdoaWNoIGdpdmUgdHNsaW50IGVycm9ycyBhZ2FpbnN0IHVuZGVyc2NvcmVfY2FzaW5nIGluIGZhdm9yIG9mXG4gICAgLy8gY2FtZWxDYXNpbmcuXG4gICAgR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHZhciBJU09NT1JQSElTTV9WRVJUSUNFU19MSU1JVCA9IDEwO1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKSk7XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbnN3ZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IGFuc3dlckdyb3Vwc1tpXS5ydWxlcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcnVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2pdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdIYXNHcmFwaFByb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS50eXBlID09PSAnSXNJc29tb3JwaGljVG8nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmlucHV0cy5nLnZlcnRpY2VzLmxlbmd0aCA+IElTT01PUlBISVNNX1ZFUlRJQ0VTX0xJTUlUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnVGhlIGdyYXBoIHVzZWQgaW4gdGhlIHJ1bGUgJyArIChqICsgMSkgKyAnIGluIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICsgJyBleGNlZWRzIHN1cHBvcnRlZCBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mICcgKyBJU09NT1JQSElTTV9WRVJUSUNFU19MSU1JVCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgZm9yIGlzb21vcnBoaXNtIGNoZWNrLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLmlucHV0cy5nLnZlcnRpY2VzLmxlbmd0aCA+IHRoaXMuVkVSVElDRVNfTElNSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdUaGUgZ3JhcGggdXNlZCBpbiB0aGUgcnVsZSAnICsgKGogKyAxKSArICcgaW4gZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgKyAnIGV4Y2VlZHMgc3VwcG9ydGVkIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2YgJyArIHRoaXMuVkVSVElDRVNfTElNSVQgKyAnLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1RoZSBydWxlICcgKyAoaiArIDEpICsgJyBpbiBncm91cCAnICsgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBpbnZhbGlkLicpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FybmluZ3NMaXN0O1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIEdyYXBoSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnR3JhcGhJbnB1dFZhbGlkYXRpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShHcmFwaElucHV0VmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbHMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgR3JhcGhVdGlsc1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhVdGlsc1NlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuR1JBUEhfQURKQUNFTkNZX01PREUgPSB7XG4gICAgICAgICAgICBESVJFQ1RFRDogJ2RpcmVjdGVkJyxcbiAgICAgICAgICAgIElOVkVSVEVEOiAnaW52ZXJ0ZWQnLFxuICAgICAgICAgICAgVU5ESVJFQ1RFRDogJ3VuZGlyZWN0ZWQnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuREZTX1NUQVRVUyA9IHtcbiAgICAgICAgICAgIFZJU0lURUQ6ICd2aXNpdGVkJyxcbiAgICAgICAgICAgIFVOVklTSVRFRDogJ3VudmlzaXRlZCcsXG4gICAgICAgICAgICBTVElMTF9WSVNJVElORzogJ3N0aWxsIHZpc2l0aW5nJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggLSBBIGdyYXBoIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRqYWNlbmN5TGlzdE1vZGUgLSBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBtb2RlLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhZGphY2VuY3kgbGlzdC4gRGVwZW5kaW5nIG9uIHRoZSBtb2RlLCB0aGUgbGlzdCBoYXNcbiAgICAgKiAgIGFsbCBlZGdlcyAoZGlyZWN0ZWQpLFxuICAgICAqICAgYWxsIGVkZ2VzIGludmVydGVkIChpbnZlcnRlZCksXG4gICAgICogICBvciBhbGwgZWRnZXMgaW4gYm90aCBkaXJlY3Rpb25zLCBhcyB0aG91Z2ggdGhlIGdyYXBoIHdlcmUgdW5kaXJlY3RlZFxuICAgICAqICAgKHVuZGlyZWN0ZWQpXG4gICAgICovXG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiB0eXBlZFxuICAgIC8vIGFzICdhbnknIHNpbmNlICdncmFwaCcgaXMgYSBkaWN0IHdpdGggJ2Fuc3dlcicgdHlwZSBvYmplY3Qgd2hpY2ggaXMgaXRzZWxmXG4gICAgLy8gdHlwZWQgJ2FueScuXG4gICAgR3JhcGhVdGlsc1NlcnZpY2UucHJvdG90eXBlLmNvbnN0cnVjdEFkamFjZW5jeUxpc3RzID0gZnVuY3Rpb24gKGdyYXBoLCBhZGphY2VuY3lMaXN0TW9kZSkge1xuICAgICAgICB2YXIgYWRqYWNlbmN5TGlzdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRqYWNlbmN5TGlzdHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBncmFwaCBpcyB1bmRpcmVjdGVkLCBhbGwgbW9kZXMgd29yayB0aGUgc2FtZSB3YXkgYW55d2F5XG4gICAgICAgIGlmICghZ3JhcGguaXNEaXJlY3RlZCkge1xuICAgICAgICAgICAgYWRqYWNlbmN5TGlzdE1vZGUgPSB0aGlzLkdSQVBIX0FESkFDRU5DWV9NT0RFLlVORElSRUNURUQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChhZGphY2VuY3lMaXN0TW9kZSA9PT0gdGhpcy5HUkFQSF9BREpBQ0VOQ1lfTU9ERS5ESVJFQ1RFRCB8fFxuICAgICAgICAgICAgICAgIGFkamFjZW5jeUxpc3RNb2RlID09PSB0aGlzLkdSQVBIX0FESkFDRU5DWV9NT0RFLlVORElSRUNURUQpIHtcbiAgICAgICAgICAgICAgICBhZGphY2VuY3lMaXN0c1tlZGdlLnNyY10ucHVzaChlZGdlLmRzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRqYWNlbmN5TGlzdE1vZGUgPT09ICh0aGlzLkdSQVBIX0FESkFDRU5DWV9NT0RFLklOVkVSVEVEKSB8fCBhZGphY2VuY3lMaXN0TW9kZSA9PT0gKHRoaXMuR1JBUEhfQURKQUNFTkNZX01PREUuVU5ESVJFQ1RFRCkpIHtcbiAgICAgICAgICAgICAgICBhZGphY2VuY3lMaXN0c1tlZGdlLmRzdF0ucHVzaChlZGdlLnNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkamFjZW5jeUxpc3RzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydFZlcnRleCAtIFRoZSBpbmRleCBvZiB0aGUgc3RhcnRpbmcgdmVydGV4LlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFkamFjZW5jeUxpc3RzIC0gQW4gYXJyYXkgb2YgYXJyYXlzLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGlzVmlzaXRlZCAtIEFuIGFycmF5IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgICAgdmVydGljZXMuIEFsbCB0aGUgdmFsdWVzIHNob3VsZCBiZSBmYWxzZSBpbml0aWFsbHkuXG4gICAgICogVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgaXNWaXNpdGVkIGFycmF5IGFuZCBjaGFuZ2VzIHRoZSB2YWx1ZXMgYXRcbiAgICAgKiB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgcmVhY2hhYmxlIGZyb20gdGhlIHN0YXJ0aW5nIHZlcnRleCB0byB0cnVlLlxuICAgICAqL1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4gdHlwZWRcbiAgICAvLyBhcyAnYW55JyBzaW5jZSAnaXNWaXNpdGVkJyBpcyBhbiBhcnJheSB3aXRoIGJvdGggc3RyaW5nIGFuZCBib29sZWFuIHZhbHVlcztcbiAgICAvLyBhIHRob3JvdWdoIGNoZWNrIG5lZWRzIHRvIGJlIGRvbmUgdG8gYXNzdXJlIGl0cyBleGFjdCB0eXBlLlxuICAgIEdyYXBoVXRpbHNTZXJ2aWNlLnByb3RvdHlwZS5tYXJrQWNjZXNzaWJsZSA9IGZ1bmN0aW9uIChzdGFydFZlcnRleCwgYWRqYWNlbmN5TGlzdHMsIGlzVmlzaXRlZCkge1xuICAgICAgICBpc1Zpc2l0ZWRbc3RhcnRWZXJ0ZXhdID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGphY2VuY3lMaXN0c1tzdGFydFZlcnRleF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0VmVydGV4ID0gYWRqYWNlbmN5TGlzdHNbc3RhcnRWZXJ0ZXhdW2ldO1xuICAgICAgICAgICAgaWYgKCFpc1Zpc2l0ZWRbbmV4dFZlcnRleF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtBY2Nlc3NpYmxlKG5leHRWZXJ0ZXgsIGFkamFjZW5jeUxpc3RzLCBpc1Zpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTY1KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIHR5cGVkXG4gICAgLy8gYXMgJ2FueScgc2luY2UgJ2lzVmlzaXRlZCcgaXMgYW4gYXJyYXkgd2l0aCBib3RoIHN0cmluZyBhbmQgYm9vbGVhbiB2YWx1ZXM7XG4gICAgLy8gQSB0aG9yb3VnaCBjaGVjayBuZWVkcyB0byBiZSBkb25lIHRvIGFzc3VyZSBvZiBpdHMgZXhhY3QgdHlwZS5cbiAgICBHcmFwaFV0aWxzU2VydmljZS5wcm90b3R5cGUuZmluZEN5Y2xlID0gZnVuY3Rpb24gKGN1cnJlbnRWZXJ0ZXgsIHByZXZpb3VzVmVydGV4LCBhZGphY2VuY3lMaXN0cywgaXNWaXNpdGVkLCBpc0RpcmVjdGVkKSB7XG4gICAgICAgIGlzVmlzaXRlZFtjdXJyZW50VmVydGV4XSA9IHRoaXMuREZTX1NUQVRVUy5TVElMTF9WSVNJVElORztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGphY2VuY3lMaXN0c1tjdXJyZW50VmVydGV4XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5leHRWZXJ0ZXggPSBhZGphY2VuY3lMaXN0c1tjdXJyZW50VmVydGV4XVtpXTtcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4ID09PSBwcmV2aW91c1ZlcnRleCAmJiAhaXNEaXJlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmlzaXRlZFtuZXh0VmVydGV4XSA9PT0gKHRoaXMuREZTX1NUQVRVUy5TVElMTF9WSVNJVElORykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Zpc2l0ZWRbbmV4dFZlcnRleF0gPT09IHRoaXMuREZTX1NUQVRVUy5VTlZJU0lURUQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRDeWNsZShuZXh0VmVydGV4LCBjdXJyZW50VmVydGV4LCBhZGphY2VuY3lMaXN0cywgaXNWaXNpdGVkLCBpc0RpcmVjdGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmlzaXRlZFtjdXJyZW50VmVydGV4XSA9IHRoaXMuREZTX1NUQVRVUy5WSVNJVEVEO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTY1KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIHR5cGVkXG4gICAgLy8gYXMgJ2FueScgc2luY2UgJ2dyYXBoJyBpcyBhIGRpY3Qgd2l0aCAnYW5zd2VyJyB0eXBlIG9iamVjdCB3aGljaCBpcyBpdHNlbGZcbiAgICAvLyB0eXBlZCAnYW55Jy5cbiAgICBHcmFwaFV0aWxzU2VydmljZS5wcm90b3R5cGUuY29uc3RydWN0QWRqYWNlbmN5TWF0cml4ID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgIHZhciBhZGpNYXRyaXggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFkak1hdHJpeFJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGFkak1hdHJpeFJvdy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRqTWF0cml4LnB1c2goYWRqTWF0cml4Um93KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKCM3MTY1KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIHR5cGVkXG4gICAgICAgIC8vIGFzICdhbnknIHNpbmNlICdlZGdlJyBpcyBhIGRpY3Qgd2l0aCB2YXJpb3VzIGtleXMuIEEgdGhvcm91Z2ggcmVzZWFyY2hcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgY2FycmllZCBvdXQgdG8gZGV0ZXJtaW5lIGV4YWN0IHR5cGUuXG4gICAgICAgIGdyYXBoLmVkZ2VzLm1hcChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGdyYXBoLmlzV2VpZ2h0ZWQgPyBlZGdlLndlaWdodCA6IDE7XG4gICAgICAgICAgICBhZGpNYXRyaXhbZWRnZS5zcmNdW2VkZ2UuZHN0XSA9IHdlaWdodDtcbiAgICAgICAgICAgIGlmICghZ3JhcGguaXNEaXJlY3RlZCkge1xuICAgICAgICAgICAgICAgIGFkak1hdHJpeFtlZGdlLmRzdF1bZWRnZS5zcmNdID0gd2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFkak1hdHJpeDtcbiAgICB9O1xuICAgIEdyYXBoVXRpbHNTZXJ2aWNlLnByb3RvdHlwZS5uZXh0UGVybXV0YXRpb24gPSBmdW5jdGlvbiAocGVybXV0YXRpb24pIHtcbiAgICAgICAgLy8gR2VuZXJhdGVzIChpbiBwbGFjZSkgdGhlIG5leHQgbGV4aWNvZ3JhcGhpY2FsIHBlcm11dGF0aW9uLlxuICAgICAgICAvLyBwZXJtdXRhdGlvbiBpcyBhIHBlcm11dGF0aW9uIG9mIFswLCAxLCAyLCAuLi4sIHBlcm11dGF0aW9uLmxlbmd0aCAtIDFdXG4gICAgICAgIC8vIEZpbmQgdGhlIHBpdm90IHRvIGxvbmdlc3QgZGVjcmVhc2luZyBzdWZmaXggYW5kIHN1Y2Nlc3NvclxuICAgICAgICB2YXIgcGl2b3QgPSBudWxsO1xuICAgICAgICB2YXIgc3VjY2Vzc29yID0gbnVsbDtcbiAgICAgICAgcGVybXV0YXRpb24ucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwaXZvdCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGl2b3QgIT09IG51bGwgJiYgY3VycmVudFZhbHVlID4gcGVybXV0YXRpb25bcGl2b3RdKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwaXZvdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhcCB0aGUgcGl2b3QgYW5kIHN1Y2Nlc3NvciBhbmQgcmV2ZXJzZSB0aGUgc3VmZml4XG4gICAgICAgIHZhciB0bXAgPSBwZXJtdXRhdGlvbltwaXZvdF07XG4gICAgICAgIHBlcm11dGF0aW9uW3Bpdm90XSA9IHBlcm11dGF0aW9uW3N1Y2Nlc3Nvcl07XG4gICAgICAgIHBlcm11dGF0aW9uW3N1Y2Nlc3Nvcl0gPSB0bXA7XG4gICAgICAgIHBlcm11dGF0aW9uID0gcGVybXV0YXRpb24uY29uY2F0KHBlcm11dGF0aW9uLnNwbGljZShwaXZvdCArIDEpLnJldmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBwZXJtdXRhdGlvbjtcbiAgICB9O1xuICAgIEdyYXBoVXRpbHNTZXJ2aWNlLnByb3RvdHlwZS5hcmVBZGphY2VuY3lNYXRyaWNlc0VxdWFsV2l0aFBlcm11dGF0aW9uID0gZnVuY3Rpb24gKGFkajEsIGFkajIsIHBlcm11dGF0aW9uKSB7XG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IGFkajEubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtVmVydGljZXM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChhZGoxW3Blcm11dGF0aW9uW2ldXVtwZXJtdXRhdGlvbltqXV0gIT09IGFkajJbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEdyYXBoVXRpbHNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KVxuICAgIF0sIEdyYXBoVXRpbHNTZXJ2aWNlKTtcbiAgICByZXR1cm4gR3JhcGhVdGlsc1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFV0aWxzU2VydmljZSA9IEdyYXBoVXRpbHNTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnR3JhcGhVdGlsc1NlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKEdyYXBoVXRpbHNTZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIGdyYXBoLXZpei5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9HcmFwaElucHV0L2RpcmVjdGl2ZXMvZ3JhcGgtZGV0YWlsLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvRGV2aWNlSW5mb1NlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL3N0YXRlZnVsL0ZvY3VzTWFuYWdlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbnMtZXh0ZW5zaW9uLmNvbnN0YW50cy5hanMudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnZ3JhcGhWaXonLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGdyYXBoOiAnPScsXG4gICAgICAgICAgICAgICAgY2FuQWRkVmVydGV4OiAnPScsXG4gICAgICAgICAgICAgICAgY2FuRGVsZXRlVmVydGV4OiAnPScsXG4gICAgICAgICAgICAgICAgY2FuTW92ZVZlcnRleDogJz0nLFxuICAgICAgICAgICAgICAgIGNhbkVkaXRWZXJ0ZXhMYWJlbDogJz0nLFxuICAgICAgICAgICAgICAgIGNhbkFkZEVkZ2U6ICc9JyxcbiAgICAgICAgICAgICAgICBjYW5EZWxldGVFZGdlOiAnPScsXG4gICAgICAgICAgICAgICAgY2FuRWRpdEVkZ2VXZWlnaHQ6ICc9JyxcbiAgICAgICAgICAgICAgICBjYW5FZGl0T3B0aW9uczogJz0nLFxuICAgICAgICAgICAgICAgIGlzSW50ZXJhY3Rpb25BY3RpdmU6ICcmaW50ZXJhY3Rpb25Jc0FjdGl2ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdncmFwaC12aXouZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckZG9jdW1lbnQnLCAnJHRpbWVvdXQnLFxuICAgICAgICAgICAgICAgICdGb2N1c01hbmFnZXJTZXJ2aWNlJywgJ0dyYXBoRGV0YWlsU2VydmljZScsICdHUkFQSF9JTlBVVF9MRUZUX01BUkdJTicsXG4gICAgICAgICAgICAgICAgJ0VWRU5UX05FV19DQVJEX0FWQUlMQUJMRScsICdEZXZpY2VJbmZvU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGRvY3VtZW50LCAkdGltZW91dCwgRm9jdXNNYW5hZ2VyU2VydmljZSwgR3JhcGhEZXRhaWxTZXJ2aWNlLCBHUkFQSF9JTlBVVF9MRUZUX01BUkdJTiwgRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFLCBEZXZpY2VJbmZvU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfTU9ERVMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNT1ZFOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgQUREX0VER0U6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBBRERfVkVSVEVYOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgREVMRVRFOiAzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBVSSBhbmQgc3R1ZmYgbGlrZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9kZTogX01PREVTLk1PVkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0ZXgsIGVkZ2UsIG1vZGUgYnV0dG9uLCBsYWJlbCBjdXJyZW50bHkgYmVpbmcgaG92ZXJlZCBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlcmVkVmVydGV4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJlZEVkZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlcmVkTW9kZUJ1dHRvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGluIEFERF9FREdFIG1vZGUsIHNvdXJjZSB2ZXJ0ZXggb2YgdGhlIG5ldyBlZGdlLCBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEVkZ2VWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgZHJhZ2dlZCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseURyYWdnZWRWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RlZCB2ZXJ0ZXggZm9yIGVkaXRpbmcgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmVydGV4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0ZWQgZWRnZSBmb3IgZWRpdGluZyB3ZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRWRnZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdXNlIHBvc2l0aW9uIGluIFNWRyBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgcG9zaXRpb24gb2YgZHJhZ2dlZCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleERyYWdTdGFydFg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhEcmFnU3RhcnRZOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgcG9zaXRpb24gb2YgbW91c2Ugd2hlbiBkcmFnZ2luZyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURyYWdTdGFydFg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURyYWdTdGFydFk6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5WRVJURVhfUkFESVVTID0gR3JhcGhEZXRhaWxTZXJ2aWNlLlZFUlRFWF9SQURJVVM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuRURHRV9XSURUSCA9IEdyYXBoRGV0YWlsU2VydmljZS5FREdFX1dJRFRIO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGVkRWRnZVdlaWdodFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zaG91bGRTaG93V3JvbmdXZWlnaHRXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNNb2JpbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERldmljZUluZm9TZXJ2aWNlLmlzTW9iaWxlRGV2aWNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaXNNb2JpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aXpDb250YWluZXIgPSAkKCRlbGVtZW50KS5maW5kKCcub3BwaWEtZ3JhcGgtdml6LXN2ZycpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnZpeldpZHRoID0gdml6Q29udGFpbmVyLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2Vtb3ZlR3JhcGhTVkcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5pc0ludGVyYWN0aW9uQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUcmFuc2Zvcm0gY2xpZW50IChYLCBZKSB0byBTVkcgKFgsIFkpLiBUaGlzIGhhcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSBzbyB0aGF0IGNoYW5nZXMgZHVlIHRvIHZpZXdCb3ggYXR0cmlidXRlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlZCBuaWNlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSB2aXpDb250YWluZXJbMF0uY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0LnggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ZncCA9IHB0Lm1hdHJpeFRyYW5zZm9ybSh2aXpDb250YWluZXJbMF0uZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUubW91c2VYID0gc3ZncC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5tb3VzZVkgPSBzdmdwLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdmVydGV4RHJhZ1N0YXJ0WC9ZIGFuZCBtb3VzZURyYWdTdGFydFgvWSB0byBtYWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZS1kcmFnZ2luZyBieSBsYWJlbCBtb3JlIG5hdHVyYWwsIGJ5IG1vdmluZyB0aGUgdmVydGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1vdXNlLWRyYWdnaW5nIGJ5IGxhYmVsIHdpbGwgbWFrZSB0aGUgdmVydGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhd2t3YXJkbHkganVtcCB0byB0aGUgbW91c2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50bHlEcmFnZ2VkVmVydGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN0cmwuc3RhdGUubW91c2VYID4gR1JBUEhfSU5QVVRfTEVGVF9NQVJHSU4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaC52ZXJ0aWNlc1tjdHJsLnN0YXRlLmN1cnJlbnRseURyYWdnZWRWZXJ0ZXhdLnggPSAoY3RybC5zdGF0ZS52ZXJ0ZXhEcmFnU3RhcnRYICsgKGN0cmwuc3RhdGUubW91c2VYIC0gY3RybC5zdGF0ZS5tb3VzZURyYWdTdGFydFgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmdyYXBoLnZlcnRpY2VzW2N0cmwuc3RhdGUuY3VycmVudGx5RHJhZ2dlZFZlcnRleF0ueSA9IChjdHJsLnN0YXRlLnZlcnRleERyYWdTdGFydFkgKyAoY3RybC5zdGF0ZS5tb3VzZVkgLSBjdHJsLnN0YXRlLm1vdXNlRHJhZ1N0YXJ0WSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uQ2xpY2tHcmFwaFNWRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5pc0ludGVyYWN0aW9uQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSA9PT0gX01PREVTLkFERF9WRVJURVggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkFkZFZlcnRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ3JhcGgudmVydGljZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGN0cmwuc3RhdGUubW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjdHJsLnN0YXRlLm1vdXNlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5ob3ZlcmVkVmVydGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5zZWxlY3RlZFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5ob3ZlcmVkRWRnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEJ1dHRvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPSBjdHJsLmJ1dHRvbnNbMF0ubW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5BRERfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJMThOX0lOVEVSQUNUSU9OU19HUkFQSF9FREdFX0lOSVRJQUxfSEVMUFRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJMThOX0lOVEVSQUNUSU9OU19HUkFQSF9NT1ZFX0lOSVRJQUxfSEVMUFRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5oZWxwVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5oZWxwVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0QnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY2FuTW92ZVZlcnRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1xcdUUwNjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX01PVkUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBfTU9ERVMuTU9WRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY2FuQWRkRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1xcdUUxNDQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX0FERF9FREdFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogX01PREVTLkFERF9FREdFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5jYW5BZGRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXHUwMDJCJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJMThOX0lOVEVSQUNUSU9OU19HUkFQSF9BRERfTk9ERScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IF9NT0RFUy5BRERfVkVSVEVYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5jYW5EZWxldGVWZXJ0ZXggfHwgY3RybC5jYW5EZWxldGVFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5idXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnXFx1MjIxMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSTE4Tl9JTlRFUkFDVElPTlNfR1JBUEhfREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogX01PREVTLkRFTEVURVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFZpZXdib3hTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN2Z0NvbnRhaW5lciA9ICQoJGVsZW1lbnQpLmZpbmQoJy5vcHBpYS1ncmFwaC12aXotc3ZnJylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBzdmdDb250YWluZXIuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdCb3hIZWlnaHQgPSBNYXRoLm1heChib3VuZGluZ0JveC5oZWlnaHQgKyBib3VuZGluZ0JveC55LCBzdmdDb250YWluZXIuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN2Z1ZpZXdCb3ggPSAoMCArICcgJyArIDAgKyAnICcgKyAoYm91bmRpbmdCb3gud2lkdGggKyBib3VuZGluZ0JveC54KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAnICsgKHZpZXdCb3hIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaE9wdGlvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdMYWJlbGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246ICdpc0xhYmVsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdEaXJlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiAnaXNEaXJlY3RlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1dlaWdodGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246ICdpc1dlaWdodGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudG9nZ2xlR3JhcGhPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiB3ZSBoYXZlIHR3byBlZGdlcyBzIC0+IGQgYW5kIGQgLT4gc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gJ2lzRGlyZWN0ZWQnICYmIGN0cmwuZ3JhcGhbb3B0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWxldGVSZXBlYXRlZFVuZGlyZWN0ZWRFZGdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaFtvcHRpb25dID0gIWN0cmwuZ3JhcGhbb3B0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5oZWxwVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXRNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSA9PT0gX01PREVTLkFERF9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaGVscFRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX0VER0VfSU5JVElBTF9IRUxQVEVYVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5NT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaGVscFRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX01PVkVfSU5JVElBTF9IRUxQVEVYVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuYWRkRWRnZVZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLnNlbGVjdGVkVmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuY3VycmVudGx5RHJhZ2dlZFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uQ2xpY2tNb2RlQnV0dG9uID0gZnVuY3Rpb24gKG1vZGUsICRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pc0ludGVyYWN0aW9uQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNb2RlKG1vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGN6eCk6IENvbnNpZGVyIGlmIHRoZXJlJ3MgYSBuZWF0IHdheSB0byB3cml0ZSBhIHJlc2V0KClcbiAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gdG8gY2xlYXIgYml0cyBvZiBjdHJsLnN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIGN1cnJlbnRseURyYWdnZWRWZXJ0ZXgsIGFkZEVkZ2VWZXJ0ZXgpXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbkNsaWNrVmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSA9PT0gX01PREVTLkRFTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmNhbkRlbGV0ZVZlcnRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVWZXJ0ZXgoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlICE9PSBfTU9ERVMuREVMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaC5pc0xhYmVsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkVkaXRWZXJ0ZXhMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luRWRpdFZlcnRleExhYmVsKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5ob3ZlcmVkVmVydGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuYWRkRWRnZVZlcnRleCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmN1cnJlbnRseURyYWdnZWRWZXJ0ZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5vblRvdWNoSW5pdGlhbFZlcnRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5hZGRFZGdlVmVydGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5ob3ZlcmVkVmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaGVscFRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJMThOX0lOVEVSQUNUSU9OU19HUkFQSF9FREdFX0lOSVRJQUxfSEVMUFRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5hZGRFZGdlVmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9uVG91Y2hGaW5hbFZlcnRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uVG91Y2hJbml0aWFsVmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSA9PT0gX01PREVTLkFERF9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY2FuQWRkRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbkFkZEVkZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID0gJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX0VER0VfRklOQUxfSEVMUFRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5NT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY2FuTW92ZVZlcnRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbkRyYWdWZXJ0ZXgoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhlbHBUZXh0ID0gJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX01PVkVfRklOQUxfSEVMUFRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vblRvdWNoRmluYWxWZXJ0ZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuQUREX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZGRFZGdlKGN0cmwuc3RhdGUuYWRkRWRnZVZlcnRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFkZEVkZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaGVscFRleHQgPSAnSTE4Tl9JTlRFUkFDVElPTlNfR1JBUEhfRURHRV9JTklUSUFMX0hFTFBURVhUJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5NT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuY3VycmVudGx5RHJhZ2dlZFZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREcmFnVmVydGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuaG92ZXJlZFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaGVscFRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0kxOE5fSU5URVJBQ1RJT05TX0dSQVBIX01PVkVfSU5JVElBTF9IRUxQVEVYVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uTW91c2Vkb3duVmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuQUREX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5jYW5BZGRFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQWRkRWRnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSA9PT0gX01PREVTLk1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5jYW5Nb3ZlVmVydGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luRHJhZ1ZlcnRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uTW91c2VsZWF2ZVZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXggPSAoaW5kZXggPT09IGN0cmwuc3RhdGUuaG92ZXJlZFZlcnRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOiBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25DbGlja1ZlcnRleExhYmVsID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5ncmFwaC5pc0xhYmVsZWQgJiYgY3RybC5jYW5FZGl0VmVydGV4TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbkVkaXRWZXJ0ZXhMYWJlbChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25DbGlja0VkZ2UgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuY2FuRGVsZXRlRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVFZGdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5jdXJyZW50TW9kZSAhPT0gX01PREVTLkRFTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ3JhcGguaXNXZWlnaHRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2FuRWRpdEVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbkVkaXRFZGdlV2VpZ2h0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbkNsaWNrRWRnZVdlaWdodCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuZ3JhcGguaXNXZWlnaHRlZCAmJiBjdHJsLmNhbkVkaXRFZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5FZGl0RWRnZVdlaWdodChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25Nb3VzZXVwRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuQUREX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zdGF0ZS5ob3ZlcmVkVmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFkZEVkZ2UoY3RybC5zdGF0ZS5hZGRFZGdlVmVydGV4LCBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRBZGRFZGdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRNb2RlID09PSBfTU9ERVMuTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnN0YXRlLmN1cnJlbnRseURyYWdnZWRWZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRHJhZ1ZlcnRleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Lm9uKCdtb3VzZXVwJywgY3RybC5vbk1vdXNldXBEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZ2luQWRkRWRnZSA9IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmFkZEVkZ2VWZXJ0ZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQWRkRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuYWRkRWRnZVZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cnlBZGRFZGdlID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9PT0gZW5kSW5kZXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4IDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4IDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPj0gY3RybC5ncmFwaC52ZXJ0aWNlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleCA+PSBjdHJsLmdyYXBoLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC5ncmFwaC5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSBjdHJsLmdyYXBoLmVkZ2VzW2ldLnNyYyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleCA9PT0gY3RybC5ncmFwaC5lZGdlc1tpXS5kc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuZ3JhcGguaXNEaXJlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gY3RybC5ncmFwaC5lZGdlc1tpXS5kc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID09PSBjdHJsLmdyYXBoLmVkZ2VzW2ldLnNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaC5lZGdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0OiBlbmRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVnaW5EcmFnVmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmN1cnJlbnRseURyYWdnZWRWZXJ0ZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUudmVydGV4RHJhZ1N0YXJ0WCA9IGN0cmwuZ3JhcGgudmVydGljZXNbaW5kZXhdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLnZlcnRleERyYWdTdGFydFkgPSBjdHJsLmdyYXBoLnZlcnRpY2VzW2luZGV4XS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5tb3VzZURyYWdTdGFydFggPSBjdHJsLnN0YXRlLm1vdXNlWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUubW91c2VEcmFnU3RhcnRZID0gY3RybC5zdGF0ZS5tb3VzZVk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmREcmFnVmVydGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5jdXJyZW50bHlEcmFnZ2VkVmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUudmVydGV4RHJhZ1N0YXJ0WCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLnZlcnRleERyYWdTdGFydFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5tb3VzZURyYWdTdGFydFggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdGF0ZS5tb3VzZURyYWdTdGFydFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVnaW5FZGl0VmVydGV4TGFiZWwgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuc2VsZWN0ZWRWZXJ0ZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvY3VzTWFuYWdlclNlcnZpY2Uuc2V0Rm9jdXMoJ3ZlcnRleExhYmVsRWRpdEJlZ3VuJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWdpbkVkaXRFZGdlV2VpZ2h0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLnNlbGVjdGVkRWRnZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3RlZEVkZ2VXZWlnaHRWYWx1ZSA9IChjdHJsLmdyYXBoLmVkZ2VzW2N0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlXS53ZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zaG91bGRTaG93V3JvbmdXZWlnaHRXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBGb2N1c01hbmFnZXJTZXJ2aWNlLnNldEZvY3VzKCdlZGdlV2VpZ2h0RWRpdEJlZ3VuJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVFZGdlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmdyYXBoLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN0YXRlLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWxldGVSZXBlYXRlZFVuZGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC5ncmFwaC5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlMSA9IGN0cmwuZ3JhcGguZWRnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgY3RybC5ncmFwaC5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZTIgPSBjdHJsLmdyYXBoLmVkZ2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVkZ2UxLnNyYyA9PT0gZWRnZTIuc3JjICYmIGVkZ2UxLmRzdCA9PT0gZWRnZTIuZHN0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkZ2UxLnNyYyA9PT0gZWRnZTIuZHN0ICYmIGVkZ2UxLmRzdCA9PT0gZWRnZTIuc3JjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlRWRnZShqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgalF1ZXJ5J3MgbWFwIGluc3RlYWQgb2Ygbm9ybWFsIGFycmF5Lm1hcCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCByZW1vdmVzIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgY2FsbGJhY2sgcmV0dXJucyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmdyYXBoLmVkZ2VzID0gJC5tYXAoY3RybC5ncmFwaC5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5zcmMgPT09IGluZGV4IHx8IGVkZ2UuZHN0ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2Uuc3JjID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5zcmMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2UuZHN0ID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5kc3QtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ3JhcGgudmVydGljZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuaG92ZXJlZFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRWZXJ0ZXhMYWJlbEdldHRlclNldHRlciA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuc2VsZWN0ZWRWZXJ0ZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaC52ZXJ0aWNlc1tjdHJsLnN0YXRlLnNlbGVjdGVkVmVydGV4XS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmwuZ3JhcGgudmVydGljZXNbY3RybC5zdGF0ZS5zZWxlY3RlZFZlcnRleF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRFZGdlV2VpZ2h0ID0gZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRFZGdlV2VpZ2h0VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHdlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGVkRWRnZVdlaWdodFZhbHVlID0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmwuc2VsZWN0ZWRFZGdlV2VpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNWYWxpZEVkZ2VXZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5pc051bWJlcihjdHJsLnNlbGVjdGVkRWRnZVdlaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vblVwZGF0ZUVkZ2VXZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcihjdHJsLnNlbGVjdGVkRWRnZVdlaWdodFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ3JhcGguZWRnZXNbY3RybC5zdGF0ZS5zZWxlY3RlZEVkZ2VdLndlaWdodCA9IChjdHJsLnNlbGVjdGVkRWRnZVdlaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3R5bGluZyBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIERFTEVURV9DT0xPUiA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgSE9WRVJfQ09MT1IgPSAnYXF1YSc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTRUxFQ1RfQ09MT1IgPSAnb3JhbmdlJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIERFRkFVTFRfQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldEVkZ2VDb2xvciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLmlzSW50ZXJhY3Rpb25BY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0NPTE9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5ERUxFVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gY3RybC5zdGF0ZS5ob3ZlcmVkRWRnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2FuRGVsZXRlRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBERUxFVEVfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gY3RybC5zdGF0ZS5ob3ZlcmVkRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBIT1ZFUl9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuc3RhdGUuc2VsZWN0ZWRFZGdlID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTRUxFQ1RfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRWZXJ0ZXhDb2xvciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLmlzSW50ZXJhY3Rpb25BY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0NPTE9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3RhdGUuY3VycmVudE1vZGUgPT09IF9NT0RFUy5ERUxFVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gY3RybC5zdGF0ZS5ob3ZlcmVkVmVydGV4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5EZWxldGVWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gREVMRVRFX0NPTE9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IGN0cmwuc3RhdGUuY3VycmVudGx5RHJhZ2dlZFZlcnRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBIT1ZFUl9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBjdHJsLnN0YXRlLmhvdmVyZWRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSE9WRVJfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnN0YXRlLnNlbGVjdGVkVmVydGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTRUxFQ1RfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXREaXJlY3RlZEVkZ2VBcnJvd1BvaW50cyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyYXBoRGV0YWlsU2VydmljZS5nZXREaXJlY3RlZEVkZ2VBcnJvd1BvaW50cyhjdHJsLmdyYXBoLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0RWRnZUNlbnRyZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyYXBoRGV0YWlsU2VydmljZS5nZXRFZGdlQ2VudHJlKGN0cmwuZ3JhcGgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZSBvZiBTVkcgdmlldyBib3guXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3ZnVmlld0JveCA9IGluaXRWaWV3Ym94U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pc0ludGVyYWN0aW9uQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBHcmFwaElucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9ncmFwaC12aXouZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzL2dyYXBoLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2V4cGxvcmF0aW9uLXBsYXllci1wYWdlL3NlcnZpY2VzL2N1cnJlbnQtaW50ZXJhY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9jb250ZXh0dWFsL1VybFNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvV2luZG93RGltZW5zaW9uc1NlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZUdyYXBoSW5wdXQnLCBbXG4gICAgJ0dyYXBoSW5wdXRSdWxlc1NlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICAnRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFJyxcbiAgICBmdW5jdGlvbiAoR3JhcGhJbnB1dFJ1bGVzU2VydmljZSwgSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSwgRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGdldExhc3RBbnN3ZXI6ICcmbGFzdEFuc3dlcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnZ3JhcGgtaW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICdXaW5kb3dEaW1lbnNpb25zU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsIFdpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlLCBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNXZWlnaHRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xhYmVsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0R3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXJlLCBhbmd1bGFyLmNvcHkgaXMgbmVlZGVkIHRvIHN0cmlwICQkaGFzaGtleSBmcm9tIHRoZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoYW5ndWxhci5jb3B5KGN0cmwuZ3JhcGgpLCBHcmFwaElucHV0UnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID0gKGN0cmwuZ2V0TGFzdEFuc3dlcigpID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbihFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5BZGRWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2FuRGVsZXRlVmVydGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkVkaXRWZXJ0ZXhMYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5Nb3ZlVmVydGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkFkZEVkZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2FuRGVsZXRlRWRnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5FZGl0RWRnZVdlaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNldEdyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0dyYXBoID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmdyYXBoV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja1ZhbGlkR3JhcGgobmV3R3JhcGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaCA9IG5ld0dyYXBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1lc3NhZ2UgPSAnSTE4Tl9JTlRFUkFDVElPTlNfR1JBUEhfRVJST1JfSU5WQUxJRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVzZXRHcmFwaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaCA9IGN0cmwuZ2V0TGFzdEFuc3dlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZ1RvQm9vbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0ciA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkFkZFZlcnRleCA9IGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9Cb29sKCRhdHRycy5jYW5BZGRWZXJ0ZXhXaXRoVmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkRlbGV0ZVZlcnRleCA9IGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9Cb29sKCRhdHRycy5jYW5EZWxldGVWZXJ0ZXhXaXRoVmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkVkaXRWZXJ0ZXhMYWJlbCA9IGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9Cb29sKCRhdHRycy5jYW5FZGl0VmVydGV4TGFiZWxXaXRoVmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbk1vdmVWZXJ0ZXggPSBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQm9vbCgkYXR0cnMuY2FuTW92ZVZlcnRleFdpdGhWYWx1ZSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2FuQWRkRWRnZSA9IGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9Cb29sKCRhdHRycy5jYW5BZGRFZGdlV2l0aFZhbHVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5EZWxldGVFZGdlID0gY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb0Jvb2woJGF0dHJzLmNhbkRlbGV0ZUVkZ2VXaXRoVmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbkVkaXRFZGdlV2VpZ2h0ID0gY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb0Jvb2woJGF0dHJzLmNhbkVkaXRFZGdlV2VpZ2h0V2l0aFZhbHVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGN6eGNqeCk6IFdyaXRlIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrVmFsaWRHcmFwaCA9IGZ1bmN0aW9uIChncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ3JhcGgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRpdHlDaGVja0ZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsaWRHcmFwaChjdHJsLmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5yZWdpc3RlckN1cnJlbnRJbnRlcmFjdGlvbihjdHJsLnN1Ym1pdEdyYXBoLCB2YWxpZGl0eUNoZWNrRm4pO1xuICAgICAgICAgICAgICAgICAgICBpbml0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBHcmFwaElucHV0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0dyYXBoSW5wdXQvZGlyZWN0aXZlcy9ncmFwaC1kZXRhaWwuc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zLWV4dGVuc2lvbi5jb25zdGFudHMuYWpzLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VHcmFwaElucHV0JywgW1xuICAgICdHcmFwaERldGFpbFNlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICAnR1JBUEhfSU5QVVRfTEVGVF9NQVJHSU4nLFxuICAgIGZ1bmN0aW9uIChHcmFwaERldGFpbFNlcnZpY2UsIEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UsIEdSQVBIX0lOUFVUX0xFRlRfTUFSR0lOKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvR3JhcGhJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdncmFwaC1pbnB1dC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5ncmFwaCA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLlZFUlRFWF9SQURJVVMgPSBHcmFwaERldGFpbFNlcnZpY2UuVkVSVEVYX1JBRElVUztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5FREdFX1dJRFRIID0gR3JhcGhEZXRhaWxTZXJ2aWNlLkVER0VfV0lEVEg7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuR1JBUEhfSU5QVVRfTEVGVF9NQVJHSU4gPSBHUkFQSF9JTlBVVF9MRUZUX01BUkdJTjtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXREaXJlY3RlZEVkZ2VBcnJvd1BvaW50cyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyYXBoRGV0YWlsU2VydmljZS5nZXREaXJlY3RlZEVkZ2VBcnJvd1BvaW50cyhjdHJsLmdyYXBoLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0RWRnZUNlbnRyZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyYXBoRGV0YWlsU2VydmljZS5nZXRFZGdlQ2VudHJlKGN0cmwuZ3JhcGgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBHcmFwaElucHV0IHNob3J0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZUdyYXBoSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9HcmFwaElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ2dyYXBoLWlucHV0LXNob3J0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGJoZW5uaW5nKTogSW1wcm92ZSB0aGlzIHNob3J0IHJlc3BvbnNlIGJ5IHVzaW5nIGEgc21hbGwgdmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZ3JhcGggaW1hZ2UgaW5zdGVhZCBvZiBhbiBhcmJpdHJhcnkgbGFiZWwgb2YgdmVydGljZXMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGVkZ2VzLlxuICAgICAgICAgICAgICAgICAgICBjdHJsLmdyYXBoID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIEltYWdlQ2xpY2tJbnB1dCBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ltYWdlQ2xpY2tJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdpbWFnZS1jbGljay1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSW1hZ2VDbGlja0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ2ltYWdlLWNsaWNrLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ltYWdlQ2xpY2tJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1pbWFnZS1jbGljay1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtaW1hZ2UtY2xpY2staW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSW1hZ2VDbGlja0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXNob3J0LXJlc3BvbnNlLWltYWdlLWNsaWNrLWlucHV0LmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBJbWFnZUNsaWNrSW5wdXRSdWxlc1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlKCkge1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTY1KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIHR5cGVkXG4gICAgLy8gYXMgJ2FueScgc2luY2UgJ2Fuc3dlcicgaXMgYSBjb21wbGV4IG9iamVjdCBoYXZpbmcgdmFyeWluZyB0eXBlcy4gQSBnZW5lcmFsXG4gICAgLy8gdHlwZSBuZWVkcyB0byBiZSBmb3VuZC4gU2FtZSBnb2VzIGZvciAnaW5wdXRzJy5cbiAgICBJbWFnZUNsaWNrSW5wdXRSdWxlc1NlcnZpY2UucHJvdG90eXBlLklzSW5SZWdpb24gPSBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFuc3dlci5jbGlja2VkUmVnaW9ucy5pbmRleE9mKGlucHV0cy54KSAhPT0gLTE7XG4gICAgfTtcbiAgICBJbWFnZUNsaWNrSW5wdXRSdWxlc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pXG4gICAgXSwgSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlKTtcbiAgICByZXR1cm4gSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlID0gSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShJbWFnZUNsaWNrSW5wdXRSdWxlc1NlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSA9IGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIEltYWdlQ2xpY2tJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydpbWFnZUFuZFJlZ2lvbnMnXSk7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIGltZ0FuZFJlZ2lvbkFyZ1ZhbHVlID0gY3VzdG9taXphdGlvbkFyZ3MuaW1hZ2VBbmRSZWdpb25zLnZhbHVlO1xuICAgICAgICBpZiAoIWltZ0FuZFJlZ2lvbkFyZ1ZhbHVlLmltYWdlUGF0aCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGFkZCBhbiBpbWFnZSBmb3IgdGhlIGxlYXJuZXIgdG8gY2xpY2sgb24uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBpbWFnZSBzcGVjaWZpZWQsIGZ1cnRoZXIgd2FybmluZ3MgZG9uJ3QgcmVhbGx5XG4gICAgICAgICAgICAvLyBhcHBseS5cbiAgICAgICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZUFueVJlZ2lvblN0cmluZ3NFbXB0eSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJlQW55UmVnaW9uU3RyaW5nc05vbkFscGhhTnVtZXJpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJlQW55UmVnaW9uU3RyaW5nc0R1cGxpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlZW5SZWdpb25TdHJpbmdzID0gW107XG4gICAgICAgIGlmIChpbWdBbmRSZWdpb25BcmdWYWx1ZS5sYWJlbGVkUmVnaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBzcGVjaWZ5IGF0IGxlYXN0IG9uZSByZWdpb24gaW4gdGhlIGltYWdlLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1nQW5kUmVnaW9uQXJnVmFsdWUubGFiZWxlZFJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZWdpb25MYWJlbCA9IChpbWdBbmRSZWdpb25BcmdWYWx1ZS5sYWJlbGVkUmVnaW9uc1tpXS5sYWJlbCk7XG4gICAgICAgICAgICB2YXIgQUxQSEFOVU1FUklDX1JFR0VYID0gL15bQS1aYS16MC05XSskLztcbiAgICAgICAgICAgIGlmIChyZWdpb25MYWJlbC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYXJlQW55UmVnaW9uU3RyaW5nc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBTFBIQU5VTUVSSUNfUkVHRVgudGVzdChyZWdpb25MYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBhcmVBbnlSZWdpb25TdHJpbmdzTm9uQWxwaGFOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5SZWdpb25TdHJpbmdzLmluZGV4T2YocmVnaW9uTGFiZWwpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFyZUFueVJlZ2lvblN0cmluZ3NEdXBsaWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlZW5SZWdpb25TdHJpbmdzLnB1c2gocmVnaW9uTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVBbnlSZWdpb25TdHJpbmdzRW1wdHkpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnN1cmUgdGhlIHJlZ2lvbiBsYWJlbHMgYXJlIG5vbmVtcHR5LidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVBbnlSZWdpb25TdHJpbmdzTm9uQWxwaGFOdW1lcmljKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnVGhlIHJlZ2lvbiBsYWJlbHMgc2hvdWxkIGNvbnNpc3Qgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVBbnlSZWdpb25TdHJpbmdzRHVwbGljYXRlZCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVuc3VyZSB0aGUgcmVnaW9uIGxhYmVscyBhcmUgdW5pcXVlLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QWxsV2FybmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKSk7XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFuc3dlckdyb3VwV2FybmluZ3MoYW5zd2VyR3JvdXBzLCBzdGF0ZU5hbWUpKTtcbiAgICAgICAgdmFyIGltZ0FuZFJlZ2lvbkFyZ1ZhbHVlID0gY3VzdG9taXphdGlvbkFyZ3MuaW1hZ2VBbmRSZWdpb25zLnZhbHVlO1xuICAgICAgICB2YXIgc2VlblJlZ2lvblN0cmluZ3MgPSBpbWdBbmRSZWdpb25BcmdWYWx1ZS5sYWJlbGVkUmVnaW9ucy5tYXAoZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbi5sYWJlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgZWFjaCBydWxlIHJlZmVycyB0byBhIHZhbGlkIHJlZ2lvbiBzdHJpbmcuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5zd2VyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBhbnN3ZXJHcm91cHNbaV0ucnVsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzW2pdLnR5cGUgPT09ICdJc0luUmVnaW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBydWxlc1tqXS5pbnB1dHMueDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5SZWdpb25TdHJpbmdzLmluZGV4T2YobGFiZWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1RoZSByZWdpb24gbGFiZWwgXFwnJyArIGxhYmVsICsgJ1xcJyBpbiBydWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcoaiArIDEpICsgJyBpbiBncm91cCAnICsgU3RyaW5nKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgaW52YWxpZC4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWZhdWx0T3V0Y29tZSB8fCBkZWZhdWx0T3V0Y29tZS5pc0NvbmZ1c2luZyhzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUGxlYXNlIGFkZCBhIHJ1bGUgdG8gY292ZXIgd2hhdCBzaG91bGQgaGFwcGVuIGlmIG5vbmUgb2YgdGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAnZ2l2ZW4gcmVnaW9ucyBhcmUgY2xpY2tlZC4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgSW1hZ2VDbGlja0lucHV0VmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkltYWdlQ2xpY2tJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gSW1hZ2VDbGlja0lucHV0VmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdJbWFnZUNsaWNrSW5wdXRWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoSW1hZ2VDbGlja0lucHV0VmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgSW1hZ2VDbGlja0lucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ltYWdlQ2xpY2tJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdpbWFnZS1jbGljay1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9pbWFnZS1wcmVsb2FkZXIuc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvQXNzZXRzQmFja2VuZEFwaVNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0NvbnRleHRTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZUltYWdlQ2xpY2tJbnB1dCcsIFtcbiAgICAnQXNzZXRzQmFja2VuZEFwaVNlcnZpY2UnLCAnQ29udGV4dFNlcnZpY2UnLFxuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlJywgJ0ltYWdlUHJlbG9hZGVyU2VydmljZScsXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgJ0VWRU5UX05FV19DQVJEX0FWQUlMQUJMRScsXG4gICAgJ0VYUExPUkFUSU9OX0VESVRPUl9UQUJfQ09OVEVYVCcsICdMT0FESU5HX0lORElDQVRPUl9VUkwnLFxuICAgIGZ1bmN0aW9uIChBc3NldHNCYWNrZW5kQXBpU2VydmljZSwgQ29udGV4dFNlcnZpY2UsIEh0bWxFc2NhcGVyU2VydmljZSwgSW1hZ2VDbGlja0lucHV0UnVsZXNTZXJ2aWNlLCBJbWFnZVByZWxvYWRlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlLCBFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUsIEVYUExPUkFUSU9OX0VESVRPUl9UQUJfQ09OVEVYVCwgTE9BRElOR19JTkRJQ0FUT1JfVVJMKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGdldExhc3RBbnN3ZXI6ICcmbGFzdEFuc3dlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW1hZ2VDbGlja0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ2ltYWdlLWNsaWNrLWlucHV0LWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRlbGVtZW50JywgJyRhdHRycycsICckc2NvcGUnLCAnQ3VycmVudEludGVyYWN0aW9uU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRlbGVtZW50LCAkYXR0cnMsICRzY29wZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUFuZFJlZ2lvbnMgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuaW1hZ2VBbmRSZWdpb25zV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5oaWdobGlnaHRSZWdpb25zT25Ib3ZlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoJGF0dHJzLmhpZ2hsaWdodFJlZ2lvbnNPbkhvdmVyV2l0aFZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmZpbGVwYXRoID0gaW1hZ2VBbmRSZWdpb25zLmltYWdlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZVVybCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxvYWRpbmdJbmRpY2F0b3JVcmwgPSBVcmxJbnRlcnBvbGF0aW9uU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFN0YXRpY0ltYWdlVXJsKExPQURJTkdfSU5ESUNBVE9SX1VSTCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNMb2FkaW5nSW5kaWNhdG9yU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pc1RyeUFnYWluU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEltYWdlUHJlbG9hZGVyU2VydmljZS5pbkV4cGxvcmF0aW9uUGxheWVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaXNMb2FkaW5nSW5kaWNhdG9yU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5kaW1lbnNpb25zID0gKEltYWdlUHJlbG9hZGVyU2VydmljZS5nZXREaW1lbnNpb25zT2ZJbWFnZShjdHJsLmZpbGVwYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYWxpZ25pbmcgdGhlIGdpZiB0byB0aGUgY2VudGVyIG9mIGl0J3MgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGluZ0luZGljYXRvclNpemUgPSAoKGN0cmwuZGltZW5zaW9ucy5oZWlnaHQgPCAxMjQpID8gMjQgOiAxMjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZUNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY3RybC5kaW1lbnNpb25zLmhlaWdodCArICdweCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvYWRpbmdJbmRpY2F0b3JTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxvYWRpbmdJbmRpY2F0b3JTaXplICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbG9hZGluZ0luZGljYXRvclNpemUgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VQcmVsb2FkZXJTZXJ2aWNlLmdldEltYWdlVXJsKGN0cmwuZmlsZXBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmplY3RVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pc1RyeUFnYWluU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pc0xvYWRpbmdJbmRpY2F0b3JTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmltYWdlVXJsID0gb2JqZWN0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pc1RyeUFnYWluU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmlzTG9hZGluZ0luZGljYXRvclNob3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2FkSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB1c2VyIGlzIGluIGV4cGxvcmF0aW9uIGVkaXRvciBvciBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlldyBtb2RlLiBXZSBkb24ndCBoYXZlIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHRyeSBhZ2FpbiBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3dpbmcgaW1hZ2VzIGluIHRoZSBleHBsb3JhdGlvbiBlZGl0b3Igb3IgaW4gcHJldmlldyBtb2RlLiBTb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZGlyZWN0bHkgYXNzaWduIHRoZSB1cmwgdG8gdGhlIGltYWdlVXJsLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZVVybCA9IEFzc2V0c0JhY2tlbmRBcGlTZXJ2aWNlLmdldEltYWdlVXJsRm9yUHJldmlldyhDb250ZXh0U2VydmljZS5nZXRFbnRpdHlUeXBlKCksIENvbnRleHRTZXJ2aWNlLmdldEVudGl0eUlkKCksIGN0cmwuZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgPSAoY3RybC5nZXRMYXN0QW5zd2VyKCkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sYXN0QW5zd2VyID0gY3RybC5nZXRMYXN0QW5zd2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5jdXJyZW50bHlIb3ZlcmVkUmVnaW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFsbFJlZ2lvbnMgPSBpbWFnZUFuZFJlZ2lvbnMubGFiZWxlZFJlZ2lvbnM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudXBkYXRlQ3VycmVudGx5SG92ZXJlZFJlZ2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlQW5kUmVnaW9ucy5sYWJlbGVkUmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbGVkUmVnaW9uID0gaW1hZ2VBbmRSZWdpb25zLmxhYmVsZWRSZWdpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb25BcmVhID0gbGFiZWxlZFJlZ2lvbi5yZWdpb24uYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnaW9uQXJlYVswXVswXSA8PSBjdHJsLm1vdXNlWCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWCA8PSByZWdpb25BcmVhWzFdWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkFyZWFbMF1bMV0gPD0gY3RybC5tb3VzZVkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVkgPD0gcmVnaW9uQXJlYVsxXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmN1cnJlbnRseUhvdmVyZWRSZWdpb25zLnB1c2gobGFiZWxlZFJlZ2lvbi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIGZvbGxvd2luZyBsaW5lcyBoaWdobGlnaHQgdGhlIGxlYXJuZXIncyBsYXN0IGFuc3dlciBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJkLiBUaGlzIG5lZWQgb25seSBiZSBkb25lIGF0IHRoZSBiZWdpbm5pbmcgYXMgaWYgaGUgc3VibWl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhbnN3ZXIsIGJhc2VkIG9uIEVWRU5UX05FV19DQVJEX0FWQUlMQUJMRSwgdGhlIGltYWdlIGlzIG1hZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmUsIHNvIGhpcyBsYXN0IHNlbGVjdGlvbiB3b3VsZCBiZSBoaWdsaWdodGVkLiovXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWCA9IGN0cmwuZ2V0TGFzdEFuc3dlcigpLmNsaWNrUG9zaXRpb25bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWSA9IGN0cmwuZ2V0TGFzdEFuc3dlcigpLmNsaWNrUG9zaXRpb25bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVwZGF0ZUN1cnJlbnRseUhvdmVyZWRSZWdpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRSZWdpb25EaW1lbnNpb25zID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSAkKCRlbGVtZW50KS5maW5kKCcub3BwaWEtaW1hZ2UtY2xpY2staW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxlZFJlZ2lvbiA9IGltYWdlQW5kUmVnaW9ucy5sYWJlbGVkUmVnaW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uQXJlYSA9IGxhYmVsZWRSZWdpb24ucmVnaW9uLmFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdERlbHRhID0gaW1hZ2Uub2Zmc2V0KCkubGVmdCAtIGltYWdlLnBhcmVudCgpLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wRGVsdGEgPSBpbWFnZS5vZmZzZXQoKS50b3AgLSBpbWFnZS5wYXJlbnQoKS5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlZ2lvbkFyZWFbMF1bMF0gKiBpbWFnZS53aWR0aCgpICsgbGVmdERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcmVnaW9uQXJlYVswXVsxXSAqIGltYWdlLmhlaWdodCgpICsgdG9wRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChyZWdpb25BcmVhWzFdWzBdIC0gcmVnaW9uQXJlYVswXVswXSkgKiBpbWFnZS53aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogKHJlZ2lvbkFyZWFbMV1bMV0gLSByZWdpb25BcmVhWzBdWzFdKSAqIGltYWdlLmhlaWdodCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldFJlZ2lvbkRpc3BsYXkgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmN1cnJlbnRseUhvdmVyZWRSZWdpb25zLmluZGV4T2YobGFiZWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0RG90RGlzcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb250ZXh0U2VydmljZS5nZXRFZGl0b3JUYWJDb250ZXh0KCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQTE9SQVRJT05fRURJVE9SX1RBQl9DT05URVhULkVESVRPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFzdEFuc3dlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlja1Bvc2l0aW9uOiBbY3RybC5tb3VzZVgsIGN0cmwubW91c2VZXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0RG90TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSAkKCRlbGVtZW50KS5maW5kKCcub3BwaWEtaW1hZ2UtY2xpY2staW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90TG9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5sYXN0QW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90TG9jYXRpb24ubGVmdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFzdEFuc3dlci5jbGlja1Bvc2l0aW9uWzBdICogaW1hZ2Uud2lkdGgoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vZmZzZXQoKS5sZWZ0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnBhcmVudCgpLm9mZnNldCgpLmxlZnQgLSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdExvY2F0aW9uLnRvcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFzdEFuc3dlci5jbGlja1Bvc2l0aW9uWzFdICogaW1hZ2UuaGVpZ2h0KCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub2Zmc2V0KCkudG9wIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnBhcmVudCgpLm9mZnNldCgpLnRvcCAtIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG90TG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25Nb3VzZW1vdmVJbWFnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSAkKCRlbGVtZW50KS5maW5kKCcub3BwaWEtaW1hZ2UtY2xpY2staW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnBhZ2VYIC0gaW1hZ2Uub2Zmc2V0KCkubGVmdCkgLyBpbWFnZS53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChldmVudC5wYWdlWSAtIGltYWdlLm9mZnNldCgpLnRvcCkgLyBpbWFnZS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3VycmVudGx5SG92ZXJlZFJlZ2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXBkYXRlQ3VycmVudGx5SG92ZXJlZFJlZ2lvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbkNsaWNrSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrUG9zaXRpb246IFtjdHJsLm1vdXNlWCwgY3RybC5tb3VzZVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRSZWdpb25zOiBjdHJsLmN1cnJlbnRseUhvdmVyZWRSZWdpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5vblN1Ym1pdChhbnN3ZXIsIEltYWdlQ2xpY2tJbnB1dFJ1bGVzU2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24obnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBJbWFnZUNsaWNrSW5wdXQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFSZXNwb25zZUltYWdlQ2xpY2tJbnB1dCcsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaW1hZ2UtY2xpY2staW5wdXQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ0h0bWxFc2NhcGVyU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRhdHRycywgSHRtbEVzY2FwZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jbGlja1JlZ2lvbkxhYmVsID0gJyhDbGlja3Mgb24gJyArIChfYW5zd2VyLmNsaWNrZWRSZWdpb25zLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcJycgKyBfYW5zd2VyLmNsaWNrZWRSZWdpb25zWzBdICsgJ1xcJycgOiAnaW1hZ2UnKSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIEltYWdlQ2xpY2tJbnB1dCBzaG9ydCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VJbWFnZUNsaWNrSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaW1hZ2UtY2xpY2staW5wdXQtc2hvcnQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2xpY2tSZWdpb25MYWJlbCA9IChfYW5zd2VyLmNsaWNrZWRSZWdpb25zLmxlbmd0aCA+IDAgPyBfYW5zd2VyLmNsaWNrZWRSZWdpb25zWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdDbGlja2VkIG9uIGltYWdlJyk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIEludGVyYWN0aXZlTWFwIGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvZGlyZWN0aXZlcy8nICtcbiAgICAnaW50ZXJhY3RpdmUtbWFwLXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9kaXJlY3RpdmVzLycgK1xuICAgICdpbnRlcmFjdGl2ZS1tYXAtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtaW50ZXJhY3RpdmUtaW50ZXJhY3RpdmUtbWFwLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXJlc3BvbnNlLWludGVyYWN0aXZlLW1hcC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1pbnRlcmFjdGl2ZS1tYXAuZGlyZWN0aXZlLnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJ1bGVzIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnSW50ZXJhY3RpdmVNYXBSdWxlc1NlcnZpY2UnLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUkFESVVTX09GX0VBUlRIX0tNID0gNjM3MS4wO1xuICAgICAgICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldERpc3RhbmNlSW5LbSA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xuICAgICAgICAgICAgdmFyIGxhdGl0dWRlMSA9IGRlZ3JlZXNUb1JhZGlhbnMocG9pbnQxWzBdKTtcbiAgICAgICAgICAgIHZhciBsYXRpdHVkZTIgPSBkZWdyZWVzVG9SYWRpYW5zKHBvaW50MlswXSk7XG4gICAgICAgICAgICB2YXIgbGF0aXR1ZGVEaWZmZXJlbmNlID0gZGVncmVlc1RvUmFkaWFucyhwb2ludDJbMF0gLSBwb2ludDFbMF0pO1xuICAgICAgICAgICAgdmFyIGxvbmdpdHVkZURpZmZlcmVuY2UgPSBkZWdyZWVzVG9SYWRpYW5zKHBvaW50MlsxXSAtIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGhhdmVyc2luZSBmb3JtdWxhXG4gICAgICAgICAgICB2YXIgaGF2ZXJzaW5lT2ZDZW50cmFsQW5nbGUgPSAoTWF0aC5wb3coTWF0aC5zaW4obGF0aXR1ZGVEaWZmZXJlbmNlIC8gMiksIDIpICtcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhsYXRpdHVkZTEpICogTWF0aC5jb3MobGF0aXR1ZGUyKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguc2luKGxvbmdpdHVkZURpZmZlcmVuY2UgLyAyKSwgMikpO1xuICAgICAgICAgICAgcmV0dXJuIFJBRElVU19PRl9FQVJUSF9LTSAqXG4gICAgICAgICAgICAgICAgMiAqIE1hdGguYXNpbihNYXRoLnNxcnQoaGF2ZXJzaW5lT2ZDZW50cmFsQW5nbGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFdpdGhpbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbERpc3RhbmNlID0gZ2V0RGlzdGFuY2VJbkttKGlucHV0cy5wLCBhbnN3ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxEaXN0YW5jZSA8PSBpbnB1dHMuZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBOb3RXaXRoaW46IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxEaXN0YW5jZSA9IGdldERpc3RhbmNlSW5LbShpbnB1dHMucCwgYW5zd2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRGlzdGFuY2UgPiBpbnB1dHMuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRpb24gc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgSW50ZXJhY3RpdmVNYXBWYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2ZU1hcFZhbGlkYXRpb25TZXJ2aWNlKGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlID0gYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZTtcbiAgICB9XG4gICAgLy8gVE9ETygjNzE3Nik6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnY3VzdG9taXphdGlvbkFyZ3MnIGlzIGEgZGljdCB3aXRoIHBvc3NpYmxlIHVuZGVyc2NvcmVfY2FzZWRcbiAgICAvLyBrZXlzIHdoaWNoIGdpdmUgdHNsaW50IGVycm9ycyBhZ2FpbnN0IHVuZGVyc2NvcmVfY2FzaW5nIGluIGZhdm9yIG9mXG4gICAgLy8gY2FtZWxDYXNpbmcuXG4gICAgSW50ZXJhY3RpdmVNYXBWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydsYXRpdHVkZScsICdsb25naXR1ZGUnXSk7XG4gICAgICAgIGlmIChjdXN0b21pemF0aW9uQXJncy5sYXRpdHVkZS52YWx1ZSA8IC05MCB8fFxuICAgICAgICAgICAgY3VzdG9taXphdGlvbkFyZ3MubGF0aXR1ZGUudmFsdWUgPiA5MCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHBpY2sgYSBzdGFydGluZyBsYXRpdHVkZSBiZXR3ZWVuIC05MCBhbmQgOTAuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbWl6YXRpb25BcmdzLmxvbmdpdHVkZS52YWx1ZSA8IC0xODAgfHxcbiAgICAgICAgICAgIGN1c3RvbWl6YXRpb25BcmdzLmxvbmdpdHVkZS52YWx1ZSA+IDE4MCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHBpY2sgYSBzdGFydGluZyBsb25naXR1ZGUgYmV0d2VlbiAtMTgwIGFuZCAxODAuJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIEludGVyYWN0aXZlTWFwVmFsaWRhdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEFsbFdhcm5pbmdzID0gZnVuY3Rpb24gKHN0YXRlTmFtZSwgY3VzdG9taXphdGlvbkFyZ3MsIGFuc3dlckdyb3VwcywgZGVmYXVsdE91dGNvbWUpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzTGlzdCA9IFtdO1xuICAgICAgICB3YXJuaW5nc0xpc3QgPSB3YXJuaW5nc0xpc3QuY29uY2F0KHRoaXMuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyhjdXN0b21pemF0aW9uQXJncykpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuc3dlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChydWxlc1tqXS50eXBlID09PSAnV2l0aGluJyB8fFxuICAgICAgICAgICAgICAgICAgICBydWxlc1tqXS50eXBlID09PSAnTm90V2l0aGluJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbal0uaW5wdXRzLmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgZW5zdXJlIHRoYXQgcnVsZSAnICsgU3RyaW5nKGogKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaW4gZ3JvdXAgJyArIFN0cmluZyhpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHJlZmVycyB0byBhIHZhbGlkIGRpc3RhbmNlLidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBJbnRlcmFjdGl2ZU1hcFZhbGlkYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBJbnRlcmFjdGl2ZU1hcFZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gSW50ZXJhY3RpdmVNYXBWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkludGVyYWN0aXZlTWFwVmFsaWRhdGlvblNlcnZpY2UgPSBJbnRlcmFjdGl2ZU1hcFZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnSW50ZXJhY3RpdmVNYXBWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoSW50ZXJhY3RpdmVNYXBWYWxpZGF0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBJbnRlcmFjdGl2ZU1hcCBpbnRlcmFjdGlvbi5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy91aUxlYWZsZXRSZXF1aXJlcy50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9Ccm93c2VyQ2hlY2tlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9kaXJlY3RpdmVzLycgK1xuICAgICdpbnRlcmFjdGl2ZS1tYXAtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgncGFnZXMvZXhwbG9yYXRpb24tcGxheWVyLXBhZ2Uvc2VydmljZXMvY3VycmVudC1pbnRlcmFjdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZUludGVyYWN0aXZlTWFwJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnSW50ZXJhY3RpdmVNYXBSdWxlc1NlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgICdFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIEludGVyYWN0aXZlTWFwUnVsZXNTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSwgRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGdldExhc3RBbnN3ZXI6ICcmbGFzdEFuc3dlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaW50ZXJhY3RpdmUtbWFwLWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRhdHRycycsICckc2NvcGUnLCAnJHRpbWVvdXQnLCAnQnJvd3NlckNoZWNrZXJTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnQ3VycmVudEludGVyYWN0aW9uU2VydmljZScsIGZ1bmN0aW9uICgkYXR0cnMsICRzY29wZSwgJHRpbWVvdXQsIEJyb3dzZXJDaGVja2VyU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY29vcmRzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmxhdGl0dWRlV2l0aFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5sb25naXR1ZGVXaXRoVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuem9vbSA9IChIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuem9vbVdpdGhWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgPSAoY3RybC5nZXRMYXN0QW5zd2VyKCkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm1hcE1hcmtlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGN0cmwuY29vcmRzIHx8IFswLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21MZXZlbCA9IHBhcnNlSW50KGN0cmwuem9vbSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0T3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3ZlcmxheVN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAxMDAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmhpZGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5vdmVybGF5U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnd2hpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlTWFya2VyUG9zaXRpb24gPSBmdW5jdGlvbiAobGF0LCBsbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubWFwTWFya2Vycy5tYWluTWFya2VyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogbGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogbG5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvc3RhdGljL21hcmtlci1pY29uLnBuZycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TaXplOiBbMjUsIDQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uQW5jaG9yOiBbMTIsIDQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9zdGF0aWMvbWFya2VyLXNoYWRvdy5wbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1NpemU6IFs0MSwgNDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93QW5jaG9yOiBbMTMsIDQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25SZXRpbmFVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL3N0YXRpYy9tYXJrZXItaWNvbi0yeC5wbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93UmV0aW5hVXJsOiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvc3RhdGljL21hcmtlci1zaGFkb3cucG5nJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbihFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zZXRPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdzaG93SW50ZXJhY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmcmVzaE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubWFwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBjb29yZHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogY29vcmRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tOiB6b29tTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgZHJhZ2dpbmcgZm9yIG1vYmlsZSBkZXZpY2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogIUJyb3dzZXJDaGVja2VyU2VydmljZS5pc01vYmlsZURldmljZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IFsnY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpYzogJ2VtaXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VNYXJrZXJQb3NpdGlvbihjdHJsLmdldExhc3RBbnN3ZXIoKVswXSwgY3RybC5nZXRMYXN0QW5zd2VyKClbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdsZWFmbGV0RGlyZWN0aXZlTWFwLmludGVyYWN0aXZlTWFwLm1vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zZXRPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdsZWFmbGV0RGlyZWN0aXZlTWFwLmludGVyYWN0aXZlTWFwLm1vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdsZWFmbGV0RGlyZWN0aXZlTWFwLmludGVyYWN0aXZlTWFwLmNsaWNrJywgZnVuY3Rpb24gKGV2dCwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdMYXQgPSBhcmdzLmxlYWZsZXRFdmVudC5sYXRsbmcubGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdMbmcgPSBhcmdzLmxlYWZsZXRFdmVudC5sYXRsbmcubG5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1hcmtlclBvc2l0aW9uKG5ld0xhdCwgbmV3TG5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLm9uU3VibWl0KFtuZXdMYXQsIG5ld0xuZ10sIEludGVyYWN0aXZlTWFwUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hNYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIEludGVyYWN0aXZlTWFwIHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL3VpTGVhZmxldFJlcXVpcmVzLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFSZXNwb25zZUludGVyYWN0aXZlTWFwJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaW50ZXJhY3RpdmUtbWFwLXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2Fuc3dlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm1hcE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb21Db250cm9sOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBfYW5zd2VyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogX2Fuc3dlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tOiA4XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwTWFya2Vyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5NYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBfYW5zd2VyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbmc6IF9hbnN3ZXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25Vcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL3N0YXRpYy9tYXJrZXItaWNvbi5wbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TaXplOiBbMjUsIDQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25BbmNob3I6IFsxMiwgNDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9zdGF0aWMvbWFya2VyLXNoYWRvdy5wbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogWzQxLCA0MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0FuY2hvcjogWzEzLCA0MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uUmV0aW5hVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9zdGF0aWMvbWFya2VyLWljb24tMngucG5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSZXRpbmFVcmw6IChVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9zdGF0aWMvbWFya2VyLXNoYWRvdy5wbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBJbnRlcmFjdGl2ZU1hcCBzaG9ydCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VJbnRlcmFjdGl2ZU1hcCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ2ludGVyYWN0aXZlLW1hcC1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5mb3JtYXR0ZWRDb29yZHMgPSBNYXRoLmFicyhfYW5zd2VyWzBdKS50b0ZpeGVkKDMpICsgJ8KwICc7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZm9ybWF0dGVkQ29vcmRzICs9IChfYW5zd2VyWzBdID49IDAgPyAnTicgOiAnUycpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmZvcm1hdHRlZENvb3JkcyArPSAnLCAnO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmZvcm1hdHRlZENvb3JkcyArPSBNYXRoLmFicyhfYW5zd2VyWzFdKS50b0ZpeGVkKDMpICsgJ8KwICc7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZm9ybWF0dGVkQ29vcmRzICs9IChfYW5zd2VyWzFdID49IDAgPyAnRScgOiAnVycpO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBJdGVtU2VsZWN0aW9uSW5wdXQgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvc3RhdGljL2l0ZW1fc2VsZWN0aW9uX2lucHV0LmNzcycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdpdGVtLXNlbGVjdGlvbi1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSXRlbVNlbGVjdGlvbklucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ2l0ZW0tc2VsZWN0aW9uLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1pdGVtLXNlbGVjdGlvbi1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtaXRlbS1zZWxlY3Rpb24taW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSXRlbVNlbGVjdGlvbklucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXNob3J0LXJlc3BvbnNlLWl0ZW0tc2VsZWN0aW9uLWlucHV0LmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ZpbHRlcnMvcmVtb3ZlLWR1cGxpY2F0ZXMtaW4tYXJyYXkuZmlsdGVyLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdJdGVtU2VsZWN0aW9uSW5wdXRSdWxlc1NlcnZpY2UnLCBbXG4gICAgJyRmaWx0ZXInLCBmdW5jdGlvbiAoJGZpbHRlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEFuc3dlciA9ICRmaWx0ZXIoJ3JlbW92ZUR1cGxpY2F0ZXNJbkFycmF5JykoYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gJGZpbHRlcigncmVtb3ZlRHVwbGljYXRlc0luQXJyYXknKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbnN3ZXIubGVuZ3RoID09PSBub3JtYWxpemVkSW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRBbnN3ZXIuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dC5pbmRleE9mKHZhbCkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb250YWluc0F0TGVhc3RPbmVPZjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRBbnN3ZXIgPSAkZmlsdGVyKCdyZW1vdmVEdXBsaWNhdGVzSW5BcnJheScpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9ICRmaWx0ZXIoJ3JlbW92ZUR1cGxpY2F0ZXNJbkFycmF5JykoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQW5zd2VyLnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0LmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETyh3eHkpOiBtaWdyYXRlIHRoZSBuYW1lIG9mIHRoaXMgcnVsZSB0byBPbWl0c0F0TGVhc3RPbmVPZiwga2VlcGluZ1xuICAgICAgICAgICAgLy8gaW4gc3luYyB3aXRoIHRoZSBiYWNrZW5kIG1pZ3JhdGlvbiBvZiB0aGUgc2FtZSBydWxlLlxuICAgICAgICAgICAgRG9lc05vdENvbnRhaW5BdExlYXN0T25lT2Y6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQW5zd2VyID0gJGZpbHRlcigncmVtb3ZlRHVwbGljYXRlc0luQXJyYXknKShhbnN3ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSAkZmlsdGVyKCdyZW1vdmVEdXBsaWNhdGVzSW5BcnJheScpKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0LnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEFuc3dlci5pbmRleE9mKHZhbCkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBhbnN3ZXJcbiAgICAgICAgICAgIC8vIGdpdmVuIGJ5IHRoZSB1c2VyIGlzIGEgc3Vic2V0IG9mIHRoZSBjb3JyZWN0IGFuc3dlcnMuXG4gICAgICAgICAgICBJc1Byb3BlclN1YnNldE9mOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEFuc3dlciA9ICRmaWx0ZXIoJ3JlbW92ZUR1cGxpY2F0ZXNJbkFycmF5JykoYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gJGZpbHRlcigncmVtb3ZlRHVwbGljYXRlc0luQXJyYXknKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbnN3ZXIubGVuZ3RoIDwgbm9ybWFsaXplZElucHV0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQW5zd2VyLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQuaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgSXRlbVNlbGVjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXRlbVNlbGVjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBJdGVtU2VsZWN0aW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydjaG9pY2VzJ10pO1xuICAgICAgICB2YXIgYXJlQW55Q2hvaWNlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmVBbnlDaG9pY2VzRHVwbGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VlbkNob2ljZXMgPSBbXTtcbiAgICAgICAgdmFyIGhhbmRsZWRBbnN3ZXJzID0gW107XG4gICAgICAgIHZhciBudW1DaG9pY2VzID0gY3VzdG9taXphdGlvbkFyZ3MuY2hvaWNlcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hvaWNlczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hvaWNlID0gY3VzdG9taXphdGlvbkFyZ3MuY2hvaWNlcy52YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmIChjaG9pY2UudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFyZUFueUNob2ljZXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VlbkNob2ljZXMuaW5kZXhPZihjaG9pY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFyZUFueUNob2ljZXNEdXBsaWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5DaG9pY2VzLnB1c2goY2hvaWNlKTtcbiAgICAgICAgICAgIGhhbmRsZWRBbnN3ZXJzLnB1c2goZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVBbnlDaG9pY2VzRW1wdHkpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnN1cmUgdGhlIGNob2ljZXMgYXJlIG5vbmVtcHR5LidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmVBbnlDaG9pY2VzRHVwbGljYXRlZCkge1xuICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVuc3VyZSB0aGUgY2hvaWNlcyBhcmUgdW5pcXVlLidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5BbGxvd2VkQ291bnQgPSBjdXN0b21pemF0aW9uQXJncy5taW5BbGxvd2FibGVTZWxlY3Rpb25Db3VudC52YWx1ZTtcbiAgICAgICAgdmFyIG1heEFsbG93ZWRDb3VudCA9IGN1c3RvbWl6YXRpb25BcmdzLm1heEFsbG93YWJsZVNlbGVjdGlvbkNvdW50LnZhbHVlO1xuICAgICAgICBpZiAobWluQWxsb3dlZENvdW50ID4gbWF4QWxsb3dlZENvdW50KSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBtYXggYWxsb3dlZCBjb3VudCBpcyBub3QgbGVzcyB0aGFuIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21pbiBjb3VudC4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNob2ljZXMgPCBtaW5BbGxvd2VkQ291bnQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogKCdQbGVhc2UgZW5zdXJlIHRoYXQgeW91IGhhdmUgZW5vdWdoIGNob2ljZXMgdG8gcmVhY2ggdGhlIG1pbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvdW50LicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1DaG9pY2VzIDwgbWF4QWxsb3dlZENvdW50KSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUGxlYXNlIGVuc3VyZSB0aGF0IHlvdSBoYXZlIGVub3VnaCBjaG9pY2VzIHRvIHJlYWNoIHRoZSBtYXggJyArXG4gICAgICAgICAgICAgICAgICAgICdjb3VudC4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIEl0ZW1TZWxlY3Rpb25JbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdCh0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpKTtcbiAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdCh0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UuZ2V0QW5zd2VyR3JvdXBXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIHN0YXRlTmFtZSkpO1xuICAgICAgICB2YXIgc2VlbkNob2ljZXMgPSBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlO1xuICAgICAgICB2YXIgaGFuZGxlZEFuc3dlcnMgPSBzZWVuQ2hvaWNlcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtaW5BbGxvd2VkQ291bnQgPSBjdXN0b21pemF0aW9uQXJncy5taW5BbGxvd2FibGVTZWxlY3Rpb25Db3VudC52YWx1ZTtcbiAgICAgICAgdmFyIG1heEFsbG93ZWRDb3VudCA9IGN1c3RvbWl6YXRpb25BcmdzLm1heEFsbG93YWJsZVNlbGVjdGlvbkNvdW50LnZhbHVlO1xuICAgICAgICB2YXIgYXJlQWxsQ2hvaWNlc0NvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1heEFsbG93ZWRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGFuc3dlckNob2ljZVRvSW5kZXggPSB7fTtcbiAgICAgICAgICAgIHNlZW5DaG9pY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlZW5DaG9pY2UsIGNob2ljZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgYW5zd2VyQ2hvaWNlVG9JbmRleFtzZWVuQ2hvaWNlXSA9IGNob2ljZUluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbnN3ZXJHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoYW5zd2VyR3JvdXAsIGFuc3dlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXAucnVsZXM7XG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgcnVsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydWxlSW5wdXRzID0gcnVsZS5pbnB1dHMueDtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaG9pY2VJbmRleCA9IGFuc3dlckNob2ljZVRvSW5kZXhbcnVsZUlucHV0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdFcXVhbHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZEFuc3dlcnNbY2hvaWNlSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnSW4gYW5zd2VyIGdyb3VwICcgKyAoYW5zd2VySW5kZXggKyAxKSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdydWxlICcgKyAocnVsZUluZGV4ICsgMSkgKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxlYXNlIHNlbGVjdCBvbmx5IG9uZSBhbnN3ZXIgY2hvaWNlLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUudHlwZSA9PT0gJ0lzUHJvcGVyU3Vic2V0T2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZEFuc3dlcnNbY2hvaWNlSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUudHlwZSA9PT0gJ0NvbnRhaW5zQXRMZWFzdE9uZU9mJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWRBbnN3ZXJzW2Nob2ljZUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnR5cGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0RvZXNOb3RDb250YWluQXRMZWFzdE9uZU9mJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlZEFuc3dlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGNob2ljZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkQW5zd2Vyc1tpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcmVBbGxDaG9pY2VzQ292ZXJlZCA9IGhhbmRsZWRBbnN3ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChoYW5kbGVkQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZWRBbnN3ZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZUFsbENob2ljZXNDb3ZlcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRPdXRjb21lIHx8IGRlZmF1bHRPdXRjb21lLmlzQ29uZnVzaW5nKHN0YXRlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdQbGVhc2UgYWRkIHNvbWV0aGluZyBmb3IgT3BwaWEgdG8gc2F5IGluIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFwiQWxsIG90aGVyIGFuc3dlcnNcXFwiIHJlc3BvbnNlLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYW5zd2VyR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlckdyb3VwLCBhbnN3ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXAucnVsZXM7XG4gICAgICAgICAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlLCBydWxlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZUlucHV0cyA9IHJ1bGUuaW5wdXRzLng7XG4gICAgICAgICAgICAgICAgcnVsZUlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ0lzUHJvcGVyU3Vic2V0T2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnSW4gYW5zd2VyIGdyb3VwICcgKyAoYW5zd2VySW5kZXggKyAxKSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3J1bGUgJyArIChydWxlSW5kZXggKyAxKSArICcsIHRoZSBcInByb3BlciBzdWJzZXRcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdydWxlIG11c3QgaW5jbHVkZSBhdCBsZWFzdCAyIG9wdGlvbnMuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnR5cGUgPT09ICdFcXVhbHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluQWxsb3dlZENvdW50ID4gcnVsZUlucHV0cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhBbGxvd2VkQ291bnQgPCBydWxlSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ0luIGFuc3dlciBncm91cCAnICsgKGFuc3dlckluZGV4ICsgMSkgKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdydWxlICcgKyAocnVsZUluZGV4ICsgMSkgKyAnLCB0aGUgbnVtYmVyIG9mIGNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9ucyBpbiB0aGUgXCJFcXVhbHNcIiBydWxlIHNob3VsZCBiZSBiZXR3ZWVuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQWxsb3dlZENvdW50ICsgJyBhbmQgJyArIG1heEFsbG93ZWRDb3VudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICh0aGUgbWluaW11bSBhbmQgbWF4aW11bSBhbGxvd2VkIHNlbGVjdGlvbiBjb3VudHMpLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZUlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ0NvbnRhaW5zQXRMZWFzdE9uZU9mJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ0luIGFuc3dlciBncm91cCAnICsgKGFuc3dlckluZGV4ICsgMSkgKyAnLCBydWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocnVsZUluZGV4ICsgMSkgKyAnLCB0aGUgXCJDb250YWluc0F0TGVhc3RPbmVPZlwiIHJ1bGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgb3B0aW9uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBJdGVtU2VsZWN0aW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgSXRlbVNlbGVjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBJdGVtU2VsZWN0aW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkl0ZW1TZWxlY3Rpb25JbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gSXRlbVNlbGVjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdJdGVtU2VsZWN0aW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoSXRlbVNlbGVjdGlvbklucHV0VmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgSXRlbVNlbGVjdGlvbklucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdpdGVtLXNlbGVjdGlvbi1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvVXJsU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9XaW5kb3dEaW1lbnNpb25zU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVJdGVtU2VsZWN0aW9uSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdJdGVtU2VsZWN0aW9uSW5wdXRSdWxlc1NlcnZpY2UnLFxuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIEl0ZW1TZWxlY3Rpb25JbnB1dFJ1bGVzU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaXRlbS1zZWxlY3Rpb24taW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnVXJsU2VydmljZScsICdDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGF0dHJzLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgVXJsU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2hvaWNlcyA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5jaG9pY2VzV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5tYXhBbGxvd2FibGVTZWxlY3Rpb25Db3VudCA9ICgkYXR0cnMubWF4QWxsb3dhYmxlU2VsZWN0aW9uQ291bnRXaXRoVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm1pbkFsbG93YWJsZVNlbGVjdGlvbkNvdW50ID0gKCRhdHRycy5taW5BbGxvd2FibGVTZWxlY3Rpb25Db3VudFdpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2hlcmUgdGhlIGtleSBpcyBhIGNob2ljZVxuICAgICAgICAgICAgICAgICAgICAvLyAoaHRtbCkgYW5kIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaG9pY2Ugd2FzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyIChkZWZhdWx0IGlzIGZhbHNlKS5cbiAgICAgICAgICAgICAgICAgICAgY3RybC51c2VyU2VsZWN0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwuY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VyU2VsZWN0aW9uc1tjdHJsLmNob2ljZXNbaV1dID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5kaXNwbGF5Q2hlY2tib3hlcyA9IChjdHJsLm1heEFsbG93YWJsZVNlbGVjdGlvbkNvdW50ID4gMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaW5kaWNhdGVzIHRoYXQgdGhlIG51bWJlciBvZiBhbnN3ZXJzIGlzIG1vcmUgdGhhblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXhBbGxvd2FibGVTZWxlY3Rpb25Db3VudC5cbiAgICAgICAgICAgICAgICAgICAgY3RybC5wcmV2ZW50QWRkaXRpb25hbFNlbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpbmRpY2F0ZXMgdGhhdCB0aGUgbnVtYmVyIG9mIGFuc3dlcnMgaXMgbGVzcyB0aGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbkFsbG93YWJsZVNlbGVjdGlvbkNvdW50LlxuICAgICAgICAgICAgICAgICAgICBjdHJsLm5vdEVub3VnaFNlbGVjdGlvbnMgPSAoY3RybC5taW5BbGxvd2FibGVTZWxlY3Rpb25Db3VudCA+IDApO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uVG9nZ2xlQ2hlY2tib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm5ld1F1ZXN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGlvbkNvdW50ID0gT2JqZWN0LmtleXMoY3RybC51c2VyU2VsZWN0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC51c2VyU2VsZWN0aW9uc1tvYmpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5wcmV2ZW50QWRkaXRpb25hbFNlbGVjdGlvbnMgPSAoY3RybC5zZWxlY3Rpb25Db3VudCA+PSBjdHJsLm1heEFsbG93YWJsZVNlbGVjdGlvbkNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubm90RW5vdWdoU2VsZWN0aW9ucyA9IChjdHJsLnNlbGVjdGlvbkNvdW50IDwgY3RybC5taW5BbGxvd2FibGVTZWxlY3Rpb25Db3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0TXVsdGlwbGVDaG9pY2VBbnN3ZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlclNlbGVjdGlvbnNbY3RybC5jaG9pY2VzW2luZGV4XV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zdWJtaXRBbnN3ZXIoY3RybC51c2VyU2VsZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlcnMgPSBPYmplY3Qua2V5cyhjdHJsLnVzZXJTZWxlY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLnVzZXJTZWxlY3Rpb25zW29ial07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoYW5zd2VycywgSXRlbVNlbGVjdGlvbklucHV0UnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkaXR5Q2hlY2tGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY3RybC5ub3RFbm91Z2hTZWxlY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uKGN0cmwuc3VibWl0QW5zd2VyLCB2YWxpZGl0eUNoZWNrRm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgSXRlbVNlbGVjdGlvbklucHV0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VJdGVtU2VsZWN0aW9uSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnaXRlbS1zZWxlY3Rpb24taW5wdXQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgSXRlbVNlbGVjdGlvbklucHV0IHNob3J0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZUl0ZW1TZWxlY3Rpb25JbnB1dCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0l0ZW1TZWxlY3Rpb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdpdGVtLXNlbGVjdGlvbi1pbnB1dC1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaXRlbV9zZWxlY3Rpb25faW5wdXQuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2l0ZW1fc2VsZWN0aW9uX2lucHV0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaXRlbV9zZWxlY3Rpb25faW5wdXQuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1aXJlcyBmb3IgTG9naWNQcm9vZiBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2xvZ2ljX3Byb29mLmNzcycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy9sb2dpYy1wcm9vZi1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzLycgK1xuICAgICdsb2dpYy1wcm9vZi12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Mb2dpY1Byb29mL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLWludGVyYWN0aXZlLWxvZ2ljLXByb29mLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtbG9naWMtcHJvb2YuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1sb2dpYy1wcm9vZi5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdMb2dpY1Byb29mUnVsZXNTZXJ2aWNlJywgW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIENvcnJlY3Q6IGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyLmNvcnJlY3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTm90Q29ycmVjdDogZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYW5zd2VyLmNvcnJlY3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTm90Q29ycmVjdEJ5Q2F0ZWdvcnk6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYW5zd2VyLmNvcnJlY3QgJiYgYW5zd2VyLmVycm9yX2NhdGVnb3J5ID09PSBpbnB1dHMuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2ljUHJvb2ZWYWxpZGF0aW9uU2VydmljZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSA9IGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIExvZ2ljUHJvb2ZWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICAvLyBUT0RPKGp1YW5zYWJhKTogSW1wbGVtZW50IGN1c3RvbWl6YXRpb24gYXJncyB2YWxpZGF0aW9ucy5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCByZXF1aXJlIGEgZGVmYXVsdCBydWxlIGZvciB0aGlzIGludGVyYWN0aW9uLCBzaW5jZSB0aGVcbiAgICAgICAgLy8gZmVlZGJhY2sgaXMgbW9zdGx5IHByb3ZpZGVkIGZyb20gd2l0aGluIHRoZSBpbnRlcmFjdGlvbiBpdHNlbGYuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpLmNvbmNhdCh0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UuZ2V0QW5zd2VyR3JvdXBXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIHN0YXRlTmFtZSkpO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIExvZ2ljUHJvb2ZWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlID0gTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnTG9naWNQcm9vZlZhbGlkYXRpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShMb2dpY1Byb29mVmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTG9naWNQcm9vZiBJbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2NvZGVtaXJyb3JSZXF1aXJlcy50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy9sb2dpYy1wcm9vZi1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvVXJsU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9XaW5kb3dEaW1lbnNpb25zU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG52YXIgc2hhcmVkX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9zaGFyZWQudHNcIikpO1xudmFyIHN0dWRlbnRfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL3N0dWRlbnQudHNcIikpO1xudmFyIGRhdGFfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2RhdGEudHNcIikpO1xudmFyIGNvbnZlcnNpb25fdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2NvbnZlcnNpb24udHNcIikpO1xudmFyIGdlbmVyYXRlZERlZmF1bHREYXRhX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9nZW5lcmF0ZWREZWZhdWx0RGF0YS50c1wiKSk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVMb2dpY1Byb29mJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLCAnRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSwgRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGdldExhc3RBbnN3ZXI6ICcmbGFzdEFuc3dlcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2YvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbG9naWMtcHJvb2YtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRhdHRycycsICckdWliTW9kYWwnLCAnTG9naWNQcm9vZlJ1bGVzU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlJywgJ1VybFNlcnZpY2UnLFxuICAgICAgICAgICAgICAgICdDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkYXR0cnMsICR1aWJNb2RhbCwgTG9naWNQcm9vZlJ1bGVzU2VydmljZSwgV2luZG93RGltZW5zaW9uc1NlcnZpY2UsIFVybFNlcnZpY2UsIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsUXVlc3Rpb25EYXRhID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLnF1ZXN0aW9uV2l0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIG1hcmsgYSBxdWVzdGlvbiAoZS5nLiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVybWl0dGVkIGxpbmUgdGVtcGxhdGVzKSB0aGF0IGlzIHN0b3JlZCBpbiBkZWZhdWx0RGF0YS5qcyB3aXRoaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgY3RybC5xdWVzdGlvbkRhdGEgPSBhbmd1bGFyLmNvcHkoZ2VuZXJhdGVkRGVmYXVsdERhdGFfdHNfMS5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID0gKGN0cmwuZ2V0TGFzdEFuc3dlcigpID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbihFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5xdWVzdGlvbkRhdGEuYXNzdW1wdGlvbnMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFF1ZXN0aW9uRGF0YS5hc3N1bXB0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5xdWVzdGlvbkRhdGEucmVzdWx0cyA9IGN0cmwubG9jYWxRdWVzdGlvbkRhdGEucmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVkdWNlIHRoZSBuZXcgb3BlcmF0b3JzLCBhcyBpbiBsb2dpY1Byb29mVGVhY2hlci5idWlsZFF1ZXN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXNlIGFyZSBub3QgY3VycmVudGx5IHN0b3JlZCBzZXBhcmF0ZWx5IGZvciBlYWNoIHF1ZXN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjdHJsLmV4cHJlc3Npb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudG9wVHlwZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnF1ZXN0aW9uRGF0YS5hc3N1bXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5leHByZXNzaW9ucy5wdXNoKGN0cmwucXVlc3Rpb25EYXRhLmFzc3VtcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudG9wVHlwZXMucHVzaCgnYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXhwcmVzc2lvbnMucHVzaChjdHJsLnF1ZXN0aW9uRGF0YS5yZXN1bHRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC50b3BUeXBlcy5wdXNoKCdib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudHlwaW5nID0gc2hhcmVkX3RzXzEuZGVmYXVsdC5hc3NpZ25UeXBlc1RvRXhwcmVzc2lvbkFycmF5KGN0cmwuZXhwcmVzc2lvbnMsIGN0cmwudG9wVHlwZXMsIGRhdGFfdHNfMS5kZWZhdWx0LkJBU0VfU1RVREVOVF9MQU5HVUFHRSwgWyd2YXJpYWJsZScsICdjb25zdGFudCcsICdwcmVmaXhfZnVuY3Rpb24nXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucXVlc3Rpb25EYXRhLmxhbmd1YWdlLm9wZXJhdG9ycyA9IGN0cmwudHlwaW5nWzBdLm9wZXJhdG9ycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwucXVlc3Rpb25EYXRhLmFzc3VtcHRpb25zLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFzc3VtcHRpb25zU3RyaW5nID0gc2hhcmVkX3RzXzEuZGVmYXVsdC5kaXNwbGF5RXhwcmVzc2lvbkFycmF5KGN0cmwucXVlc3Rpb25EYXRhLmFzc3VtcHRpb25zLCBjdHJsLnF1ZXN0aW9uRGF0YS5sYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hc3N1bXB0aW9uc1N0cmluZyA9IHNoYXJlZF90c18xLmRlZmF1bHQuZGlzcGxheUV4cHJlc3Npb25BcnJheShjdHJsLnF1ZXN0aW9uRGF0YS5hc3N1bXB0aW9ucy5zbGljZSgwLCBjdHJsLnF1ZXN0aW9uRGF0YS5hc3N1bXB0aW9ucy5sZW5ndGggLSAxKSwgY3RybC5xdWVzdGlvbkRhdGEubGFuZ3VhZ2Uub3BlcmF0b3JzKSArICcgYW5kICcgKyBzaGFyZWRfdHNfMS5kZWZhdWx0LmRpc3BsYXlFeHByZXNzaW9uKGN0cmwucXVlc3Rpb25EYXRhLmFzc3VtcHRpb25zW2N0cmwucXVlc3Rpb25EYXRhLmFzc3VtcHRpb25zLmxlbmd0aCAtIDFdLCBjdHJsLnF1ZXN0aW9uRGF0YS5sYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwudGFyZ2V0U3RyaW5nID0gc2hhcmVkX3RzXzEuZGVmYXVsdC5kaXNwbGF5RXhwcmVzc2lvbihjdHJsLnF1ZXN0aW9uRGF0YS5yZXN1bHRzWzBdLCBjdHJsLnF1ZXN0aW9uRGF0YS5sYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnF1ZXN0aW9uU3RyaW5nID0gKGN0cmwuYXNzdW1wdGlvbnNTdHJpbmcgPT09ICcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdJMThOX0lOVEVSQUNUSU9OU19MT0dJQ19QUk9PRl9RVUVTVElPTl9TVFJfTk9fQVNTVU1QVElPTicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0kxOE5fSU5URVJBQ1RJT05TX0xPR0lDX1BST09GX1FVRVNUSU9OX1NUUl9BU1NVTVBUSU9OUycpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnF1ZXN0aW9uU3RyaW5nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY3RybC50YXJnZXRTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3N1bXB0aW9uczogY3RybC5hc3N1bXB0aW9uc1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnF1ZXN0aW9uSW5zdGFuY2UgPSBzdHVkZW50X3RzXzEuZGVmYXVsdC5idWlsZEluc3RhbmNlKGN0cmwucXVlc3Rpb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVub3RlcyB3aGV0aGVyIG1lc3NhZ2VzIGFyZSBpbiByZXNwb25zZSB0byBhIHN1Ym1pc3Npb24sIGluIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgdGhleSBwZXJzaXN0IGZvciBsb25nZXIuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwubWVzc2FnZUlzU3RpY2t5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IGZvciBpbmZvcm1hdGlvbiBvbiBpbnRlZ3JhdGluZyBhbmd1bGFyIGFuZCBjb2RlLW1pcnJvciBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1jb2RlbWlycm9yXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY29kZUVkaXRvciA9IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9vZlN0cmluZyA9IChjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxRdWVzdGlvbkRhdGEuZGVmYXVsdF9wcm9vZl9zdHJpbmcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0TGFzdEFuc3dlcigpLnByb29mX3N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUocHJvb2ZTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5wcm9vZlN0cmluZyA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gZWRpdG9yLmRvYy5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oJ2xpbmVOdW1iZXJzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9uKCdsaW5lV3JhcHBpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIHRoZSB0ZXh0YXJlYSBiZWluZyBncmV5ZWQtb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzgzNDk1NzEgZm9yIGRpc2N1c3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIG11c3QgdXNlIGJlZm9yZUNoYW5nZSByYXRoZXIgdGhhbiBjaGFuZ2UgaGVyZSB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW5maW5pdGUgbG9vcCAod2hpY2ggY29kZS1taXJyb3Igd2lsbCBub3QgY2F0Y2gpLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdiZWZvcmVDaGFuZ2UnLCBmdW5jdGlvbiAoaW5zdGFuY2UsIGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRUZXh0ID0gY29udmVyc2lvbl90c18xLmRlZmF1bHQuY29udmVydFRvTG9naWNDaGFyYWN0ZXJzKGNoYW5nZS50ZXh0LmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVkVGV4dCAhPT0gY2hhbmdlLnRleHQuam9pbignXFxuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXBkYXRlIHVzaW5nIHRoZSBjb252ZXJ0ZWQgdGV4dCwgdGhlbiBjYW5jZWwgaXRzIGJlaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0dGVuIGJ5IHRoZSBvcmlnaW5hbCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9jLnJlcGxhY2VSYW5nZShjb252ZXJ0ZWRUZXh0LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdjdXJzb3JBY3Rpdml0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmRvYy5nZXRDdXJzb3IoKS5saW5lICE9PSBjdXJzb3JQb3NpdGlvbi5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2hlY2tGb3JCYXNpY0Vycm9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5kb2MuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSB1c2UgY2hhbmdlIHJhdGhlciB0aGFuIGJlZm9yZUNoYW5nZSBoZXJlIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZvciBtaXN0YWtlcyBpcyBkb25lIHdpdGggcmVzcGVjdCB0byB0aGUgdXBkYXRlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoaW5zdGFuY2UsIGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucHJvb2ZTdHJpbmcgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB1cGRhdGUgdGhlIG1lc3NhZ2Ugb25seSBpZiB0aGUgdXNlciBoYXMgYWRkZWQgb3IgcmVtb3ZlZCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBicmVhaywgc28gdGhhdCBpdCByZW1haW5zIHdoaWxlIHRoZXkgd29yayBvbiBhIHNpbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA+IDEgfHwgY2hhbmdlLnJlbW92ZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNoZWNrRm9yQmFzaWNFcnJvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBlcmZvcm1zIHNpbXBsZSBlcnJvciBjaGVja3MgdGhhdCBhcmUgZG9uZSBhcyB0aGUgc3R1ZGVudFxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlcyByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciB0aGUgcHJvb2YgdG8gYmUgc3VibWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBjdHJsLmNoZWNrRm9yQmFzaWNFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwubWVzc2FnZUlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jbGVhck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZGVudF90c18xLmRlZmF1bHQudmFsaWRhdGVQcm9vZihjdHJsLnByb29mU3RyaW5nLCBjdHJsLnF1ZXN0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2xlYXJNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zaG93TWVzc2FnZShlcnIubWVzc2FnZSwgZXJyLmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubWVzc2FnZUlzU3RpY2t5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGxpbmUgaXMgbmVjZXNzYXJ5IHRvIGZvcmNlIGFuZ3VsYXIgdG8gcmVmcmVzaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXllZCBlcnJvck1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2xlYXJNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuZXJyb3JNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1hcmsuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2hvd01lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGluZU51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1lc3NhZ2UgPSBjdHJsLmNvbnN0cnVjdERpc3BsYXllZE1lc3NhZ2UobWVzc2FnZSwgbGluZU51bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVycm9yTWFyayA9IGN0cmwuZWRpdG9yLmRvYy5tYXJrVGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2g6IDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xvZ2ljLXByb29mLWVycm9uZW91cy1saW5lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY29uc3RydWN0RGlzcGxheWVkTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBsaW5lTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xpbmUgJyArIChsaW5lTnVtICsgMSkgKyAnOiAnICsgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5kaXNwbGF5UHJvb2YgPSBmdW5jdGlvbiAocHJvb2ZTdHJpbmcsIGVycm9yTGluZU51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb29mTGluZXMgPSBwcm9vZlN0cmluZy5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9vZkxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyZWRMaW5lcy5wdXNoKChpICsgMSkgKyAnICAnICsgcHJvb2ZMaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzcGxpdCBpbmNvcnJlY3QgcHJvb2ZzIGludG8gdGhyZWUgcGFydHMgc28gdGhhdCByZXNwb25zZS5odG1sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gbWFrZSB0aGUgaW52YWxpZCBsaW5lIGJvbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVycm9yTGluZU51bSA9PT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW251bWJlcmVkTGluZXMuam9pbignXFxuJyldIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcmVkTGluZXMuc2xpY2UoMCwgZXJyb3JMaW5lTnVtKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyZWRMaW5lc1tlcnJvckxpbmVOdW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJlZExpbmVzLnNsaWNlKGVycm9yTGluZU51bSArIDEsIG51bWJlcmVkTGluZXMubGVuZ3RoKS5qb2luKCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHByb29mX251bV9saW5lcywgZGlzcGxheWVkX3F1ZXN0aW9uIGFuZCBkaXNwbGF5ZWRfcHJvb2YgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY29tcHV0ZWQgaGVyZSBiZWNhdXNlIHJlc3BvbnNlLmh0bWwgbmVlZHMgdGhlbSBhbmQgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBpdHMgb3duIGphdmFzY3JpcHQuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0UHJvb2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNsZWFyTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1pc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzdW1wdGlvbnNfc3RyaW5nOiBjdHJsLmFzc3VtcHRpb25zU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdHJpbmc6IGN0cmwudGFyZ2V0U3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mX3N0cmluZzogY3RybC5wcm9vZlN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZl9udW1fbGluZXM6IGN0cmwucHJvb2ZTdHJpbmcuc3BsaXQoJ1xcbicpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ZWRfcXVlc3Rpb246IGN0cmwucXVlc3Rpb25TdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9jYXRlZ29yeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9jb2RlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbGluZV9udW1iZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheWVkX21lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheWVkX3Byb29mOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvb2YgPSBzdHVkZW50X3RzXzEuZGVmYXVsdC5idWlsZFByb29mKGN0cmwucHJvb2ZTdHJpbmcsIGN0cmwucXVlc3Rpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZGVudF90c18xLmRlZmF1bHQuY2hlY2tQcm9vZihwcm9vZiwgY3RybC5xdWVzdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLmNvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24uY29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24uZXJyb3JfY2F0ZWdvcnkgPSBlcnIuY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5lcnJvcl9jb2RlID0gZXJyLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5lcnJvcl9tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5lcnJvcl9saW5lX251bWJlciA9IGVyci5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24uZGlzcGxheWVkX21lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNvbnN0cnVjdERpc3BsYXllZE1lc3NhZ2UoZXJyLm1lc3NhZ2UsIGVyci5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLmRpc3BsYXllZF9wcm9vZiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZGlzcGxheVByb29mKGN0cmwucHJvb2ZTdHJpbmcsIGVyci5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNob3dNZXNzYWdlKGVyci5tZXNzYWdlLCBlcnIubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tZXNzYWdlSXNTdGlja3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Ym1pc3Npb24uY29ycmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb24uZGlzcGxheWVkX21lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLmRpc3BsYXllZF9wcm9vZiA9IGN0cmwuZGlzcGxheVByb29mKGN0cmwucHJvb2ZTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5vblN1Ym1pdChzdWJtaXNzaW9uLCBMb2dpY1Byb29mUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5yZWdpc3RlckN1cnJlbnRJbnRlcmFjdGlvbihjdHJsLnN1Ym1pdFByb29mLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zaG93SGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR1aWJNb2RhbC5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbG9naWMtcHJvb2YtaGVscC1tb2RhbC5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRzY29wZScsICckdWliTW9kYWxJbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICR1aWJNb2RhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpYk1vZGFsSW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZXN1bHQudGhlbihmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTG9naWNQcm9vZiByZXNwb25zZS5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VMb2dpY1Byb29mJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdsb2dpYy1wcm9vZi1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBMb2dpY1Byb29mIHNob3J0IHJlc3BvbnNlLlxuICovXG5yZXF1aXJlKCdmaWx0ZXJzL3N0cmluZy11dGlsaXR5LWZpbHRlcnMvdHJ1bmNhdGUtYXQtZmlyc3QtbGluZS5maWx0ZXIudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VMb2dpY1Byb29mJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdsb2dpYy1wcm9vZi1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBGdW5jdGlvbnMgdG8gY29udmVydCBzeW1ib2xzIGF2YWlsYWJsZSBvbiB0aGUga2V5Ym9hcmQgdG9cbiAqICAgZGVzaXJlZCBsb2dpYyBzeW1ib2xzIGFzIGEgdXNlciB0eXBlcy5cbiAqL1xudmFyIGxvZ2ljUHJvb2ZDb252ZXJzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOT1RFOiB0aGUgJ29sZCcgdmFsdWVzIG11c3QgYWxsIGJlIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgdmFyIFJFUExBQ0VNRU5UX1BBSVJTID0gW3tcbiAgICAgICAgICAgIG9sZDogJyYnLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUgcXVvdGUtcHJvcHNcbiAgICAgICAgICAgICduZXcnOiAnXFx1MjIyNydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2xkOiAnfCcsXG4gICAgICAgICAgICAnbmV3JzogJ1xcdTIyMjgnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9sZDogJ0AnLFxuICAgICAgICAgICAgJ25ldyc6ICdcXHUyMjAwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbGQ6ICckJyxcbiAgICAgICAgICAgICduZXcnOiAnXFx1MjIwMydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2xkOiAnXicsXG4gICAgICAgICAgICAnbmV3JzogJ1xcdTIyMjcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9sZDogJ1xcdTAwMDknLFxuICAgICAgICAgICAgJ25ldyc6ICcgICdcbiAgICAgICAgICAgIC8vIGVzbGludC1lbmFibGUgcXVvdGUtcHJvcHNcbiAgICAgICAgfV07XG4gICAgdmFyIGNvbnZlcnRUb0xvZ2ljQ2hhcmFjdGVycyA9IGZ1bmN0aW9uIChvbGRTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkU3RyaW5nID0gb2xkU3RyaW5nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJFUExBQ0VNRU5UX1BBSVJTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgLnJlcGxhY2UoKSBhcyBpdCBvbmx5IGFmZmVjdHMgdGhlIGZpcnN0IGluc3RhbmNlXG4gICAgICAgICAgICByZXBsYWNlZFN0cmluZyA9IHJlcGxhY2VkU3RyaW5nLnNwbGl0KFJFUExBQ0VNRU5UX1BBSVJTW2ldLm9sZCkuam9pbihSRVBMQUNFTUVOVF9QQUlSU1tpXVsnbmV3J10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlZFN0cmluZztcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljQ2hhcmFjdGVyczogY29udmVydFRvTG9naWNDaGFyYWN0ZXJzXG4gICAgfTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBsb2dpY1Byb29mQ29udmVyc2lvbjtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udGFpbnMgbG9naWMgcHJvb2YgZGF0YS5cbiAqL1xudmFyIGxvZ2ljUHJvb2ZEYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQkFTRV9WT0NBQlVMQVJZID0ge1xuICAgICAgICBmcm9tOiBbJ2Zyb20nXSxcbiAgICAgICAgYW5kOiBbJ2FuZCddLFxuICAgICAgICBoYXZlOiBbJ3dlIGhhdmUnLCAnd2Uga25vdycsICdoYXZlJ10sXG4gICAgICAgIGhlbmNlOiBbJ2hlbmNlJywgJ3NvJywgJ3RodXMnLCAndGhlbmNlJywgJ3doZW5jZSddLFxuICAgICAgICB3aGljaGV2ZXI6IFtcbiAgICAgICAgICAgICdhbmQgd2hpY2hldmVyIGlzIHRydWUnLCAnYW5kIGVpdGhlciB3YXknLCAnYW5kIGluIGVpdGhlciBjYXNlJ1xuICAgICAgICBdLFxuICAgICAgICBhcmJpdHJhcnk6IFsnd2FzIGFyYml0cmFyeScsICdpcyBhcmJpdHJhcnknXSxcbiAgICAgICAgdGFrZTogWyd0YWtlJ10sXG4gICAgICAgIHNhdGlzZnlpbmc6IFsnc2F0aXNmeWluZycsICdzdWNoIHRoYXQnXSxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUgcXVvdGUtcHJvcHNcbiAgICAgICAgJ2lmJzogWydpZiddLFxuICAgICAgICBnaXZlbjogWydnaXZlbiddLFxuICAgICAgICBjb250cmFkaWN0aW9uOiBbJ2NvbnRyYWRpY3Rpb24nXSxcbiAgICAgICAgYXQ6IFsnYXQnXVxuICAgIH07XG4gICAgdmFyIFNJTkdMRV9CT09MRUFOID0ge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGFyYml0cmFyaWx5X21hbnk6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgU0lOR0xFX0VMRU1FTlQgPSB7XG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgYXJiaXRyYXJpbHlfbWFueTogZmFsc2VcbiAgICB9O1xuICAgIC8vIE5PVEU6IEJ5IGRlZmF1bHQsICdhbmQnICYgJ29yJyBtdXN0IGJlIGJpbmFyeS5cbiAgICAvLyBOT1RFOiBXZSBhcmUgbm90IHlldCB1c2luZyB0aGUgZGlzcGxheSBrZXlzIGZyb20gdGhlIGtpbmRzICh3ZSBhcmUgdXNpbmdcbiAgICAvLyBzeW1ib2wga2V5cyBmcm9tIHRoZSBsaXN0IG9mIG9wZXJhdG9ycykuXG4gICAgdmFyIEJBU0VfU1RVREVOVF9MQU5HVUFHRSA9IHtcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgICdib29sZWFuJzoge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1lbmFibGUgcXVvdGUtcHJvcHNcbiAgICAgICAgICAgICAgICBxdWFudGlmaWFibGU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIHF1YW50aWZpYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBraW5kczoge1xuICAgICAgICAgICAgYmluYXJ5X2Nvbm5lY3RpdmU6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnYXJndW1lbnRfaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogMFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICduYW1lJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdhcmd1bWVudF9pbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAxXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5hcnlfY29ubmVjdGl2ZToge1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FyZ3VtZW50X2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWFudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgbWF0Y2hhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZHVtbXlfaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogMFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FyZ3VtZW50X2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmVudDogMFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpbmFyeV9mdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FyZ3VtZW50X2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnYXJndW1lbnRfaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogMVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfRUxFTUVOVCwgU0lOR0xFX0VMRU1FTlRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdlbGVtZW50J1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWZpeF9mdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyaWx5X21hbnk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnZWxlbWVudCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyaWx5X21hbnk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25zdGFudDoge1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2VsZW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFyaWFibGU6IHtcbiAgICAgICAgICAgICAgICBtYXRjaGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2VsZW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdG9yczoge1xuICAgICAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9jb25uZWN0aXZlJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJ1xcdTIyMjcnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9jb25uZWN0aXZlJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJ1xcdTIyMjgnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltcGxpZXM6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X2Nvbm5lY3RpdmUnLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9CT09MRUFOLCBTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnPT4nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlmZjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0JPT0xFQU4sIFNJTkdMRV9CT09MRUFOXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc8PT4nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdDoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICd1bmFyeV9jb25uZWN0aXZlJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnfiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yX2FsbDoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdxdWFudGlmaWVyJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbU0lOR0xFX0VMRU1FTlRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWydcXHUyMjAwJywgJy4nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4aXN0czoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdxdWFudGlmaWVyJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbU0lOR0xFX0VMRU1FTlRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWydcXHUyMjAzJywgJy4nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVxdWFsczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnPSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm90X2VxdWFsczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnIT0nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlc3NfdGhhbjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnPCddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JlYXRlcl90aGFuOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9yZWxhdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0VMRU1FTlQsIFNJTkdMRV9FTEVNRU5UXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc+J11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZXNzX3RoYW5fb3JfZXF1YWxzOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9yZWxhdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0VMRU1FTlQsIFNJTkdMRV9FTEVNRU5UXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc8PSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JlYXRlcl90aGFuX29yX2VxdWFsczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnPj0nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZGl0aW9uOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0VMRU1FTlQsIFNJTkdMRV9FTEVNRU5UXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnZWxlbWVudCdcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWycrJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJ0cmFjdGlvbjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2VsZW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnLSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGljYXRpb246IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfRUxFTUVOVCwgU0lOR0xFX0VMRU1FTlRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdlbGVtZW50J1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJyonXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpdmlzaW9uOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0VMRU1FTlQsIFNJTkdMRV9FTEVNRU5UXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnZWxlbWVudCdcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWycvJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBvbmVudGlhdGlvbjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9FTEVNRU5ULCBTSU5HTEVfRUxFTUVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2VsZW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnXiddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBTSU5HTEVfSU5URUdFUiA9IHtcbiAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICBhcmJpdHJhcmlseV9tYW55OiBmYWxzZVxuICAgIH07XG4gICAgdmFyIFNJTkdMRV9TVFJJTkcgPSB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBhcmJpdHJhcmlseV9tYW55OiBmYWxzZVxuICAgIH07XG4gICAgdmFyIFNJTkdMRV9GT1JNVUxBID0ge1xuICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgIGFyYml0cmFyaWx5X21hbnk6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgU0lOR0xFX1NFVF9PRl9GT1JNVUxBUyA9IHtcbiAgICAgICAgdHlwZTogJ3NldF9vZl9mb3JtdWxhcycsXG4gICAgICAgIGFyYml0cmFyaWx5X21hbnk6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgQkFTRV9DT05UUk9MX0xBTkdVQUdFID0ge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHF1b3RlLXByb3BzXG4gICAgICAgICAgICAnYm9vbGVhbic6IHtcbiAgICAgICAgICAgICAgICBxdWFudGlmaWFibGU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVXNlZCBmb3IgbGluZSBudW1iZXJzICYgaW5kZW50YXRpb24uXG4gICAgICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICAgICAgcXVhbnRpZmlhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVXNlZCBmb3IgbGluZS50ZW1wbGF0ZS5cbiAgICAgICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgICAgIHF1YW50aWZpYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBVc2VkIGZvciBtYXRjaGluZ3MsIHRhcmdldC5cbiAgICAgICAgICAgIGZvcm11bGE6IHtcbiAgICAgICAgICAgICAgICBxdWFudGlmaWFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBVc2VkIGZvciBhbnRlY2VkZW50cywgcmVzdWx0cyAmIGFzc3VtcHRpb25zLlxuICAgICAgICAgICAgc2V0X29mX2Zvcm11bGFzOiB7XG4gICAgICAgICAgICAgICAgcXVhbnRpZmlhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBraW5kczoge1xuICAgICAgICAgICAgYmluYXJ5X2Nvbm5lY3RpdmU6IHt9LFxuICAgICAgICAgICAgdW5hcnlfY29ubmVjdGl2ZToge30sXG4gICAgICAgICAgICBxdWFudGlmaWVyOiB7fSxcbiAgICAgICAgICAgIGJvdW5kZWRfcXVhbnRpZmllcjoge30sXG4gICAgICAgICAgICBiaW5hcnlfcmVsYXRpb246IHt9LFxuICAgICAgICAgICAgYmluYXJ5X2Z1bmN0aW9uOiB7fSxcbiAgICAgICAgICAgIC8vIE5PVEU6IG5ldyBwcmVmaXhfZnVuY3Rpb25zIHdpbGwgYmUgZXhwbGljaXRlbHkgYWRkZWQgYnkgbWFraW5nXG4gICAgICAgICAgICAvLyBkZWZpbml0aW9ucywgYW5kIGZyb20gdGhlc2UgZGVmaW5pdGlvbnMgdGhlaXIgdHlwZXMgd2lsbCBiZSBrbm93bi5cbiAgICAgICAgICAgIC8vIFRodXMgaXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlaXIga2luZHMgdG8gaGF2ZSB0eXBpbmcgcnVsZXMgKGFuZFxuICAgICAgICAgICAgLy8gc3VjaCB0eXBpbmcgcnVsZXMgd291bGQgaW4gYW55IGNhc2UgaGF2ZSB0byBiZSBpbmNvbnZlbmllbnRseSBsb25nKS5cbiAgICAgICAgICAgIHByZWZpeF9mdW5jdGlvbjoge30sXG4gICAgICAgICAgICByYW5nZWRfZnVuY3Rpb246IHt9LFxuICAgICAgICAgICAgY29uc3RhbnQ6IHtcbiAgICAgICAgICAgICAgICBtYXRjaGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2ludGVnZXInXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YXJpYWJsZToge1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Zvcm11bGEnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ3NldF9vZl9mb3JtdWxhcydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlcmF0b3JzOiB7XG4gICAgICAgICAgICBhbmQ6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X2Nvbm5lY3RpdmUnLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmJpdHJhcmlseV9tYW55OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnXFx1MjIyNyddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3I6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X2Nvbm5lY3RpdmUnLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmJpdHJhcmlseV9tYW55OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnXFx1MjIyOCddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wbGllczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0JPT0xFQU4sIFNJTkdMRV9CT09MRUFOXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc9PiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWZmOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9jb25uZWN0aXZlJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJzw9PiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm90OiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3VuYXJ5X2Nvbm5lY3RpdmUnLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9CT09MRUFOXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyd+J11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcXVhbHM6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfSU5URUdFUiwgU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfU1RSSU5HLCBTSU5HTEVfU1RSSU5HXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0ZPUk1VTEEsIFNJTkdMRV9GT1JNVUxBXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX1NFVF9PRl9GT1JNVUxBUywgU0lOR0xFX1NFVF9PRl9GT1JNVUxBU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnPSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm90X2VxdWFsczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9JTlRFR0VSLCBTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9TVFJJTkcsIFNJTkdMRV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfRk9STVVMQSwgU0lOR0xFX0ZPUk1VTEFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfU0VUX09GX0ZPUk1VTEFTLCBTSU5HTEVfU0VUX09GX0ZPUk1VTEFTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWychPSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVzc190aGFuOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9yZWxhdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVIsIFNJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc8J11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBncmVhdGVyX3RoYW46IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfSU5URUdFUiwgU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJz4nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlc3NfdGhhbl9vcl9lcXVhbHM6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfSU5URUdFUiwgU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJzw9J11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBncmVhdGVyX3RoYW5fb3JfZXF1YWxzOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9yZWxhdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVIsIFNJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyc+PSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNfaW46IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfRk9STVVMQSwgU0lOR0xFX1NFVF9PRl9GT1JNVUxBU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnXFx1MjIwOCddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkaXRpb246IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYmluYXJ5X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfSU5URUdFUiwgU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJysnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YnRyYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JpbmFyeV9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVIsIFNJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnaW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWyctJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9JTlRFR0VSLCBTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2ludGVnZXInXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnKiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm91bmRlZF9mb3JfYWxsOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2JvdW5kZWRfcXVhbnRpZmllcicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBib3VuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9CT09MRUFOLCBTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0JPT0xFQU4sIFNJTkdMRV9CT09MRUFOXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzeW1ib2xzOiBbJ1xcdTIyMDAnLCAnLiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm91bmRlZF9leGlzdHM6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAnYm91bmRlZF9xdWFudGlmaWVyJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW1NJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgYm91bmRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW1NJTkdMRV9GT1JNVUxBXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnXFx1MjIwMycsICcuJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUaGlzIGhhcyBmb3JtIG1pbntuPG18QShuKX0sIEEobikgaXMgdGhlIGFyZ3VtZW50IGFuZCBuIHRoZSBkdW1teSwgb3JcbiAgICAgICAgICAgIC8vIGFsdGVyYXRpdmVseSBtaW57cOKIiGFudGVjZWRlbnRzKG4pfEIocCl9IHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgICAgICAgLy8gZWxlbWVudCBvZiBzZXRfb2ZfZm9ybXVsYXMgYW50ZWNlZGVudHMobikgc2F0aXNmeWluZyBCLlxuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3JhbmdlZF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0JPT0xFQU4sIFNJTkdMRV9CT09MRUFOXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW1NJTkdMRV9GT1JNVUxBXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Zvcm11bGEnXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnbWluJywgJ3snLCAnfCcsICd9J11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncmFuZ2VkX2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0JPT0xFQU5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW1NJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2ludGVnZXInXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9CT09MRUFOLCBTSU5HTEVfQk9PTEVBTl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbU0lOR0xFX0ZPUk1VTEFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnZm9ybXVsYSdcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc3ltYm9sczogWydtYXgnLCAneycsICd8JywgJ30nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGVudGF0aW9uOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW50ZWNlZGVudHM6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncHJlZml4X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ3NldF9vZl9mb3JtdWxhcydcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHRzOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdzZXRfb2ZfZm9ybXVsYXMnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdzZXRfb2ZfZm9ybXVsYXMnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwcmVmaXhfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncHJlZml4X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfU1RSSU5HLCBTSU5HTEVfSU5URUdFUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ2Zvcm11bGEnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtX2xpbmVzOiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnaW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3N1bXB0aW9uczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwcmVmaXhfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ3NldF9vZl9mb3JtdWxhcydcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncHJlZml4X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdmb3JtdWxhJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXN0aW9uX3ZhcmlhYmxlczoge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwcmVmaXhfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ3NldF9vZl9mb3JtdWxhcydcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGUtcHJvcHNcbiAgICAgICAgICAgICdpZic6IHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIHByZWZpeCBmdW5jdGlvbiBpcyB1bnVzdWFsIGluIGhhdmluZyBhIGJvb2xlYW4gaW5wdXRcbiAgICAgICAgICAgICAgICBraW5kOiAncHJlZml4X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX0lOVEVHRVIsIFNJTkdMRV9JTlRFR0VSXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnaW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0JPT0xFQU4sIFNJTkdMRV9TVFJJTkcsIFNJTkdMRV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1NJTkdMRV9CT09MRUFOLCBTSU5HTEVfRk9STVVMQSwgU0lOR0xFX0ZPUk1VTEFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdmb3JtdWxhJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU5HTEVfQk9PTEVBTiwgU0lOR0xFX1NFVF9PRl9GT1JNVUxBUywgU0lOR0xFX1NFVF9PRl9GT1JNVUxBU1xuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnc2V0X29mX2Zvcm11bGFzJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgICAga2luZDogJ3ByZWZpeF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwaW5nOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbU0lOR0xFX0lOVEVHRVIsIFNJTkdMRV9TRVRfT0ZfRk9STVVMQVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICdmb3JtdWxhJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YnN0aXR1dGU6IHtcbiAgICAgICAgICAgICAgICBraW5kOiAncHJlZml4X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBpbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtTSU5HTEVfRk9STVVMQSwgU0lOR0xFX0ZPUk1VTEEsIFNJTkdMRV9GT1JNVUxBXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnZm9ybXVsYSdcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIEJBU0VfR0VORVJBTF9NRVNTQUdFUyA9IHtcbiAgICAgICAgb2RkX251bWJlcl9zcGFjZXM6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCdBbiBpbmRlbnRhdGlvbiBpcyBpbmRpY2F0ZWQgYnkgYSBkb3VibGUgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGUgbGluZSwgYnV0IHRoaXMgbGluZSBzdGFydHMgd2l0aCBhbiBvZGQgbnVtYmVyIG9mIHNwYWNlcy4nKVxuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAncGFyc2luZydcbiAgICAgICAgfSxcbiAgICAgICAgdW5tYXRjaGVkX2xpbmU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCdUaGlzIGxpbmUgY291bGQgbm90IGJlIGlkZW50aWZpZWQgYXMgdmFsaWQgLSBwbGVhc2UgY2hlY2sgdGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0IG9mIHBvc3NpYmxlIGxpbmVzLicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdwYXJzaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB3cm9uZ19raW5kX2luX2xpbmU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ0luIGEgbGluZSBvZiB0aGlzIGZvcm0sIHlvdXIgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyBzaG91bGQgYmUgYSAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2V4cGVjdGVkX2tpbmQnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZXhwcmVzc2lvbidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkX2tpbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3R5cGluZydcbiAgICAgICAgfSxcbiAgICAgICAgdW5zcGVjaWZpZWRfbWlzdGFrZToge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhpcyBsaW5lIGNvbnRhaW5zIGEgbWlzdGFrZSBpbiBpdHMgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdzZWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAod2l0aCBjb2RlICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnZW50cnknXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnKS4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdtaXN0YWtlJ1xuICAgICAgICB9LFxuICAgICAgICBpbGxlZ2FsX3N5bWJvbDoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhlIHN5bWJvbCAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgd2FzIG5vdCByZWNvZ25pc2VkLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHN5bWJvbDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAncGFyc2luZydcbiAgICAgICAgfSxcbiAgICAgICAgYmxhbmtfbGluZToge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhpcyBsaW5lIGlzIGJsYW5rLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3BhcnNpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHVuaWRlbnRpZmllZF93b3JkOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdXZSBjb3VsZCBub3QgaWRlbnRpZnkgXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCdcXCc7IHBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSB1c2luZyB2b2NhYnVsYXJ5IGZyb20gdGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnaXZlbiBsaXN0LCBhbmQgZG9uXFwndCBoYXZlIHR3byBjb25zZWN1dGl2ZSBleHByZXNzaW9ucy4nKVxuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgd29yZDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAncGFyc2luZydcbiAgICAgICAgfSxcbiAgICAgICAgdW5pZGVudGlmaWVkX3dvcmRzOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdXZSBjb3VsZCBub3QgaWRlbnRpZnkgZWl0aGVyIG9mIFxcJydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZDEnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnXFwnIG9yIFxcJydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZDInXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoJ1xcJyBhcyB3b3JkczsgcGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHZvY2FidWxhcnkgZnJvbSB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dpdmVuIGxpc3QsIGFuZCBkb25cXCd0IGhhdmUgdHdvIGNvbnNlY3V0aXZlIGV4cHJlc3Npb25zLicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB3b3JkMToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3b3JkMjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAncGFyc2luZydcbiAgICAgICAgfSxcbiAgICAgICAgY29uc2VjdXRpdmVfZXhwcmVzc2lvbnM6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoaXMgbGluZSBoYXMgdHdvIGV4cHJlc3Npb25zIGluIGEgcm93ICgnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ3dvcmQxJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyBhbmQgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkMidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcpIHdoaWNoIGlzIG5vdCBhbGxvd2VkLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHdvcmQxOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdvcmQyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdwYXJzaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB1bmlkZW50aWZpZWRfcGhyYXNlX3N0YXJ0aW5nX2F0OiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgcGhyYXNlIHN0YXJ0aW5nIFxcJydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnXFwnIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkOyBwbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgb25seSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXNpbmcgcGhyYXNlcyBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIHZvY2FidWxhcnkuJylcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHdvcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeTogJ2Zvcm1hdHR0aW5nJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JiaWRkZW5fd29yZDoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhlIG5hbWUgXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1xcJyBpcyByZXNlcnZlZCBmb3Igdm9jYWJ1bGFyeSBhbmQgc28gY2Fubm90IGJlIHVzZWQgaGVyZS4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB3b3JkOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdwYXJzaW5nJ1xuICAgICAgICB9LFxuICAgICAgICBub3RfZW5vdWdoX2lucHV0czoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ29wZXJhdG9yJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyBtdXN0IGhhdmUgYXQgbGVhc3QgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdudW1fbmVlZGVkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2lucHV0X2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBudW1fbmVlZGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0X2NhdGVnb3J5OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICd0eXBpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHdyb25nX251bV9pbnB1dHM6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdvcGVyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgbXVzdCBoYXZlICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnbnVtX25lZWRlZCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbnB1dF9jYXRlZ29yeSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgbnVtX25lZWRlZDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dF9jYXRlZ29yeToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAndHlwaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB3cm9uZ19raW5kOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnb3BlcmF0b3InXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnIGlzIHN1cHBvc2VkIHRvIGJlIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHBlY3RlZF9raW5kJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZF9raW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHVhbF9raW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICd0eXBpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHdyb25nX3R5cGU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdvcGVyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgeWllbGRzIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdhY3R1YWxfdHlwZSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgYnV0IHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBpdCB0byBnaXZlIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHBlY3RlZF90eXBlJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZF90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHVhbF90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICd0eXBpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIGR1cGxpY2F0ZV9kdW1teV9uYW1lOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgbmFtZSBcXCcnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2R1bW15J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1xcJyBpcyBhbHJlYWR5IGluIHVzZSBhbmQgc28gY2Fubm90IGJlIHF1YW50aWZpZWQgb3ZlciBpbiAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGR1bW15OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAndHlwaW5nJ1xuICAgICAgICB9LFxuICAgICAgICBkdW1teV9ub3RfdmFyaWFibGU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1lvdSBjYW4gb25seSBxdWFudGlmeSBvdmVyIHZhcmlhYmxlcywgbm90ICAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2R1bW15J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBkdW1teToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3R5cGluZydcbiAgICAgICAgfSxcbiAgICAgICAgdW5rbm93bl9vcGVyYXRvcjoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhlIG9wZXJhdG9yICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnb3BlcmF0b3InXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICd0eXBpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHRvb19tYW55X3BhcnNpbmdzOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnVGhpcyBjYW4gYmUgcGFyc2VkIGluIHRvbyBtYW55IGRpZmZlcmVudCB3YXlzIC0gdHJ5IHVzaW5nIGZld2VyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3b3JkcywgZXNwZWNpYWxseSBzaW5nbGUtY2hhcmFjdGVyIHdvcmRzLicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdwYXJzaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB0b29fbWFueV90eXBpbmdzOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnVGhpcyBoYXMgdG9vIG1hbnkgcG9zc2libGUgdHlwaW5ncyAtIHRyeSB1c2luZyBmZXdlciB2YXJpYWJsZXMuJylcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge31cbiAgICAgICAgfSxcbiAgICAgICAgY2F0ZWdvcnk6ICd0eXBpbmcnXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBCQVNFX1ZPQ0FCVUxBUlk6IEJBU0VfVk9DQUJVTEFSWSxcbiAgICAgICAgQkFTRV9TVFVERU5UX0xBTkdVQUdFOiBCQVNFX1NUVURFTlRfTEFOR1VBR0UsXG4gICAgICAgIEJBU0VfQ09OVFJPTF9MQU5HVUFHRTogQkFTRV9DT05UUk9MX0xBTkdVQUdFLFxuICAgICAgICBCQVNFX0dFTkVSQUxfTUVTU0FHRVM6IEJBU0VfR0VORVJBTF9NRVNTQUdFU1xuICAgIH07XG59KSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9naWNQcm9vZkRhdGE7XG4iLCJ2YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV90c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9zdGF0aWMvanMvZGF0YS50c1wiKSk7XG4vLyBQYXN0ZSBnZW5lcmF0ZWQgY29kZSBoZXJlLlxudmFyIExPR0lDX1BST09GX0RFRkFVTFRfUVVFU1RJT05fREFUQSA9IHsgYXNzdW1wdGlvbnM6IFtdLCByZXN1bHRzOiBbXSwgbGFuZ3VhZ2U6IGRhdGFfdHNfMS5kZWZhdWx0LkJBU0VfU1RVREVOVF9MQU5HVUFHRSwgZ2VuZXJhbF9tZXNzYWdlczogZGF0YV90c18xLmRlZmF1bHQuQkFTRV9HRU5FUkFMX01FU1NBR0VTLCBcImxpbmVfdGVtcGxhdGVzXCI6IFt7IFwibmFtZVwiOiBcImFuZF9lbGltaW5hdGVfbGVmdFwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJhbmRfZWxpbWluYXRlX3JpZ2h0XCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImFuZF9pbnRyb2R1Y2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImFuZF9pbnRyb2R1Y2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImlmZl9lbGltaW5hdGVfcmlnaHRcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZmXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImlmZl9lbGltaW5hdGVfcmlnaHRcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJhbmRcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZmXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImlmZl9lbGltaW5hdGVfbGVmdFwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJhbmRcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZmXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpZmZcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiaWZmX2VsaW1pbmF0ZV9sZWZ0XCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpZmZcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJpZmZfZWxpbWluYXRlX2Npc1wiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZmXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW1wbGllc1wiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJpZmZfZWxpbWluYXRlX3RyYW5zXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpZmZcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbXBsaWVzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZmXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW1wbGllc1wiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImlmZl9pbnRyb2R1Y2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpZmZcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbXBsaWVzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW1wbGllc1wiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImlmZl9pbnRyb2R1Y2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpZmZcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbXBsaWVzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW1wbGllc1wiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlmZlwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImFzc3VtcHRpb25cIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJpZlwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbXSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiaW1wbGllc19lbGltaW5hdGVcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiaW1wbGllc19lbGltaW5hdGVcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImltcGxpZXNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiaW1wbGllc19pbnRyb2R1Y2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoZW5jZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbXBsaWVzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbXSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbXBsaWVzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwibm90X2VsaW1pbmF0ZVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJhbmRcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJjb250cmFkaWN0aW9uXCIgfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbXSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJub3RfZWxpbWluYXRlXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImFuZFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImNvbnRyYWRpY3Rpb25cIiB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFtdLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImNvbnRyYWRpY3Rpb25fZWxpbWluYXRlXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiY29udHJhZGljdGlvblwiIH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbXSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwibm90X2ludHJvZHVjZVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhlbmNlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFtdLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJleGNsdWRlZF9taWRkbGVfMVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFtdLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiZXhjbHVkZWRfbWlkZGxlXzJcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbXSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImV4Y2x1ZGVkX21pZGRsZV8zXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwib3JfZWxpbWluYXRlXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJ3aGljaGV2ZXJcIiB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiVFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiVFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcIm9yX2ludHJvZHVjZV9sZWZ0XCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW10sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJvcl9pbnRyb2R1Y2VfcmlnaHRcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImV4aXN0c19lbGltaW5hdGVcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicXVhbnRpZmllclwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXhpc3RzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoZW5jZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwidGFrZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJlbGVtZW50XCIsIFwia2luZFwiOiBcInZhcmlhYmxlXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcInNhdGlzZnlpbmdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbeyBcInhcIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0gfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInF1YW50aWZpZXJcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImV4aXN0c1wiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFt7IFwieFwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiZXhpc3RzX2ludHJvZHVjZVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbeyBcInhcIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0gfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYXRcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZWxlbWVudFwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicXVhbnRpZmllclwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXhpc3RzXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInBcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW3sgXCJ4XCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9IH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJxdWFudGlmaWVyXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJleGlzdHNcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInBcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZXJyb3JcIjogW10gfSwgeyBcIm5hbWVcIjogXCJmb3JfYWxsX2VsaW1pbmF0ZVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJxdWFudGlmaWVyXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJmb3JfYWxsXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJhdFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJlbGVtZW50XCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbeyBcInhcIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0gfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInF1YW50aWZpZXJcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImZvcl9hbGxcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInBcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbeyBcInhcIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0gfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImZvcl9hbGxfaW50cm9kdWNlXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJlbGVtZW50XCIsIFwia2luZFwiOiBcInZhcmlhYmxlXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImFyYml0cmFyeVwiIH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGVuY2VcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJxdWFudGlmaWVyXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJmb3JfYWxsXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW10sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJxdWFudGlmaWVyXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJmb3JfYWxsXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiZ2l2ZW5cIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJnaXZlblwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJlbGVtZW50XCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbXSwgXCJyZXN1bHRzXCI6IFtdLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwidGFrZVwiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcInRha2VcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZWxlbWVudFwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW10sIFwicmVzdWx0c1wiOiBbXSwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcInJlbWluZGVyXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwicmVtaW5kZXJcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbXSB9LCB7IFwibmFtZVwiOiBcImFuZF9pbnRyb2R1Y2VfZTFcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJTaG91bGQgdGhpcyBiZSAnRnJvbSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgYW5kIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB3ZSBoYXZlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJz9cIiB9XSwgW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVG8gcHJvdmUgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgeW91IG5lZWQgdG8gaGF2ZSBzaG93biBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgYXMgd2VsbC5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJhbmRfaW50cm9kdWNlX2UyXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiZnJvbVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImhhdmVcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9XSwgXCJhbnRlY2VkZW50c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiU2hvdWxkIHRoaXMgYmUgJ0Zyb20gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGFuZCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgd2UgaGF2ZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIic/XCIgfV0sIFt7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBtZWFucyB0aGF0IFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBhbmQgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGFyZSBib3RoIHRydWUsIHNvIHlvdSBhbHNvIG5lZWQgdG8gaGF2ZSBzaG93biBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiYW5kX2ludHJvZHVjZV9lM1wiLCBcInJlYWRlcl92aWV3XCI6IFt7IFwiZm9ybWF0XCI6IFwicGhyYXNlXCIsIFwiY29udGVudFwiOiBcImZyb21cIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJhbmRcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiVFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJUXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJZb3UgaGF2ZSBzaG93biBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiVFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiwgbm90IFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImFuZF9pbnRyb2R1Y2VfZTRcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiYW5kXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGF2ZVwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJUXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInJlc3VsdHNcIjogW3sgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IGhhdmUgc2hvd24gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiVFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIsIG5vdCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIi5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJhbmRfZWxpbWluYXRlX2VcIiwgXCJyZWFkZXJfdmlld1wiOiBbeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJmcm9tXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlNcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInBocmFzZVwiLCBcImNvbnRlbnRcIjogXCJoYXZlXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH1dLCBcImFudGVjZWRlbnRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJyZXN1bHRzXCI6IFt7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJUXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwidmFyaWFibGVzXCI6IFtdLCBcImVycm9yXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJGcm9tIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHlvdSBjYW4gY29uY2x1ZGUgZWl0aGVyIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwiZXhwcmVzc2lvblwiOiB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgXCJzdWJzdGl0dXRpb25zXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBvciBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibm90X2ludHJvZHVjZV9lXCIsIFwicmVhZGVyX3ZpZXdcIjogW3sgXCJmb3JtYXRcIjogXCJwaHJhc2VcIiwgXCJjb250ZW50XCI6IFwiaGVuY2VcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfV0sIFwiYW50ZWNlZGVudHNcIjogW10sIFwicmVzdWx0c1wiOiBbeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcInZhcmlhYmxlc1wiOiBbXSwgXCJlcnJvclwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiSWYgeW91IHdhbnQgdG8gcmVhY2ggYSBjb250cmFkaWN0aW9uIGZyb20gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJleHByZXNzaW9uXCI6IHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGFuZCBzbyBjb25jbHVkZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIFwic3Vic3RpdHV0aW9uc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgdGhlbiB5b3UnbGwgbmVlZCB0byBzdGFydCBmcm9tIHRoZSBsYXcgb2YgdGhlIGV4Y2x1ZGVkIG1pZGRsZSAnV2Uga25vdyBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcImV4cHJlc3Npb25cIjogeyBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcImR1bW1pZXNcIjogW10gfV0sIFwiZHVtbWllc1wiOiBbXSB9LCBcInN1YnN0aXR1dGlvbnNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJy5cIiB9XV0gfV0sIFwidm9jYWJ1bGFyeVwiOiB7IFwiZnJvbVwiOiBbXCJmcm9tXCJdLCBcImFuZFwiOiBbXCJhbmRcIl0sIFwiaGF2ZVwiOiBbXCJ3ZSBoYXZlXCIsIFwid2Uga25vd1wiLCBcImhhdmVcIl0sIFwiaGVuY2VcIjogW1wiaGVuY2VcIiwgXCJzb1wiLCBcInRodXNcIiwgXCJ3aGVuY2VcIiwgXCJ0aGVyZWZvcmVcIl0sIFwid2hpY2hldmVyXCI6IFtcImFuZCB3aGljaGV2ZXIgaXMgdHJ1ZVwiLCBcImFuZCBlaXRoZXIgd2F5XCIsIFwiYW5kIGluIGVpdGhlciBjYXNlXCJdLCBcImFyYml0cmFyeVwiOiBbXCJ3YXMgYXJiaXRyYXJ5XCIsIFwiaXMgYXJiaXRyYXJ5XCJdLCBcInRha2VcIjogW1widGFrZVwiXSwgXCJzYXRpc2Z5aW5nXCI6IFtcInNhdGlzZnlpbmdcIiwgXCJzdWNoIHRoYXRcIl0sIFwiaWZcIjogW1wiaWZcIl0sIFwiZ2l2ZW5cIjogW1wiZ2l2ZW5cIl0sIFwiY29udHJhZGljdGlvblwiOiBbXCJjb250cmFkaWN0aW9uXCJdLCBcImF0XCI6IFtcImF0XCJdIH0sIFwibWlzdGFrZV90YWJsZVwiOiBbeyBcIm5hbWVcIjogXCJsYXlvdXRcIiwgXCJlbnRyaWVzXCI6IFt7IFwibmFtZVwiOiBcImZpcnN0X2xpbmVfaW5kZW50ZWRcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJncmVhdGVyX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMCwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJUaGUgZmlyc3QgbGluZSBvZiBhIHByb29mIHNob3VsZCBub3QgYmUgaW5kZW50ZWQuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiaWxsZWdhbF9pbmRlbnRcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJncmVhdGVyX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfc2NvcGVfY3JlYXRvclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJJbmRlbnRzIHNob3VsZCBvbmx5IG9jY3VyIGFmdGVyIGxpbmVzIG9mIHRoZSBmb3JtICdJZi4uJyBvciAnR2l2ZW4uLi4nLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImRvdWJsZV9pbmRlbnRcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJncmVhdGVyX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhZGRpdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX3Njb3BlX2NyZWF0b3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJPbmx5IGluZGVudCBvbmNlIGFmdGVyICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibWlzc2luZ19pbmRlbnRfZ2l2ZW5cIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2dpdmVuJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuX29yX2VxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIkFmdGVyICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgdGhlIGZvbGxvd2luZyBsaW5lcyBpbiB3aGljaCB5b3UgcmVhc29uIHVzaW5nIHRoZSB2YXJpYWJsZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHNob3VsZCBiZSBpbmRlbnRlZC4gVGhlbiBzdG9wIGluZGVudGluZyBvbmNlIHlvdSByZWFjaCBhIHN0YXRlbWVudCBvZiB0aGUgZm9ybSAnXFx1MjIwMHguLi4uLicgaW4gd2hpY2ggdGhlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgbm8gbG9uZ2VyIG9jY3Vycy5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJtaXNzaW5nX2luZGVudF9hc3N1bXB0aW9uXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidhc3N1bXB0aW9uJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuX29yX2VxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIkFmdGVyICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgdGhlIGZvbGxvd2luZyBsaW5lcyBpbiB3aGljaCB5b3UgcmVhc29uIHVuZGVyIHRoZSBhc3N1bXB0aW9uIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHNob3VsZCBiZSBpbmRlbnRlZC4gT25jZSB5b3UgaGF2ZSBwcm92ZWQgc29tZSBzdGF0ZW1lbnQgcCBhc3N1bWluZyBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB0aGVuIHlvdSBjYW4gd3JpdGUgYW4gdW5pbmRlbnRlZCBsaW5lICdIZW5jZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIj0+cCcuIEFsdGVybmF0aXZlbHkgeW91IGNhbiBzaW1wbHkgc3RvcCBpbmRlbnRpbmcgaWYgeW91IG5vIGxvbmdlciB3aXNoIHRvIHVzZSB0aGUgYXNzdW1wdGlvbiBvZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIi5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJtaXNzaW5nX2RlaW5kZW50X2ZvcmFsbF8wXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZm9yX2FsbF9pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDAsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRvIHByb3ZlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB5b3UgbmVlZCB0byBzdGFydCBieSB3cml0aW5nICdHaXZlbiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgYW5kIHRoZW4gc3RhcnQgaW5kZW50aW5nIHlvdXIgbGluZXMgdW50aWwgeW91IG1hbmFnZSB0byBwcm92ZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZW50cnlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFudGVjZWRlbnRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuIEFmdGVyIHRoaXMgeW91IGNhbiB3cml0ZSB0aGlzIGxpbmUgKHdoaWNoIHNob3VsZCBub3QgYmUgaW5kZW50ZWQpLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImluY29ycmVjdF9kZWluZGVudF9mb3JhbGxcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidmb3JfYWxsX2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdF9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidnaXZlbidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIldlIGFyZSBzdGlsbCB3b3JraW5nIHVuZGVyIHRoZSBhc3N1bXB0aW9uIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBhbmQgbXVzdCBzdG9wIGRvaW5nIHNvIChmb3IgZXhhbXBsZSBieSBtb3ZpbmcgdG8gYSBzdGF0ZW1lbnQgb2YgdGhlIGZvcm0gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiPT5wKSBiZWZvcmUgd2UgY2FuIGxlYXZlIHRoZSBzY29wZSBvZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBhbmQgaW50cm9kdWNlIGEgZm9yLWFsbCBxdWFudGlmaWVyLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcIm1pc3NpbmdfZGVpbmRlbnRfZm9yX2FsbF8xXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZm9yX2FsbF9pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRoaXMgbGluZSBzaG91bGQgbm8gbG9uZ2VyIGJlaW5nIGluZGVudGVkIChiZWNhdXNlIHdlIGFyZSBubyBsb25nZXIgd2l0aGluIHRoZSBzY29wZSBvZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIikuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibWlzc2luZ19kZWluZGVudF9mb3JfYWxsXzJcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidmb3JfYWxsX2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVGhpcyBsaW5lIHNob3VsZCBiZSBpbmRlbnRlZCBvbmUgc3RlcCBsZXNzIHRoYW4gdGhlIHByZXZpb3VzIGxpbmUgKGJlY2F1c2UgaXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBzY29wZSBvZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIikuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiZG91YmxlX2RlaW5kZW50X2ZvcmFsbFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2Zvcl9hbGxfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJXZSBvbmx5IHJlZHVjZSB0aGUgbGV2ZWwgb2YgaW5kZW50YXRpb24gYnkgb25lIGhlcmU7IHdlIGFyZSBqdXN0IGxlYXZpbmcgdGhlIHNjb3BlIG9mICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcIm1pc3NpbmdfZGVpbmRlbnRfaW1wbGllc18wXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInaW1wbGllc19pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAwLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJUbyBwcm92ZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgeW91IG5lZWQgdG8gc3RhcnQgYnkgd3JpdGluZyAnSWYgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInLCB0aGVuIGdpdmUgYSBjaGFpbiBvZiByZWFzb25pbmcgKHdoaWNoIHNob3VsZCBiZSBpbmRlbnRlZCkgdGhhdCBlbmRzIHdpdGggXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUydcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuIEFmdGVyIHRoYXQgeW91IGNhbiBwdXQgdGhpcyBsaW5lICh3aGljaCBzaG91bGQgbm90IGJlIGluZGVudGVkKS5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJtaXNzaW5nX2RlaW5kZW50X25vdF8wXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInbm90X2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDAsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRvIHByb3ZlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB5b3UgbmVlZCB0byBzdGFydCBieSB3cml0aW5nICdJZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidSJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgYW5kIHRoZW4gZ2l2ZSBhIGNoYWluIG9mIHJlYXNvbmluZyAob24gaW5kZW50ZWQgbGluZXMpIHRoYXQgZW5kcyB3aXRoIGEgY29udHJhZGljdGlvbi4gQWZ0ZXIgdGhhdCB5b3UgYXJlIGFsbG93ZWQgdG8gd3JpdGUgdGhpcyBsaW5lICh1bmluZGVudGVkKS5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJpbmNvcnJlY3RfZGVpbmRlbnRcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInaW1wbGllc19pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidub3RfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdF9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidhc3N1bXB0aW9uJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IGFyZSBzdGlsbCB3b3JraW5nIHdpdGhpbmcgdGhlIHNjb3BlIG9mICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInIGFuZCB5b3UgbmVlZCB0byBzdG9wIGRvaW5nIHNvICh0eXBpY2FsbHkgYmUgaW50cm9kdWNpbmcgYSBmb3JhbGwgc3RhdGVtZW50KSBiZWZvcmUgeW91IGNhbiBkcm9wIHRoZSBhc3N1bXB0aW9uIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLiBBbHRlcm5hdGl2ZWx5IHlvdSBjb3VsZCB0cnkgY2hhbmdpbmcgdGhlIG9yZGVyIG9mIHlvdXIgJ0dpdmVuLi4uJyBhbmQgJ0lmLi4uJyBsaW5lcy5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJtaXNzaW5nX2RlaW5kZW50XzFcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInaW1wbGllc19pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidub3RfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiU3RvcCBpbmRlbnRpbmcgYXQgdGhpcyBwb2ludCwgYmVjYXVzZSB0aGUgdHJ1dGggb2YgdGhpcyBsaW5lIGRvZXMgbm90IHJlbHkgb24gdGhlIGFzc3VtcHRpb24gb2YgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibWlzc2luZ19kZWluZGVudF8yXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2ltcGxpZXNfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInbm90X2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIldoZW4gd3JpdGluZyAnXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRleHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJyB3ZSByZWR1Y2UgdGhlIGxldmVsIG9mIGluZGVudGF0aW9uIGJ5IG9uZSwgdG8gaW5kaWNhdGUgdGhhdCB3ZSBhcmUgbm8gbG9uZ2VyIG1ha2luZyB0aGUgYXNzdW1wdGlvbiB0aGF0IFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImRvdWJsZV9kZWluZGVudF9hc3N1bXB0aW9uXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2ltcGxpZXNfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInbm90X2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2Fzc3VtcHRpb24nXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IHNob3VsZCBvbmx5IGRlLWluZGVudCBvbmNlIGhlcmU7IHdlIGFyZSBkcm9wcGluZyB0aGUgYXNzdW1wdGlvbiBvZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic2NvcGVyXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgYnV0IG5vdCB0aGF0IG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiZG91YmxlX2RlaW5kZW50X2dpdmVuXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2ltcGxpZXNfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInbm90X2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2dpdmVuJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIk9ubHkgZGVpbmRlbnQgb25jZSBoZXJlOyB3ZSBhcmUgZHJvcHBpbmcgdGhlIGFzc3VtcHRpb24gb2YgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGJ1dCBhcmUgc3RpbGwgd2l0aGluIHRoZSBzY29wZSBvZiAnXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRleHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiaWxsZWdhbF9maXJzdF9saW5lXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2Zvcl9hbGxfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2ltcGxpZXNfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInbm90X2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IGNhbid0IGhhdmUgdGhpcyBhcyB0aGUgZmlyc3QgbGluZSBvZiB5b3VyIHByb29mXCIgfV1dIH1dIH0sIHsgXCJuYW1lXCI6IFwidmFyaWFibGVzXCIsIFwiZW50cmllc1wiOiBbeyBcIm5hbWVcIjogXCJ1bnNwZWNpZmllZF92YXJpYWJsZVwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pbml0aWFsaXplclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYm91bmRlZF9leGlzdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYm91bmRlZF9xdWFudGlmaWVyXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInZhcmlhYmxlc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5pdGlhbGl6ZWRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IGhhdmVuJ3Qgc2FpZCB3aGVyZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBjb21lcyBmcm9tOyBpZiB5b3Ugd2FudCBpdCB0byBiZSBhcmJpdHJhcnkgdGhlbiBhZGQgYSBwcmVjZWRpbmcgbGluZSBzYXlpbmcgJ0dpdmVuIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJzsgYWx0ZXJuYXRpdmVseSB5b3UgbWlnaHQgd2FudCB0byB0YWtlIGEgcGFydGljdWxhciBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB3aXRuZXNzaW5nIHNvbWUgZXhpc3RlbnRpYWwgZm9ybXVsYS5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJpbmFjY2Vzc2libGVfdmFyaWFibGVcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5pdGlhbGl6ZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90X2VxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2Zvcl9hbGxfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYm91bmRlZF9leGlzdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYm91bmRlZF9xdWFudGlmaWVyXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInZhcmlhYmxlc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfYWNjZXNzaWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVGhlIHZhcmlhYmxlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHdhcyBvbmx5IHNwZWNpZmllZCB3aXRoaW4gdGhlIHNjb3BlIG9mICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGV4dFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlcjJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbml0aWFsaXplclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgaW4gbGluZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic2NvcGVyMlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluaXRpYWxpemVyXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLCBhbmQgc28gY2FuIG9ubHkgYmUgdXNlZCB0aGVyZS4gSWYgeW91IHdhbnQgaXQgYXMgYW4gYXJiaXRyYXJ5IHZhcmlhYmxlIGFnYWluIHRoZW4gd3JpdGUgJ0dpdmVuIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJy5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJpbmNvcnJlY3RfdmFyaWFibGVfZm9yYWxsXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZm9yX2FsbF9pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RfZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIldlIG9yaWdpbmFsbHkgdG9vayBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBhcyBvdXIgYXJiaXRyYXJ5IHZhcmlhYmxlIHNvIHRoaXMsIHJhdGhlciB0aGFuIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLCBuZWVkcyB0byBiZSB0aGUgb25lIHRoYXQgd2UgcXVhbnRpZnkgb3V0IG92ZXIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiYXJiaXRyYXJ5X3ZhcmlhYmxlX2NsYXNoXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZ2l2ZW4nXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19hY2Nlc3NpYmxlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRoZSB2YXJpYWJsZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBpcyBhbHJlYWR5IGluIHVzZTsgY2hvc2UgYSBuZXcgdmFyaWFibGUgdG8gd29yayB3aXRoIGluc3RlYWQuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwidmFyaWFibGVfY2xhc2hcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidleGlzdHNfZWxpbWluYXRlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfYWNjZXNzaWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJZb3UganVzdCBrbm93IHRoYXQgdGhlcmUgaXMgc29tZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBzdWNoIHRoYXQgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiOyB5b3UgY2FuJ3QgYXNzdW1lIHRoYXQgaXQgaXMgdGhlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHdlIHdlcmUgcHJldmlvdXNseSBkaXNjdXNzaW5nLiBUcnkgdXNpbmcgYW4gZW50aXJlbHkgbmV3IHZhcmlhYmxlIGluIHBsYWNlIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLlwiIH1dXSB9XSB9LCB7IFwibmFtZVwiOiBcImxvZ2ljXCIsIFwiZW50cmllc1wiOiBbeyBcIm5hbWVcIjogXCJtaXNzaW5nX2FudGVjZWRlbnRcIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYm91bmRlZF9leGlzdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYm91bmRlZF9xdWFudGlmaWVyXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFudGVjZWRlbnRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19wcm92ZW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJUaGlzIGxpbmUgdXNlcyBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWluXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbnRlY2VkZW50c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfcHJvdmVuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiQVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9XSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIsIHNvIHlvdSBuZWVkIHRvIGhhdmUgYW4gZWFybGllciBsaW5lIHByb3ZpbmcgdGhhdCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWluXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbnRlY2VkZW50c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfcHJvdmVuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiQVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9XSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgaXMgdHJ1ZS5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJpbmFjY2Vzc2libGVfYW50ZWNlZGVudFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiQVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW50ZWNlZGVudHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzZXRfb2ZfZm9ybXVsYXNcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2F2YWlsYWJsZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiQVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIllvdSBhcmUgdXNpbmcgaGVyZSB0aGF0IFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicmFuZ2VkX2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFudGVjZWRlbnRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19hdmFpbGFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH1dLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiwgd2hpY2ggd2FzIG9ubHkgcHJvdmVkIHdpdGhpbiB0aGUgY29udGV4dCBvZiAnXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRleHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJwcm92ZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicmFuZ2VkX2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFudGVjZWRlbnRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19hdmFpbGFibGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJBXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH1dLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiJyBhbmQgc28gaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSB0byB5b3UuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibWlzc2luZ19mYWxzZVwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5lZWRzX2ZhbHNlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ5aWVsZHNfZmFsc2VcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVGhpcyBsaW5lIGFzc3VtZXMgeW91IGhhdmUgYWxyZWFkeSBwcm92ZWQgYSBjb250cmFkaWN0aW9uLCB3aGljaCBpcyBub3QgdGhlIGNhc2UuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwiaW5hY2Nlc3NpYmxlX2ZhbHNlXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibmVlZHNfZmFsc2VcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieWllbGRzX2ZhbHNlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luX3Njb3BlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJJdCBpcyB0cnVlIHRoYXQgeW91IHByb3ZlZCBhIGNvbnRyYWRpY3Rpb24gaW4gbGluZSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWF4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19mYWxzZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgYnV0IHRoaXMgbGluZSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIHRvIHlvdS5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJmb3JfYWxsX2luY29ycmVjdF9jb25jbHVzaW9uXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZm9yX2FsbF9pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJzdGl0dXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidwJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIid4J1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidhJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVG8gY29uY2x1ZGUgdGhpcyB5b3UgbmVlZCB0byBoYXZlIHNob3duIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJzdGl0dXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidwJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIid4J1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidhJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgb24gdGhlIGltbWVkaWF0ZWx5IHByZWNlZGluZyBsaW5lLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImltcGxpZXNfaW5jb3JyZWN0X2NvbmNsdXNpb25cIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidpbXBsaWVzX2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUydcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVG8gZGVkdWNlICdcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInIHlvdSBuZWVkIHRvIGhhdmUgcHJvdmVkIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1MnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGluIHRoZSBpbW1lZGlhdGVseSBwcmVjZWRpbmcgbGluZSAodW5kZXIgdGhlIGFzc3VtcHRpb24gb2YgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIpLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcImltcGxpZXNfaW5jb3JyZWN0X2Fzc3VtcHRpb25cIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidpbXBsaWVzX2ludHJvZHVjZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdF9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIllvdSBzdGFydGVkIHdpdGggdGhlIGFzc3VtcHRpb24gb2YgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIG5vdCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidSJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiwgc28geW91IG11c3QgY29uY2x1ZGUgJ0hlbmNlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIj0+XCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUydcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInLlwiIH1dXSB9LCB7IFwibmFtZVwiOiBcIm5vdF9pbmNvcnJlY3RfY29uY2x1c2lvblwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ25vdF9pbnRyb2R1Y2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieWllbGRzX2ZhbHNlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic3VidHJhY3Rpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRvIHByb3ZlIHRoZSBzdGF0ZW1lbnQgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHlvdSBuZWVkIHRvIHN0YXJ0IGJ5IGFzc3VtaW5nIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGlzIHRydWUgYW5kIHByb3ZlIGEgY29udHJhZGljdGlvbi4gVGhlbiB3cml0ZSB0aGlzIGxpbmUgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkcy5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJub3RfaW5jb3JyZWN0X2Fzc3VtcHRpb25cIiwgXCJvY2N1cnNcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidub3RfaW50cm9kdWNlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90X2VxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInN1YnRyYWN0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiV2Ugc3RhcnRlZCB3aXRoIHRoZSBhc3N1bXB0aW9uIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiwgc28gd2hhdCB3ZSBoYXZlIGluIGZhY3Qgc2hvd24gaXMgflwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzdWJ0cmFjdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAxLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIi5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJvcl9taXNzaW5nX2FudGVjZWRlbnRfYm90aFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ29yX2VsaW1pbmF0ZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19pbXBsaWNhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ5aWVsZHNfaW1wbGljYXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1MnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVG8gY29uY2x1ZGUgdGhhdCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidUJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBmb2xsb3dzIGZyb20gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVudHJ5XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbnRlY2VkZW50c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHlvdSBuZWVkIHRvIHNob3cgdGhhdCBpdCBmb2xsb3dzIGlmIGVpdGhlciBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidSJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBvciBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidTJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBpcyB0cnVlLiBXcml0ZSAnSWYgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInIGFuZCB0aGVuIGdpdmUgYW4gKGluZGVudGVkKSBzZXJpZXMgb2YgbGluZXMgdGhhdCBkZWR1Y2UgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgKG9yIGEgY29udHJhZGljdGlvbikgZnJvbSBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidSJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIi4gVGhlbiBzZXBhcmF0ZWx5IHdyaXRlICdJZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidTJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgYW5kIHByb3ZlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIChvciBhIGNvbnRyYWRpY3Rpb24pIHVuZGVyIHRoaXMgYXNzdW1wdGlvbi5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJvcl9taXNzaW5nX2FudGVjZWRlbnRfbGVmdFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ29yX2VsaW1pbmF0ZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ5aWVsZHNfaW1wbGljYXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJZb3UgaGF2ZSBwcm92ZWQgdGhhdCBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidUJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBmb2xsb3dzIGlmIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1MnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGhvbGRzOyB5b3UgbmVlZCB0byBhbHNvIHByb3ZlIGl0IGZvbGxvd3MgaWYgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgaG9sZHMuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwib3JfbWlzc2luZ19hbnRlY2VkZW50X3JpZ2h0XCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInb3JfZWxpbWluYXRlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19pbXBsaWNhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUydcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIllvdSBoYXZlIHByb3ZlZCB0aGF0IFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIGZvbGxvd3MgaWYgXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIgaG9sZHM7IHlvdSBuZWVkIHRvIGFsc28gcHJvdmUgaXQgZm9sbG93cyBpZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidTJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiBob2xkcy5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJvcl9pbmFjY2Vzc2libGVfYW50ZWNlZGVudF9sZWZ0XCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInb3JfZWxpbWluYXRlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2F2YWlsYWJsZV9pbXBsaWNhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiWW91IHByb3ZlZCB0aGF0IGlmIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1InXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHRoZW4gXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIsIGJ1dCB0aGlzIHdhcyBpbiB0aGUgY29udGV4dCBvZiAnXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRleHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtYXhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicmFuZ2VkX2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYm91bmRlZF9leGlzdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYm91bmRlZF9xdWFudGlmaWVyXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieWllbGRzX2ltcGxpY2F0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidSJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidUJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicsIHdoaWNoIHdlIGhhdmUgc2luY2UgbGVmdC5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJvcl9pbmFjY2Vzc2libGVfYW50ZWNlZGVudF9yaWdodFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ29yX2VsaW1pbmF0ZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19hdmFpbGFibGVfaW1wbGljYXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1MnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIllvdSBwcm92ZWQgdGhhdCBpZiBcIiB9LCB7IFwiZm9ybWF0XCI6IFwiZXhwcmVzc2lvblwiLCBcImNvbnRlbnRcIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZWxlbWVudFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidTJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIiB0aGVuIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlbGVtZW50XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ1QnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiLCBidXQgdGhpcyB3YXMgaW4gdGhlIGNvbnRleHQgb2YgJ1wiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZXh0XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwic2NvcGVyXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWF4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19pbXBsaWNhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInUydcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVsZW1lbnRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInVCdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJqXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCInLCB3aGljaCB3ZSBoYXZlIHNpbmNlIGxlZnQuXCIgfV1dIH1dIH0sIHsgXCJuYW1lXCI6IFwidGFyZ2V0XCIsIFwiZW50cmllc1wiOiBbeyBcIm5hbWVcIjogXCJsYXN0X2xpbmVfaW5kZW50ZWRfYXNzdW1wdGlvblwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm51bV9saW5lc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAwLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdF9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInZ2l2ZW4nXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwibWVzc2FnZVwiOiBbW3sgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiVGhlIGxhc3QgbGluZSBvZiBhIHByb29mIHNob3VsZCBub3QgYmUgaW5kZW50ZWQ7IHlvdSBuZWVkIHRvIHByb3ZlIHRoYXQgdGhlIGdpdmVuIGZvcm11bGFzIGhvbGRzIGp1c3QgZnJvbSB0aGUgb3JpZ2luYWwgYXNzdW1wdGlvbnMsIG5vdCB0aGUgYWRkaXRpb25hbCBhc3N1bXB0aW9uIG9mIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0gfSwgeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCIuXCIgfV1dIH0sIHsgXCJuYW1lXCI6IFwibGFzdF9saW5lX2luZGVudGVkX2dpdmVuXCIsIFwib2NjdXJzXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibnVtX2xpbmVzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDAsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2dpdmVuJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcIm1lc3NhZ2VcIjogW1t7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIlRoZSBsYXN0IGxpbmUgb2YgYSBwcm9vZiBzaG91bGQgbm90IGJlIGluZGVudGVkOyB5b3Ugc2hvdWxkIGhhdmUgY2Vhc2VkIHdvcmtpbmcgd2l0aGluIHRoZSBzY29wZSBvZiAnXCIgfSwgeyBcImZvcm1hdFwiOiBcImV4cHJlc3Npb25cIiwgXCJjb250ZW50XCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRleHRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJzY29wZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9LCB7IFwiZm9ybWF0XCI6IFwic3RyaW5nXCIsIFwiY29udGVudFwiOiBcIicgYnkgdGhpcyBwb2ludCwgdHlwaWNhbGx5IGJ5IGludHJvZHVjaW5nIGEgZm9yYWxsIHN0YXRlbWVudC5cIiB9XV0gfSwgeyBcIm5hbWVcIjogXCJsYXN0X2xpbmVfbm90X3RhcmdldFwiLCBcIm9jY3Vyc1wiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm51bV9saW5lc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0YXJnZXRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJtZXNzYWdlXCI6IFtbeyBcImZvcm1hdFwiOiBcInN0cmluZ1wiLCBcImNvbnRlbnRcIjogXCJXZSBhcmUgdHJ5aW5nIHRvIHByb3ZlIFwiIH0sIHsgXCJmb3JtYXRcIjogXCJleHByZXNzaW9uXCIsIFwiY29udGVudFwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0YXJnZXRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9IH0sIHsgXCJmb3JtYXRcIjogXCJzdHJpbmdcIiwgXCJjb250ZW50XCI6IFwiIHNvIGl0IHNob3VsZCBiZSBnaXZlbiBieSB0aGUgZmluYWwgbGluZSBvZiB0aGUgcHJvb2YuXCIgfV1dIH1dIH1dLCBcImNvbnRyb2xfZnVuY3Rpb25zXCI6IFt7IFwibmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiZm9ybXVsYVwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZW50cnlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInZhcmlhYmxlc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGZyZWUgdmFyaWFibGUgb2NjdXJyaW5nIGluIGxpbmUgbiAoaWYgYW55KVwiIH0sIHsgXCJuYW1lXCI6IFwicmVzdWx0XCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiZm9ybXVsYVwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZW50cnlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInJlc3VsdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzZXRfb2ZfZm9ybXVsYXNcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByZXN1bHQgb2YgbGluZSBuIChpZiBhbnkpXCIgfSwgeyBcIm5hbWVcIjogXCJpc19zY29wZV9jcmVhdG9yXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiYm9vbGVhblwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2dpdmVuJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInYXNzdW1wdGlvbidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0aGUgbGluZSBhZnRlciB0aGlzIG9uZSBzaG91bGQgYmUgaW5kZW50ZWRcIiB9LCB7IFwibmFtZVwiOiBcInNjb3BlclwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImludGVnZXJcIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1heFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJyYW5nZWRfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG1vc3QgcmVjZW50IGxpbmUgKG5vdCBpbmNsdWRpbmcgbikgaW4gd2hvc2Ugc2NvcGUgbGluZSBuIGlzXCIgfSwgeyBcIm5hbWVcIjogXCJzY29wZXIyXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiaW50ZWdlclwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaWZcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19zY29wZV9jcmVhdG9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInNjb3BlclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBtb3N0IHJlY2VudCBsaW5lIChpbmNsdWRpbmcgbikgaW4gd2hvc2Ugc2NvcGUgbGluZSBuIGlzXCIgfSwgeyBcIm5hbWVcIjogXCJpc19pbl9zY29wZVwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19zY29wZV9jcmVhdG9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhbl9vcl9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJub3RcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYm91bmRlZF9leGlzdHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYm91bmRlZF9xdWFudGlmaWVyXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5fb3JfZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhbl9vcl9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgdGhlIHJlc3VsdHMgYW5kIHZhcmlhYmxlcyBvZiBsaW5lIGs8PW4gYXJlIGFjY2Vzc2libGUgdG8gbGluZSBuXCIgfSwgeyBcIm5hbWVcIjogXCJpc19pbml0aWFsaXplclwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidnaXZlbidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidmb3JfYWxsX2VsaW1pbmF0ZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidleGlzdHNfZWxpbWluYXRlJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCIndGFrZSdcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIGxpbmUgbiBpbml0aWFsaXplcyBpdHMgdmFyaWFibGVzXCIgfSwgeyBcIm5hbWVcIjogXCJpbml0aWFsaXplc1wiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5pdGlhbGl6ZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ2YXJpYWJsZXNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzZXRfb2ZfZm9ybXVsYXNcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIGxpbmUgbiBpbml0aWFsaXplcyB2YXJpYWJsZSB4XCIgfSwgeyBcIm5hbWVcIjogXCJpc19pbml0aWFsaXplZFwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInF1ZXN0aW9uX3ZhcmlhYmxlc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluaXRpYWxpemVzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIHZhcmlhYmxlIHggaXMgaW5pdGlhbGl6ZWQgYnkgbGluZSBuICh0aGlzIGRvZXMgbm90IG1lYW4gaXQgaXMgbGVnYWwgdG8gdXNlLCBhcyBpdCBtYXkgYmUgb3V0IG9mIHNjb3BlKS5cIiB9LCB7IFwibmFtZVwiOiBcImluaXRpYWxpemVyXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJmb3JtdWxhXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiaW50ZWdlclwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWF4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluaXRpYWxpemVzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBtb3N0IHJlY2VudCBsaW5lIGJlZm9yZSBuIHRoYXQgaW5pdGlhbGl6ZXMgeFwiIH0sIHsgXCJuYW1lXCI6IFwiaXNfYWNjZXNzaWJsZVwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm9yXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpc19pblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInhcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInF1ZXN0aW9uX3ZhcmlhYmxlc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5pdGlhbGl6ZXNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5fc2NvcGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIHZhcmlhYmxlIHggaXMgaW5pdGlhbGl6ZWQgYW5kIHN0aWxsIGF2YWlsYWJsZSBieSBsaW5lIG5cIiB9LCB7IFwibmFtZVwiOiBcImlzX2FyYml0cmFyeVwiLCBcInZhcmlhYmxlc1wiOiBbeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwieFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9XSwgXCJkdW1taWVzXCI6IFtdLCBcIm91dHB1dFwiOiBcImJvb2xlYW5cIiB9XSwgXCJkZWZpbml0aW9uXCI6IHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5pdGlhbGl6ZXJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2dpdmVuJ1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgdmFyaWFibGUgeCBpcyBhcmJpdHJhcnkgYXQgbGluZSBuXCIgfSwgeyBcIm5hbWVcIjogXCJpc19wcm92ZW5cIiwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImZvcm11bGFcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH0sIHsgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJvdXRwdXRcIjogXCJib29sZWFuXCIgfV0sIFwiZGVmaW5pdGlvblwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJvclwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhc3N1bXB0aW9uc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0aGVyZSBpcyBhIGxpbmUgYmVmb3JlIG4gdGhhdCBwcm92ZXMgUiAoYWdhaW4sIGl0IG1heSBzdGlsbCBiZSBvdXQgb2Ygc2NvcGUgYW5kIHRodXMgdW51c2FibGUpLlwiIH0sIHsgXCJuYW1lXCI6IFwicHJvdmVyXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJmb3JtdWxhXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiaW50ZWdlclwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibWF4XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInJhbmdlZF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJrXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbW9zdCByZWNlbnQgbGluZSBiZWZvcmUgbiB0aGF0IHByb3ZlcyBSLlwiIH0sIHsgXCJuYW1lXCI6IFwiaXNfYXZhaWxhYmxlXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJmb3JtdWxhXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiYm9vbGVhblwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYXNzdW1wdGlvbnNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luX3Njb3BlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgUiBpcyBhdmFpbGFibGUgdG8gdXNlIGJ5IGxpbmUgblwiIH0sIHsgXCJuYW1lXCI6IFwieWllbGRzX2ZhbHNlXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiYm9vbGVhblwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ25vdF9lbGltaW5hdGUnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJlcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ0ZW1wbGF0ZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIidvcl9lbGltaW5hdGVfZmFsc2UnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgbGluZSBuIHByb3ZlcyBhIGNvbnRyYWRpY3Rpb25cIiB9LCB7IFwibmFtZVwiOiBcIm5lZWRzX2ZhbHNlXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiYm9vbGVhblwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInY29udHJhZGljdGlvbl9lbGltaW5hdGUnXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciBsaW5lIG4gYXNzdW1lcyBhIGNvbnRyYWRpY3Rpb24gaGFzIGJlZW4gcHJvdmVkXCIgfSwgeyBcIm5hbWVcIjogXCJ5aWVsZHNfaW1wbGljYXRpb25cIiwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIlJcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJTXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJmb3JtdWxhXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH0sIHsgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJvdXRwdXRcIjogXCJib29sZWFuXCIgfV0sIFwiZGVmaW5pdGlvblwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiAwLCBcInRvcF9raW5kX25hbWVcIjogXCJjb25zdGFudFwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwib3JcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiU1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJ5aWVsZHNfZmFsc2VcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwidGVtcGxhdGVcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJzdHJpbmdcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCInYXNzdW1wdGlvbidcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaXNfaW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImZvcm11bGFcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJyZXN1bHRzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic2V0X29mX2Zvcm11bGFzXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYWRkaXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMSwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhbl9vcl9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIGxpbmUgbiBpcyBhIHByb29mIG9mIFMgdW5kZXIgdGhlIGFzc3VtcHRpb24gb2YgUiwgbWFkZSBvbiBsaW5lIG1cIiB9LCB7IFwibmFtZVwiOiBcInlpZWxkc19pbXBsaWVzX2ZhbHNlXCIsIFwidmFyaWFibGVzXCI6IFt7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJSXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH0sIHsgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9XSwgXCJ0eXBpbmdcIjogW3sgXCJhcmd1bWVudHNcIjogW3sgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfSwgeyBcInR5cGVcIjogXCJpbnRlZ2VyXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImludGVnZXJcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH1dLCBcImR1bW1pZXNcIjogW10sIFwib3V0cHV0XCI6IFwiYm9vbGVhblwiIH1dLCBcImRlZmluaXRpb25cIjogeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiYW5kXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJncmVhdGVyX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogMCwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiY29uc3RhbnRcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19mYWxzZVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInRlbXBsYXRlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiJ2Fzc3VtcHRpb24nXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlzX2luXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiUlwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwicmVzdWx0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcInNldF9vZl9mb3JtdWxhc1wiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImVxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFkZGl0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IDEsIFwidG9wX2tpbmRfbmFtZVwiOiBcImNvbnN0YW50XCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm1cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5fb3JfZXF1YWxzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaW5kZW50YXRpb25cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwicHJlZml4X2Z1bmN0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJtXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciBsaW5lIG4gaXMgYSBwcm9vZiBvZiBjb250cmFkaWN0aW9uIHVuZGVyIHRoZSBhc3N1bXB0aW9uIG9mIFIsIG1hZGUgb24gbGluZSBtXCIgfSwgeyBcIm5hbWVcIjogXCJpc19hdmFpbGFibGVfaW1wbGljYXRpb25cIiwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJCXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfSwgeyBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdIH1dLCBcInR5cGluZ1wiOiBbeyBcImFyZ3VtZW50c1wiOiBbeyBcInR5cGVcIjogXCJmb3JtdWxhXCIsIFwiYXJiaXRyYXJpbHlfbWFueVwiOiBmYWxzZSB9LCB7IFwidHlwZVwiOiBcImZvcm11bGFcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH0sIHsgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJvdXRwdXRcIjogXCJib29sZWFuXCIgfV0sIFwiZGVmaW5pdGlvblwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19pbXBsaWNhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkJcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5vdFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ1bmFyeV9jb25uZWN0aXZlXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImdyZWF0ZXJfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJsZXNzX3RoYW5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImtcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhbl9vcl9lcXVhbHNcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X3JlbGF0aW9uXCIsIFwiYXJndW1lbnRzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpbmRlbnRhdGlvblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJwcmVmaXhfZnVuY3Rpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFt7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJpXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImludGVnZXJcIiB9XSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgdGhlcmUgaXMgYSBwcm9vZiBvZiBCIHVuZGVyIHRoZSBhc3N1bXB0aW9uIG9mIEEgYXZhaWxhYmxlIGF0IGxpbmUgblwiIH0sIHsgXCJuYW1lXCI6IFwiaXNfYXZhaWxhYmxlX2ltcGxpZXNfZmFsc2VcIiwgXCJ2YXJpYWJsZXNcIjogW3sgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIkFcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSB9LCB7IFwidG9wX2tpbmRfbmFtZVwiOiBcInZhcmlhYmxlXCIsIFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJuXCIsIFwiYXJndW1lbnRzXCI6IFtdLCBcImR1bW1pZXNcIjogW10gfV0sIFwidHlwaW5nXCI6IFt7IFwiYXJndW1lbnRzXCI6IFt7IFwidHlwZVwiOiBcImZvcm11bGFcIiwgXCJhcmJpdHJhcmlseV9tYW55XCI6IGZhbHNlIH0sIHsgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLCBcImFyYml0cmFyaWx5X21hbnlcIjogZmFsc2UgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJvdXRwdXRcIjogXCJib29sZWFuXCIgfV0sIFwiZGVmaW5pdGlvblwiOiB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcIm5cIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJib3VuZGVkX2V4aXN0c1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJib3VuZGVkX3F1YW50aWZpZXJcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImpcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCB7IFwidG9wX29wZXJhdG9yX25hbWVcIjogXCJhbmRcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwiYmluYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcInlpZWxkc19pbXBsaWVzX2ZhbHNlXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiQVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJmb3JtdWxhXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibm90XCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInVuYXJ5X2Nvbm5lY3RpdmVcIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImJvdW5kZWRfZXhpc3RzXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJvdW5kZWRfcXVhbnRpZmllclwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImFuZFwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfY29ubmVjdGl2ZVwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiZ3JlYXRlcl90aGFuXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcImJpbmFyeV9yZWxhdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImxlc3NfdGhhblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwia1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSwgeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwibGVzc190aGFuX29yX2VxdWFsc1wiLCBcInRvcF9raW5kX25hbWVcIjogXCJiaW5hcnlfcmVsYXRpb25cIiwgXCJhcmd1bWVudHNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiaVwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH0sIHsgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImluZGVudGF0aW9uXCIsIFwidG9wX2tpbmRfbmFtZVwiOiBcInByZWZpeF9mdW5jdGlvblwiLCBcImFyZ3VtZW50c1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwiblwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcImR1bW1pZXNcIjogW10sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1dLCBcImR1bW1pZXNcIjogW3sgXCJ0b3Bfb3BlcmF0b3JfbmFtZVwiOiBcImlcIiwgXCJ0b3Bfa2luZF9uYW1lXCI6IFwidmFyaWFibGVcIiwgXCJhcmd1bWVudHNcIjogW10sIFwiZHVtbWllc1wiOiBbXSwgXCJ0eXBlXCI6IFwiaW50ZWdlclwiIH1dLCBcInR5cGVcIjogXCJib29sZWFuXCIgfV0sIFwiZHVtbWllc1wiOiBbeyBcInRvcF9vcGVyYXRvcl9uYW1lXCI6IFwialwiLCBcInRvcF9raW5kX25hbWVcIjogXCJ2YXJpYWJsZVwiLCBcImFyZ3VtZW50c1wiOiBbXSwgXCJkdW1taWVzXCI6IFtdLCBcInR5cGVcIjogXCJpbnRlZ2VyXCIgfV0sIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LCBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0aGVyZSBpcyBhIHByb29mIG9mIGNvbnRyYWRpY3Rpb24gdW5kZXIgdGhlIGFzc3VtcHRpb24gb2YgQSBhdmFpbGFibGUgYXQgbGluZSBuXCIgfV0gfTtcbi8vIF5eUGFzdGUgZ2VuZXJhdGVkIGNvZGUgYWJvdmUgdGhpcyBsaW5lXl5cbmV4cG9ydHMuZGVmYXVsdCA9IExPR0lDX1BST09GX0RFRkFVTFRfUVVFU1RJT05fREFUQTtcbiIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dpY1Byb29mUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKlxuICAgICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC43LjAuXG4gICAgICpcbiAgICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVvdGUocykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBFQ01BLTI2MiwgNXRoIGVkLiwgNy44LjQ6IEFsbCBjaGFyYWN0ZXJzIG1heSBhcHBlYXIgbGl0ZXJhbGx5IGluIGFcbiAgICAgICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgICAgICogY2FycmlhZ2UgcmV0dXJuLCBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC5cbiAgICAgICAgICogQW55IGNoYXJhY3RlciBtYXkgYXBwZWFyIGluIHRoZSBmb3JtIG9mIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgICAgICAgKiBjaGFyYWN0ZXJzLiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZFxuICAgICAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAnXCInICsgc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgLy8gYmFja3NsYXNoXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgLy8gYmFja3NwYWNlXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpIC8vIGhvcml6b250YWwgdGFiXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIGxpbmUgZmVlZFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAvLyBmb3JtIGZlZWRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIGVzY2FwZSlcbiAgICAgICAgICAgICsgJ1wiJztcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgLypcbiAgICAgICAgICogUGFyc2VzIHRoZSBpbnB1dCB3aXRoIGEgZ2VuZXJhdGVkIHBhcnNlci4gSWYgdGhlIHBhcnNpbmcgaXMgc3VjY2Vzc2Z1bGwsXG4gICAgICAgICAqIHJldHVybnMgYSB2YWx1ZSBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHRoZSBncmFtbWFyIGZyb21cbiAgICAgICAgICogd2hpY2ggdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIChzZWUgfFBFRy5idWlsZFBhcnNlcnwpLiBJZiB0aGUgcGFyc2luZyBpc1xuICAgICAgICAgKiB1bnN1Y2Nlc3NmdWwsIHRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25UZW1wbGF0ZVwiOiBwYXJzZV9leHByZXNzaW9uVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgXCJib29sZWFuVGVtcGxhdGVcIjogcGFyc2VfYm9vbGVhblRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIFwic3Vic3RpdHV0aW9uXCI6IHBhcnNlX3N1YnN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICBcImVsZW1lbnRUZW1wbGF0ZVwiOiBwYXJzZV9lbGVtZW50VGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgXCJ2YXJpYWJsZVRlbXBsYXRlXCI6IHBhcnNlX3ZhcmlhYmxlVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgXCJsaXN0T2ZCb29sZWFuVGVtcGxhdGVzXCI6IHBhcnNlX2xpc3RPZkJvb2xlYW5UZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgXCJjb21tYVRoZW5Cb29sZWFuVGVtcGxhdGVcIjogcGFyc2VfY29tbWFUaGVuQm9vbGVhblRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblRlbXBsYXRlMlwiOiBwYXJzZV9leHByZXNzaW9uVGVtcGxhdGUyLFxuICAgICAgICAgICAgICAgIFwiYm9vbGVhblRlbXBsYXRlMlwiOiBwYXJzZV9ib29sZWFuVGVtcGxhdGUyLFxuICAgICAgICAgICAgICAgIFwiZm9ybXVsYUxIU1wiOiBwYXJzZV9mb3JtdWxhTEhTLFxuICAgICAgICAgICAgICAgIFwibGlzdE9mVmFyaWFibGVzXCI6IHBhcnNlX2xpc3RPZlZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBcImNvbW1hVGhlblZhcmlhYmxlXCI6IHBhcnNlX2NvbW1hVGhlblZhcmlhYmxlLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiOiBwYXJzZV9leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIFwibGlzdE9mRXhwcmVzc2lvbnNcIjogcGFyc2VfbGlzdE9mRXhwcmVzc2lvbnMsXG4gICAgICAgICAgICAgICAgXCJjb21tYVRoZW5FeHByZXNzaW9uXCI6IHBhcnNlX2NvbW1hVGhlbkV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgXCJpZmZTeW1ib2xcIjogcGFyc2VfaWZmU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwiaW1wbGllc1N5bWJvbFwiOiBwYXJzZV9pbXBsaWVzU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwiZm9yQWxsU3ltYm9sXCI6IHBhcnNlX2ZvckFsbFN5bWJvbCxcbiAgICAgICAgICAgICAgICBcImV4aXN0c1N5bWJvbFwiOiBwYXJzZV9leGlzdHNTeW1ib2wsXG4gICAgICAgICAgICAgICAgXCJhbmRTeW1ib2xcIjogcGFyc2VfYW5kU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwib3JTeW1ib2xcIjogcGFyc2Vfb3JTeW1ib2wsXG4gICAgICAgICAgICAgICAgXCJub3RTeW1ib2xcIjogcGFyc2Vfbm90U3ltYm9sLFxuICAgICAgICAgICAgICAgIFwiZXF1YWxzU3ltYm9sXCI6IHBhcnNlX2VxdWFsc1N5bWJvbCxcbiAgICAgICAgICAgICAgICBcImxlc3NUaGFuT3JFcXVhbHNTeW1ib2xcIjogcGFyc2VfbGVzc1RoYW5PckVxdWFsc1N5bWJvbCxcbiAgICAgICAgICAgICAgICBcImdyZWF0ZXJUaGFuT3JFcXVhbHNTeW1ib2xcIjogcGFyc2VfZ3JlYXRlclRoYW5PckVxdWFsc1N5bWJvbCxcbiAgICAgICAgICAgICAgICBcImxlc3NUaGFuU3ltYm9sXCI6IHBhcnNlX2xlc3NUaGFuU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwiZ3JlYXRlclRoYW5TeW1ib2xcIjogcGFyc2VfZ3JlYXRlclRoYW5TeW1ib2wsXG4gICAgICAgICAgICAgICAgXCJub3RFcXVhbHNTeW1ib2xcIjogcGFyc2Vfbm90RXF1YWxzU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc2hpcFN5bWJvbFwiOiBwYXJzZV9tZW1iZXJzaGlwU3ltYm9sLFxuICAgICAgICAgICAgICAgIFwiYWRkaXRpb25cIjogcGFyc2VfYWRkaXRpb24sXG4gICAgICAgICAgICAgICAgXCJzdWJ0cmFjdGlvblwiOiBwYXJzZV9zdWJ0cmFjdGlvbixcbiAgICAgICAgICAgICAgICBcIm11bHRpcGxpY2F0aW9uXCI6IHBhcnNlX211bHRpcGxpY2F0aW9uLFxuICAgICAgICAgICAgICAgIFwiZGl2aXNpb25cIjogcGFyc2VfZGl2aXNpb24sXG4gICAgICAgICAgICAgICAgXCJleHBvbmVudGlhdGlvblwiOiBwYXJzZV9leHBvbmVudGlhdGlvbixcbiAgICAgICAgICAgICAgICBcImlmZkZvcm11bGFcIjogcGFyc2VfaWZmRm9ybXVsYSxcbiAgICAgICAgICAgICAgICBcImltcGxpZXNGb3JtdWxhXCI6IHBhcnNlX2ltcGxpZXNGb3JtdWxhLFxuICAgICAgICAgICAgICAgIFwicXVhbnRpZmllckZvcm11bGFcIjogcGFyc2VfcXVhbnRpZmllckZvcm11bGEsXG4gICAgICAgICAgICAgICAgXCJmb3JBbGxGb3JtdWxhXCI6IHBhcnNlX2ZvckFsbEZvcm11bGEsXG4gICAgICAgICAgICAgICAgXCJleGlzdHNGb3JtdWxhXCI6IHBhcnNlX2V4aXN0c0Zvcm11bGEsXG4gICAgICAgICAgICAgICAgXCJib3VuZGVkRm9yQWxsRm9ybXVsYVwiOiBwYXJzZV9ib3VuZGVkRm9yQWxsRm9ybXVsYSxcbiAgICAgICAgICAgICAgICBcImJvdW5kZWRFeGlzdHNGb3JtdWxhXCI6IHBhcnNlX2JvdW5kZWRFeGlzdHNGb3JtdWxhLFxuICAgICAgICAgICAgICAgIFwib3JGb3JtdWxhXCI6IHBhcnNlX29yRm9ybXVsYSxcbiAgICAgICAgICAgICAgICBcImFuZEZvcm11bGFcIjogcGFyc2VfYW5kRm9ybXVsYSxcbiAgICAgICAgICAgICAgICBcImFuZFJIU1wiOiBwYXJzZV9hbmRSSFMsXG4gICAgICAgICAgICAgICAgXCJ1bmFyeUZvcm11bGFcIjogcGFyc2VfdW5hcnlGb3JtdWxhLFxuICAgICAgICAgICAgICAgIFwibm90Rm9ybXVsYVwiOiBwYXJzZV9ub3RGb3JtdWxhLFxuICAgICAgICAgICAgICAgIFwibm90UkhTXCI6IHBhcnNlX25vdFJIUyxcbiAgICAgICAgICAgICAgICBcImluZml4UmVsYXRpb25Gb3JtdWxhXCI6IHBhcnNlX2luZml4UmVsYXRpb25Gb3JtdWxhLFxuICAgICAgICAgICAgICAgIFwiaW5maXhSZWxhdGlvbk5hbWVcIjogcGFyc2VfaW5maXhSZWxhdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgXCJib3VuZGFibGVJbmZpeFJlbGF0aW9uTmFtZVwiOiBwYXJzZV9ib3VuZGFibGVJbmZpeFJlbGF0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBcImluZml4UmVsYXRpb25SSFNcIjogcGFyc2VfaW5maXhSZWxhdGlvblJIUyxcbiAgICAgICAgICAgICAgICBcImFkZGl0aW9uQXJndW1lbnRcIjogcGFyc2VfYWRkaXRpb25Bcmd1bWVudCxcbiAgICAgICAgICAgICAgICBcImFkZGl0aW9uUkhTXCI6IHBhcnNlX2FkZGl0aW9uUkhTLFxuICAgICAgICAgICAgICAgIFwic3VidHJhY3Rpb25Bcmd1bWVudFwiOiBwYXJzZV9zdWJ0cmFjdGlvbkFyZ3VtZW50LFxuICAgICAgICAgICAgICAgIFwic3VidHJhY3Rpb25SSFNcIjogcGFyc2Vfc3VidHJhY3Rpb25SSFMsXG4gICAgICAgICAgICAgICAgXCJtdWx0aXBsaWNhdGlvbkFyZ3VtZW50XCI6IHBhcnNlX211bHRpcGxpY2F0aW9uQXJndW1lbnQsXG4gICAgICAgICAgICAgICAgXCJtdWx0aXBsaWNhdGlvblJIU1wiOiBwYXJzZV9tdWx0aXBsaWNhdGlvblJIUyxcbiAgICAgICAgICAgICAgICBcImRpdmlzaW9uQXJndW1lbnRcIjogcGFyc2VfZGl2aXNpb25Bcmd1bWVudCxcbiAgICAgICAgICAgICAgICBcImRpdmlzaW9uUkhTXCI6IHBhcnNlX2RpdmlzaW9uUkhTLFxuICAgICAgICAgICAgICAgIFwiZXhwb25lbnRpYXRpb25Bcmd1bWVudFwiOiBwYXJzZV9leHBvbmVudGlhdGlvbkFyZ3VtZW50LFxuICAgICAgICAgICAgICAgIFwiZXhwb25lbnRpYXRpb25SSFNcIjogcGFyc2VfZXhwb25lbnRpYXRpb25SSFMsXG4gICAgICAgICAgICAgICAgXCJyZWR1Y2VkQXJndW1lbnRcIjogcGFyc2VfcmVkdWNlZEFyZ3VtZW50LFxuICAgICAgICAgICAgICAgIFwiYnJhY2tldEV4cHJlc3Npb25cIjogcGFyc2VfYnJhY2tldEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgXCJwcmVmaXhGdW5jdGlvblwiOiBwYXJzZV9wcmVmaXhGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBcInJhbmdlZEZ1bmN0aW9uXCI6IHBhcnNlX3JhbmdlZEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIFwiY29uc3RhbnRcIjogcGFyc2VfY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogcGFyc2Vfc3RyaW5nLFxuICAgICAgICAgICAgICAgIFwidmFyaWFibGVcIjogcGFyc2VfdmFyaWFibGUsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IHBhcnNlX25hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcnVsZSBuYW1lOiBcIiArIHF1b3RlKHN0YXJ0UnVsZSkgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRSdWxlID0gXCJleHByZXNzaW9uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIHZhciByZXBvcnRGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSAwO1xuICAgICAgICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlKGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgZXNjYXBlQ2hhcjtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUNoYXIgPSAneCc7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDaGFyID0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlQ2hhciArIHBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksICcwJywgbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoRmFpbGVkKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhwcmVzc2lvblRlbXBsYXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZXhwcmVzc2lvblRlbXBsYXRlQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV92YXJpYWJsZVRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VsZW1lbnRUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2Jvb2xlYW5UZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYm9vbGVhblRlbXBsYXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiYm9vbGVhblRlbXBsYXRlQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3N1YnN0aXR1dGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3N1YnN0aXR1dGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBleHByZXNzaW9uLCBzdWJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uczogc3VicyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9zdWJzdGl0dXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJzdWJzdGl0dXRpb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIltcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJbXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfdmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCItPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiLT5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCItPlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbZnJvbS50b3Bfb3BlcmF0b3JfbmFtZV0gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2VsZW1lbnRUZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImVsZW1lbnRUZW1wbGF0ZUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcInt7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwie3tcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ7e1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2FkZGl0aW9uQXJndW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAxMCkgPT09IFwifGVsZW1lbnR9fVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwifGVsZW1lbnR9fVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ8ZWxlbWVudH19XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfdmFyaWFibGVUZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInZhcmlhYmxlVGVtcGxhdGVAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJ7e1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcInt7XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwie3tcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV92YXJpYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDExKSA9PT0gXCJ8dmFyaWFibGV9fVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwifHZhcmlhYmxlfX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwifHZhcmlhYmxlfX1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAndmFyaWFibGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9saXN0T2ZCb29sZWFuVGVtcGxhdGVzKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwibGlzdE9mQm9vbGVhblRlbXBsYXRlc0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2Jvb2xlYW5UZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSByZXN1bHQwICE9PSBudWxsID8gcmVzdWx0MCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfY29tbWFUaGVuQm9vbGVhblRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfY29tbWFUaGVuQm9vbGVhblRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2LCBhdkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoYXYgPT09ICcnKSA/IFtdIDogW2F2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXZMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXZMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2NvbW1hVGhlbkJvb2xlYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImNvbW1hVGhlbkJvb2xlYW5UZW1wbGF0ZUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIixcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9ib29sZWFuVGVtcGxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2KSB7IHJldHVybiBhdjsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhwcmVzc2lvblRlbXBsYXRlMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImV4cHJlc3Npb25UZW1wbGF0ZTJAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2VsZW1lbnRUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV92YXJpYWJsZVRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYm9vbGVhblRlbXBsYXRlMigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYm9vbGVhblRlbXBsYXRlMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImJvb2xlYW5UZW1wbGF0ZTJAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJ7e1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcInt7XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwie3tcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc3Vic3RpdHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc3Vic3RpdHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJ9fVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBcIn19XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwifX1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBleHByZXNzaW9uLCBzdWJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uczogc3VicyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9mb3JtdWxhTEhTKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZm9ybXVsYUxIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IFwiKFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIihcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfbGlzdE9mVmFyaWFibGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIpXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgbmFtZSwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnYmluYXJ5X2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfb3BlcmF0b3JfbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2xpc3RPZlZhcmlhYmxlcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImxpc3RPZlZhcmlhYmxlc0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3ZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHJlc3VsdDAgIT09IG51bGwgPyByZXN1bHQwIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9jb21tYVRoZW5WYXJpYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2NvbW1hVGhlblZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2LCBhdkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoYXYgPT09ICcnKSA/IFtdIDogW2F2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXZMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXZMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2NvbW1hVGhlblZhcmlhYmxlKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiY29tbWFUaGVuVmFyaWFibGVAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIsXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfdmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2KSB7IHJldHVybiBhdjsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhwcmVzc2lvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImV4cHJlc3Npb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgdmFyIHBvczA7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfaWZmRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgYSkgeyByZXR1cm4gYTsgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfbGlzdE9mRXhwcmVzc2lvbnMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJsaXN0T2ZFeHByZXNzaW9uc0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcmVzdWx0MCAhPT0gbnVsbCA/IHJlc3VsdDAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2NvbW1hVGhlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9jb21tYVRoZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2LCBhdkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoYXYgPT09ICcnKSA/IFtdIDogW2F2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXZMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXZMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2NvbW1hVGhlbkV4cHJlc3Npb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJjb21tYVRoZW5FeHByZXNzaW9uQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCIsXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGF2KSB7IHJldHVybiBhdjsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfaWZmU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiaWZmU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAzKSA9PT0gXCI8PT5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCI8PT5cIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI8PT5cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfaW1wbGllc1N5bWJvbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImltcGxpZXNTeW1ib2xAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIj0+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiPT5cIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI9PlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9mb3JBbGxTeW1ib2woKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJmb3JBbGxTeW1ib2xAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gODcwNCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXHUyMjAwXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHUyMjAwXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2V4aXN0c1N5bWJvbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImV4aXN0c1N5bWJvbEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA4NzA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcdTIyMDNcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcdTIyMDNcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYW5kU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiYW5kU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDg3NDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFx1MjIyN1wiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFx1MjIyN1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9vclN5bWJvbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcIm9yU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDg3NDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFx1MjIyOFwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFx1MjIyOFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9ub3RTeW1ib2woKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJub3RTeW1ib2xAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIn5cIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ+XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2VxdWFsc1N5bWJvbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImVxdWFsc1N5bWJvbEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDYxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI9XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQpIHsgcmV0dXJuICdlcXVhbHMnOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9sZXNzVGhhbk9yRXF1YWxzU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwibGVzc1RoYW5PckVxdWFsc1N5bWJvbEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCI8PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIjw9XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiPD1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCkgeyByZXR1cm4gJ2xlc3NfdGhhbl9vcl9lcXVhbHMnOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9ncmVhdGVyVGhhbk9yRXF1YWxzU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZ3JlYXRlclRoYW5PckVxdWFsc1N5bWJvbEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCI+PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIj49XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiPj1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCkgeyByZXR1cm4gJ2dyZWF0ZXJfdGhhbl9vcl9lcXVhbHMnOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9sZXNzVGhhblN5bWJvbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImxlc3NUaGFuU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiPFwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjxcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCkgeyByZXR1cm4gJ2xlc3NfdGhhbic7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2dyZWF0ZXJUaGFuU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZ3JlYXRlclRoYW5TeW1ib2xAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgdmFyIHBvczA7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCI+XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiPlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0KSB7IHJldHVybiAnZ3JlYXRlcl90aGFuJzsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2Vfbm90RXF1YWxzU3ltYm9sKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwibm90RXF1YWxzU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIiE9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiIT1cIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIhPVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0KSB7IHJldHVybiAnbm90X2VxdWFscyc7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX21lbWJlcnNoaXBTeW1ib2woKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJtZW1iZXJzaGlwU3ltYm9sQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gODcxMikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXHUyMjA4XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXHUyMjA4XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQpIHsgcmV0dXJuICdpc19pbic7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2FkZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiYWRkaXRpb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiK1wiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIitcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2Vfc3VidHJhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJzdWJ0cmFjdGlvbkBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9tdWx0aXBsaWNhdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcIm11bHRpcGxpY2F0aW9uQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIqXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2RpdmlzaW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZGl2aXNpb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiL1wiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi9cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhwb25lbnRpYXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJleHBvbmVudGlhdGlvbkBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA5NCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJeXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9pZmZGb3JtdWxhKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiaWZmRm9ybXVsYUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2ltcGxpZXNGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2lmZlN5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2lmZkZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdpZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pbXBsaWVzRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2ltcGxpZXNGb3JtdWxhKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiaW1wbGllc0Zvcm11bGFAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9xdWFudGlmaWVyRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9pbXBsaWVzU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfaW1wbGllc0Zvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdpbXBsaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtsZWZ0LCByaWdodF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcXVhbnRpZmllckZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9xdWFudGlmaWVyRm9ybXVsYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInF1YW50aWZpZXJGb3JtdWxhQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9mb3JBbGxGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX29yRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2ZvckFsbEZvcm11bGEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJmb3JBbGxGb3JtdWxhQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3ZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIuXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiAhPT0gbnVsbCA/IHJlc3VsdDIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfcXVhbnRpZmllckZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ3F1YW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnZm9yX2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbcmlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtsZWZ0XVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9leGlzdHNGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhpc3RzRm9ybXVsYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImV4aXN0c0Zvcm11bGFAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9leGlzdHNTeW1ib2woKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfdmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi5cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyICE9PSBudWxsID8gcmVzdWx0MiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9xdWFudGlmaWVyRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAncXVhbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdleGlzdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW3JpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbbGVmdF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYm91bmRlZEZvckFsbEZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9ib3VuZGVkRm9yQWxsRm9ybXVsYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImJvdW5kZWRGb3JBbGxGb3JtdWxhQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0LCByZXN1bHQ1O1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3ZhcmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfYm91bmRhYmxlSW5maXhSZWxhdGlvbk5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX2FkZGl0aW9uQXJndW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NCA9IFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi5cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSByZXN1bHQ0ICE9PSBudWxsID8gcmVzdWx0NCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ1ID0gcGFyc2VfcXVhbnRpZmllckZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0LCByZXN1bHQ1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGssIHJlbGF0aW9uLCBuLCBBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdib3VuZGVkX3F1YW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnYm91bmRlZF9mb3JfYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiByZWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2ssIG5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgQV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW2tdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdLCByZXN1bHQwWzNdLCByZXN1bHQwWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2JvdW5kZWRFeGlzdHNGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYm91bmRlZEV4aXN0c0Zvcm11bGEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJib3VuZGVkRXhpc3RzRm9ybXVsYUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2V4aXN0c1N5bWJvbCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV92YXJpYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2JvdW5kYWJsZUluZml4UmVsYXRpb25OYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9hZGRpdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIuXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcmVzdWx0NCAhPT0gbnVsbCA/IHJlc3VsdDQgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NSA9IHBhcnNlX3F1YW50aWZpZXJGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBrLCByZWxhdGlvbiwgbiwgQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnYm91bmRlZF9xdWFudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfb3BlcmF0b3JfbmFtZTogJ2JvdW5kZWRfZXhpc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnYmluYXJ5X3JlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiByZWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2ssIG5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgQV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW2tdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdLCByZXN1bHQwWzNdLCByZXN1bHQwWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9vckZvcm11bGEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJvckZvcm11bGFAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9hbmRGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX29yU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfcXVhbnRpZmllckZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbGVmdCwgcmlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2FuZEZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9hbmRGb3JtdWxhKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiYW5kRm9ybXVsYUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VuYXJ5Rm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9hbmRTeW1ib2woKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9hbmRSSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfY29ubmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdhbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bmFyeUZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9hbmRSSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJhbmRSSFNAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2ZvckFsbEZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYW5kRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX3VuYXJ5Rm9ybXVsYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInVuYXJ5Rm9ybXVsYUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfbm90Rm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pbmZpeFJlbGF0aW9uRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX25vdEZvcm11bGEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJub3RGb3JtdWxhQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfbm90U3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX25vdFJIUygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ3VuYXJ5X2Nvbm5lY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnbm90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtyaWdodF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX25vdFJIUygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcIm5vdFJIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV91bmFyeUZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9pbmZpeFJlbGF0aW9uRm9ybXVsYSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImluZml4UmVsYXRpb25Gb3JtdWxhQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYWRkaXRpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9pbmZpeFJlbGF0aW9uTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2luZml4UmVsYXRpb25SSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIG5hbWUsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfcmVsYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9hZGRpdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfaW5maXhSZWxhdGlvbk5hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJpbmZpeFJlbGF0aW9uTmFtZUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZXF1YWxzU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2xlc3NUaGFuT3JFcXVhbHNTeW1ib2woKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ncmVhdGVyVGhhbk9yRXF1YWxzU3ltYm9sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9sZXNzVGhhblN5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ncmVhdGVyVGhhblN5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25vdEVxdWFsc1N5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbWVtYmVyc2hpcFN5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYm91bmRhYmxlSW5maXhSZWxhdGlvbk5hbWUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJib3VuZGFibGVJbmZpeFJlbGF0aW9uTmFtZUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbGVzc1RoYW5PckVxdWFsc1N5bWJvbCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9sZXNzVGhhblN5bWJvbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX21lbWJlcnNoaXBTeW1ib2woKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2luZml4UmVsYXRpb25SSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJpbmZpeFJlbGF0aW9uUkhTQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9mb3JBbGxGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25vdEZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pbmZpeFJlbGF0aW9uRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYWRkaXRpb25Bcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImFkZGl0aW9uQXJndW1lbnRAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zdWJ0cmFjdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2FkZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfYWRkaXRpb25SSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnYWRkaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zdWJ0cmFjdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfYWRkaXRpb25SSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJhZGRpdGlvblJIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3RGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYWRkaXRpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2Vfc3VidHJhY3Rpb25Bcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInN1YnRyYWN0aW9uQXJndW1lbnRAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9tdWx0aXBsaWNhdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3N1YnRyYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc3VidHJhY3Rpb25SSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnc3VidHJhY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9tdWx0aXBsaWNhdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2Vfc3VidHJhY3Rpb25SSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJzdWJ0cmFjdGlvblJIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3RGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfc3VidHJhY3Rpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfbXVsdGlwbGljYXRpb25Bcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcIm11bHRpcGxpY2F0aW9uQXJndW1lbnRAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9kaXZpc2lvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX211bHRpcGxpY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfbXVsdGlwbGljYXRpb25SSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnbXVsdGlwbGljYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9kaXZpc2lvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfbXVsdGlwbGljYXRpb25SSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJtdWx0aXBsaWNhdGlvblJIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3RGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbXVsdGlwbGljYXRpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZGl2aXNpb25Bcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImRpdmlzaW9uQXJndW1lbnRAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9leHBvbmVudGlhdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2RpdmlzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfZGl2aXNpb25SSFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdiaW5hcnlfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnZGl2aXNpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9leHBvbmVudGlhdGlvbkFyZ3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZGl2aXNpb25SSFMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJkaXZpc2lvblJIU0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZm9yQWxsRm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9ub3RGb3JtdWxhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfZGl2aXNpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfZXhwb25lbnRpYXRpb25Bcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcImV4cG9uZW50aWF0aW9uQXJndW1lbnRAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9yZWR1Y2VkQXJndW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZXhwb25lbnRpYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9leHBvbmVudGlhdGlvblJIUygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ2JpbmFyeV9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6ICdleHBvbmVudGlhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbGVmdCwgcmlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3JlZHVjZWRBcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2V4cG9uZW50aWF0aW9uUkhTKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiZXhwb25lbnRpYXRpb25SSFNAXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2ZvckFsbEZvcm11bGEoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2Vfbm90Rm9ybXVsYSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2V4cG9uZW50aWF0aW9uQXJndW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX3JlZHVjZWRBcmd1bWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInJlZHVjZWRBcmd1bWVudEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfYnJhY2tldEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfcHJlZml4RnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9jb25zdGFudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX2JyYWNrZXRFeHByZXNzaW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwiYnJhY2tldEV4cHJlc3Npb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIihcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIoXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiKVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgZSkgeyByZXR1cm4gZTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfcHJlZml4RnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJwcmVmaXhGdW5jdGlvbkBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IFwiKFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIihcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfbGlzdE9mRXhwcmVzc2lvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MyA9IFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIilcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbiAob2Zmc2V0LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICdwcmVmaXhfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9yYW5nZWRGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX3JhbmdlZEZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwicmFuZ2VkRnVuY3Rpb25AXCIgKyBwb3M7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDQsIHJlc3VsdDUsIHJlc3VsdDYsIHJlc3VsdDc7XG4gICAgICAgICAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9uYW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gXCJ7XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwie1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV92YXJpYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfYm91bmRhYmxlSW5maXhSZWxhdGlvbk5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcGFyc2VfYWRkaXRpb25Bcmd1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NSA9IFwifFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInxcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NiA9IHBhcnNlX2V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDcgPSBcIn1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0NyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ9XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0LCByZXN1bHQ1LCByZXN1bHQ2LCByZXN1bHQ3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgbmFtZSwgaywgcmVsYXRpb24sIG4sIEEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ3JhbmdlZF9mdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ2JpbmFyeV9yZWxhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfb3BlcmF0b3JfbmFtZTogcmVsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtrLCBuXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIEFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtrXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsyXSwgcmVzdWx0MFszXSwgcmVzdWx0MFs0XSwgcmVzdWx0MFs2XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VfY29uc3RhbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJjb25zdGFudEBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmICgvXlswLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIGRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnY29uc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiBwYXJzZUludChkaWdpdHMuam9pbihcIlwiKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbWllczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInN0cmluZ0BcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiJ1wiO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIidcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eW2EtekEtWjAtOV9dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW2EtekEtWjAtOV9dXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15bYS16QS1aMC05X10vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW2EtekEtWjAtOV9dXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gXCInXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiJ1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgY2hhcmFjdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiAnY29uc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9vcGVyYXRvcl9uYW1lOiAnXFwnJyArIGNoYXJhY3RlcnMuam9pbignJykgKyAnXFwnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV92YXJpYWJsZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBcInZhcmlhYmxlQFwiICsgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICAgICAgICAgIHZhciBwb3MwO1xuICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX25hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uIChvZmZzZXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogJ3ZhcmlhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfb3BlcmF0b3JfbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZV9uYW1lKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IFwibmFtZUBcIiArIHBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKC9eW0EtWmEtel0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIltBLVphLXpdXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eW0EtWmEtejAtOV9dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW0EtWmEtejAtOV9dXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15bQS1aYS16MC05X10vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW0EtWmEtejAtOV9dXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24gKG9mZnNldCwgZmlyc3QsIG1pZGRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ICsgbWlkZGxlLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZC5zb3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RFeHBlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFuRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZFtpXSAhPT0gbGFzdEV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbkV4cGVjdGVkLnB1c2goZXhwZWN0ZWRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEV4cGVjdGVkID0gZXhwZWN0ZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuRXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wdXRlRXJyb3JQb3NpdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZSBmaXJzdCBpZGVhIHdhcyB0byB1c2UgfFN0cmluZy5zcGxpdHwgdG8gYnJlYWsgdGhlIGlucHV0IHVwIHRvIHRoZVxuICAgICAgICAgICAgICAgICAqIGVycm9yIHBvc2l0aW9uIGFsb25nIG5ld2xpbmVzIGFuZCBkZXJpdmUgdGhlIGxpbmUgYW5kIGNvbHVtbiBmcm9tXG4gICAgICAgICAgICAgICAgICogdGhlcmUuIEhvd2V2ZXIgSUUncyB8c3BsaXR8IGltcGxlbWVudGF0aW9uIGlzIHNvIGJyb2tlbiB0aGF0IGl0IHdhc1xuICAgICAgICAgICAgICAgICAqIGVub3VnaCB0byBwcmV2ZW50IGl0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5DUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uc1tzdGFydFJ1bGVdKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDEuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgd2hvbGUgaW5wdXQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICAgICAgICogICAgLSB8cG9zID09PSBpbnB1dC5sZW5ndGh8XG4gICAgICAgICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDIuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbmx5IGEgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICAgICAgICogICAgLSB8cG9zIDwgaW5wdXQubGVuZ3RofFxuICAgICAgICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgIC0gfHJlc3VsdCA9PT0gbnVsbHxcbiAgICAgICAgICAgICAqICAgLSB8cG9zID09PSAwfFxuICAgICAgICAgICAgICogICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFsbCBjb2RlIGZvbGxvd2luZyB0aGlzIGNvbW1lbnQgKGluY2x1ZGluZyBjYWxsZWQgZnVuY3Rpb25zKSBtdXN0XG4gICAgICAgICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpO1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IG9mZnNldCA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChvZmZzZXQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9IGNvbXB1dGVFcnJvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuU3ludGF4RXJyb3IoY2xlYW51cEV4cGVjdGVkKHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQpLCBmb3VuZCwgb2Zmc2V0LCBlcnJvclBvc2l0aW9uLmxpbmUsIGVycm9yUG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIFJldHVybnMgdGhlIHBhcnNlciBzb3VyY2UgY29kZS4gKi9cbiAgICAgICAgdG9Tb3VyY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfSxcbiAgICAgICAgU3ludGF4RXJyb3I6IG51bGxcbiAgICB9O1xuICAgIC8qIFRocm93biB3aGVuIGEgcGFyc2VyIGVuY291bnRlcnMgYSBzeW50YXggZXJyb3IuICovXG4gICAgcmVzdWx0LlN5bnRheEVycm9yID0gZnVuY3Rpb24gKGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkSHVtYW5pemVkLCBmb3VuZEh1bWFuaXplZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBleHBlY3RlZC5sZW5ndGggLSAxKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgZXhwZWN0ZWRbZXhwZWN0ZWQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZEh1bWFuaXplZCA9IGZvdW5kID8gcXVvdGUoZm91bmQpIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWRIdW1hbml6ZWQgKyBcIiBidXQgXCIgKyBmb3VuZEh1bWFuaXplZCArIFwiIGZvdW5kLlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfTtcbiAgICByZXN1bHQuU3ludGF4RXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9naWNQcm9vZlBhcnNlcjtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcG9uZW50cyB1c2VkIGJ5IGJvdGggdGhlIGVkaXRvciBhbmQgcmVhZGVyIG9mIHRoZVxuICogIExvZ2ljUHJvb2YgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBnZW5lcmF0ZWRQYXJzZXJfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2dlbmVyYXRlZFBhcnNlci50c1wiKSk7XG52YXIgbG9naWNQcm9vZlNoYXJlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVXNlZCBieSBwYXJzZUxpbmVTdHJpbmcoKSB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIHBvc3NpYmxlIHBhcnNpbmdzIG9mIGFcbiAgICAvLyBsaW5lIChvciBsaW5lIHRlbXBsYXRlKSBjb25zaWRlcmVkLlxuICAgIHZhciBNQVhfTlVNX1BBUlNJTkdTX1BFUk1JVFRFRCA9IDEwMDA7XG4gICAgLy8gVXNlZCBieSBhc3NpZ25UeXBlc1RvRXhwcmVzc2lvbkFycmF5KCkgdG8gbGltaXQgdGhlIG51bWJlciBvZiBwb3NzaWJsZVxuICAgIC8vIHR5cGluZ3Mgb2YgYW4gZXhwcmVzc2lvbiBjb25zaWRlcmVkLlxuICAgIHZhciBNQVhfTlVNX1RZUElOR1NfUEVSTUlUVEVEID0gMTAwMDtcbiAgICAvLyBFUlJPUi1IQU5ETElOR1xuICAgIC8vIFVzZXJFcnJvcnMgaGF2ZSBjb2RlcyB0aGF0IHJlZmVyIHRvIGVudHJpZXMgaW4gdGhlIGVycm9yRGljdGlvbmFyeSAod2hpY2hcbiAgICAvLyBpcyBlaXRoZXIgbG9naWNQcm9vZkRhdGEuQkFTRV9HRU5FUkFMX01FU1NBR0VTIG9yXG4gICAgLy8gbG9naWNQcm9vZlRlYWNoZXIuVEVBQ0hFUl9FUlJPUl9NRVNTQUdFUyksIGZyb20gd2hpY2ggYSBodW1hbi1yZWFkYWJsZVxuICAgIC8vIG1lc3NhZ2UgY2FuIGJlIGNvbnN0cnVjdGVkLlxuICAgIHZhciBVc2VyRXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgcGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLm5hbWUgPSAnVXNlckVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcbiAgICB9O1xuICAgIC8vIFRoZXNlIGVycm9ycyBhbHJlYWR5IGhhdmUgbWVzc2FnZXMgd2hpY2ggYXJlIHVzZXItcmVhZGFibGUuXG4gICAgdmFyIFByZVJlbmRlcmVkVXNlckVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBjb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdQcmVSZW5kZXJlZFVzZXJFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9O1xuICAgIC8vIFRPRE8oSmFjb2IpOiBNYWtlIHRoZXNlIGVycm9ycyBwcm90b3R5cGUgZnJvbSBFcnJvcigpXG4gICAgLyoqIENvbnZlcnRzIGEgbWVzc2FnZSB0ZW1wbGF0ZSBpbnRvIGEgc3RyaW5nIHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VUZW1wbGF0ZTogYSBHZW5lcmFsTWVzc2FnZVRlbXBsYXRlIG9iamVjdCB0aGF0IGRldGVybWluZXMgaG93XG4gICAgICogdG8gYnVpbGQgdGhlIHN0cmluZyBkZXNjcmliaW5nIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJGb3JtYXRzOiBhIGRpY3Rpb25hcnkgb2YgR2VuZXJhbE1lc3NhZ2VQYXJhbWV0ZXJzLCB3aGljaFxuICAgICAqICAgICAgICBzcGVjaWZ5IHRoZSBmb3JtYXQgb2YgdGhlIHBhcmFtZXRlciBpbiBxdWVzdGlvbiAoZS5nLiAnc3RyaW5nJykuXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnM6IGEgZGljdGlvbmFyeSBnaXZpbmcgdGhlIHZhbHVlcyBvZiB0aGUgcGFyYW1ldGVycyBmb3JcbiAgICAgKiAgICAgICAgdGhpcyBwYXJ0aWN1bGFyIGluc3RhbmNlIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZTogdGhlIHJlbGV2YW50IExhbmd1YWdlLlxuICAgICAqIEByZXN1bHQgYSB1c2VyLXJlYWRhYmxlIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgcmVuZGVyR2VuZXJhbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZVRlbXBsYXRlLCBwYXJhbWV0ZXJGb3JtYXRzLCBwYXJhbWV0ZXJzLCBsYW5ndWFnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VUZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VUZW1wbGF0ZVtpXS5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBtZXNzYWdlVGVtcGxhdGVbaV0uY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJGb3JtYXQgPSBwYXJhbWV0ZXJGb3JtYXRzW21lc3NhZ2VUZW1wbGF0ZVtpXS5jb250ZW50XS5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbbWVzc2FnZVRlbXBsYXRlW2ldLmNvbnRlbnRdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1ldGVyRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IHBhcmFtZXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdleHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZGlzcGxheUV4cHJlc3Npb24ocGFyYW1ldGVyLCBsYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBmb3JtYXQgJyArIHBhcmFtZXRlckZvcm1hdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBzZW50IHRvIHJlbmRlckdlbmVyYWxNZXNzYWdlKCkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVc2VyRXJyb3J9IGVycm9yIC0gYSBVc2VyRXJyb3Igb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVycm9yRGljdGlvbmFyeSAtIGEgZGljdGlvbmFyeSBrZXllZCBieSBlcnJvciBjb2RlcyBmb3JcbiAgICAgKiAgICAgICAgZWFjaCBvZiB3aGljaCBpdCBwcm92aWRlcyBhIGRlc2NyaXB0aW9uIG9mIHBvc3NpYmxlIHdheXMgdG8gZGlzcGxheVxuICAgICAqICAgICAgICB0aGUgZXJyb3IgdG8gdGhlIHVzZXIsIG9uZSBvZiB3aGljaCB3aWxsIGJlIGNob3NlbiBhdCByYW5kb20uXG4gICAgICogQHBhcmFtIHtMYW5ndWFnZX0gbGFuZ3VhZ2UgLSB0aGUgcmVsZXZhbnQgTGFuZ3VhZ2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHRvIHNob3cgdG8gdGhlIHVzZXIgZGVzY3JpYmluZyB3aGF0IHdlbnQgd3JvbmcuXG4gICAgICovXG4gICAgdmFyIHJlbmRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlcnJvckRpY3Rpb25hcnksIGxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVXNlckVycm9yJykge1xuICAgICAgICAgICAgaWYgKCFlcnJvckRpY3Rpb25hcnkuaGFzT3duUHJvcGVydHkoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3IgY29kZSAnICsgZXJyb3IuY29kZSArICcgc2VudCB0byByZW5kZXJFcnJvcigpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1lc3NhZ2VUZW1wbGF0ZXMgPSBlcnJvckRpY3Rpb25hcnlbZXJyb3IuY29kZV0udGVtcGxhdGVzO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VUZW1wbGF0ZSA9IG1lc3NhZ2VUZW1wbGF0ZXNbTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIG1lc3NhZ2VUZW1wbGF0ZXMubGVuZ3RoKSldO1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckdlbmVyYWxNZXNzYWdlKG1lc3NhZ2VUZW1wbGF0ZSwgZXJyb3JEaWN0aW9uYXJ5W2Vycm9yLmNvZGVdLnBhcmFtZXRlcnMsIGVycm9yLnBhcmFtZXRlcnMsIGxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnUHJlUmVuZGVyZWRVc2VyRXJyb3InKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZXNbTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIGVycm9yLm1lc3NhZ2VzLmxlbmd0aCkpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBESVNQTEFZXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFeHByZXNzaW9ufSBleHByZXNzaW9uIC0gYW4gRXhwcmVzc2lvbiwgd2hpY2ggaXMgdG8gYmUgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdG9ycyAtIHByb3ZpZGVzIHRoZSBzeW1ib2xzIGtleXMgb2YgdGhlIG9wZXJhdG9ycyBzb1xuICAgICAqICAgICAgICB0aGF0IHdlIHdlIGtub3cgZS5nLiAnZm9yX2FsbCcgc2hvdWxkIGJlIGRpc3BsYXllZCB1c2luZyAnQCcuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgc2hvd24gdG9cbiAgICAgKiAgICAgICAgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdmFyIGRpc3BsYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9wZXJhdG9ycykge1xuICAgICAgICByZXR1cm4gZGlzcGxheUV4cHJlc3Npb25IZWxwZXIoZXhwcmVzc2lvbiwgb3BlcmF0b3JzLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGRpc3BsYXlFeHByZXNzaW9uKCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V4cHJlc3Npb259IGV4cHJlc3Npb24gLSBhbiBFeHByZXNzaW9uLCB3aGljaCBpcyB0byBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3JzIC0gcHJvdmlkZXMgdGhlIHN5bWJvbHMga2V5cyBvZiB0aGUgb3BlcmF0b3JzIHNvXG4gICAgICogICAgICAgIHRoYXQgd2Ugd2Uga25vdyBlLmcuICdmb3JfYWxsJyBzaG91bGQgYmUgZGlzcGxheWVkIHVzaW5nICdAJy5cbiAgICAgKiBAcGFyYW0ge2ludH0gZGVzaXJhYmlsaXR5T2ZCcmFja2V0cyAtIHVzZWQgaW50ZXJuYWxseSB0byBkZXRlcm1pbmUgd2hldGhlclxuICAgICAqICAgICAgICB0byBzdXJyb3VuZCB0aGUgZm9ybXVsYSB3aXRoIGJyYWNrZXRzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIHZhciBkaXNwbGF5RXhwcmVzc2lvbkhlbHBlciA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcGVyYXRvcnMsIGRlc2lyYWJpbGl0eU9mQnJhY2tldHMpIHtcbiAgICAgICAgaWYgKGRlc2lyYWJpbGl0eU9mQnJhY2tldHMgPT09IHZvaWQgMCkgeyBkZXNpcmFiaWxpdHlPZkJyYWNrZXRzID0gMDsgfVxuICAgICAgICB2YXIgZGVzaXJhYmlsaXR5T2ZCcmFja2V0c0JlbG93ID0gKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ2JpbmFyeV9jb25uZWN0aXZlJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnYmluYXJ5X3JlbGF0aW9uJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnYmluYXJ5X2Z1bmN0aW9uJykgPyAyIDogKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ3VuYXJ5X2Nvbm5lY3RpdmUnIHx8XG4gICAgICAgICAgICBleHByZXNzaW9uLnRvcF9raW5kX25hbWUgPT09ICdxdWFudGlmaWVyJykgPyAxIDogMDtcbiAgICAgICAgdmFyIHByb2Nlc3NlZEFyZ3VtZW50cyA9IFtdO1xuICAgICAgICB2YXIgcHJvY2Vzc2VkRHVtbWllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24uYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRBcmd1bWVudHMucHVzaChkaXNwbGF5RXhwcmVzc2lvbkhlbHBlcihleHByZXNzaW9uLmFyZ3VtZW50c1tpXSwgb3BlcmF0b3JzLCBkZXNpcmFiaWxpdHlPZkJyYWNrZXRzQmVsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24uZHVtbWllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvY2Vzc2VkRHVtbWllcy5wdXNoKGRpc3BsYXlFeHByZXNzaW9uSGVscGVyKGV4cHJlc3Npb24uZHVtbWllc1tpXSwgb3BlcmF0b3JzLCBkZXNpcmFiaWxpdHlPZkJyYWNrZXRzQmVsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltYm9sID0gKCFvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSkpID9cbiAgICAgICAgICAgIGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUgOlxuICAgICAgICAgICAgKCFvcGVyYXRvcnNbZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZV0uaGFzT3duUHJvcGVydHkoJ3N5bWJvbHMnKSkgP1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUgOlxuICAgICAgICAgICAgICAgIG9wZXJhdG9yc1tleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXS5zeW1ib2xzWzBdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ2JpbmFyeV9jb25uZWN0aXZlJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnYmluYXJ5X3JlbGF0aW9uJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnYmluYXJ5X2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIChkZXNpcmFiaWxpdHlPZkJyYWNrZXRzID4gMCA/XG4gICAgICAgICAgICAgICAgJygnICsgcHJvY2Vzc2VkQXJndW1lbnRzLmpvaW4oc3ltYm9sKSArICcpJyA6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXJndW1lbnRzLmpvaW4oc3ltYm9sKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAndW5hcnlfY29ubmVjdGl2ZScpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHN5bWJvbCArIHByb2Nlc3NlZEFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJldHVybiAoZGVzaXJhYmlsaXR5T2ZCcmFja2V0cyA9PT0gMikgPyAnKCcgKyBvdXRwdXQgKyAnKScgOiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAncXVhbnRpZmllcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHN5bWJvbCArIHByb2Nlc3NlZER1bW1pZXNbMF0gKyAnLicgKyBwcm9jZXNzZWRBcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gKGRlc2lyYWJpbGl0eU9mQnJhY2tldHMgPT09IDIpID8gJygnICsgb3V0cHV0ICsgJyknIDogb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ2JvdW5kZWRfcXVhbnRpZmllcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHN5bWJvbCArIHByb2Nlc3NlZEFyZ3VtZW50c1swXSArICcuJyArIHByb2Nlc3NlZEFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJldHVybiAoZGVzaXJhYmlsaXR5T2ZCcmFja2V0cyA9PT0gMikgPyAnKCcgKyBvdXRwdXQgKyAnKScgOiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAncHJlZml4X3JlbGF0aW9uJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAncHJlZml4X2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbCArICcoJyArIHByb2Nlc3NlZEFyZ3VtZW50cy5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAncmFuZ2VkX2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIChzeW1ib2wgKyAneycgKyBwcm9jZXNzZWRBcmd1bWVudHNbMF0gKyAnIHwgJyArIHByb2Nlc3NlZEFyZ3VtZW50c1sxXSArXG4gICAgICAgICAgICAgICAgJ30nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByZXNzaW9uLnRvcF9raW5kX25hbWUgPT09ICdhdG9tJyB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnY29uc3RhbnQnIHx8XG4gICAgICAgICAgICBleHByZXNzaW9uLnRvcF9raW5kX25hbWUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBraW5kICcgKyBleHByZXNzaW9uLnRvcF9raW5kX25hbWUgK1xuICAgICAgICAgICAgICAgICcgc2VudCB0byBkaXNwbGF5RXhwcmVzc2lvbigpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkaXNwbGF5RXhwcmVzc2lvbkFycmF5ID0gZnVuY3Rpb24gKGV4cHJlc3Npb25BcnJheSwgb3BlcmF0b3JzKSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWRBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvY2Vzc2VkQXJyYXkucHVzaChkaXNwbGF5RXhwcmVzc2lvbkhlbHBlcihleHByZXNzaW9uQXJyYXlbaV0sIG9wZXJhdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRBcnJheS5qb2luKCcsICcpO1xuICAgIH07XG4gICAgLy8gUEFSU0lOR1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHdoZXRoZXIgdGhlIHN0cmluZyBjb250YWlucyBhbnkgc3ltYm9sIHRoYXQgb2NjdXJzXG4gICAgICogaW4gYSBtZW1iZXIgb2YgdGhlIHN5bWJvbHMga2V5IGZvciBzb21lIG9wZXJhdG9yICh0aGVzZSB3aWxsIGJlXG4gICAgICogc3ltYm9scyBzdWNoIGFzIOKIgCwgPSwgPCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHdlIGNoZWNrXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdG9ycyAtIGEgZGljdGlvbmFyeSBvZiBPcGVyYXRvciBvYmplY3RzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1RlbXBsYXRlIC0gZGVub3RlcyB0aGF0IHRoZSBzdHJpbmcgcmVwcmVzZW50cyBhIGxpbmVcbiAgICAgKiAgICAgICAgdGVtcGxhdGUgKHdoaWNoIG1heSBoYXZlIHN1YnN0aXR1dGlvbnMpIGFuZCBub3QganVzdCBhIGxpbmUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZVxuICAgICAqL1xuICAgIHZhciBjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcGVyYXRvcnMsIGlzVGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIEdFTkVSQUxfTE9HSUNBTF9DSEFSQUNURVJTID0gJygpLCc7XG4gICAgICAgIHZhciBURU1QTEFURV9MT0dJQ0FMX0NIQVJBQ1RFUlMgPSAnWy0+XXt8fSc7XG4gICAgICAgIGlmIChjb250YWluc0NoYXJhY3RlckZyb21BcnJheShzdHJpbmcsIEdFTkVSQUxfTE9HSUNBTF9DSEFSQUNURVJTKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zQ2hhcmFjdGVyRnJvbUFycmF5KHN0cmluZywgVEVNUExBVEVfTE9HSUNBTF9DSEFSQUNURVJTKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wZXJhdG9ycykge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yc1trZXldLmhhc093blByb3BlcnR5KCdzeW1ib2xzJykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdG9yc1trZXldLnN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2hlY2sgZWFjaCBjaGFyYWN0ZXIgb2YgYSBtdWx0aS1jaGFyYWN0ZXIgc3ltYm9sIGluIHR1cm4uXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BlcmF0b3JzW2tleV0uc3ltYm9sc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKG9wZXJhdG9yc1trZXldLnN5bWJvbHNbaV1bal0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB3aXRoaW4gZXhwcmVzc2lvbnMsIHdoaWxzdCB1c2luZyB0aGVcbiAgICAgKiB3aGl0ZXNwYWNlIGJldHdlZW4gZXhwcmVzc2lvbnMgdG8gc3BsaXQgYSBsaW5lIGludG8gYW4gYXJyYXkgb2Ygd29yZCAvXG4gICAgICogZXhwcmVzc2lvbiBzdHJpbmdzLlxuICAgICAqICBlLmcuICdmcm9tIHAgYW5kIHEgd2UgaGF2ZSBwIOKIpyBxJyB3aWxsIGJlIGNvbnZlcnRlZCB0byBbJ2Zyb20nLCAncCcsXG4gICAgICogICAnYW5kJywgJ3EnLCAnd2UnLCAnaGF2ZScsICdw4oincSddLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFN0cmluZyAtIHRoZSBzdHJpbmcgZnJvbSB3aGljaCB3aGl0ZXNwYWNlIGlzIHRvIGJlXG4gICAgICogICAgICAgIHN0cmlwcGVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRvcnMgLSBhIGRpY3Rpb25hcnkgb2YgdGhlIE9wZXJhdG9yIG9iamVjdHMgdXNhYmxlIGluXG4gICAgICogICAgICAgIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1RlbXBsYXRlIC0gZGVub3RlcyB0aGF0IHRoZSBzdHJpbmcgcmVwcmVzZW50cyBhIGxpbmVcbiAgICAgKiAgICAgICAgdGVtcGxhdGUgKHdoaWNoIG1heSBoYXZlIHN1YnN0aXR1dGlvbnMpIGFuZCBub3QganVzdCBhIGxpbmUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbm9uLWVtcHR5IGFycmF5IG9mIHdvcmRzIGFuZCBleHByZXNzaW9ucyAoYXMgc3RyaW5ncykuXG4gICAgICogQHRocm93cyBpZiB0aGUgbGluZSBpcyBibGFuayBvciBjb250YWlucyBhbiB1bmtub3duIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICB2YXIgcHJlUGFyc2VMaW5lU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0U3RyaW5nLCBvcGVyYXRvcnMsIGlzVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gVGhlIGxvZ2ljYWwgY2hhcmFjdGVycyB0aGF0IG1heSBvY2N1ciBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhIGZvcm11bGFcbiAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LiBUaGUgdW5pY29kZSBjaGFyYWN0ZXJzIGFyZSAnZm9yIGFsbCcgYW5kICdleGlzdHMnLlxuICAgICAgICB2YXIgUE9TU0lCTEVfU1RBUlRfQ0hBUlMgPSAnKHtcXHUyMjAwXFx1MjIwM34nO1xuICAgICAgICB2YXIgUE9TU0lCTEVfRU5EX0NIQVJTID0gJyl9XSc7XG4gICAgICAgIHZhciBQT1NTSUJMRV9OQU1FX0NIQVJTID0gKCdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSBfJyk7XG4gICAgICAgIHZhciBfYWJzb3Jic1NwYWNlc1RvVGhlTGVmdCA9IGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIoY2hhcmFjdGVyLCBvcGVyYXRvcnMsIGlzVGVtcGxhdGUpICYmXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zQ2hhcmFjdGVyKFBPU1NJQkxFX1NUQVJUX0NIQVJTLCBjaGFyYWN0ZXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2Fic29yYnNTcGFjZXNUb1RoZVJpZ2h0ID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIoY2hhcmFjdGVyLCBvcGVyYXRvcnMsIGlzVGVtcGxhdGUpICYmXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zQ2hhcmFjdGVyKFBPU1NJQkxFX0VORF9DSEFSUywgY2hhcmFjdGVyKSkgfHxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPT09ICcgJztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9pc0xlZ2FsQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zQ2hhcmFjdGVyKFBPU1NJQkxFX05BTUVfQ0hBUlMsIGNoYXJhY3RlcikgfHxcbiAgICAgICAgICAgICAgICBjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIoY2hhcmFjdGVyLCBvcGVyYXRvcnMsIGlzVGVtcGxhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RyaXBwZWRTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFfaXNMZWdhbENoYXJhY3RlcihpbnB1dFN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlckVycm9yKCdpbGxlZ2FsX3N5bWJvbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBpbnB1dFN0cmluZ1tpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Uga2VlcCBhbGwgbm9uLXNwYWNlcywgYW5kIGFsbCBzcGFjZXMgdGhhdCBhcmUgYWJzb3JiZWQgbmVpdGhlciBieVxuICAgICAgICAgICAgLy8gY2hhcmFjdGVycyB0byB0aGVpciBsZWZ0IG5vciB0aGVpciByaWdodC5cbiAgICAgICAgICAgIGlmIChpbnB1dFN0cmluZ1tpXSAhPT0gJyAnIHx8XG4gICAgICAgICAgICAgICAgKGkgPT09IDAgfHwgIV9hYnNvcmJzU3BhY2VzVG9UaGVSaWdodChzdHJpcHBlZFN0cmluZ1tzdHJpcHBlZFN0cmluZy5sZW5ndGggLSAxXSkpICYmXG4gICAgICAgICAgICAgICAgICAgIChpID09PSBpbnB1dFN0cmluZy5sZW5ndGggLSAxIHx8ICFfYWJzb3Jic1NwYWNlc1RvVGhlTGVmdChpbnB1dFN0cmluZ1tpICsgMV0pKSkge1xuICAgICAgICAgICAgICAgIHN0cmlwcGVkU3RyaW5nICs9IGlucHV0U3RyaW5nW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpcHBlZFN0cmluZy5yZXBsYWNlKC8gL2csICcnKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVc2VyRXJyb3IoJ2JsYW5rX2xpbmUnLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmlwcGVkU3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U3RyaW5nIC0gd3JpdHRlbiBieSB0aGUgdXNlciAtIHdlIHdpbGwgcGFyc2UgaXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdG9ycyAtIHRoZSByZWxldmFudCBvcGVyYXRvcnMsIHdoaWNoIGFyZSBqdXN0IG5lZWRlZFxuICAgICAqICAgICAgICBmb3IgdGhlaXIgc3ltYm9scyBzbyB3ZSBjYW4gaWRlbnRpZnkgd2hldGhlciB0aGUgc3ltYm9scyB0aGUgdXNlclxuICAgICAqICAgICAgICBpcyB1c2luZyBhcmUgbGVnaXRpbWF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdm9jYWJ1bGFyeSAtIGEgZGljdGlvbmFyeSB3aG9zZSBrZXlzIGFyZSBwaHJhc2VzIHN1Y2ggYXNcbiAgICAgKiAgICAgICAgJ2hhdmUnIHdob3NlIGVudHJpZXMgYXJlIGFycmF5cyBvZiBwb3NzaWJsZSB3YXlzIHRvIHdyaXRlIGVhY2hcbiAgICAgKiAgICAgICAgcGhyYXNlLCBmb3IgZXhhbXBsZSBbJ2hhdmUnLCAnd2UgaGF2ZSddLiBXZSB3aWxsIGF0dGVtcHQgdG8gbWF0Y2hcbiAgICAgKiAgICAgICAgc2VjdGlvbnMgb2YgdGhlIGlucHV0U3RyaW5nIHRvIHRoZSB3YXlzIG9mIHdyaXRpbmcgZWFjaCBwaHJhc2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1RlbXBsYXRlIC0gaWYgdHJ1ZSwgd2UgcGFyc2UgdGhlIGlucHV0IGFzIGFcbiAgICAgKiAgICAgICAgTGluZVRlbXBsYXRlOyBvdGhlcndpc2Ugd2UgcGFyc2UgaXQgYXMgYSBMaW5lLlxuICAgICAqIEByZXR1cm4geyp9IEEgTGluZVRlbXBsYXRlLnJlYWRlcl92aWV3IGlmIGlzVGVtcGxhdGUgPT09IHRydWUsIGFuZCBhXG4gICAgICogICAgICAgICBQcm90b0xpbmUgaWYgaXNUZW1wbGF0ZSA9PT0gZmFsc2UuXG4gICAgICogQHRocm93cyBJZiBhIHNlY3Rpb24gb2YgdGhlIHN0cmluZyBjYW5ub3QgYmUgaWRlbnRpZmllZCBhcyBlaXRoZXIgYSBwaHJhc2VcbiAgICAgKiAgICAgICAgIG9yIGFuIGV4cHJlc3Npb24gdGhlbiB3ZSB0aHJvdyBhbiBlcnJvciB0aGF0IHRyaWVzIHRvIGJlc3QgaWRlbnRpZnlcbiAgICAgKiAgICAgICAgIHdoYXQgdGhlIHVzZXIgaW50ZW5kZWQgYW5kIGRpZCB3cm9uZy5cbiAgICAgKi9cbiAgICB2YXIgcGFyc2VMaW5lU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0U3RyaW5nLCBvcGVyYXRvcnMsIHZvY2FidWxhcnksIGlzVGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKGlzVGVtcGxhdGUgPT09IHZvaWQgMCkgeyBpc1RlbXBsYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHVucGFyc2VkQXJyYXkgPSBwcmVQYXJzZUxpbmVTdHJpbmcoaW5wdXRTdHJpbmcsIG9wZXJhdG9ycywgaXNUZW1wbGF0ZSk7XG4gICAgICAgIC8vIFdlIGNvbXBpbGUgYWxsIHdvcmRzIG9jY3VycmluZyBpbiB0aGUgdm9jYWJ1bGFyeSwgdG8gaGVscCB1cyBpZGVudGlmeVxuICAgICAgICAvLyB0aGVtIGluIGxpbmVzLlxuICAgICAgICB2YXIgdm9jYWJ1bGFyeVdvcmRzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2b2NhYnVsYXJ5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZvY2FidWxhcnlba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdm9jYWJ1bGFyeVtrZXldW2ldLnNwbGl0KCcgJykubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvY2FidWxhcnlXb3Jkcy5pbmRleE9mKHZvY2FidWxhcnlba2V5XVtpXS5zcGxpdCgnICcpW2pdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvY2FidWxhcnlXb3Jkcy5wdXNoKHZvY2FidWxhcnlba2V5XVtpXS5zcGxpdCgnICcpW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbHRoIGVudHJ5IGluIHRoaXMgYXJyYXkgd2lsbCBjb250YWluIGFsbCBwYXJzaW5ncyBvZiB0aGUgZmlyc3RcbiAgICAgICAgLy8gbC1tYW55IGVsZW1lbnRzIG9mIHRoZSB1bnBhcnNlZEFycmF5LlxuICAgICAgICB2YXIgcGFydGlhbGx5UGFyc2VkQXJyYXlzID0gW1tbXV1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB1bnBhcnNlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0aWFsbHlQYXJzZWRBcnJheXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnBhcnNlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHBhcnNlZCB0aGUgZmlyc3QgaS1tYW55IGVudHJpZXMgaW4gdGhlIGdpdmVuIHVucGFyc2VkQXJyYXksXG4gICAgICAgICAgICAvLyBhbmQgd2lsbCBub3cgYXR0ZW1wdCB0byBwYXJzZSB0aGUgbmV4dCBvbmUuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgb25seSBvY2N1ciBpbiBwYXRob2xvZ2ljYWwgY2FzZXNcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsbHlQYXJzZWRBcnJheXNbaV0ubGVuZ3RoID4gTUFYX05VTV9QQVJTSU5HU19QRVJNSVRURUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlckVycm9yKCd0b29fbWFueV9wYXJzaW5ncycsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8PSB1bnBhcnNlZEFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZvY2FidWxhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB2b2NhYnVsYXJ5W2tleV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnBhcnNlZEFycmF5LnNsaWNlKGksIGopLmpvaW4oJyAnKS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvY2FidWxhcnlba2V5XVtrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgaWRlbnRpZmllZCB0aGUgbmV4dCAoai1pKS1tYW55IHdvcmRzIHRvZ2V0aGVyIGZvcm0gYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBocmFzZSBpbiB0aGUgdm9jYWJ1bGFyeSBkaWN0aW9uYXJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcGFydGlhbGx5UGFyc2VkQXJyYXlzW2ldLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxseVBhcnNlZEFycmF5c1tqXS5wdXNoKHBhcnRpYWxseVBhcnNlZEFycmF5c1tpXVtsXS5jb25jYXQoW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdwaHJhc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgYSBrbm93biB3b3JkIHRoZW4gd2UgZG8gbm90IGF0dGVtcHQgdG8gcGFyc2UgaXQgYXMgYW5cbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb24uIFRoaXMgaXMgYmVjYXVzZSBhbnkgd29yZCBjYW4gYmUgcmVnYXJkZWQgYXMgYW4gZXhwcmVzc2lvblxuICAgICAgICAgICAgLy8gKGFzIGEgc2luZ2xlIGF0b20pIHNvIG90aGVyd2lzZSB3ZSB3b3VsZCBlbmQgdXAgd2l0aCBhIGxhcmdlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gc3B1cmlvdXMgcGFyc2luZ3MuIFRoZSBleGNlcHRpb24gaXMgc2luZ2xlLWNoYXJhY3RlciB3b3JkcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gZS5nLiAnYScgY291bGQgcmVhc29uYWJseSBiZSBlaXRoZXIgYSB3b3JkIG9yIHRoZSBuYW1lIG9mIGFuIGF0b20uXG4gICAgICAgICAgICBpZiAodW5wYXJzZWRBcnJheVtpXS5sZW5ndGggPT09IDEgfHxcbiAgICAgICAgICAgICAgICB2b2NhYnVsYXJ5V29yZHMuaW5kZXhPZih1bnBhcnNlZEFycmF5W2ldLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGF0dGVtcHQgdG8gcGFyc2UgdGhpcyBlbnRyeSBhcyBhbiBleHByZXNzaW9uIC8gZXhwcmVzc2lvbiB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZ2VuZXJhdGVkUGFyc2VyX3RzXzEuZGVmYXVsdC5wYXJzZSh1bnBhcnNlZEFycmF5W2ldLCBpc1RlbXBsYXRlID8gJ2V4cHJlc3Npb25UZW1wbGF0ZScgOiAnZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRpYWxseVBhcnNlZEFycmF5c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IGFsbG93IGEgbGluZSB0byBoYXZlIHR3byBleHByZXNzaW9ucyBpbiBhIHJvdy4gVGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgdGhlIGlkZW50aWZpY2F0aW9uIG9mIHR5cG9zOiBGb3IgZXhhbXBsZSBpZiB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZXMgJ2Zyb24gcOKIp3EgLi4uJyB0aGVuIG90aGVyd2lzZSB3ZSB3b3VsZCB0aGluayB0aGF0IGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdmcm9uJyBhbmQgJ3DiiKdxJyBhcmUgZXhwcmVzc2lvbnMuIFdlIGFsc28gZG8gbm90IGF0dGVtcHQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIGEgd29yZCBhcyBhbiBleHByZXNzaW9uIGlmIGl0IGlzIGEgdm9jYWJ1bGFyeSB3b3JkLCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgbWFzc2VzIG9mIHNpbGx5IGF0dGVtcHRzIHRvIHBhcnNlIHRoZSBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsbHlQYXJzZWRBcnJheXNbaV1bal1bcGFydGlhbGx5UGFyc2VkQXJyYXlzW2ldW2pdLmxlbmd0aCAtIDFdLmZvcm1hdCA9PT0gJ3BocmFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsbHlQYXJzZWRBcnJheXNbaSArIDFdLnB1c2gocGFydGlhbGx5UGFyc2VkQXJyYXlzW2ldW2pdLmNvbmNhdChbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxseVBhcnNlZEFycmF5c1t1bnBhcnNlZEFycmF5Lmxlbmd0aF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBzdWNjZWVkZWQgaW4gZnVsbHkgcGFyc2luZ1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWxseVBhcnNlZEFycmF5c1t1bnBhcnNlZEFycmF5Lmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBpZGVudGlmeSB0aGUgYmVzdCBhdHRlbXB0c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVucGFyc2VkQXJyYXkubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsbHlQYXJzZWRBcnJheXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRW50cmllc01hdGNoZWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvYmxlbSwgYmFzZWQgb24gb25lIG9mIHRoZSBiZXN0XG4gICAgICAgICAgICAvLyBhdHRlbXB0cy5cbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgbm90IGd1YXJhbnRlZWQgdG8gY29ycmVjdGx5IGlkZW50aWZ5IHRoZSBtaXN0YWtlIHRoZVxuICAgICAgICAgICAgLy8gdXNlciBtYWRlLiBJdCBjb3VsZCBkbyB3aXRoIGltcHJvdmVtZW50IGJhc2VkIG9uIHVzZXIgZmVlZGJhY2suXG4gICAgICAgICAgICAvLyBjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIgaXMgdXNlZCB0byBndWVzcyBpZiBzb21ldGhpbmcgaXMgYW5cbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb24sIGJ1dCBpdCBpcyBub3QgYWx3YXlzIGNvcnJlY3QgYmVjYXVzZSBleHByZXNzaW9ucyBtYXlcbiAgICAgICAgICAgIC8vIGNvbnNpc3Qgb25seSBvZiBsZXR0ZXJzLlxuICAgICAgICAgICAgdmFyIGJlc3RBdHRlbXB0ID0gcGFydGlhbGx5UGFyc2VkQXJyYXlzW251bUVudHJpZXNNYXRjaGVkXVswXTtcbiAgICAgICAgICAgIGlmIChudW1FbnRyaWVzTWF0Y2hlZCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGJlc3RBdHRlbXB0W2Jlc3RBdHRlbXB0Lmxlbmd0aCAtIDFdLmZvcm1hdCA9PT0gJ3BocmFzZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHVucGFyc2VkQXJyYXlbbnVtRW50cmllc01hdGNoZWRdO1xuICAgICAgICAgICAgICAgIHRocm93ICh2b2NhYnVsYXJ5V29yZHMuaW5kZXhPZih3b3JkKSAhPT0gLTEpID9cbiAgICAgICAgICAgICAgICAgICAgbmV3IFVzZXJFcnJvcigndW5pZGVudGlmaWVkX3BocmFzZV9zdGFydGluZ19hdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICBuZXcgVXNlckVycm9yKCd1bmlkZW50aWZpZWRfd29yZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZDEgPSB1bnBhcnNlZEFycmF5W251bUVudHJpZXNNYXRjaGVkIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIHdvcmQyID0gdW5wYXJzZWRBcnJheVtudW1FbnRyaWVzTWF0Y2hlZF07XG4gICAgICAgICAgICAgICAgaWYgKHZvY2FidWxhcnlXb3Jkcy5pbmRleE9mKHdvcmQxKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJFcnJvcigndW5pZGVudGlmaWVkX3BocmFzZV9zdGFydGluZ19hdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmQxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWluc0xvZ2ljYWxDaGFyYWN0ZXIod29yZDEsIG9wZXJhdG9ycywgaXNUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKHZvY2FidWxhcnlXb3Jkcy5pbmRleE9mKHdvcmQyKSAhPT0gLTEpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVc2VyRXJyb3IoJ3VuaWRlbnRpZmllZF9waHJhc2Vfc3RhcnRpbmdfYXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogd29yZDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zTG9naWNhbENoYXJhY3Rlcih3b3JkMiwgb3BlcmF0b3JzLCBpc1RlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVzZXJFcnJvcignY29uc2VjdXRpdmVfZXhwcmVzc2lvbnMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQxOiB3b3JkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDI6IHdvcmQyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVc2VyRXJyb3IoJ3VuaWRlbnRpZmllZF93b3JkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkOiB3b3JkMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKHZvY2FidWxhcnlXb3Jkcy5pbmRleE9mKHdvcmQyKSAhPT0gLTEpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVc2VyRXJyb3IoJ3VuaWRlbnRpZmllZF9waHJhc2Vfc3RhcnRpbmdfYXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogd29yZDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zTG9naWNhbENoYXJhY3Rlcih3b3JkMiwgb3BlcmF0b3JzLCBpc1RlbXBsYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVzZXJFcnJvcigndW5pZGVudGlmaWVkX3dvcmQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmQxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVc2VyRXJyb3IoJ3VuaWRlbnRpZmllZF93b3JkcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDE6IHdvcmQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkMjogd29yZDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRZUElORyBBU1NJR05NRU5UXG4gICAgLyoqXG4gICAgICogVGhpcyB0YWtlcyBhbiBhcnJheSBvZiBUeXBpbmdFbGVtZW50cyBhbmQgY29udmVydHMgaXQgaW50byBhbiBhcnJheSBvZlxuICAgICAqIHR5cGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHR5cGVzIC0gYW4gYXJyYXkgb2YgZGljdGlvbmFyaWVzIG9mIHRoZSBmb3JtIHtcbiAgICAgKiAgICAgICAgICAgICAgIHR5cGU6IHRoZSBuYW1lIG9mIGFuIGF2YWlsYWJsZSB0eXBlICgnYm9vbGVhbicgb3IgJ2VsZW1lbnQnKVxuICAgICAqICAgICAgICAgICAgICAgYXJiaXRyYXJpbHlfbWFueTogYm9vbGVhblxuICAgICAqICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgIHdoZXJlIGF0IG1vc3Qgb25lIG1lbWJlciBjYW4gaGF2ZSAnYXJiaXRyYXJpbHlfbWFueScgc2V0IHRvXG4gICAgICogICAgICAgICAgdHJ1ZSwgc2lnbmlmeWluZyB0aGF0IGFueSBudW1iZXIgb2YgYXJndW1lbnRzIG9mIHRoaXMgdHlwZVxuICAgICAqICAgICAgICAgIGNhbiBvY2N1ciBoZXJlLlxuICAgICAqIEBwYXJhbSB7aW50fSBkZXNpcmVkTGVuZ3RoIC0gdGhlIG51bWJlciBvZiBlbnRyaWVzIHdlIHdvdWxkIGxpa2UgdG8gaGF2ZS5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IGFuIGFycmF5IG9mIHR5cGVzIHdpdGggdGhlIHJpZ2h0IG51bWJlciBvZiBlbnRyaWVzLFxuICAgICAqICAgICAgICAgIGRlcml2ZWQgZnJvbSAndHlwZXMnLlxuICAgICAqIEB0aHJvd3MgaWYgdGhpcyBpcyBub3QgcG9zc2libGUuXG4gICAgICovXG4gICAgdmFyIGluc3RhbnRpYXRlVHlwaW5nRWxlbWVudEFycmF5ID0gZnVuY3Rpb24gKHR5cGVzLCBkZXNpcmVkTGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaXN0T2ZUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0T2ZUeXBlcy5wdXNoKHR5cGVzW2ldLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmFyYml0cmFyaWx5X21hbnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhXaXRoQXJiaXRyYXJpbHlNYW55ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhXaXRoQXJiaXRyYXJpbHlNYW55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IGRlc2lyZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdE9mVHlwZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlckVycm9yKCd3cm9uZ19udW1faW5wdXRzJywge1xuICAgICAgICAgICAgICAgICAgICBudW1fbmVlZGVkOiBkZXNpcmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoIDw9IGRlc2lyZWRMZW5ndGggKyAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXhXaXRoQXJiaXRyYXJpbHlNYW55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRlc2lyZWRMZW5ndGggLSB0eXBlcy5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChsaXN0T2ZUeXBlc1tpbmRleFdpdGhBcmJpdHJhcmlseU1hbnldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGxpc3RPZlR5cGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJFcnJvcignbm90X2Vub3VnaF9pbnB1dHMnLCB7XG4gICAgICAgICAgICAgICAgICAgIG51bV9uZWVkZWQ6IGRlc2lyZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyB0YWtlcyBhbiAodW50eXBlZCkgRXhwcmVzc2lvbiwgdXN1YWxseSBwcm92aWRlZCBieSB0aGUgcGFyc2VyLCBhbmRcbiAgICAgKiByZXR1cm5zIGEgVHlwZWRFeHByZXNzaW9uIGluIHdoaWNoIHR5cGVzIGhhdmUgYmVlbiBhZGRlZCBhdCBlYWNoIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RXhwcmVzc2lvbn0gdW50eXBlZEV4cHJlc3Npb24gLSB0aGUgZXhwcmVzc2lvbiB0byBiZSB0eXBlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvc3NpYmxlVG9wVHlwZXMgLSBhbiBhcnJheSBvZiB0eXBlcyB0aGF0IHRoZSBleHByZXNzaW9uIGFzXG4gICAgICogICAgICAgIGEgd2hvbGUgY291bGQgaGF2ZSAtIGVhY2ggd2lsbCBiZSB0cmllZCBpbiB0dXJuLlxuICAgICAqIEBwYXJhbSB7TGFuZ3VhZ2V9IGxhbmd1YWdlIC0gdGhlIHJlbGV2YW50IGxhbmd1YWdlXG4gICAgICogQHBhcmFtIHtBcnJheX0gbmV3S2luZHNQZXJtaXR0ZWQgLSBhbiBhcnJheSBvZiBraW5kcyAoZS5nLiAndmFyaWFibGUnLFxuICAgICAqICAgICAgICAnY29uc3RhbnQnKSBvZiB3aGljaCB0aGUgdXNlciBpcyBhbGxvd2VkIHRvIGNyZWF0ZSBuZXcgb3BlcmF0b3JzLlxuICAgICAqICAgICAgICBBbnkgb3BlcmF0b3Igd2l0aCBhIGtpbmQgbm90IGluIHRoaXMgbGlzdCBhbmQgdGhhdCBkb2VzIG5vdCBhbHJlYWR5XG4gICAgICogICAgICAgIG9jY3VyIGluIHRoZSBsYW5ndWFnZSB3aWxsIGNhdXNlIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGVybWl0RHVwbGljYXRlRHVtbXlOYW1lcyAtIGlmIHRydWUgdGhlIHVzZXIgY2FuIHdyaXRlXG4gICAgICogICAgICAgIGUuZy4g4oiAeC5wIGV2ZW4gaWYgeCBpcyBhbHJlYWR5IGluIHVzZTsgaWYgZmFsc2UgdGhleSBjYW5ub3QuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGRpY3Rpb25hcmllcyBvZiB0aGUgZm9ybToge1xuICAgICAqICAgICAgICAgICB0eXBlZEV4cHJlc3Npb246IEEgVHlwZWRFeHByZXNzaW9uXG4gICAgICogICAgICAgICAgIG9wZXJhdG9yczogdGhlIGdpdmVuIGxhbmd1YWdlLm9wZXJhdG9yc3MgdG9nZXRoZXIgd2l0aCBhbnkgbmV3XG4gICAgICogICAgICAgICAgICAgb3BlcmF0b3JzIHRoYXQgb2NjdXJyZWQgaW4gdGhlIGV4cHJlc3Npb24uXG4gICAgICogQHRocm93cyBJZiBhIHZhbGlkIHR5cGluZyBjYW5ub3QgYmUgZm91bmQgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFcbiAgICAgKiAgICAgICAgIFVzZXJFcnJvci4gVGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBlcnJvciB3aWxsIGNvbnRhaW4gYW4gYWRkaXRpb25hbFxuICAgICAqICAgICAgICAga2V5ICdhbW91bnRUeXBlZCcgdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZC4gZS5nLlxuICAgICAqICAgICAgICAgWzEsMiwwXSB3b3VsZCBpbmRpY2F0ZSB0aGF0IHRoZXJlIHdhcyBhIHByb2JsZW0gYXQgdGhlIDB0aCBpbnB1dFxuICAgICAqICAgICAgICAgKGR1bW15IG9yIGFyZ3VtZW50KSBvZiB0aGUgMm5kIGlucHV0IG9mIHRoZSAxc3QgaW5wdXQgb2YgdGhpc1xuICAgICAqICAgICAgICAgZXhwcmVzc2lvbi4gV2UgcmV0dXJuIHRoZSB0eXBpbmcgYXR0ZW1wdCBmb3Igd2hpY2ggdGhpcyAgdmFsdWUgaXNcbiAgICAgKiAgICAgICAgIGxhcmdlc3QgKGluIGxleGljb2dyYXBoaWMgb3JkZXJpbmcpIGFzIHRoaXMgaXMgbGlrZWx5IHRvIGJlIGNsb3Nlc3RcbiAgICAgKiAgICAgICAgIHRvIHdoYXQgdGhlIHVzZXIgaW50ZW5kZWQuXG4gICAgICovXG4gICAgdmFyIGFzc2lnblR5cGVzVG9FeHByZXNzaW9uID0gZnVuY3Rpb24gKHVudHlwZWRFeHByZXNzaW9uLCBwb3NzaWJsZVRvcFR5cGVzLCBsYW5ndWFnZSwgbmV3S2luZHNQZXJtaXR0ZWQsIHBlcm1pdER1cGxpY2F0ZUR1bW15TmFtZXMpIHtcbiAgICAgICAgaWYgKG5ld0tpbmRzUGVybWl0dGVkID09PSB2b2lkIDApIHsgbmV3S2luZHNQZXJtaXR0ZWQgPSBbJ2NvbnN0YW50JywgJ3ZhcmlhYmxlJ107IH1cbiAgICAgICAgaWYgKHBlcm1pdER1cGxpY2F0ZUR1bW15TmFtZXMgPT09IHZvaWQgMCkgeyBwZXJtaXREdXBsaWNhdGVEdW1teU5hbWVzID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9wZXJhdG9ycyA9IGxhbmd1YWdlLm9wZXJhdG9ycztcbiAgICAgICAgdmFyIF9hdHRlbXB0VHlwaW5nID0gZnVuY3Rpb24gKHRvcFR5cGUsIHR5cGluZ1J1bGUpIHtcbiAgICAgICAgICAgIGlmICghb3BlcmF0b3JJc05ldyAmJlxuICAgICAgICAgICAgICAgIHVudHlwZWRFeHByZXNzaW9uLnRvcF9raW5kX25hbWUgIT09XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yc1t1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZV0ua2luZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyRXJyb3IoJ3dyb25nX2tpbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfa2luZDogb3BlcmF0b3JzW3VudHlwZWRFeHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXS5raW5kLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxfa2luZDogdW50eXBlZEV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcFR5cGUgIT09IHR5cGluZ1J1bGUub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJFcnJvcignd3JvbmdfdHlwZScsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHVudHlwZWRFeHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZF90eXBlOiB0b3BUeXBlLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxfdHlwZTogdHlwaW5nUnVsZS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudF90eXBlZDogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9pc1N0cmluZyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNbMF0gPT09ICdcXCcnICYmIHNbcy5sZW5ndGggLSAxXSA9PT0gJ1xcJyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhbmd1YWdlLnR5cGVzLmhhc093blByb3BlcnR5KCdpbnRlZ2VyJykgJiZcbiAgICAgICAgICAgICAgICBfaXNOdW1iZXIodW50eXBlZEV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUpICYmXG4gICAgICAgICAgICAgICAgdW50eXBlZEV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ2NvbnN0YW50JyAmJlxuICAgICAgICAgICAgICAgIHRvcFR5cGUgIT09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyRXJyb3IoJ3dyb25nX3R5cGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfdHlwZTogdG9wVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsX3R5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlLnR5cGVzLmhhc093blByb3BlcnR5KCdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgICAgIF9pc1N0cmluZyh1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSkgJiZcbiAgICAgICAgICAgICAgICB1bnR5cGVkRXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lID09PSAnY29uc3RhbnQnICYmXG4gICAgICAgICAgICAgICAgdG9wVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlckVycm9yKCd3cm9uZ190eXBlJywge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogdW50eXBlZEV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkX3R5cGU6IHRvcFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbF90eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYXJndW1lbnRUeXBlcyA9IGluc3RhbnRpYXRlVHlwaW5nRWxlbWVudEFycmF5KHR5cGluZ1J1bGUuYXJndW1lbnRzLCB1bnR5cGVkRXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnIucGFyYW1ldGVycy5vcGVyYXRvciA9IHVudHlwZWRFeHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lO1xuICAgICAgICAgICAgICAgIGVyci5wYXJhbWV0ZXJzLmlucHV0X2NhdGVnb3J5ID0gJ2FyZ3VtZW50cyc7XG4gICAgICAgICAgICAgICAgZXJyLnBhcmFtZXRlcnMuYW1vdW50X3R5cGVkID0gW107XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZHVtbXlUeXBlcyA9IGluc3RhbnRpYXRlVHlwaW5nRWxlbWVudEFycmF5KHR5cGluZ1J1bGUuZHVtbWllcywgdW50eXBlZEV4cHJlc3Npb24uZHVtbWllcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVyci5wYXJhbWV0ZXJzLm9wZXJhdG9yID0gdW50eXBlZEV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWU7XG4gICAgICAgICAgICAgICAgZXJyLnBhcmFtZXRlcnMuaW5wdXRfY2F0ZWdvcnkgPSAnZHVtbWllcyc7XG4gICAgICAgICAgICAgICAgZXJyLnBhcmFtZXRlcnMuYW1vdW50X3R5cGVkID0gW107XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVwZGF0ZWRPcGVyYXRvcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcGVyYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkT3BlcmF0b3JzW2tleV0gPSBvcGVyYXRvcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVyYXRvcklzTmV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kZWNvcmF0ZVR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWRUeXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHR5cGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZWRUeXBlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlc1trXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmJpdHJhcmlseV9tYW55OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRlZFR5cGVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdXBkYXRlZE9wZXJhdG9yc1t1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHVudHlwZWRFeHByZXNzaW9uLnRvcF9raW5kX25hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGluZzogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IF9kZWNvcmF0ZVR5cGVzKGFyZ3VtZW50VHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IF9kZWNvcmF0ZVR5cGVzKGR1bW15VHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogdG9wVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB1bnR5cGVkRXhwcmVzc2lvbi5kdW1taWVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZXJtaXREdXBsaWNhdGVEdW1teU5hbWVzICYmXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRPcGVyYXRvcnMuaGFzT3duUHJvcGVydHkodW50eXBlZEV4cHJlc3Npb24uZHVtbWllc1tuXS50b3Bfb3BlcmF0b3JfbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJFcnJvcignZHVwbGljYXRlX2R1bW15X25hbWUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1teTogdW50eXBlZEV4cHJlc3Npb24uZHVtbWllc1tuXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHVudHlwZWRFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodW50eXBlZEV4cHJlc3Npb24uZHVtbWllc1tuXS50b3Bfa2luZF9uYW1lICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJzZXIgZG9lcyBub3QgY3VycmVudGx5IHBlcm1pdCB0aGlzIHRvIGhhcHBlblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlckVycm9yKCdkdW1teV9ub3RfdmFyaWFibGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1teTogdW50eXBlZEV4cHJlc3Npb24uZHVtbWllc1tuXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHVudHlwZWRFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzaWduVHlwZXNUb0V4cHJlc3Npb25BcnJheSh1bnR5cGVkRXhwcmVzc2lvbi5kdW1taWVzLmNvbmNhdCh1bnR5cGVkRXhwcmVzc2lvbi5hcmd1bWVudHMpLCBkdW1teVR5cGVzLmNvbmNhdChhcmd1bWVudFR5cGVzKSwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yczogdXBkYXRlZE9wZXJhdG9ycyxcbiAgICAgICAgICAgICAgICBraW5kczogbGFuZ3VhZ2Uua2luZHMsXG4gICAgICAgICAgICAgICAgdHlwZXM6IGxhbmd1YWdlLnR5cGVzXG4gICAgICAgICAgICB9LCBuZXdLaW5kc1Blcm1pdHRlZCwgcGVybWl0RHVwbGljYXRlRHVtbXlOYW1lcywgdW50eXBlZEV4cHJlc3Npb24uZHVtbWllcy5sZW5ndGgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3BlcmF0b3JJc05ldyA9IGZhbHNlO1xuICAgICAgICBpZiAoIW9wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eSh1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChuZXdLaW5kc1Blcm1pdHRlZC5pbmRleE9mKHVudHlwZWRFeHByZXNzaW9uLnRvcF9raW5kX25hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyRXJyb3IoJ3Vua25vd25fb3BlcmF0b3InLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB1bnR5cGVkRXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3R5cGVkOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3JJc05ldyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGluZ1J1bGVzID0gKG9wZXJhdG9ySXNOZXcpID9cbiAgICAgICAgICAgIGxhbmd1YWdlLmtpbmRzW3VudHlwZWRFeHByZXNzaW9uLnRvcF9raW5kX25hbWVdLnR5cGluZyA6XG4gICAgICAgICAgICBvcGVyYXRvcnNbdW50eXBlZEV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWVdLnR5cGluZztcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZVRvcFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHR5cGluZ1J1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0F0dGVtcHRzID0gX2F0dGVtcHRUeXBpbmcocG9zc2libGVUb3BUeXBlc1tpXSwgdHlwaW5nUnVsZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5ld0F0dGVtcHRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZWREdW1taWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHVudHlwZWRFeHByZXNzaW9uLmR1bW1pZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZER1bW1pZXMucHVzaChuZXdBdHRlbXB0c1trXS50eXBlZEFycmF5W2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBkdW1teSB2YXJpYWJsZXMgc2hvdWxkIG5vdCBiZSBhdmFpbGFibGUgb3V0c2lkZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgdW50eXBlZEV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkodW50eXBlZEV4cHJlc3Npb24uZHVtbWllc1tsXS50b3Bfb3BlcmF0b3JfbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld0F0dGVtcHRzW2tdLm9wZXJhdG9yc1t1bnR5cGVkRXhwcmVzc2lvbi5kdW1taWVzW2xdLnRvcF9vcGVyYXRvcl9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZWRBcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB1bnR5cGVkRXhwcmVzc2lvbi5kdW1taWVzLmxlbmd0aDsgbSA8IHVudHlwZWRFeHByZXNzaW9uLmR1bW1pZXMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnR5cGVkRXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFyZ3VtZW50cy5wdXNoKG5ld0F0dGVtcHRzW2tdLnR5cGVkQXJyYXlbbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6IHVudHlwZWRFeHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Bfa2luZF9uYW1lOiB1bnR5cGVkRXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHR5cGVkQXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1taWVzOiB0eXBlZER1bW1pZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBvc3NpYmxlVG9wVHlwZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yczogbmV3QXR0ZW1wdHNba10ub3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0QXR0ZW1wdFNvRmFyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFiZXN0QXR0ZW1wdFNvRmFyLmhhc093blByb3BlcnR5KCdwYXJhbWV0ZXJzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGJlc3RBdHRlbXB0U29GYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RBdHRlbXB0U29GYXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JlYXRlclRoYW5JbkxleChlcnIucGFyYW1ldGVycy5hbW91bnRfdHlwZWQsIGJlc3RBdHRlbXB0U29GYXIucGFyYW1ldGVycy5hbW91bnRfdHlwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdEF0dGVtcHRTb0ZhciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGJlc3RBdHRlbXB0U29GYXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDb21wYW5pb24gZnVuY3Rpb24gdG8gYXNzaWduVHlwZXNUb0V4cHJlc3Npb24sIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIG1vZGlmaWNhdGlvbnM6XG4gICAgICogQHBhcmFtIHVudHlwZWRBcnJheTogYW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgdG8gdHlwZVxuICAgICAqICBAcGFyYW0gdG9wVHlwZXM6IGFuIGFycmF5IG9mIHR5cGVzIHRoYXQgdGhlIGV4cHJlc3Npb25zIGluIHRoZSBhcnJheSBtdXN0XG4gICAgICogICAgICAgIGhhdmUgKG9ubHkgb25lIG9wdGlvbiBmb3IgZWFjaCkuXG4gICAgICogQG51bUR1bW1pZXM6IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IChmcm9tIHRoZSBzdGFydCkgdGhhdCBhcmVcbiAgICAgKiAgICAgICAgICAgICAgZHVtbWllcyByYXRoZXIgdGhhbiBhcmd1bWVudHMuXG4gICAgICogQHJlc3VsdDoge1xuICAgICAqICAgICAgICAgICAgdHlwZWRBcnJheTogYW4gYXJyYXkgb2YgVHlwZWRFeHByZXNzaW9uc1xuICAgICAqICAgICAgICAgICAgb3BlcmF0b3JzOiB0aGUgdXBkYXRlZCBsaXN0IG9mIG9wZXJhdG9yc1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiBAcmFpc2VzOiBhcyBiZWZvcmVcbiAgICAgKi9cbiAgICB2YXIgYXNzaWduVHlwZXNUb0V4cHJlc3Npb25BcnJheSA9IGZ1bmN0aW9uICh1bnR5cGVkQXJyYXksIHRvcFR5cGVzLCBsYW5ndWFnZSwgbmV3S2luZHNQZXJtaXR0ZWQsIGlzVGVtcGxhdGUsIG51bUR1bW1pZXMpIHtcbiAgICAgICAgaWYgKG5ld0tpbmRzUGVybWl0dGVkID09PSB2b2lkIDApIHsgbmV3S2luZHNQZXJtaXR0ZWQgPSBbJ2NvbnN0YW50JywgJ3ZhcmlhYmxlJ107IH1cbiAgICAgICAgaWYgKGlzVGVtcGxhdGUgPT09IHZvaWQgMCkgeyBpc1RlbXBsYXRlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKG51bUR1bW1pZXMgPT09IHZvaWQgMCkgeyBudW1EdW1taWVzID0gMDsgfVxuICAgICAgICB2YXIgcGFydGlhbGx5VHlwZWRBcnJheXMgPSBbW1tdXV07XG4gICAgICAgIHZhciBwYXJ0aWFsbHlVcGRhdGVkT3BlcmF0b3JzID0gW1t7fV1dO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGFuZ3VhZ2Uub3BlcmF0b3JzKSB7XG4gICAgICAgICAgICBwYXJ0aWFsbHlVcGRhdGVkT3BlcmF0b3JzWzBdWzBdW2tleV0gPSBsYW5ndWFnZS5vcGVyYXRvcnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB1bnR5cGVkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRpYWxseVR5cGVkQXJyYXlzLnB1c2goW10pO1xuICAgICAgICAgICAgcGFydGlhbGx5VXBkYXRlZE9wZXJhdG9ycy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVudHlwZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgaGFwcGVuIGluIHBhdGhvbG9naWNhbCBjYXNlcy5cbiAgICAgICAgICAgIGlmIChwYXJ0aWFsbHlUeXBlZEFycmF5c1tpXS5sZW5ndGggPiBNQVhfTlVNX1RZUElOR1NfUEVSTUlUVEVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJFcnJvcigndG9vX21hbnlfdHlwaW5ncycsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydGlhbGx5VHlwZWRBcnJheXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAvLyBEdW1taWVzIGFyZSBhbHdheXMgYWxsb3dlZCB0byBoYXZlIHByZXZpb3VzbHkgdW5zZWVuIG5hbWVzXG4gICAgICAgICAgICAgICAgdmFyIG5ld0tpbmRzUGVybWl0dGVkSGVyZSA9IChpIDwgbnVtRHVtbWllcykgP1xuICAgICAgICAgICAgICAgICAgICBuZXdLaW5kc1Blcm1pdHRlZC5jb25jYXQoWyd2YXJpYWJsZSddKSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0tpbmRzUGVybWl0dGVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdSZXN1bHRzID0gYXNzaWduVHlwZXNUb0V4cHJlc3Npb24odW50eXBlZEFycmF5W2ldLCBbdG9wVHlwZXNbaV1dLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnM6IHBhcnRpYWxseVVwZGF0ZWRPcGVyYXRvcnNbaV1bal0sXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogbGFuZ3VhZ2Uua2luZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogbGFuZ3VhZ2UudHlwZXNcbiAgICAgICAgICAgICAgICAgICAgfSwgbmV3S2luZHNQZXJtaXR0ZWRIZXJlLCBpc1RlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuZXdSZXN1bHRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsbHlUeXBlZEFycmF5c1tpICsgMV0ucHVzaChwYXJ0aWFsbHlUeXBlZEFycmF5c1tpXVtqXS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jlc3VsdHNba10udHlwZWRFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsbHlVcGRhdGVkT3BlcmF0b3JzW2kgKyAxXS5wdXNoKG5ld1Jlc3VsdHNba10ub3BlcmF0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyLmhhc093blByb3BlcnR5KCdwYXJhbWV0ZXJzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYW1vdW50VHlwZWQgPSBbaV0uY29uY2F0KGVyci5wYXJhbWV0ZXJzLmFtb3VudF90eXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0QXR0ZW1wdFNvRmFyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWF0ZXJUaGFuSW5MZXgoYW1vdW50VHlwZWQsIGJlc3RBdHRlbXB0U29GYXIucGFyYW1ldGVycy5hbW91bnRfdHlwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucGFyYW1ldGVycy5hbW91bnRfdHlwZWQgPSBhbW91bnRUeXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZXN0QXR0ZW1wdFNvRmFyID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmdWxseVR5cGVkQXJyYXlzID0gcGFydGlhbGx5VHlwZWRBcnJheXNbdW50eXBlZEFycmF5Lmxlbmd0aF07XG4gICAgICAgIHZhciBmdWxseVVwZGF0ZWRPcGVyYXRvcnNzID0gcGFydGlhbGx5VXBkYXRlZE9wZXJhdG9yc1t1bnR5cGVkQXJyYXkubGVuZ3RoXTtcbiAgICAgICAgaWYgKGZ1bGx5VHlwZWRBcnJheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdWxseVR5cGVkQXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5OiBmdWxseVR5cGVkQXJyYXlzW2ldLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnM6IGZ1bGx5VXBkYXRlZE9wZXJhdG9yc3NbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBiZXN0QXR0ZW1wdFNvRmFyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBVVElMSVRJRVNcbiAgICAvLyBFeHByZXNzaW9ucyB3aXRoIGRpZmZlcmVudCBkdW1teSB2YXJpYWJsZXMgYXJlIGNvbnNpZGVyZWQgZGlmZmVyZW50XG4gICAgdmFyIGNoZWNrRXhwcmVzc2lvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIChleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIpIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24xLnRvcF9raW5kX25hbWUgIT09IGV4cHJlc3Npb24yLnRvcF9raW5kX25hbWUgfHxcbiAgICAgICAgICAgIGV4cHJlc3Npb24xLnRvcF9vcGVyYXRvcl9uYW1lICE9PSBleHByZXNzaW9uMi50b3Bfb3BlcmF0b3JfbmFtZSB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbjEuYXJndW1lbnRzLmxlbmd0aCAhPT0gZXhwcmVzc2lvbjIuYXJndW1lbnRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbjEuZHVtbWllcy5sZW5ndGggIT09IGV4cHJlc3Npb24yLmR1bW1pZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJlc3Npb24xLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uMS50eXBlICE9PSBleHByZXNzaW9uMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbjEuYXJndW1lbnRzLmxlbmd0aCArIGV4cHJlc3Npb24xLmR1bW1pZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tFeHByZXNzaW9uc0FyZUVxdWFsKChleHByZXNzaW9uMS5hcmd1bWVudHMuY29uY2F0KGV4cHJlc3Npb24xLmR1bW1pZXMpKVtpXSwgKGV4cHJlc3Npb24yLmFyZ3VtZW50cy5jb25jYXQoZXhwcmVzc2lvbjIuZHVtbWllcykpW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBjaGVja0V4cHJlc3Npb25Jc0luU2V0ID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoZWNrRXhwcmVzc2lvbnNBcmVFcXVhbChleHByZXNzaW9uLCBzZXRbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIGNoZWNrU2V0c09mRXhwcmVzc2lvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0MS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjaGVja0V4cHJlc3Npb25Jc0luU2V0KHNldDFbaV0sIHNldDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Mi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjaGVja0V4cHJlc3Npb25Jc0luU2V0KHNldDJbaV0sIHNldDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBuYW1lcyBvZiBvcGVyYXRvcnMgaW4gYW4gZXhwcmVzc2lvbi4ga2luZHMgaXMgYW5cbiAgICAvLyBhcnJheSBzcGVjaWZ5aW5nIHdoaWNoIGtpbmRzIG9mIG9wZXJhdG9ycyB0byByZXR1cm47IGlmIGl0IGlzIG5vdCBzdXBwbGllZFxuICAgIC8vIHRoZW4gYWxsIGFyZSByZXR1cm5lZFxuICAgIHZhciBnZXRPcGVyYXRvcnNGcm9tRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBraW5kcykge1xuICAgICAgICBpZiAoa2luZHMgPT09IHZvaWQgMCkgeyBraW5kcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGdldE9wZXJhdG9yc0Zyb21FeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbi5hcmd1bWVudHMuY29uY2F0KGV4cHJlc3Npb24uZHVtbWllcyksIGtpbmRzKTtcbiAgICAgICAgcmV0dXJuIChvdXRwdXQuaW5kZXhPZihleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIChraW5kcyA9PT0gbnVsbCB8fCBraW5kcy5pbmRleE9mKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSkgIT09IC0xKSkgP1xuICAgICAgICAgICAgb3V0cHV0LmNvbmNhdChbZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZV0pIDpcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICB9O1xuICAgIHZhciBnZXRPcGVyYXRvcnNGcm9tRXhwcmVzc2lvbkFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBraW5kcykge1xuICAgICAgICBpZiAoa2luZHMgPT09IHZvaWQgMCkgeyBraW5kcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3T3V0cHV0ID0gZ2V0T3BlcmF0b3JzRnJvbUV4cHJlc3Npb24oYXJyYXlbaV0sIGtpbmRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3T3V0cHV0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKG5ld091dHB1dFtqXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5jb25jYXQoW25ld091dHB1dFtqXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgLy8gVGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHR5cGVkOyByZXR1cm5zIHRoZSB0eXBlIG9mIG9wZXJhdG9yIChvciB0aHJvd3MgYW5cbiAgICAvLyBlcnJvciBpZiBub3QgZm91bmQpLiBEb2VzIG5vdCBjaGVjayBmb3IgaW5jb25zaXN0ZW50IHR5cGluZy5cbiAgICAvLyBOT1RFOiB0cmVhdHMgZHVtbXkgdmFyaWFibGVzIGxpa2UgZnJlZSBvbmVzLlxuICAgIHZhciBzZWVrVHlwZUluRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUgPyBleHByZXNzaW9uLnR5cGUgOlxuICAgICAgICAgICAgc2Vla1R5cGVJbkV4cHJlc3Npb25BcnJheShleHByZXNzaW9uLmFyZ3VtZW50cy5jb25jYXQoZXhwcmVzc2lvbi5kdW1taWVzKSwgb3BlcmF0b3IpO1xuICAgIH07XG4gICAgdmFyIHNlZWtUeXBlSW5FeHByZXNzaW9uQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIG9wZXJhdG9yKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZWtUeXBlSW5FeHByZXNzaW9uKGFycmF5W2ldLCBvcGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBVc2VyRXJyb3IoJ3Vua25vd25fdHlwaW5nX2Vycm9yJywge1xuICAgICAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB3aGV0aGVyIExIUyBpcyBsYXJnZXIgdGhhbiBSSFMgaW4gbGV4aWNvZ3JhcGhpYyBvcmRlcmluZ1xuICAgIHZhciBncmVhdGVyVGhhbkluTGV4ID0gZnVuY3Rpb24gKExIUywgUkhTKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTEhTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBSSFMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChMSFNbaV0gPiBSSFNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKExIU1tpXSA8IFJIU1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBDaGVja3MgaWYgdGhlIHN0cmluZyBjb250YWlucyB0aGUgY2hhcmFjdGVyXG4gICAgdmFyIGNvbnRhaW5zQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoY2hhcmFjdGVyKSAhPT0gLTEpO1xuICAgIH07XG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgc29tZSBjaGFyYWN0ZXIgZnJvbSB0aGUgYXJyYXlcbiAgICB2YXIgY29udGFpbnNDaGFyYWN0ZXJGcm9tQXJyYXkgPSBmdW5jdGlvbiAoc3RyaW5nLCBhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoYXJyYXlbaV0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIFVzZXJFcnJvcjogVXNlckVycm9yLFxuICAgICAgICBQcmVSZW5kZXJlZFVzZXJFcnJvcjogUHJlUmVuZGVyZWRVc2VyRXJyb3IsXG4gICAgICAgIHJlbmRlckVycm9yOiByZW5kZXJFcnJvcixcbiAgICAgICAgZGlzcGxheUV4cHJlc3Npb246IGRpc3BsYXlFeHByZXNzaW9uLFxuICAgICAgICBkaXNwbGF5RXhwcmVzc2lvbkFycmF5OiBkaXNwbGF5RXhwcmVzc2lvbkFycmF5LFxuICAgICAgICBwcmVQYXJzZUxpbmVTdHJpbmc6IHByZVBhcnNlTGluZVN0cmluZyxcbiAgICAgICAgcGFyc2VMaW5lU3RyaW5nOiBwYXJzZUxpbmVTdHJpbmcsXG4gICAgICAgIGluc3RhbnRpYXRlVHlwaW5nRWxlbWVudEFycmF5OiBpbnN0YW50aWF0ZVR5cGluZ0VsZW1lbnRBcnJheSxcbiAgICAgICAgYXNzaWduVHlwZXNUb0V4cHJlc3Npb246IGFzc2lnblR5cGVzVG9FeHByZXNzaW9uLFxuICAgICAgICBhc3NpZ25UeXBlc1RvRXhwcmVzc2lvbkFycmF5OiBhc3NpZ25UeXBlc1RvRXhwcmVzc2lvbkFycmF5LFxuICAgICAgICBjaGVja0V4cHJlc3Npb25zQXJlRXF1YWw6IGNoZWNrRXhwcmVzc2lvbnNBcmVFcXVhbCxcbiAgICAgICAgY2hlY2tFeHByZXNzaW9uSXNJblNldDogY2hlY2tFeHByZXNzaW9uSXNJblNldCxcbiAgICAgICAgY2hlY2tTZXRzT2ZFeHByZXNzaW9uc0FyZUVxdWFsOiBjaGVja1NldHNPZkV4cHJlc3Npb25zQXJlRXF1YWwsXG4gICAgICAgIGdldE9wZXJhdG9yc0Zyb21FeHByZXNzaW9uOiBnZXRPcGVyYXRvcnNGcm9tRXhwcmVzc2lvbixcbiAgICAgICAgZ2V0T3BlcmF0b3JzRnJvbUV4cHJlc3Npb25BcnJheTogZ2V0T3BlcmF0b3JzRnJvbUV4cHJlc3Npb25BcnJheSxcbiAgICAgICAgc2Vla1R5cGVJbkV4cHJlc3Npb246IHNlZWtUeXBlSW5FeHByZXNzaW9uLFxuICAgICAgICBncmVhdGVyVGhhbkluTGV4OiBncmVhdGVyVGhhbkluTGV4XG4gICAgfTtcbn0pKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBsb2dpY1Byb29mU2hhcmVkO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wb25lbnRzIHVzZWQgYnkgdGhlIExvZ2ljUHJvb2YgaW50ZXJhY3Rpb24gcmVhZGVyLlxuICovXG52YXIgc2hhcmVkX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9zaGFyZWQudHNcIikpO1xudmFyIGRhdGFfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2RhdGEudHNcIikpO1xudmFyIGxvZ2ljUHJvb2ZTdHVkZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBCVUlMRCBJTlNUQU5DRVxuICAgIC8vIFRoZXNlIGV2YWx1YXRpb24gcnVsZXMgbXVzdCBhbGwgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGVpciBzcGVjaWZpZWQgb3V0cHV0XG4gICAgLy8gdHlwZSAoYm9vbGVhbiwgaW50ZWdlciwgc3RyaW5nLCBmb3JtdWxhIG9yIHNldF9vZl9mb3JtdWxhcykgb3IgdGhyb3cgYW5cbiAgICAvLyBlcnJvciB3aXRoIG1lc3NhZ2UgJ2V2YWx1YXRpb24gZmFpbGVkJy4gVGhleSB3aWxsIGJlIHVzZWQgYnkgZXZhbHVhdGUoKVxuICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSB2YWx1ZSBvZiBhbiBleHByZXNzaW9uIHRoYXQgY29udGFpbnMgdGhlc2Ugb3BlcmF0b3JzLlxuICAgIC8vIEV2YWx1YXRpb24gc3RyaWN0bmVzczogaWYgYW4gZXJyb3Igb2NjdXJzIGF0IGFueSBwb2ludCBpbiBhIGNvbXB1dGF0aW9uXG4gICAgLy8gdGhlbiB0aGUgZW50aXJlIGNvbXB1dGF0aW9uIHdpbGwgcmV0dXJuIGFuIGVycm9yOyBzbyBmb3IgZXhhbXBsZVxuICAgIC8vIHRydWV8fGVycm9yIGV2YWx1YXRlcyBhcyBlcnJvciByYXRoZXIgdGhhbiB0cnVlLiBUaGUgZXhjZXB0aW9ucyB0byB0aGlzXG4gICAgLy8gYXJlIGJvdW5kZWQgcXVhbnRpZmljYXRpb24gYW5kIHJhbmdlZCBmdW5jdGlvbnM7IGZvciB0aGVzZSB3ZSB3aWxsXG4gICAgLy8gZXZhbHVhdGUgdW50aWwgd2UgcmVhY2ggYW4gYW5zd2VyIGFuZCB0aGVuIHJldHVybiB3aXRob3V0IGNvbXB1dGluZyBhbnlcbiAgICAvLyBsYXRlciB2YWx1ZXMuIFNvIGZvciBleGFtcGxlIG1pbnt4PG58QSh4KX0gd2hlcmUgfkEoMSk9ZmFsc2UsIEEoMik9dHJ1ZVxuICAgIC8vIGFuZCBBKDMpPWVycm9yIHdpbGwgcmV0dXJuIHRydWUgcmF0aGVyIHRoYW4gZXJyb3IuIFRoZSBkZWZhdWx0IGNvbnRyb2xcbiAgICAvLyBmdW5jdGlvbnMgcmVseSBoZWF2aWx5IG9uIHRoaXMgZnVuY3Rpb25hbGl0eSBhbmQgd2lsbCBuZWVkIHRvIGJlIHJld3JpdHRlblxuICAgIC8vIGlmIGl0IGlzIGNoYW5nZWQuXG4gICAgdmFyIEJBU0VfQ09OVFJPTF9NT0RFTCA9IHtcbiAgICAgICAgZXZhbHVhdGlvbl9ydWxlczoge1xuICAgICAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcjoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3Q6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbXBsaWVzOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYXJnc1swXSB8fCBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZmY6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhcmdzWzBdICYmIGFyZ3NbMV0pIHx8ICghYXJnc1swXSAmJiAhYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVxdWFsczoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncywgdHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlc1swXSA9PT0gJ2Zvcm11bGEnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRfdHNfMS5kZWZhdWx0LmNoZWNrRXhwcmVzc2lvbnNBcmVFcXVhbChhcmdzWzBdLCBhcmdzWzFdKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXJnc1swXS50eXBlID09PSAnc2V0X29mX2Zvcm11bGFzJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZF90c18xLmRlZmF1bHQuY2hlY2tTZXRzT2ZFeHByZXNzaW9uc0FyZUVxdWFsKGFyZ3NbMF0sIGFyZ3NbMV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXJnc1swXSA9PT0gYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdF9lcXVhbHM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MsIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZXNbMF0gPT09ICdmb3JtdWxhJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIXNoYXJlZF90c18xLmRlZmF1bHQuY2hlY2tFeHByZXNzaW9uc0FyZUVxdWFsKGFyZ3NbMF0sIGFyZ3NbMV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIChhcmdzWzBdLnR5cGUgPT09ICdzZXRfb2ZfZm9ybXVsYXMnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXNoYXJlZF90c18xLmRlZmF1bHQuY2hlY2tTZXRzT2ZFeHByZXNzaW9uc0FyZUVxdWFsKGFyZ3NbMF0sIGFyZ3NbMV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXJnc1swXSAhPT0gYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlc3NfdGhhbjoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFyZ3NbMF0gPCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVzc190aGFuX29yX2VxdWFsczoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFyZ3NbMF0gPD0gYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdyZWF0ZXJfdGhhbjoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFyZ3NbMF0gPiBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JlYXRlcl90aGFuX29yX2VxdWFsczoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFyZ3NbMF0gPj0gYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzX2luOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFyZWRfdHNfMS5kZWZhdWx0LmNoZWNrRXhwcmVzc2lvbklzSW5TZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZGl0aW9uOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdICsgYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VidHJhY3Rpb246IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF0gLSBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXSAqIGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpdmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdIC8gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb25lbnRpYXRpb246IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF0gXiBhcmdzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3VuZGVkX2Zvcl9hbGw6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0b3BfZG93bicsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbnB1dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRzW2tleV0gPSBpbnB1dHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRlciA9IGV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzWzBdLmFyZ3VtZW50c1sxXSwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uYXJndW1lbnRzWzBdLmFyZ3VtZW50c1swXS50eXBlID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZUVuZCA9IChleHByZXNzaW9uLmFyZ3VtZW50c1swXS50b3Bfb3BlcmF0b3JfbmFtZSA9PT0gJ2xlc3NfdGhhbicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGVyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmFuZ2VFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1tleHByZXNzaW9uLmR1bW1pZXNbMF0udG9wX29wZXJhdG9yX25hbWVdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzWzFdLCBuZXdJbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUsIHRoZSBib3VuZGVyIGlzIGEgc2V0X29mX2Zvcm11bGFzIChzbyBhbiBhcnJheSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dHNbZXhwcmVzc2lvbi5kdW1taWVzWzBdLnRvcF9vcGVyYXRvcl9uYW1lXSA9IGJvdW5kZXJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmFsdWF0ZShleHByZXNzaW9uLmFyZ3VtZW50c1sxXSwgbmV3SW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm91bmRlZF9leGlzdHM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0b3BfZG93bicsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbnB1dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5wdXRzW2tleV0gPSBpbnB1dHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRlciA9IGV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzWzBdLmFyZ3VtZW50c1sxXSwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uYXJndW1lbnRzWzBdLmFyZ3VtZW50c1swXS50eXBlID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZUVuZCA9IChleHByZXNzaW9uLmFyZ3VtZW50c1swXS50b3Bfb3BlcmF0b3JfbmFtZSA9PT0gJ2xlc3NfdGhhbicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGVyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmFuZ2VFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1tleHByZXNzaW9uLmR1bW1pZXNbMF0udG9wX29wZXJhdG9yX25hbWVdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sIG5ld0lucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSwgdGhlIGJvdW5kZXIgaXMgYSBzZXRfb2ZfZm9ybXVsYXMgKHNvIGFuIGFycmF5KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1tleHByZXNzaW9uLmR1bW1pZXNbMF0udG9wX29wZXJhdG9yX25hbWVdID0gYm91bmRlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sIG5ld0lucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBtaW57azxufEEoayl9IHdpbGwgcmFuZ2Ugb3ZlciBbMSwuLixuLTFdLCB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm8gbWF0Y2ggaXMgZm91bmQuXG4gICAgICAgICAgICAvLyBtaW57cOKIiGFudGVjZWRlbnRzKG4pfEEocCl9IHdpbGwgcmFuZ2Ugb3ZlciBhbnRlY2VkZW50cyhuKSwgdGhyb3dpbmdcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlxuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAndG9wX2Rvd24nLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb24sIGlucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5wdXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1trZXldID0gaW5wdXRzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kZXIgPSBldmFsdWF0ZShleHByZXNzaW9uLmFyZ3VtZW50c1swXS5hcmd1bWVudHNbMV0sIGlucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmFyZ3VtZW50c1swXS5hcmd1bWVudHNbMF0udHlwZSA9PT0gJ2ludGVnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2VFbmQgPSAoZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0udG9wX29wZXJhdG9yX25hbWUgPT09ICdsZXNzX3RoYW4nKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRlciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlRW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dHNbZXhwcmVzc2lvbi5kdW1taWVzWzBdLnRvcF9vcGVyYXRvcl9uYW1lXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzWzFdLCBuZXdJbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1tleHByZXNzaW9uLmR1bW1pZXNbMF0udG9wX29wZXJhdG9yX25hbWVdID0gYm91bmRlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sIG5ld0lucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kZXJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heDoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3RvcF9kb3duJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByZXNzaW9uLCBpbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0lucHV0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dHNba2V5XSA9IGlucHV0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGVyID0gZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0uYXJndW1lbnRzWzFdLCBpbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0uYXJndW1lbnRzWzBdLnR5cGUgPT09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gKGV4cHJlc3Npb24uYXJndW1lbnRzWzBdLnRvcF9vcGVyYXRvcl9uYW1lID09PSAnbGVzc190aGFuJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kZXIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kZXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlRW5kIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lucHV0c1tleHByZXNzaW9uLmR1bW1pZXNbMF0udG9wX29wZXJhdG9yX25hbWVdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sIG5ld0lucHV0cywgbW9kZWwsIGV2YWx1YXRpb25QYXJhbWV0ZXJzLCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGJvdW5kZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnB1dHNbZXhwcmVzc2lvbi5kdW1taWVzWzBdLnRvcF9vcGVyYXRvcl9uYW1lXSA9IGJvdW5kZXJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzWzFdLCBuZXdJbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib3VuZGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBvbmUgZm9yIHRoZXNlIGJlY2F1c2UgZm9yIHRoZSB1c2VyIHByb29mIGxpbmVzIGFyZSBpbmRleGVkXG4gICAgICAgICAgICAvLyBmcm9tIDEuXG4gICAgICAgICAgICBpbmRlbnRhdGlvbjoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncywgdHlwZXMsIGV2YWx1YXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gZXZhbHVhdGlvblBhcmFtZXRlcnMucHJvb2YubGluZXNbYXJnc1swXSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2YWx1YXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuaW5kZW50YXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzLCB0eXBlcywgZXZhbHVhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBldmFsdWF0aW9uUGFyYW1ldGVycy5wcm9vZi5saW5lc1thcmdzWzBdIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcJycgKyBsaW5lLnRlbXBsYXRlX25hbWUgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW50ZWNlZGVudHM6IHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBhc3N1bWVzIGFudGVjZWRlbnRzIGFyZSBnaXZlbiBhcyBmb3JtdWxhcywgbm90IGludGVnZXJzXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzLCB0eXBlcywgZXZhbHVhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBldmFsdWF0aW9uUGFyYW1ldGVycy5wcm9vZi5saW5lc1thcmdzWzBdIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5hbnRlY2VkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5hbnRlY2VkZW50c1tpXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHRzOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzLCB0eXBlcywgZXZhbHVhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBldmFsdWF0aW9uUGFyYW1ldGVycy5wcm9vZi5saW5lc1thcmdzWzBdIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MsIHR5cGVzLCBldmFsdWF0aW9uUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGV2YWx1YXRpb25QYXJhbWV0ZXJzLnByb29mLmxpbmVzW2FyZ3NbMF0gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncywgdHlwZXMsIGV2YWx1YXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gZXZhbHVhdGlvblBhcmFtZXRlcnMucHJvb2YubGluZXNbYXJnc1swXSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2YWx1YXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncywgdHlwZXMsIGV2YWx1YXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IGlzIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHN1Y2ggYXMgXFwnUlxcJywgc29cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbXVzdCBzdHJpcCB0aGUgcXVvdGVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGFyZ3NbMF0uc3Vic3RyKDEsIGFyZ3NbMF0ubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gZXZhbHVhdGlvblBhcmFtZXRlcnMucHJvb2YubGluZXNbYXJnc1sxXSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2YWx1YXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxpbmUubWF0Y2hpbmdzW2VsZW1lbnRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZhbHVhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1fbGluZXM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdib3R0b21fdXAnLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFyZ3MsIHR5cGVzLCBldmFsdWF0aW9uUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZhbHVhdGlvblBhcmFtZXRlcnMucHJvb2YubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3N1bXB0aW9uczoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncywgdHlwZXMsIGV2YWx1YXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0aW9uUGFyYW1ldGVycy5hc3N1bXB0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzLCB0eXBlcywgZXZhbHVhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRpb25QYXJhbWV0ZXJzLnRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlc3Rpb25fdmFyaWFibGVzOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzLCB0eXBlcywgZXZhbHVhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzID0gc2hhcmVkX3RzXzEuZGVmYXVsdC5nZXRPcGVyYXRvcnNGcm9tRXhwcmVzc2lvbkFycmF5KGV2YWx1YXRpb25QYXJhbWV0ZXJzLmFzc3VtcHRpb25zLmNvbmNhdChbZXZhbHVhdGlvblBhcmFtZXRlcnMudGFyZ2V0XSksIFsndmFyaWFibGUnXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdXMgdGhlIHZhcmlhYmxlcyBhcyBzdHJpbmdzLCB3ZSBjb252ZXJ0IHRoZW0gdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9raW5kX25hbWU6ICd2YXJpYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6IG5hbWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW1pZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRyeToge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJnc1sxXVthcmdzWzBdIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZS1wcm9wc1xuICAgICAgICAgICAgJ2lmJzoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JvdHRvbV91cCcsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXSA/IGFyZ3NbMV0gOiBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJzdGl0dXRlOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnYm90dG9tX3VwJyxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnNbYXJnc1sxXS50b3Bfb3BlcmF0b3JfbmFtZV0gPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZUludG9FeHByZXNzaW9uKGFyZ3NbMF0sIHN1YnN0aXR1dGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBydW4gd2hlbiB0aGUgc3RhdGUgaXMgbG9hZGVkLCBpdCBpcyB0b3AtbGV2ZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXN0aW9uRGF0YSAtIFRoZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0ZWFjaGVyIHNwZWNpZnlpbmdcbiAgICAgKiAgICAgICAgdGhlIHF1ZXN0aW9uIC0gdGhpcyB3aWxsIGJlIG9uZSBvZiB0aGUga2V5cyBvZiB0aGUgaW50ZXJhY3Rpb24nc1xuICAgICAqICAgICAgICBjdXN0b21pemF0aW9uX2FyZ3MuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIFF1ZXN0aW9uSW5zdGFuY2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIGFuZFxuICAgICAqICAgICAgICBjaGVjayBwcm9vZnMgZnJvbSB0aGUgc3R1ZGVudC5cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRJbnN0YW5jZSA9IGZ1bmN0aW9uIChxdWVzdGlvbkRhdGEpIHtcbiAgICAgICAgdmFyIGV2YWx1YXRpb25SdWxlcyA9IGFuZ3VsYXIuY29weShCQVNFX0NPTlRST0xfTU9ERUwuZXZhbHVhdGlvbl9ydWxlcyk7XG4gICAgICAgIHZhciBjb250cm9sT3BlcmF0b3JzID0gYW5ndWxhci5jb3B5KGRhdGFfdHNfMS5kZWZhdWx0LkJBU0VfQ09OVFJPTF9MQU5HVUFHRS5vcGVyYXRvcnMpO1xuICAgICAgICAvLyBOT1RFOiB0aGUgamF2YXNjcmlwdCBmYWlscyBpZiB3ZSB0cnkgdG8gb21pdCB0aGlzIGZ1bmN0aW9uIGFuZCBkZWZpbmVcbiAgICAgICAgLy8gZXZhbHVhdGVFeHByZXNzaW9uKCkgZGlyZWN0bHkgaW5zaWRlIHRoZSBmb3IgbG9vcC4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9qc2xpbnRlcnJvcnMuY29tL2RvbnQtbWFrZS1mdW5jdGlvbnMtd2l0aGluLWEtbG9vcFxuICAgICAgICB2YXIgbWFrZUV2YWx1YXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblBhcmFtZXRlcnMsIGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50VmFsdWVzID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRWYWx1ZXNbdmFyaWFibGVzW2ldLnRvcF9vcGVyYXRvcl9uYW1lXSA9IGV2YWx1YXRlKGV4cHJlc3Npb24uYXJndW1lbnRzW2ldLCBpbnB1dHMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbHVhdGUoZGVmaW5pdGlvbiwgYXJndW1lbnRWYWx1ZXMsIG1vZGVsLCBldmFsdWF0aW9uUGFyYW1ldGVycywgY2FjaGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVzdGlvbkRhdGEuY29udHJvbF9mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV2YWx1YXRpb25SdWxlc1txdWVzdGlvbkRhdGEuY29udHJvbF9mdW5jdGlvbnNbaV0ubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnZGVmaW5pdGlvbicsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uOiBtYWtlRXZhbHVhdGVFeHByZXNzaW9uKHF1ZXN0aW9uRGF0YS5jb250cm9sX2Z1bmN0aW9uc1tpXS5kZWZpbml0aW9uLCBxdWVzdGlvbkRhdGEuY29udHJvbF9mdW5jdGlvbnNbaV0udmFyaWFibGVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRyb2xPcGVyYXRvcnNbcXVlc3Rpb25EYXRhLmNvbnRyb2xfZnVuY3Rpb25zW2ldLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwcmVmaXhfZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGluZzogcXVlc3Rpb25EYXRhLmNvbnRyb2xfZnVuY3Rpb25zW2ldLnR5cGluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzdW1wdGlvbnM6IHF1ZXN0aW9uRGF0YS5hc3N1bXB0aW9ucyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHF1ZXN0aW9uRGF0YS5yZXN1bHRzLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlczogZGF0YV90c18xLmRlZmF1bHQuQkFTRV9TVFVERU5UX0xBTkdVQUdFLnR5cGVzLFxuICAgICAgICAgICAgICAgIGtpbmRzOiBkYXRhX3RzXzEuZGVmYXVsdC5CQVNFX1NUVURFTlRfTEFOR1VBR0Uua2luZHMsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzOiBxdWVzdGlvbkRhdGEubGFuZ3VhZ2Uub3BlcmF0b3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZV90ZW1wbGF0ZXM6IHF1ZXN0aW9uRGF0YS5saW5lX3RlbXBsYXRlcyxcbiAgICAgICAgICAgIHZvY2FidWxhcnk6IHF1ZXN0aW9uRGF0YS52b2NhYnVsYXJ5LFxuICAgICAgICAgICAgZ2VuZXJhbF9tZXNzYWdlczogcXVlc3Rpb25EYXRhLmdlbmVyYWxfbWVzc2FnZXMsXG4gICAgICAgICAgICBtaXN0YWtlX3RhYmxlOiBxdWVzdGlvbkRhdGEubWlzdGFrZV90YWJsZSxcbiAgICAgICAgICAgIGNvbnRyb2xfbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlczogZGF0YV90c18xLmRlZmF1bHQuQkFTRV9DT05UUk9MX0xBTkdVQUdFLnR5cGVzLFxuICAgICAgICAgICAgICAgIGtpbmRzOiBkYXRhX3RzXzEuZGVmYXVsdC5CQVNFX0NPTlRST0xfTEFOR1VBR0Uua2luZHMsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzOiBjb250cm9sT3BlcmF0b3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udHJvbF9tb2RlbDoge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRpb25fcnVsZXM6IGV2YWx1YXRpb25SdWxlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gQlVJTEQgUFJPT0ZcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlkZW50aWZpZXMgYSB3YXkgaW4gd2hpY2ggdGhlIGV4cHJlc3Npb24gaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiB0ZW1wbGF0ZSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdC4gRXhhbXBsZXM6XG4gICAgICogLSBBKHgp4oindCwgcOKIp3EsIHt9IHdpbGwgcmV0dXJuIHtwOiBBKHgpLCBxOnR9XG4gICAgICogLSBBKHgp4oindCwgcOKIp3EsIHtxOiBzfSB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICogLSDiiIN5LlIoeSksIOKIg3gucCwge30gd2lsbCByZXR1cm4ge3g6eSwgcDogUih5KX0gYXMgZHVtbWllcyBhbHNvIG1hdGNoZWRcbiAgICAgKiBPbmx5IHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUgY2FuIGJlIG1hdGNoZWQgdG8gYXJiaXRyYXJ5IGV4cHJlc3Npb25zIGluXG4gICAgICogdGhlIGV4cHJlc3Npb247IGUuZy4gcuKIqHMgaXMgbm90IGFuIGluc3RhbmNlIG9mIHDiiKdxIGJlY2F1c2Ug4oinIGlzIG5vdCBhXG4gICAgICogdmFyaWFibGUgYW5kIHNvIG5lZWRzIHRvIGJlIG1hdGNoZWQgZXhhY3RseS5cbiAgICAgKiBAcGFyYW0ge0V4cHJlc3Npb259IGV4cHJlc3Npb24gLSBhbiBFeHByZXNzaW9uLCB3aGljaCBpcyB0byBiZSBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtFeHByZXNzaW9ufSB0ZW1wbGF0ZSAtIHRoZSBFeHByZXNzaW9uIGFnYWluc3Qgd2hpY2ggd2Ugd2lsbCBtYXRjaFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvbGRNYXRjaGluZ3MgLSB2YXJpYWJsZXMgcG90ZW50aWFsbHkgaW4gdGhlIHRlbXBsYXRlIHdob3NlXG4gICAgICogICAgICAgIGNvcnJlc3BvbmRpbmcgc3ViLWV4cHJlc3Npb25zIGluIHRoZSBleHByZXNzaW9uIHdlIGhhdmUgcHJldmlvdXNseVxuICAgICAqICAgICAgICBpZGVudGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSBkaWN0aW9uYXJ5IGV4dGVuZGluZyBvbGRFbGVtZW50cywgdGhhdCBmb3IgbmV3XG4gICAgICogICBvcGVyYXRvcnMgaW4gdGVtcGxhdGUgZ2l2ZXMgdGhlIGNvcnJlc3BvbmRpbmcgb3BlcmF0b3IgaW4gZXhwcmVzc2lvbi5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBleHByZXNzaW9uIGNhbm5vdCBiZSB2aWV3ZWQgYXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHZhciBtYXRjaEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgdGVtcGxhdGUsIG9sZE1hdGNoaW5ncykge1xuICAgICAgICB2YXIgbWF0Y2hpbmdzID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvbGRNYXRjaGluZ3MpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nc1trZXldID0gb2xkTWF0Y2hpbmdzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBsYXRlLnRvcF9raW5kX25hbWUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ3MuaGFzT3duUHJvcGVydHkodGVtcGxhdGUudG9wX29wZXJhdG9yX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlZF90c18xLmRlZmF1bHQuY2hlY2tFeHByZXNzaW9uc0FyZUVxdWFsKGV4cHJlc3Npb24sIG9sZE1hdGNoaW5nc1t0ZW1wbGF0ZS50b3Bfb3BlcmF0b3JfbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5Vc2VyRXJyb3IoJ3VubWF0Y2hlZF9saW5lJywge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nc1t0ZW1wbGF0ZS50b3Bfb3BlcmF0b3JfbmFtZV0gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSAhPT0gdGVtcGxhdGUudG9wX29wZXJhdG9yX25hbWUgfHxcbiAgICAgICAgICAgIGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSAhPT0gdGVtcGxhdGUudG9wX2tpbmRfbmFtZSB8fFxuICAgICAgICAgICAgZXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoICE9PSB0ZW1wbGF0ZS5hcmd1bWVudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBleHByZXNzaW9uLmR1bW1pZXMubGVuZ3RoICE9PSB0ZW1wbGF0ZS5kdW1taWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCd1bm1hdGNoZWRfbGluZScsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBtYXRjaGluZyBwdXJwb3NlcyBhcmd1bWVudHMgYW5kIGR1bW1pZXMgYXJlIGVxdWl2YWxlbnRcbiAgICAgICAgICAgIHZhciBzdWJFeHByZXNzaW9ucyA9IGV4cHJlc3Npb24uYXJndW1lbnRzLmNvbmNhdChleHByZXNzaW9uLmR1bW1pZXMpO1xuICAgICAgICAgICAgdmFyIHN1YlRlbXBsYXRlcyA9IHRlbXBsYXRlLmFyZ3VtZW50cy5jb25jYXQodGVtcGxhdGUuZHVtbWllcyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hFeHByZXNzaW9uQXJyYXkoc3ViRXhwcmVzc2lvbnMsIHN1YlRlbXBsYXRlcywgbWF0Y2hpbmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQ29tcGFuaW9uIG9mIG1hdGNoRXhwcmVzc2lvbi5cbiAgICB2YXIgbWF0Y2hFeHByZXNzaW9uQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHRlbXBsYXRlQXJyYXksIG1hdGNoaW5ncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXRjaGluZ3MgPSBtYXRjaEV4cHJlc3Npb24oYXJyYXlbaV0sIHRlbXBsYXRlQXJyYXlbaV0sIG1hdGNoaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoaW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXhwcmVzc2lvbn0gZXhwcmVzc2lvbiAtIGFuIEV4cHJlc3Npb24gaW50byB3aGljaCB3ZSBhcmVcbiAgICAgKiAgIHN1YnN0aXR1dGluZywgZS5nLiB4PXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9ucyAtIGEgZGljdGlvbmFyeSBvZiB7c3RyaW5nOiBFeHByZXNzaW9ufVxuICAgICAqICAgc3BlY2lmeWluZyB0aGUgc3Vic3RpdGlvbnMgdG8gcGVyZm9ybSAoc2ltdWx0YW5lb3VzbHkpLCBlLmdcbiAgICAgKiAgIHt4OjIsIHk6YStifVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoZSBzdWJzdGl0dXRlZCBFeHByZXNzaW9uLCBlLmcuIDI9YStiXG4gICAgICovXG4gICAgdmFyIHN1YnN0aXR1dGVJbnRvRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBzdWJzdGl0dXRpb25zKSB7XG4gICAgICAgIC8vIFdlIGlnbm9yZSBzdWJzdGl0dXRpb25zIGZvciBkdW1teSB2YXJpYWJsZXMuXG4gICAgICAgIHZhciBuZXdTdWJzdGl0dXRpb25zID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdWJzdGl0dXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaXNEdW1teSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmR1bW1pZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5kdW1taWVzW2ldLnRvcF9vcGVyYXRvcl9uYW1lID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEdW1teSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0R1bW15KSB7XG4gICAgICAgICAgICAgICAgbmV3U3Vic3RpdHV0aW9uc1trZXldID0gc3Vic3RpdHV0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zLmhhc093blByb3BlcnR5KGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0aW9uc1tleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6IGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUsXG4gICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogc3Vic3RpdHV0ZUludG9FeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbi5hcmd1bWVudHMsIG5ld1N1YnN0aXR1dGlvbnMpLFxuICAgICAgICAgICAgICAgIGR1bW1pZXM6IHN1YnN0aXR1dGVJbnRvRXhwcmVzc2lvbkFycmF5KGV4cHJlc3Npb24uZHVtbWllcywgbmV3U3Vic3RpdHV0aW9ucylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIENvbXBhbmlvbiB0byBzdWJzdGl0dXRlSW50b0V4cHJlc3Npb24uXG4gICAgdmFyIHN1YnN0aXR1dGVJbnRvRXhwcmVzc2lvbkFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBzdWJzdGl0dXRpb25zKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goc3Vic3RpdHV0ZUludG9FeHByZXNzaW9uKGFycmF5W2ldLCBzdWJzdGl0dXRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIC8vIFJlcGxhY2VzIGFsbCBvcGVyYXRvcnMgZnJvbSBleHByZXNzaW9uIChpbmNsdWRpbmcgZHVtbWllcykgdGhhdCBhcHBlYXIgaW5cbiAgICAvLyB0aGUgZGljdGlvbmFyeSAnbWF0Y2hpbmdzJyB3aXRoIHRoZWlyIHZhbHVlcyBpbiBtYXRjaGluZ3MuXG4gICAgdmFyIGluc3RhbnRpYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBtYXRjaGluZ3MpIHtcbiAgICAgICAgaWYgKG1hdGNoaW5ncy5oYXNPd25Qcm9wZXJ0eShleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nc1tleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgdG9wX29wZXJhdG9yX25hbWU6IGV4cHJlc3Npb24udG9wX29wZXJhdG9yX25hbWUsXG4gICAgICAgICAgICAgICAgdG9wX2tpbmRfbmFtZTogZXhwcmVzc2lvbi50b3Bfa2luZF9uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogaW5zdGFudGlhdGVFeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbi5hcmd1bWVudHMsIG1hdGNoaW5ncyksXG4gICAgICAgICAgICAgICAgZHVtbWllczogaW5zdGFudGlhdGVFeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbi5kdW1taWVzLCBtYXRjaGluZ3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluc3RhbnRpYXRlRXhwcmVzc2lvbkFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBtYXRjaGluZ3MpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChpbnN0YW50aWF0ZUV4cHJlc3Npb24oYXJyYXlbaV0sIG1hdGNoaW5ncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V4cHJlc3Npb25UZW1wbGF0ZX0gdGVtcGxhdGUgLSBhbiBFeHByZXNzaW9uVGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hpbmdzIC0gYSBkaWN0aW9uYXJ5IG9mIHtzdHJpbmc6IEV4cHJlc3Npb259XG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn1cbiAgICAgKi9cbiAgICB2YXIgY29tcHV0ZUV4cHJlc3Npb25Gcm9tVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG1hdGNoaW5ncykge1xuICAgICAgICAvLyBFLmcuIHRlbXBsYXRlIHJlcHJlc2VudHMgcFt4IC0+IGFdIGFuZCBtYXRjaGluZ3MgcmVwcmVzZW50c1xuICAgICAgICAvLyB7cDogQSh5KSwgeDogeSwgYTogMn1cbiAgICAgICAgdmFyIG5ld0V4cHJlc3Npb24gPSBpbnN0YW50aWF0ZUV4cHJlc3Npb24odGVtcGxhdGUuZXhwcmVzc2lvbiwgbWF0Y2hpbmdzKTtcbiAgICAgICAgdmFyIG5ld1N1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZS5zdWJzdGl0dXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGVtcGxhdGUuc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvblttYXRjaGluZ3Nba2V5XS50b3Bfb3BlcmF0b3JfbmFtZV0gPSBpbnN0YW50aWF0ZUV4cHJlc3Npb24odGVtcGxhdGUuc3Vic3RpdHV0aW9uc1tpXVtrZXldLCBtYXRjaGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3U3Vic3RpdHV0aW9ucy5wdXNoKHN1YnN0aXR1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRS5nLiBub3cgbmV3X2V4cHJlc3Npb24gaXMgQSh5KSBhbmQgbmV3X3N1YnNpdHV0aW9ucyByZXByZXNlbnRzIFt5IC0+IDJdXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U3Vic3RpdHV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3RXhwcmVzc2lvbiA9IHN1YnN0aXR1dGVJbnRvRXhwcmVzc2lvbihuZXdFeHByZXNzaW9uLCBuZXdTdWJzdGl0dXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RXhwcmVzc2lvbjtcbiAgICAgICAgLy8gRS5nLiByZXN1bHQgaXMgQSgyKVxuICAgIH07XG4gICAgdmFyIGNvbXB1dGVFeHByZXNzaW9uc0Zyb21UZW1wbGF0ZUFycmF5ID0gZnVuY3Rpb24gKHRlbXBsYXRlQXJyYXksIG1hdGNoaW5ncykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY29tcHV0ZUV4cHJlc3Npb25Gcm9tVGVtcGxhdGUodGVtcGxhdGVBcnJheVtpXSwgbWF0Y2hpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPExpbmVNZXNzYWdlcz59IG1lc3NhZ2VzIC0gYW4gYXJyYXkgb2YgTGluZU1lc3NhZ2VzLCBlYWNoIG9mXG4gICAgICogICAgICAgIHdoaWNoIGRlc2NyaWJlcyB0aGUgbWlzdGFrZSB0aGUgc3R1ZGVudCBoYXMgbWFkZSBieSB3cml0aW5nIHRoaXNcbiAgICAgKiAgICAgICAgc29ydCBvZiBsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgTGluZVRlbXBsYXRlIGZyb20gd2hpY2ggdGhlXG4gICAgICogICAgICAgIG1lc3NhZ2VzIGNvbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1hdGNoaW5ncyAtIGEge3N0cmluZzogRXhwcmVzc2lvbn0gZGljdGlvbmFyeSBkZWR1Y2VkIGZyb21cbiAgICAgKiAgICAgICAgY29tcGFyaW5nIHRoZSBsaW5lIHRoZSBzdHVkZW50IGFjdHVhbGx5IHdyb3RlIHRvIHRoZSBMaW5lVGVtcGxhdGVcbiAgICAgKiAgICAgICAgcHJvdmlkZWQgYnkgdGhlIHRlY2hlciBvZiB3aGljaCBpdCBpcyBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3JzIC0gZnJvbSB0aGUgc3R1ZGVudCBMYW5ndWFnZSBhbmQgdXNlZCBmb3IgZGlzcGxheVxuICAgICAqICAgICAgICBwdXJwb3Nlcy5cbiAgICAgKiBAdGhyb3dzIFRoaXMgZnVuY3Rpb24gdGhyb3dzIGEgbG9naWNQcm9vZlNoYXJlZC5Vc2VyRXJyb3IgKHdpdGggdGhlXG4gICAgICogICAgICAgICAncHJlLXJlbmRlcmVkJyBjb2RlKSB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIHN0cmluZ3MgZGVzY3JpYmluZ1xuICAgICAqICAgICAgICAgdGhlIGVycm9yLCBvbmUgb2Ygd2hpY2ggd2lsbCBiZSBjaG9zZW4gbGF0ZXIgdG8gc2hvdyB0byB0aGVcbiAgICAgKiAgICAgICAgIHN0dWRlbnQuIElmIHRoZSBtZXNzYWdlcyBsaXN0IGlzIGVtcHR5IChzaWduaWZ5aW5nIHRoYXQgdGhlIGxpbmVcbiAgICAgKiAgICAgICAgIGluIHF1ZXN0aW9uIGlzIGEgY29ycmVjdCBvbmUpIHdlIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgdmFyIHRocm93TGluZU1lc3NhZ2VzID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCB0ZW1wbGF0ZU5hbWUsIG1hdGNoaW5ncywgb3BlcmF0b3JzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkTWVzc2FnZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNbaV1bal0uZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRNZXNzYWdlc1tpXSArPSBtZXNzYWdlc1tpXVtqXS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRNZXNzYWdlc1tpXSArPSBzaGFyZWRfdHNfMS5kZWZhdWx0LmRpc3BsYXlFeHByZXNzaW9uKGNvbXB1dGVFeHByZXNzaW9uRnJvbVRlbXBsYXRlKG1lc3NhZ2VzW2ldW2pdLmNvbnRlbnQsIG1hdGNoaW5ncyksIG9wZXJhdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5QcmVSZW5kZXJlZFVzZXJFcnJvcihyZW5kZXJlZE1lc3NhZ2VzLCB0ZW1wbGF0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBwcm90b0xpbmUgaXMgYW4gaW5zdGFuY2Ugb2YgdGVtcGxhdGUsIGluIHRlcm1zIG9mIGJvdGhcbiAgICAgKiBleHByZXNzaW9ucyBhbmQgcGhyYXNlcy5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwcm90b0xpbmUgLSBhIFByb3RvTGluZSwgdGhhdCBpcyBhbiBhcnJheSBvZiBwaHJhc2VzXG4gICAgICogICAgICAgIGFuZCBleHByZXNzaW9uc1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHRlbXBsYXRlIC0gdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlYWRlcl92aWV3IGtleVxuICAgICAqICAgICAgICBvZiBhIExpbmVUZW1wbGF0ZSwgc28gYW4gYXJyYXkgb2YgcGhyYXNlcyBhbmQgRXhwcmVzc2lvblRlbXBsYXRlcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgZGljdGlvbmFyeSBvZiB0aGUgZm9ybSB7c3RyaW5nOiBFeHByZXNzaW9ufSB0aGF0XG4gICAgICogICAgICAgIHNwZWNpZmllcyB3aGF0IGVhY2ggdmFyaWFibGUgLyBhdG9tIGluIHRoZSB0ZW1wbGF0ZSBjb3JyZXNwb25kcyB0b1xuICAgICAqICAgICAgICBpbiB0aGUgcHJvdG9MaW5lLlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIGxpbmUgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hMaW5lVG9UZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcm90b0xpbmUsIHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFRoZXNlIHdpdG5lc3MgdGhhdCB0aGUgcHJvdG9MaW5lIGlzIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZS4gRm9yXG4gICAgICAgIC8vIGV4YW1wbGUgaWYgdGhlIHByb3RvTGluZSBpcyAnd2Uga25vdyBB4oinQicgYW5kIHRoZSB0ZW1wbGF0ZSBpcyAnd2Uga25vd1xuICAgICAgICAvLyBwJyB0aGVuIG1hdGNoaW5ncyB3b3VsZCBlbmQgdXAgYXMge3A6IEHiiKdCfS5cbiAgICAgICAgdmFyIG1hdGNoaW5ncyA9IHt9O1xuICAgICAgICAvLyBDaGVjayB1bnN1YnN0aXR1dGVkIGV4cHJlc3Npb25zIGFncmVlXG4gICAgICAgIGlmIChwcm90b0xpbmUubGVuZ3RoICE9PSB0ZW1wbGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzaGFyZWRfdHNfMS5kZWZhdWx0LlVzZXJFcnJvcigndW5tYXRjaGVkX2xpbmUnLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm90b0xpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwcm90b0xpbmVbaV0uZm9ybWF0ICE9PSB0ZW1wbGF0ZVtpXS5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5Vc2VyRXJyb3IoJ3VubWF0Y2hlZF9saW5lJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3RvTGluZVtpXS5mb3JtYXQgPT09ICdleHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdW5zdWJzdGl0dXRlZCBleHByZXNzaW9uIHRlbXBsYXRlcyBhcmUgdXNlZnVsIGluIGVzdGFibGlzaGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBtYXRjaGluZ3MuIGUuZy4gaWYgd2UgYXJlIHRvbGQgc2ltcGxlIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZGluZyB0byBwW3gtPmFdIGl0IHdpbGwgbm90IGJlIHBvc3NpYmxlIHRvIGRpc2Nlcm4gcCwgeCBvclxuICAgICAgICAgICAgICAgIC8vIGEsIGJlY2F1c2UgdGhlcmUgYXJlIG1hbnkgcG9zc2libGUgc3Vic2l0dXRpb25zIHRoYXQgY291bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2VkIHRoZSBleHByZXNzaW9uIHdlIHNlZS5cbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0uY29udGVudC5zdWJzdGl0dXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ3MgPSBtYXRjaEV4cHJlc3Npb24ocHJvdG9MaW5lW2ldLmNvbnRlbnQsIHRlbXBsYXRlW2ldLmNvbnRlbnQuZXhwcmVzc2lvbiwgbWF0Y2hpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93LCBjaGVjayB0aGUgc3Vic3RpdHV0ZWQgZXhwcmVzc2lvbiB0ZW1wbGF0ZXMgYWdyZWUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdG9MaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocHJvdG9MaW5lW2ldLmZvcm1hdCA9PT0gJ2V4cHJlc3Npb24nICYmXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVbaV0uY29udGVudC5zdWJzdGl0dXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGNvbXB1dGVFeHByZXNzaW9uRnJvbVRlbXBsYXRlKHRlbXBsYXRlW2ldLmNvbnRlbnQsIG1hdGNoaW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFyZWRfdHNfMS5kZWZhdWx0LmNoZWNrRXhwcmVzc2lvbnNBcmVFcXVhbChwcm90b0xpbmVbaV0uY29udGVudCwgZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCd1bm1hdGNoZWRfbGluZScsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSBjaGVjayBwaHJhc2VzIGFncmVlLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3RvTGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHByb3RvTGluZVtpXS5mb3JtYXQgPT09ICdwaHJhc2UnICYmXG4gICAgICAgICAgICAgICAgcHJvdG9MaW5lW2ldLmNvbnRlbnQgIT09IHRlbXBsYXRlW2ldLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5Vc2VyRXJyb3IoJ3VubWF0Y2hlZF9saW5lJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGluZ3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgYnVpbGRMaW5lLiBJdCBjaGVja3MgdGhhdCB0aGUgdHlwZXMgb2YgdGhlIGxpbmUgYXJlXG4gICAgICogY29ycmVjdCBhbmQgYXQgdGhlIHRvcCBhZ3JlZSB3aXRoIHRob3NlIHRoZSB0ZW1wbGF0ZSByZXF1aXJlcywgYW5kXG4gICAgICogbGlrZXdpc2UgZm9yIHRoZSBraW5kcyBvZiB0aGUgbGluZSAoaWYgdGhlIHRlbXBsYXRlIGhhcyBhbiBvcGluaW9uKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hpbmdzIC0gYSBkaWN0aW9uYXJ5IG9mIHtzdHJpbmc6IEV4cHJlc3Npb259IHRoYXRcbiAgICAgKiAgICAgICAgYWxsb3dzIHRoZSBsaW5lIHRoZSBzdHVkZW50IHdyb3RlIHRvIGJlIGRlZHVjZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgcmVhZGVyX3ZpZXcga2V5IG9mIHRoZSBMaW5lVGVtcGxhdGUgaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHthcnJheX0gdGVtcGxhdGVSZWFkZXJWaWV3IC0gdGhlIHZhbHVlIG9mIHRoZSByZWFkZXJfdmlldyBrZXkgb2YgYVxuICAgICAqICAgICAgICBMaW5lVGVtcGxhdGUsIHNvIGFuIGFycmF5IG9mIHBocmFzZXMgYW5kIEV4cHJlc3Npb25UZW1wbGF0ZXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxhbmd1YWdlIC0gYSBMYW5ndWFnZSBvYmplY3QgZ2l2aW5nIHRoZSBzdHVkZW50IGxhbmd1YWdlXG4gICAgICogQHRocm93cyBBIHR5cGluZyBlcnJvciBpZiB0aGUgdHlwZXMgYXJlIGludmFsaWQuXG4gICAgICovXG4gICAgdmFyIHJlcXVpcmVWYWxpZE1hdGNoaW5nID0gZnVuY3Rpb24gKG1hdGNoaW5ncywgdGVtcGxhdGVSZWFkZXJWaWV3LCBsYW5ndWFnZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnNUb0NoZWNrID0gW107XG4gICAgICAgIHZhciB0eXBlc1JlcXVpcmVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVSZWFkZXJWaWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVSZWFkZXJWaWV3W2ldLmZvcm1hdCA9PT0gJ2V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBjb21wdXRlRXhwcmVzc2lvbkZyb21UZW1wbGF0ZSh0ZW1wbGF0ZVJlYWRlclZpZXdbaV0uY29udGVudCwgbWF0Y2hpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVSZWFkZXJWaWV3W2ldLmNvbnRlbnQuaGFzT3duUHJvcGVydHkoJ2tpbmQnKSAmJlxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlYWRlclZpZXdbaV0uY29udGVudC5raW5kICE9PSBleHByZXNzaW9uLnRvcF9raW5kX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCd3cm9uZ19raW5kX2luX2xpbmUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfa2luZDogdGVtcGxhdGVSZWFkZXJWaWV3W2ldLmNvbnRlbnQua2luZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnNUb0NoZWNrLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgdHlwZXNSZXF1aXJlZC5wdXNoKHRlbXBsYXRlUmVhZGVyVmlld1tpXS5jb250ZW50LnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYXJlZF90c18xLmRlZmF1bHQuYXNzaWduVHlwZXNUb0V4cHJlc3Npb25BcnJheShleHByZXNzaW9uc1RvQ2hlY2ssIHR5cGVzUmVxdWlyZWQsIGxhbmd1YWdlLCBbJ3ZhcmlhYmxlJywgJ2NvbnN0YW50J10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBydW4gb24gZWFjaCBsaW5lIGFzIHRoZSBzdHVkZW50IHR5cGVzIGl0LCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICogbGluZSBpcyBvZiBhIGtub3duIHR5cGUuIEl0IGRvZXMgbm90IGNoZWNrIGZvciBtb3JlIHNvcGhpc3RpY2F0ZWQgZXJyb3JzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lU3RyaW5nIC0gb25lIG9mIHRoZSBsaW5lcyB3cml0dGVuIGJ5IHRoZSBzdHVkZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48TGluZVRlbXBsYXRlPn0gbGluZVRlbXBsYXRlcyAtIGFzIGZvciBidWlsZExpbmUoKVxuICAgICAqIEBwYXJhbSB7TGFuZ3VhZ2V9IGxhbmd1YWdlIC0gYXMgZm9yIGJ1aWxkTGluZSgpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZvY2FidWxhcnkgLSBhcyBmb3IgYnVpbGRMaW5lKClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ2VuZXJhbE1lc3NhZ2VzIC0gYSBkaWN0aW9uYXJ5IG9mIEdlbmVyYWxNZXNzYWdlcywgdXNlZCB0b1xuICAgICAqICAgICAgICAgcmVuZGVyIGVycm9ycyBpbnRvIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2VzLlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIGxpbmUgY2Fubm90IGJlIGlkZW50aWZpZWQsIHtcbiAgICAgKiAgICAgICAgICAgbWVzc2FnZTogYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgcHJvYmxlbVxuICAgICAqICAgICAgICAgfVxuICAgICAqL1xuICAgIHZhciByZXF1aXJlSWRlbnRpZmlhYmxlTGluZSA9IGZ1bmN0aW9uIChsaW5lU3RyaW5nLCBsaW5lVGVtcGxhdGVzLCBsYW5ndWFnZSwgdm9jYWJ1bGFyeSwgZ2VuZXJhbE1lc3NhZ2VzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvdG9MaW5lcyA9IHNoYXJlZF90c18xLmRlZmF1bHQucGFyc2VMaW5lU3RyaW5nKGxpbmVTdHJpbmcudHJpbSgpLCBsYW5ndWFnZS5vcGVyYXRvcnMsIHZvY2FidWxhcnksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc2hhcmVkX3RzXzEuZGVmYXVsdC5yZW5kZXJFcnJvcihlcnIsIGdlbmVyYWxNZXNzYWdlcywgbGFuZ3VhZ2UpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lSWRlbnRpZmllZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3RvTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVRlbXBsYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTGluZVRvVGVtcGxhdGUocHJvdG9MaW5lc1tpXSwgbGluZVRlbXBsYXRlc1tqXS5yZWFkZXJfdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVJZGVudGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBzaGFyZWRfdHNfMS5kZWZhdWx0LnJlbmRlckVycm9yKGVyciwgZ2VuZXJhbE1lc3NhZ2VzLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5lSWRlbnRpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHRvcC1sZXZlbCBmdW5jdGlvbiB0aGF0IGNoZWNrcyBhbGwgbGluZXMgb2YgYSBwcm9vZiBtYXRjaCBzb21lXG4gICAgICogbGluZSB0ZW1wbGF0ZSAob3IgYXJlIGJsYW5rKSwgYnV0IG5vdGhpbmcgZWxzZS4gSXQgaXMgcnVuIGFzIHRoZSBzdHVkZW50XG4gICAgICogdHlwZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb29mU3RyaW5nIC0gdGhlIHByb29mIGFzIHdyaXR0ZW4gYnkgdGhlIHN0dWRlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlc3Rpb25JbnN0YW5jZSAtIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwcm9ibGVtLFxuICAgICAqICAgICAgICB3aGljaCB3YXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgUXVlc3Rpb25EYXRhIGJ5IGJ1aWxkSW5zdGFuY2UoKS5cbiAgICAgKiBAdGhyb3dzIChpZiB0aGVyZSBpcyBhbiB1bm1hdGNoYWJsZSBsaW5lKSBhIGRpY3Rpb25hcnkge1xuICAgICAqICAgICAgICAgICBtZXNzYWdlOiBhIG1lc3NhZ2UgZGVzY3JpYmluZyBzb21ldGhpbmcgdGhhdCB3ZW50IHdyb25nLFxuICAgICAqICAgICAgICAgICBsaW5lOiB0aGUgbGluZSBpbiB3aGljaCB0aGUgcHJvYmxlbSBvY2N1cnJlZCAoemVyby1pbmRleGVkKSxcbiAgICAgKiAgICAgICAgICB9XG4gICAgICovXG4gICAgdmFyIHZhbGlkYXRlUHJvb2YgPSBmdW5jdGlvbiAocHJvb2ZTdHJpbmcsIHF1ZXN0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHByb29mU3RyaW5nLnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHByb29mU3RyaW5nID0gcHJvb2ZTdHJpbmcuc2xpY2UoMCwgcHJvb2ZTdHJpbmcubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVTdHJpbmdzID0gcHJvb2ZTdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVN0cmluZ3NbaV0uc3BsaXQoJyAnKS5qb2luKCcnKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlSWRlbnRpZmlhYmxlTGluZShsaW5lU3RyaW5nc1tpXSwgcXVlc3Rpb25JbnN0YW5jZS5saW5lX3RlbXBsYXRlcywgcXVlc3Rpb25JbnN0YW5jZS5sYW5ndWFnZSwgcXVlc3Rpb25JbnN0YW5jZS52b2NhYnVsYXJ5LCBxdWVzdGlvbkluc3RhbmNlLmdlbmVyYWxfbWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogaVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmVTdHJpbmcgLSBhIGxpbmUgb2YgdGV4dCB3cml0dGVuIGJ5IHRoZSBzdHVkZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48TGluZVRlbXBsYXRlPn0gbGluZVRlbXBsYXRlcyAtIGFuIGFycmF5IG9mIExpbmVUZW1wbGF0ZXNcbiAgICAgKiAgICAgICAgd3JpdHRlbiBieSB0aGUgdGVhY2hlciwgdGhhdCBkZXNjcmliZSB0aGUgc29ydHMgb2YgbGluZXMgYSBzdHVkZW50XG4gICAgICogICAgICAgIG1pZ2h0IHdyaXRlOyB3ZSB0cnkgdG8gZmluZCBvbmUgb2Ygd2hpY2ggdGhlIGdpdmVuIGxpbmUgaXMgYW5cbiAgICAgKiAgICAgICAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtMYW5ndWFnZX0gbGFuZ3VhZ2UgLSB0aGUgc3R1ZGVudCBsYW5ndWFnZSAoYSBMYW5ndWFnZSBvYmplY3QpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZvY2FidWxhcnkgLSB0aGUgcGhyYXNlcyBhdmFpbGFibGUgZm9yIHRoZSBzdHVkZW50IHRvIHVzZS5cbiAgICAgKiAgICAgICAgSXQgaXMgYSBkaWN0aW9uYXJ5IHdpdGggZW50cmllcyBsaWtlXG4gICAgICogICAgICAgICAgICBzYXRpc2Z5aW5nOiBbJ3NhdGlzZnlpbmcnLCAnc3VjaCB0aGF0J11cbiAgICAgKiAgICAgICAgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIHN0dWRlbnQgY2FuIGNvbnZleSB0aGUgY29uY2VwdCBvZlxuICAgICAqICAgICAgICAnc2F0aXNmeWluZycgYnkgd3JpdGluZyBlaXRoZXIgJ3NhdGlzZnlpbmcnIG9yICdzdWNoIHRoYXQnLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gYSBMaW5lIG9iamVjdCB0aGF0IGlzIGFuIGFic3RyYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgICAgICAgIHN0dWRlbnQncyBsaW5lU3RyaW5nLCBjb25zdHJ1Y3RlZCBmcm9tIHRoaXMgc3RyaW5nIGFuZCBvbmUgb2YgdGhlXG4gICAgICogICAgICAgICAgbGluZVRlbXBsYXRlcy5cbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIHJlcHJlc2VudGluZyB0aGUgY2xvc2VzdCB3ZSBnb3QgdG8gdW5kZXJzdGFuZGluZyB0aGUgbGluZSxcbiAgICAgKiAgICAgICAgIGdlbmVyYWxseSAndW5tYXRjaGVkIGxpbmUnLCBhIGNvbXBsYWludCBhYm91dCB0eXBpbmcsIG9yIGFcbiAgICAgKiAgICAgICAgIExpbmVNZXNzYWdlIGZyb20gdGhlIHRlYWNoZXIgaWYgdGhpcyBpcyBpZGVudGlmaWVkIGFzIGFuIGluc3RhbmNlXG4gICAgICogICAgICAgICBvZiBhbiBpbnZhbGlkIGRlZHVjdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRMaW5lID0gZnVuY3Rpb24gKGxpbmVTdHJpbmcsIGxpbmVUZW1wbGF0ZXMsIGxhbmd1YWdlLCB2b2NhYnVsYXJ5KSB7XG4gICAgICAgIC8vIEdldCBsaXN0IG9mIHBvc3NpYmxlIHBhcnNpbmdzIG9mIGxpbmUgKHVzdWFsbHkgdGhlcmUgaXMgb25seSBvbmUpXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgd2hpbGUgKGxpbmVTdHJpbmdbbl0gPT09ICcgJykge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCdvZGRfbnVtYmVyX3NwYWNlcycsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZW50YXRpb24gPSBuIC8gMjtcbiAgICAgICAgdmFyIHByb3RvTGluZXMgPSBzaGFyZWRfdHNfMS5kZWZhdWx0LnBhcnNlTGluZVN0cmluZyhsaW5lU3RyaW5nLnNsaWNlKG4sIGxpbmVTdHJpbmcubGVuZ3RoKSwgbGFuZ3VhZ2Uub3BlcmF0b3JzLCB2b2NhYnVsYXJ5LCBmYWxzZSk7XG4gICAgICAgIC8vIEF0IHRoaXMgc3RhZ2Ugd2Ugd2lzaCB0byByZXR1cm4gdGhlICdiZXN0JyBtYXRjaGluZyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gcHJpb3JpdHkgbGlzdDpcbiAgICAgICAgLy8gMS4gQSBjb3JyZWN0bHkgdHlwZWQgbWF0Y2hpbmcgdG8gYSAnY29ycmVjdCcgbGluZSB0ZW1wbGF0ZSAtIGkuZS4gb25lXG4gICAgICAgIC8vICAgIGZvciBhIGxvZ2ljYWxseSBjb3JyZWN0IGRlcml2YXRpb24uIElmIHdlIGZpbmQgb25lIHdlIHJldHVybiBpdFxuICAgICAgICAvLyAgICBpbW1lZGlhdGVseVxuICAgICAgICAvLyAyLiBBIGNvcnJlY3RseSB0eXBlZCBtYXRjaGluZyB0byBhbiBpbmNvcnJlY3QgbGluZSB0ZW1wbGF0ZVxuICAgICAgICAvLyAzLiBBbiBpbmNvcnJlY3RseSB0eXBlZCBtYXRjaGluZyB0byBhIGxpbmUgdGVtcGxhdGVcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmZiBlcnJvcjEgaXMgYSBiZXR0ZXIgYXR0ZW1wdCB0aGFuIGVycm9yMlxuICAgICAgICB2YXIgX2lzQmV0dGVyQXR0ZW1wdCA9IGZ1bmN0aW9uIChlcnJvcjEsIGVycm9yMikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yMiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKGVycm9yMS5jb2RlID09PSAncHJlLXJlbmRlcmVkJyAmJiBlcnJvcjIuY29kZSAhPT0gJ3ByZS1yZW5kZXJlZCcpIHx8XG4gICAgICAgICAgICAgICAgKGVycm9yMS5jb2RlICE9PSAndW5tYXRjaGVkX2xpbmUnICYmIGVycm9yMi5jb2RlID09PSAndW5tYXRjaGVkX2xpbmUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm90b0xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVUZW1wbGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdzID0gbWF0Y2hMaW5lVG9UZW1wbGF0ZShwcm90b0xpbmVzW2ldLCBsaW5lVGVtcGxhdGVzW2pdLnJlYWRlcl92aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVZhbGlkTWF0Y2hpbmcobWF0Y2hpbmdzLCBsaW5lVGVtcGxhdGVzW2pdLnJlYWRlcl92aWV3LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93TGluZU1lc3NhZ2VzKGxpbmVUZW1wbGF0ZXNbal0uZXJyb3IsIGxpbmVUZW1wbGF0ZXNbal0ubmFtZSwgbWF0Y2hpbmdzLCBsYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW50ZWNlZGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lVGVtcGxhdGVzW2pdLmFudGVjZWRlbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbnRlY2VkZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb21wdXRlRXhwcmVzc2lvbkZyb21UZW1wbGF0ZShsaW5lVGVtcGxhdGVzW2pdLmFudGVjZWRlbnRzW2tdLCBtYXRjaGluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVfbmFtZTogbGluZVRlbXBsYXRlc1tqXS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdzOiBtYXRjaGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbnRlY2VkZW50czogYW50ZWNlZGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBjb21wdXRlRXhwcmVzc2lvbnNGcm9tVGVtcGxhdGVBcnJheShsaW5lVGVtcGxhdGVzW2pdLnJlc3VsdHMsIG1hdGNoaW5ncyksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGluc3RhbnRpYXRlRXhwcmVzc2lvbkFycmF5KGxpbmVUZW1wbGF0ZXNbal0udmFyaWFibGVzLCBtYXRjaGluZ3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb246IGluZGVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGluZVN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCZXR0ZXJBdHRlbXB0KGVyciwgYmVzdEF0dGVtcHRTb0ZhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZXN0QXR0ZW1wdFNvRmFyID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGJlc3RBdHRlbXB0U29GYXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIG9uZSBvZiB0aGUgdHdvIG1haW4gdG9wLWxldmVsIHN0dWRlbnQgZnVuY3Rpb25zICh3aXRoIGNoZWNrUHJvb2YpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9vZlN0cmluZyAtIHRoZSBwcm9vZiBhcyB3cml0dGVuIGJ5IHRoZSBzdHVkZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXN0aW9uSW5zdGFuY2UgLSB0aGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHJvYmxlbSxcbiAgICAgKiAgICAgICAgd2hpY2ggd2FzIGNvbnN0cnVjdGVkIGZyb20gdGhlIFF1ZXN0aW9uRGF0YSBieSBidWlsZEluc3RhbmNlKCkuXG4gICAgICogQHJldHVybiB7UHJvb2Z9IGEgUHJvb2Ygb2JqZWN0IGJ1aWx0IGZyb20gdGhlIGdpdmVuIHByb29mU3RyaW5nXG4gICAgICogQHRocm93cyBhIGRpY3Rpb25hcnkge1xuICAgICAqICAgICAgICAgICBtZXNzYWdlOiBhIG1lc3NhZ2UgZGVzY3JpYmluZyBzb21ldGhpbmcgdGhhdCB3ZW50IHdyb25nLFxuICAgICAqICAgICAgICAgICBsaW5lOiB0aGUgbGluZSBpbiB3aGljaCB0aGUgcHJvYmxlbSBvY2N1cnJlZCAoemVyby1pbmRleGVkKSxcbiAgICAgKiAgICAgICAgICAgY29kZTogdGhlIGNvZGUgb2YgdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQsXG4gICAgICogICAgICAgICAgIGNhdGVnb3J5OiBlaXRoZXIgJ2xpbmUnLCAncGFyc2luZycgb3IgJ3R5cGluZydcbiAgICAgKiAgICAgICAgICB9XG4gICAgICovXG4gICAgdmFyIGJ1aWxkUHJvb2YgPSBmdW5jdGlvbiAocHJvb2ZTdHJpbmcsIHF1ZXN0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIGxpbmVTdHJpbmdzID0gcHJvb2ZTdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgICAgICAvLyBJZ25vcmUgYmxhbmsgbGluZXMgYXQgdGhlIGVuZFxuICAgICAgICB2YXIgbGFzdExpbmVOdW0gPSBsaW5lU3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGFzdExpbmVOdW0gPiAwICYmXG4gICAgICAgICAgICBsaW5lU3RyaW5nc1tsYXN0TGluZU51bV0ucmVwbGFjZSgvIC9nLCAnJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0TGluZU51bS0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWlsdExpbmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3RMaW5lTnVtOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYnVpbHRMaW5lcy5wdXNoKGJ1aWxkTGluZShsaW5lU3RyaW5nc1tpXSwgcXVlc3Rpb25JbnN0YW5jZS5saW5lX3RlbXBsYXRlcywgcXVlc3Rpb25JbnN0YW5jZS5sYW5ndWFnZSwgcXVlc3Rpb25JbnN0YW5jZS52b2NhYnVsYXJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzaGFyZWRfdHNfMS5kZWZhdWx0LnJlbmRlckVycm9yKGVyciwgcXVlc3Rpb25JbnN0YW5jZS5nZW5lcmFsX21lc3NhZ2VzLCBxdWVzdGlvbkluc3RhbmNlLmxhbmd1YWdlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAoZXJyLm5hbWUgPT09ICdQcmVSZW5kZXJlZFVzZXJFcnJvcicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbkluc3RhbmNlLmdlbmVyYWxfbWVzc2FnZXNbZXJyLmNvZGVdLmNhdGVnb3J5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZXM6IGJ1aWx0TGluZXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIENIRUNLIFBST09GXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhIGNvcmUgY29tcG9uZW50IG9mIHRoZSBwcm9ncmFtIC0gaXQgdGFrZXMgYW4gZXhwcmVzc2lvblxuICAgICAqIGFuZCByZXR1cm5zIGl0cyB2YWx1ZSAod2l0aCByZXNwZWN0IHRvIGdpdmVuIGlucHV0cywgbW9kZWwgYW5kIHBhcmFtZXRlcnMpLlxuICAgICAqIEBwYXJhbSB7VHlwZWRFeHByZXNzaW9ufSBleHByZXNzaW9uIC0gdGhlIFR5cGVkRXhwcmVzc2lvbiAoaW4gdGhlIGNvbnRyb2xcbiAgICAgKiAgICAgICAgbGFuZ3VhZ2UpIHRvIGJlIGV2YWx1YXRlZCwgZS5nLiBuKzJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRzIC0gYSBkaWN0aW9uYXJ5IHdpdGgga2V5cyB0aGUgZnJlZSB2YXJpYWJsZXMgaW4gdGhlXG4gICAgICogICAgICAgIGV4cHJlc3Npb24sIGdpdmluZyBmb3IgZWFjaCB0aGUgdmFsdWUgdGhleSBzaG91bGQgYmUgdGFrZW4gdG8gaGF2ZSxcbiAgICAgKiAgICAgICAgZS5nLiB7bjozfVxuICAgICAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsIC0gYSBNb2RlbCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgaG93IHRvIGV2YWx1YXRlXG4gICAgICogICAgICAgIGZ1bmN0aW9ucywgZS5nLiwgdGhhdCAnKycgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIHRoZSB1c3VhbFxuICAgICAqICAgICAgICBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZhbHVhdGlvblJ1bGVQYXJhbWV0ZXJzIC0gdGhlc2UgYXJlIHNlbnQgdG8gYWxsIG9mIHRoZVxuICAgICAqICAgICAgICBFdmFsdWF0aW9uUnVsZXMgb2NjdXJyaW5nIGluIHRoZSBtb2RlbCwgZm9yIHRoZW0gdG8gbWFrZSB1c2Ugb2YgaWZcbiAgICAgKiAgICAgICAgdGhleSB3aXNoLiBlLmcuIGhlcmUgdGhleSB3b3VsZCBpbmNsdWRlIHRoZSBzdHVkZW50J3MgcHJvb2YsIGFuZFxuICAgICAqICAgICAgICB0aGUgZnVuY3Rpb24gJ251bV9saW5lcycgd291bGQgZXZhbHVhdGUgYnkgZXhhbWluaW5nIHRoaXMgcHJvb2YuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNhY2hlIC0gZXhwcmVzc2lvbnMsIGF0IHBhcnRpY3VsYXIgaW5wdXRzLCB0aGF0IHdlcmVcbiAgICAgKiAgICAgICAgYWxyZWFkeSBldmFsdWF0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbiB3aXRoIHRoZXNlIGlucHV0cywgZS5nLiA1XG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiBhbnkgcGFydCBvZiB0aGUgZXZhbHVhdGlvbiBmYWlsZWQsIGZvciBleGFtcGxlIGJ5XG4gICAgICogICAgICAgICB0cnlpbmcgdG8gYWNjZXNzIGFuIGVsZW1lbnQgb2YgYW4gYXJyYXkgYmV5b25kIHRoZSBhcnJheSdzIGxlbmd0aC5cbiAgICAgKi9cbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgaW5wdXRzLCBtb2RlbCwgZXZhbHVhdGlvblJ1bGVQYXJhbWV0ZXJzLCBjYWNoZSkge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShleHByZXNzaW9uKSArICcjJyArIEpTT04uc3RyaW5naWZ5KGlucHV0cyk7XG4gICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkgJiYgZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJlc3Npb24udG9wX2tpbmRfbmFtZSA9PT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgdmFyIGFuc3dlciA9IGlucHV0c1tleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByZXNzaW9uLnRvcF9raW5kX25hbWUgPT09ICdjb25zdGFudCcpIHtcbiAgICAgICAgICAgIHZhciBhbnN3ZXIgPSBleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRpb25SdWxlID0gbW9kZWwuZXZhbHVhdGlvbl9ydWxlc1tleHByZXNzaW9uLnRvcF9vcGVyYXRvcl9uYW1lXTtcbiAgICAgICAgICAgIGlmIChldmFsdWF0aW9uUnVsZS5mb3JtYXQgPT09ICd0b3BfZG93bicpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0gZXZhbHVhdGlvblJ1bGUuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGlucHV0cywgbW9kZWwsIGV2YWx1YXRpb25SdWxlUGFyYW1ldGVycywgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZhbHVhdGlvblJ1bGUuZm9ybWF0ID09PSAnZGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBhcmd1bWVudHMgKHNwZWMgcmVxdWlyZXMgdGhhdCB0aGUgZXhwcmVzc2lvbiBoYXMgbm9cbiAgICAgICAgICAgICAgICAvLyBkdW1taWVzKS5cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5kdW1taWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0ZSgpIHJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHRvIGJlIGV2YWx1YXRlZCB2aWEgYSBkZWZpbml0aW9uIGJ1dCBpdCBoYXMgZHVtbWllcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0gZXZhbHVhdGlvblJ1bGUuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGlucHV0cywgbW9kZWwsIGV2YWx1YXRpb25SdWxlUGFyYW1ldGVycywgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZhbHVhdGlvblJ1bGUuZm9ybWF0ID09PSAnYm90dG9tX3VwJykge1xuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFyZ3VtZW50cyAoc3BlYyByZXF1aXJlcyB0aGF0IHRoZXJlIGFyZSBubyBkdW1taWVzKS5cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5kdW1taWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmFsdWF0ZSgpIHJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi50b3Bfb3BlcmF0b3JfbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHRvIGJlIGV2YWx1YXRlZCBib3R0b20tdXAgYnV0IGl0IGhhcyBkdW1taWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmd1bWVudHNMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNMaXN0LnB1c2goZXZhbHVhdGUoZXhwcmVzc2lvbi5hcmd1bWVudHNbaV0sIGlucHV0cywgbW9kZWwsIGV2YWx1YXRpb25SdWxlUGFyYW1ldGVycywgY2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKGV4cHJlc3Npb24uYXJndW1lbnRzW2ldLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0gZXZhbHVhdGlvblJ1bGUuZXZhbHVhdGVFeHByZXNzaW9uKGFyZ3VtZW50c0xpc3QsIHR5cGVzLCBldmFsdWF0aW9uUnVsZVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gZXZhbHVhdGlvbiBydWxlIGZvcm1hdCAoJyArXG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25SdWxlLmZvcm1hdCArICcpIHNlbnQgdG8gZXZhbHVhdGUoKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSBhbnN3ZXI7XG4gICAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01pc3Rha2VFbnRyeX0gbWlzdGFrZSAtIGEgTWlzdGFrZUVudHJ5IHRoYXQgZGVzY3JpYmVzIHdoZW4gYVxuICAgICAqICAgICAgICBtaXN0YWtlIG9jY3VycywgYW5kIGlmIHNvIHdoYXQgdG8gc2F5IHRvIHRoZSBzdHVkZW50LlxuICAgICAqIEBwYXJhbSB7aW50fSBsaW5lTnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgbGluZSBpbiB0aGUgcHJvb2YgaW4gd2hpY2ggdGhlXG4gICAgICogICAgICAgIG1pc3Rha2Ugd2FzIG1hZGUgKHplcm8taW5kZXhlZClcbiAgICAgKiBAcGFyYW0ge01vZGVsfSBtb2RlbCAtIGEgTW9kZWwgb2JqZWN0IHByb3ZpZGluZyBpbmZvcm1hdGlvbiBvbiBob3cgdG9cbiAgICAgKiAgICAgICAgZXZhbHVhdGUgZnVuY3Rpb25zIHRoZSB0ZWFjaGVyIG1heSBoYXZlIHVzZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlcnMgLSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5IG9mIHtcbiAgICAgKiAgICAgICAgICBwcm9vZjogdGhlIHN0dWRlbnQncyBwcm9vZiBpbiB3aGljaCB0aGUgbWlzdGFrZSB3YXMgbWFkZVxuICAgICAqICAgICAgICAgIGFzc3VtcHRpb25zOiB0aGUgYXNzdW1wdGlvbnMgYWxsb3dlZCBpbiB0aGUgcXVlc3Rpb25cbiAgICAgKiAgICAgICAgICB0YXJnZXQ6IHdoYXQgdGhlIHN0dWRlbnQgc2hvdWxkIHByb3ZlIChpc1xuICAgICAqICAgICAgICAgICAgcXVlc3Rpb25JbnN0YW5jZS5yZXN1bHRbMF0pXG4gICAgICogICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3JzIC0gZnJvbSB0aGUgc3R1ZGVudCBsYW5ndWFnZSwgdGhpcyBpcyB1c2VkIHRvXG4gICAgICogICAgICAgIGRpc3BsYXkgZXhwcmVzc2lvbnMuXG4gICAgICogQHRocm93cyBUaGlzIGZ1bmN0aW9uIHdpbGwgdGFrZSB0aGUgTWlzdGFrZU1lc3NhZ2VzIGdpdmVuIGluIHRoZVxuICAgICAqICAgICAgICAgTWlzdGFrZUVudHJ5IGFuZCBldmFsdWF0ZSB0aGVtIHRvIGdldCBzdHJpbmdzIGRlc2NyaWJpbmcgdGhlXG4gICAgICogICAgICAgICBwcm9ibGVtIHRoYXQgY291bGQgYmUgc2hvd24gdG8gdGhlIHN0dWRlbnQuIEl0IHRoZW4gdGhyb3dzIGFcbiAgICAgKiAgICAgICAgIGxvZ2ljUHJvb2ZTaGFyZWQuVXNlckVycm9yIGNvbnRhaW5pbmcgdGhlc2Ugc3RyaW5ncy5cbiAgICAgKi9cbiAgICB2YXIgcmVuZGVyTWlzdGFrZU1lc3NhZ2VzID0gZnVuY3Rpb24gKG1pc3Rha2UsIGxpbmVOdW1iZXIsIG1vZGVsLCBwYXJhbWV0ZXJzLCBvcGVyYXRvcnMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXN0YWtlLm1lc3NhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtaXN0YWtlLm1lc3NhZ2VbaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVtqXS5mb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZE1lc3NhZ2UgKz0gbWVzc2FnZVtqXS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd1Jlc3VsdCA9IGV2YWx1YXRlKG1lc3NhZ2Vbal0uY29udGVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG46IGxpbmVOdW1iZXIgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBtb2RlbCwgcGFyYW1ldGVycywge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRNZXNzYWdlICs9IChtZXNzYWdlW2pdLmNvbnRlbnQudHlwZSA9PT0gJ3NldF9vZl9mb3JtdWxhcycpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRfdHNfMS5kZWZhdWx0LmRpc3BsYXlFeHByZXNzaW9uQXJyYXkocmF3UmVzdWx0LCBvcGVyYXRvcnMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZVtqXS5jb250ZW50LnR5cGUgPT09ICdmb3JtdWxhJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRfdHNfMS5kZWZhdWx0LmRpc3BsYXlFeHByZXNzaW9uKHJhd1Jlc3VsdCwgb3BlcmF0b3JzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW5kZXJlZE1lc3NhZ2VzLnB1c2gocmVuZGVyZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgIT09ICdldmFsdWF0aW9uIGZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRNZXNzYWdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHNlY29uZCB0b3AtbGV2ZWwgZnVuY3Rpb24gZm9yIHRoZSBzdHVkZW50LlxuICAgICAqIEBwYXJhbSB7UHJvb2Z9IHByb29mIC0gYSBQcm9vZiBvYmplY3QgY29uc3RydWN0ZWQgYnkgYnVpbGRQcm9vZigpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXN0aW9uSW5zdGFuY2UgLSB0aGUgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0gYnVpbHRcbiAgICAgKiAgICAgICAgZnJvbSB0aGUgUXVlc3Rpb25EYXRhIChhbiBhcmd1bWVudCBvZiB0aGUgaW50ZXJhY3Rpb24nc1xuICAgICAqICAgICAgICBjdXN0b21pemF0aW9uX2FyZ3MpIGJ5IGJ1aWxkSW5zdGFuY2UoKS5cbiAgICAgKiBAdGhyb3dzIGlmIGEgbWlzdGFrZSBmcm9tIHRoZSBtaXN0YWtlX3RhYmxlIGhhcyBiZWVuXG4gICAgICogICAgICAgICAgbWFkZSBpbiB0aGUgcHJvb2YsIHtcbiAgICAgKiAgICAgICAgICAgIG1lc3NhZ2U6IGEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGZpcnN0IG1pc3Rha2VcbiAgICAgKiAgICAgICAgICAgICAgaWRlbnRpZmllZCxcbiAgICAgKiAgICAgICAgICAgIGxpbmU6IHRoZSBsaW5lICh6ZXJvLWluZGV4ZWQpIHRoZSBlcnJvciBvY2N1cnJlZCBpbixcbiAgICAgKiAgICAgICAgICAgIGNvZGU6IHRoZSBuYW1lIG9mIHRoZSBtaXN0YWtlIHRoYXQgd2FzIG1hZGVcbiAgICAgKiAgICAgICAgICAgIGNhdGVnb3J5OiB0aGUgTWlzdGFrZVNlY3Rpb24gdGhhdCB0aGUgbWlzdGFrZSBjYW1lIGZyb21cbiAgICAgKiAgICAgICAgICB9XG4gICAgICovXG4gICAgdmFyIGNoZWNrUHJvb2YgPSBmdW5jdGlvbiAocHJvb2YsIHF1ZXN0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIGV2YWx1YXRpb25DYWNoZSA9IHt9O1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHByb29mOiBwcm9vZixcbiAgICAgICAgICAgIGFzc3VtcHRpb25zOiBxdWVzdGlvbkluc3RhbmNlLmFzc3VtcHRpb25zLFxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHF1ZXN0aW9uSW5zdGFuY2UucmVzdWx0cyBpcyBhbiBhcnJheSBvZiBleHByZXNzaW9ucywgdG9cbiAgICAgICAgICAgIC8vIGFsbG93IGZvciBmdXR1cmUgcXVlc3Rpb25zIGluIHdoaWNoIHRoZSBzdHVkZW50IGhhcyB0byBwcm92ZSBtb3JlIHRoYW5cbiAgICAgICAgICAgIC8vIG9uZSB0aGluZywgYnV0IGZvciBub3cgd2Ugb25seSBwZXJtaXQgb25lIHRhcmdldCBwZXIgcXVlc3Rpb24uXG4gICAgICAgICAgICB0YXJnZXQ6IHF1ZXN0aW9uSW5zdGFuY2UucmVzdWx0c1swXVxuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBjaGVjayBmb3IgYWxsIG1pc3Rha2VzIGluIHRoZSBmaXJzdCBtaXN0YWtlIHNlY3Rpb24gKGxheW91dCkgZmlyc3Qgc29cbiAgICAgICAgLy8gdGhhdCBmb3JtdWxhcyBpbiBzdWJzZXF1ZW50IHNlY3Rpb25zIGNhbiBhc3N1bWUgdGhlIGxheW91dCBpcyBjb3JyZWN0LFxuICAgICAgICAvLyBhbmQgc28gb24gd2l0aCB0aGUgc3Vic2VxdWVudCBzZWN0aW9ucy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVzdGlvbkluc3RhbmNlLm1pc3Rha2VfdGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGxpbmVOdW1iZXIgPSAwOyBsaW5lTnVtYmVyIDwgcHJvb2YubGluZXMubGVuZ3RoOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHF1ZXN0aW9uSW5zdGFuY2UubWlzdGFrZV90YWJsZVtpXS5lbnRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaXN0YWtlID0gcXVlc3Rpb25JbnN0YW5jZS5taXN0YWtlX3RhYmxlW2ldLmVudHJpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmb3JtdWxhIGRldGVybWluaW5nIHdoZXRoZXIgYW4gZXJyb3Igb2NjdXJzIGNhbm5vdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZWQgdGhlbiB0aGUgZXJyb3IgaXMgZGVlbWVkIG5vdCB0byBoYXZlIG9jY3VycmVkLiBUaGlzIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoZSB0ZWFjaGVyIGNhbiB3cml0ZSBmb3JtdWxhcyBsaWtlICdpbmRlbnRhdGlvbihuLTEpJyBhbmQgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpbXBsaWNpdCB0aGF0IG4+MS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVjayA9IGV2YWx1YXRlKG1pc3Rha2Uub2NjdXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogbGluZU51bWJlciArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXN0aW9uSW5zdGFuY2UuY29udHJvbF9tb2RlbCwgcGFyYW1ldGVycywgZXZhbHVhdGlvbkNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgIT09ICdldmFsdWF0aW9uIGZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlzdGFrZU1lc3NhZ2VzID0gcmVuZGVyTWlzdGFrZU1lc3NhZ2VzKG1pc3Rha2UsIGxpbmVOdW1iZXIsIHF1ZXN0aW9uSW5zdGFuY2UuY29udHJvbF9tb2RlbCwgcGFyYW1ldGVycywgcXVlc3Rpb25JbnN0YW5jZS5sYW5ndWFnZS5vcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRlYWNoZXIgaGFzIG1hZGUgYSBtaXN0YWtlIGFuZCBub25lIG9mIHRoZSBtZXNzYWdlcyB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHByb3ZpZGVkIGNhbiBiZSBldmFsdWF0ZWQgdGhlbiB3ZSB0cnkgdG8gcmV0dXJuIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R1ZGVudCBhcyBoZWxwZnVsIGEgbWVzc2FnZSBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IChtaXN0YWtlTWVzc2FnZXMubGVuZ3RoID4gMCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBzaGFyZWRfdHNfMS5kZWZhdWx0LlByZVJlbmRlcmVkVXNlckVycm9yKG1pc3Rha2VNZXNzYWdlcywgbWlzdGFrZS5uYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCd1bnNwZWNpZmllZF9taXN0YWtlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uOiBxdWVzdGlvbkluc3RhbmNlLm1pc3Rha2VfdGFibGVbaV0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IG1pc3Rha2UubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNoYXJlZF90c18xLmRlZmF1bHQucmVuZGVyRXJyb3IoZXJyb3IsIHF1ZXN0aW9uSW5zdGFuY2UuZ2VuZXJhbF9tZXNzYWdlcywgcXVlc3Rpb25JbnN0YW5jZS5sYW5ndWFnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBtaXN0YWtlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHF1ZXN0aW9uSW5zdGFuY2UubWlzdGFrZV90YWJsZVtpXS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBCQVNFX0NPTlRST0xfTU9ERUw6IEJBU0VfQ09OVFJPTF9NT0RFTCxcbiAgICAgICAgYnVpbGRJbnN0YW5jZTogYnVpbGRJbnN0YW5jZSxcbiAgICAgICAgbWF0Y2hFeHByZXNzaW9uOiBtYXRjaEV4cHJlc3Npb24sXG4gICAgICAgIHN1YnN0aXR1dGVJbnRvRXhwcmVzc2lvbjogc3Vic3RpdHV0ZUludG9FeHByZXNzaW9uLFxuICAgICAgICBpbnN0YW50aWF0ZUV4cHJlc3Npb246IGluc3RhbnRpYXRlRXhwcmVzc2lvbixcbiAgICAgICAgY29tcHV0ZUV4cHJlc3Npb25Gcm9tVGVtcGxhdGU6IGNvbXB1dGVFeHByZXNzaW9uRnJvbVRlbXBsYXRlLFxuICAgICAgICB0aHJvd0xpbmVNZXNzYWdlczogdGhyb3dMaW5lTWVzc2FnZXMsXG4gICAgICAgIG1hdGNoTGluZVRvVGVtcGxhdGU6IG1hdGNoTGluZVRvVGVtcGxhdGUsXG4gICAgICAgIHJlcXVpcmVJZGVudGlmaWFibGVMaW5lOiByZXF1aXJlSWRlbnRpZmlhYmxlTGluZSxcbiAgICAgICAgdmFsaWRhdGVQcm9vZjogdmFsaWRhdGVQcm9vZixcbiAgICAgICAgYnVpbGRMaW5lOiBidWlsZExpbmUsXG4gICAgICAgIGJ1aWxkUHJvb2Y6IGJ1aWxkUHJvb2YsXG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgcmVuZGVyTWlzdGFrZU1lc3NhZ2VzOiByZW5kZXJNaXN0YWtlTWVzc2FnZXMsXG4gICAgICAgIGNoZWNrUHJvb2Y6IGNoZWNrUHJvb2ZcbiAgICB9O1xufSkoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvZ2ljUHJvb2ZTdHVkZW50O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wb25lbnRzIHVzZWQgYnkgdGhlIExvZ2ljUHJvb2YgaW50ZXJhY3Rpb24gZWRpdG9yLlxuICovXG52YXIgc2hhcmVkX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9zaGFyZWQudHNcIikpO1xudmFyIGRhdGFfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2RhdGEudHNcIikpO1xudmFyIGdlbmVyYXRlZFBhcnNlcl90c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9zdGF0aWMvanMvZ2VuZXJhdGVkUGFyc2VyLnRzXCIpKTtcbnZhciBsb2dpY1Byb29mVGVhY2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUVVFU1RJT05cbiAgICAvKipcbiAgICAgKiBBIHF1ZXN0aW9uIGlzIGNvbXBvc2VkIG9mIHRoZSBmb3JtdWxhcyB0aGUgc3R1ZGVudCBtYXkgYXNzdW1lIGFuZCB0aGVcbiAgICAgKiBmb3JtdWxhIHNoZSBtdXN0IHByb3ZlOyBpdCB3aWxsIGJlIGRpZmZlcmVudCBmb3IgZWFjaCBzdGF0ZSBpbiB3aGljaCB0aGVcbiAgICAgKiBpbnRlcmFjdGlvbiBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3N1bXB0aW9uc1N0cmluZyAtIHR5cGVkIGJ5IHRoZSB0ZWFjaGVyIHRvIGRlc2NyaWJlIHRoZVxuICAgICAqICAgICAgICBhc3N1bXB0aW9ucyB0aGUgc3R1ZGVudCBpcyBhbGxvd2VkIHRvIG1ha2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFN0cmluZyAtIHR5cGVkIGJ5IHRoZSB0ZWFjaGVyIHRvIGRlc2NyaWJlIHdoYXQgdGhlXG4gICAgICogICAgICAgIHN0dWRlbnQgaXMgc3VwcG9zZWQgdG8gcHJvdmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZvY2FidWxhcnkgLSBBIHZvY2FidWxhcnkgb2JqZWN0LCB0aGUgd29yZHMgZnJvbSB3aGljaCB0aGVcbiAgICAgKiAgICAgICAgdGVhY2hlciBpcyBub3QgYWxsb3dlZCB0byB1c2UgYXMgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHJldHVybnMge1xuICAgICAqICAgICAgICAgICBvcGVyYXRvcnM6IHRoZSBvcGVyYXRvcnMgb2NjdXJyaW5nIGluIHRoZSBxdWVzdGlvbiBpbmNsdWRpbmcgYm90aFxuICAgICAqICAgICAgICAgICAgIG9yZGluYXJ5IG9uZXMgKGxpa2Ug4oinKSBhbmQgc3BlY2lmaWMgb25lcyAobGlrZSBmKS5cbiAgICAgKiAgICAgICAgICAgYXNzdW1wdGlvbnM6IGFuIGFycmF5IG9mIEV4cHJlc3Npb25zLCB3aGljaCB3aWxsIGZvcm0gdGhlXG4gICAgICogICAgICAgICAgICAgJ2Fzc3VtcHRpb25zJyBrZXkgaW4gdGhlIGludGVyYWN0aW9uLlxuICAgICAqICAgICAgICAgICByZXN1bHRzOiBhbiBhcnJheSBvZiBsZW5ndGggb25lIGJ1aWx0IGZyb20gdGhlIHRhcmdldFN0cmluZyB3aGljaFxuICAgICAqICAgICAgICAgICAgIHdpbGwgZm9ybSB0aGUgJ3Jlc3VsdHMnIGtleSBpbiB0aGUgaW50ZXJhY3Rpb24uXG4gICAgICogICAgICAgICB9XG4gICAgICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gc3RyaW5ncyBjYW5ub3QgYmUgcGFyc2VkLCBvciBhcmUgbWFsLXR5cGVkIG9yIHVzZVxuICAgICAqICAgICAgICAgd29yZHMgdGhhdCBhcmUgcmVzZXJ2ZWQgZm9yIHRoZSB2b2NhYnVsYXJ5LlxuICAgICAqL1xuICAgIHZhciBidWlsZFF1ZXN0aW9uID0gZnVuY3Rpb24gKGFzc3VtcHRpb25zU3RyaW5nLCB0YXJnZXRTdHJpbmcsIHZvY2FidWxhcnkpIHtcbiAgICAgICAgdmFyIGFzc3VtcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKGFzc3VtcHRpb25zU3RyaW5nLnJlcGxhY2UoLyAvZywgJycpID09PSAnJykge1xuICAgICAgICAgICAgYXNzdW1wdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXNzdW1wdGlvbnMgPSBnZW5lcmF0ZWRQYXJzZXJfdHNfMS5kZWZhdWx0LnBhcnNlKGFzc3VtcHRpb25zU3RyaW5nLnJlcGxhY2UoLyAvZywgJycpLCAnbGlzdE9mRXhwcmVzc2lvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5Vc2VyRXJyb3IoJ3VucGFyc2VhYmxlJywge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2Fzc3VtcHRpb25zJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2hhcmVkX3RzXzEuZGVmYXVsdC5yZW5kZXJFcnJvcihlcnJvciwgVEVBQ0hFUl9FUlJPUl9NRVNTQUdFUywgZGF0YV90c18xLmRlZmF1bHQuQkFTRV9TVFVERU5UX0xBTkdVQUdFKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZW5lcmF0ZWRQYXJzZXJfdHNfMS5kZWZhdWx0LnBhcnNlKHRhcmdldFN0cmluZy5yZXBsYWNlKC8gL2csICcnKSwgJ2V4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgc2hhcmVkX3RzXzEuZGVmYXVsdC5Vc2VyRXJyb3IoJ3VucGFyc2VhYmxlJywge1xuICAgICAgICAgICAgICAgIGZpZWxkOiAndGFyZ2V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc2hhcmVkX3RzXzEuZGVmYXVsdC5yZW5kZXJFcnJvcihlcnJvciwgVEVBQ0hFUl9FUlJPUl9NRVNTQUdFUywgZGF0YV90c18xLmRlZmF1bHQuQkFTRV9TVFVERU5UX0xBTkdVQUdFKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgYXNzdW1wdGlvbnMgYW5kIHRoZSB0YXJnZXQgbXVzdCBiZSBib29sZWFucy5cbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHZhciB0b3BUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzc3VtcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzc3VtcHRpb25zW2ldKTtcbiAgICAgICAgICAgIHRvcFR5cGVzLnB1c2goJ2Jvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHRvcFR5cGVzLnB1c2goJ2Jvb2xlYW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0eXBpbmcgPSBzaGFyZWRfdHNfMS5kZWZhdWx0LmFzc2lnblR5cGVzVG9FeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbnMsIHRvcFR5cGVzLCBkYXRhX3RzXzEuZGVmYXVsdC5CQVNFX1NUVURFTlRfTEFOR1VBR0UsIFsndmFyaWFibGUnLCAnY29uc3RhbnQnLCAncHJlZml4X2Z1bmN0aW9uJ10pO1xuICAgICAgICAgICAgaWYgKHR5cGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCdhbWJpZ3VvdXNfdHlwaW5nJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWlyZU5vVm9jYWJ1bGFyeVdvcmRzVXNlZChleHByZXNzaW9ucywgZGF0YV90c18xLmRlZmF1bHQuQkFTRV9TVFVERU5UX0xBTkdVQUdFLm9wZXJhdG9ycywgdm9jYWJ1bGFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNoYXJlZF90c18xLmRlZmF1bHQucmVuZGVyRXJyb3IoZXJyLCBURUFDSEVSX0VSUk9SX01FU1NBR0VTLCBkYXRhX3RzXzEuZGVmYXVsdC5CQVNFX1NUVURFTlRfTEFOR1VBR0UpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVyYXRvcnM6IHR5cGluZ1swXS5vcGVyYXRvcnMsXG4gICAgICAgICAgICBhc3N1bXB0aW9uczogYXNzdW1wdGlvbnMsXG4gICAgICAgICAgICByZXN1bHRzOiBbdGFyZ2V0XVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBnaXZlbiBleHByZXNzaW9uIGFycmF5IHVzZXMgYW4gb3BlcmF0b3IgdGhhdCBpcyBub3RcbiAgICAvLyBpbiBrbm93bk9wZXJhdG9ycyBhbmQgd2hvc2UgbmFtZSBoYXMgbGVuZ3RoIGdyZWF0ZXIgdGhhbiBvbmUgYW5kIG9jY3VycyBhc1xuICAgIC8vIGEgd29yZCBpbiB0aGUgdm9jYWJ1bGFyeS5cbiAgICB2YXIgcmVxdWlyZU5vVm9jYWJ1bGFyeVdvcmRzVXNlZCA9IGZ1bmN0aW9uIChleHByZXNzaW9uQXJyYXksIGtub3duT3BlcmF0b3JzLCB2b2NhYnVsYXJ5KSB7XG4gICAgICAgIHZhciBfaXNNZW1iZXIgPSBmdW5jdGlvbiAoZW50cnksIGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKGFycmF5LmluZGV4T2YoZW50cnkpICE9PSAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2b2NhYnVsYXJ5V29yZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZvY2FidWxhcnkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm9jYWJ1bGFyeVtrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IHZvY2FidWxhcnlba2V5XVtpXS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd29yZEFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2lzTWVtYmVyKHdvcmRBcnJheVtqXSwgdm9jYWJ1bGFyeVdvcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9jYWJ1bGFyeVdvcmRzLnB1c2god29yZEFycmF5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0b3JOYW1lc1RvQ2hlY2sgPSBzaGFyZWRfdHNfMS5kZWZhdWx0LmdldE9wZXJhdG9yc0Zyb21FeHByZXNzaW9uQXJyYXkoZXhwcmVzc2lvbkFycmF5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVyYXRvck5hbWVzVG9DaGVjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9pc01lbWJlcihvcGVyYXRvck5hbWVzVG9DaGVja1tpXSwgdm9jYWJ1bGFyeVdvcmRzKSAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdG9yTmFtZXNUb0NoZWNrW2ldLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAha25vd25PcGVyYXRvcnMuaGFzT3duUHJvcGVydHkob3BlcmF0b3JOYW1lc1RvQ2hlY2tbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNoYXJlZF90c18xLmRlZmF1bHQuVXNlckVycm9yKCdmb3JiaWRkZW5fd29yZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZDogb3BlcmF0b3JOYW1lc1RvQ2hlY2tbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gREFUQVxuICAgIHZhciBURUFDSEVSX0VSUk9SX01FU1NBR0VTID0ge1xuICAgICAgICB1bnBhcnNlYWJsZToge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhlICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnZmllbGQnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnIGNvdWxkIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYW1iaWd1b3VzX3R5cGluZzoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoJ1VuZm9ydHVuYXRlbHkgdGhpcyBjYW5ub3QgYmUgYWNjZXB0ZWQgYXMgaXQgaGFzIG11bHRpcGxlIHBvc3NpYmxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBpbmdzLicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGRlbl9vcGVyYXRvcjoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnSXQgd2lsbCBub3QgYmUgcG9zc2libGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdvcGVyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgZnJvbSBhIGxpbmUgb2YgdGhpcyBmb3JtLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGR1cGxpY2F0ZV9mdW5jdGlvbl9uYW1lOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgZnVuY3Rpb24gJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZS1wcm9wc1xuICAgICAgICAgICAgICAgICdmdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb25fbmFtZV9pc19uOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnWW91IGNhbm5vdCB1c2UgbiBhcyBhIGZ1bmN0aW9uIG5hbWU7IGl0IGlzIHJlc2VydmVkIHRvIHJlZmVyIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lIG51bWJlcnMnKVxuICAgICAgICAgICAgICAgICAgICB9XV1cbiAgICAgICAgfSxcbiAgICAgICAgYXJndW1lbnRfaXNfZnVuY3Rpb25fbmFtZToge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdhcmd1bWVudCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnXFwnIGlzIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50LicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkdXBsaWNhdGVfYXJndW1lbnQ6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoZSB2YXJpYWJsZXMgdXNlZCBhcyBhcmd1bWVudHMgbXVzdCBhbGwgYmUgZGlzdGluY3QnXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bnVzZWRfYXJndW1lbnQ6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoZSBhcmd1bWVudCBcXCcnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2FyZ3VtZW50J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1xcJyBkb2VzIG5vdCBvY2N1ciBpbiB0aGUgZGVmaW5pdGlvbi4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmtub3duX3R5cGluZ19lcnJvcjoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnQSB0eXBpbmcgZXJyb3IgaGFzIG9jY3VycmVkIHdpdGggJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndW5tYXRjaGVkX3t7Jzoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhpcyBoYXMgYW4gdW5tYXRjaGVkIHt7LidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge31cbiAgICAgICAgfSxcbiAgICAgICAgdW5wYXJzZWFibGVfZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ0l0IHdhcyBub3QgcG9zc2libGUgdG8gcGFyc2UgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdmcmFnbWVudCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYW1iaWd1b3VzX3BhcnNpbmc6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoZSAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2ZpZWxkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCcgY2FuIGJlIHVuZGVyc3Rvb2QgaW4gbW9yZSB0aGFuIG9uZSB3YXkuIFRyeSB1c2luZyBmZXdlciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2luZ2xlLWNoYXJhY3RlciB3b3JkcyBhbmQgdmFyaWFibGVzIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d28uJylcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGZpZWxkOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlsbGVnYWxfc3ltYm9sOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgc3ltYm9sICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyB3YXMgbm90IHJlY29nbmlzZWQuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJsYW5rX2xpbmU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoaXMgbGluZSBpcyBibGFuay4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHVuaWRlbnRpZmllZF93b3JkOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdXZSBjb3VsZCBub3QgaWRlbnRpZnkgXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCdcXCc7IHBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSB1c2luZyB2b2NhYnVsYXJ5IGZyb20gdGhlIGdpdmVuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0LCBhbmQgZG9uXFwndCBoYXZlIHR3byBjb25zZWN1dGl2ZSBleHByZXNzaW9ucy4nKVxuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgd29yZDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmlkZW50aWZpZWRfd29yZHM6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1dlIGNvdWxkIG5vdCBpZGVudGlmeSBlaXRoZXIgb2YgXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkMSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcXCcgb3IgXFwnJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkMidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnXFwnIGFzIHdvcmRzOyBwbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgdm9jYWJ1bGFyeSBmcm9tICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGUgZ2l2ZW4gbGlzdCwgYW5kIGRvblxcJ3QgaGF2ZSB0d28gY29uc2VjdXRpdmUgZXhwcmVzc2lvbnMuJylcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHdvcmQxOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdvcmQyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnNlY3V0aXZlX2V4cHJlc3Npb25zOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGlzIGxpbmUgaGFzIHR3byBleHByZXNzaW9ucyBpbiBhIHJvdyAoJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd3b3JkMSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgYW5kICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZDInXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnKSB3aGljaCBpcyBub3QgYWxsb3dlZC4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB3b3JkMToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3b3JkMjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmlkZW50aWZpZWRfcGhyYXNlX3N0YXJ0aW5nX2F0OiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgcGhyYXNlIHN0YXJ0aW5nIFxcJydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnXFwnIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkOyBwbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgb25seSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXNpbmcgcGhyYXNlcyBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIHZvY2FidWxhcnkuJylcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHdvcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9yYmlkZGVuX3dvcmQ6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1RoZSBuYW1lIFxcJydcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnd29yZCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcXCcgaXMgcmVzZXJ2ZWQgZm9yIHZvY2FidWxhcnkgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGhlcmUuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgd29yZDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3RfZW5vdWdoX2lucHV0czoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ29wZXJhdG9yJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyBtdXN0IGhhdmUgYXQgbGVhc3QgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdudW1fbmVlZGVkJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2lucHV0X2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBudW1fbmVlZGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0X2NhdGVnb3J5OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdyb25nX251bV9pbnB1dHM6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdvcGVyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgbXVzdCBoYXZlICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnbnVtX25lZWRlZCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbnB1dF9jYXRlZ29yeSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcuJ1xuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgbnVtX25lZWRlZDoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dF9jYXRlZ29yeToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3cm9uZ19raW5kOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnb3BlcmF0b3InXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnIGlzIHN1cHBvc2VkIHRvIGJlIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHBlY3RlZF9raW5kJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZF9raW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHVhbF9raW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdyb25nX3R5cGU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdvcGVyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgeWllbGRzIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdhY3R1YWxfdHlwZSdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgYnV0IHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBpdCB0byBnaXZlIGEgJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdleHBlY3RlZF90eXBlJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZF90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHVhbF90eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGR1cGxpY2F0ZV9kdW1teV9uYW1lOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdUaGUgbmFtZSBcXCcnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2R1bW15J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1xcJyBpcyBhbHJlYWR5IGluIHVzZSBhbmQgc28gY2Fubm90IGJlIHF1YW50aWZpZWQgb3ZlciBpbiAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGR1bW15OiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2V4cHJlc3Npb24nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkdW1teV9ub3RfdmFyaWFibGU6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1lvdSBjYW4gb25seSBxdWFudGlmeSBvdmVyIHZhcmlhYmxlcywgbm90ICAnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2R1bW15J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJy4nXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBkdW1teToge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5rbm93bl9vcGVyYXRvcjoge1xuICAgICAgICAgICAgdGVtcGxhdGVzOiBbW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnVGhlIG9wZXJhdG9yICdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnb3BlcmF0b3InXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkLidcbiAgICAgICAgICAgICAgICAgICAgfV1dLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb19tYW55X3BhcnNpbmdzOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IFtbe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICgnVGhpcyBjYW4gYmUgcGFyc2VkIGluIHRvbyBtYW55IGRpZmZlcmVudCB3YXlzIC0gdHJ5IHVzaW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmZXdlciB3b3JkcywgZXNwZWNpYWxseSBzaW5nbGUtY2hhcmFjdGVyIHdvcmRzLicpXG4gICAgICAgICAgICAgICAgICAgIH1dXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb19tYW55X3R5cGluZ3M6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlczogW1t7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKCdUaGlzIGhhcyB0b28gbWFueSBwb3NzaWJsZSB0eXBpbmdzIC0gdHJ5IHVzaW5nIGZld2VyIHZhcmlhYmxlcy4nKVxuICAgICAgICAgICAgICAgICAgICB9XV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBidWlsZFF1ZXN0aW9uOiBidWlsZFF1ZXN0aW9uLFxuICAgICAgICBURUFDSEVSX0VSUk9SX01FU1NBR0VTOiBURUFDSEVSX0VSUk9SX01FU1NBR0VTXG4gICAgfTtcbn0pKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBsb2dpY1Byb29mVGVhY2hlcjtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xvZ2ljX3Byb29mLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sb2dpY19wcm9vZi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xvZ2ljX3Byb29mLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIE1hdGhFeHByZXNzaW9uSW5wdXQgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9NYXRoRXhwcmVzc2lvbklucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ21hdGgtZXhwcmVzc2lvbi1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdtYXRoLWV4cHJlc3Npb24taW5wdXQtdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1tYXRoLWV4cHJlc3Npb24taW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1yZXNwb25zZS1tYXRoLWV4cHJlc3Npb24taW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1tYXRoLWV4cHJlc3Npb24taW5wdXQuZGlyZWN0aXZlLnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJ1bGVzIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIE1hdGhFeHByZXNzaW9uSW5wdXRSdWxlc1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZSgpIHtcbiAgICB9XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiB0eXBlZFxuICAgIC8vIGFzICdhbnknIHNpbmNlICdhbnN3ZXInIGlzIGEgY29tcGxleCBvYmplY3QgaGF2aW5nIHZhcnlpbmcgdHlwZXMuIEEgZ2VuZXJhbFxuICAgIC8vIHR5cGUgbmVlZHMgdG8gYmUgZm91bmQuIFNhbWUgZ29lcyBmb3IgJ2lucHV0cycuXG4gICAgTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZS5wcm90b3R5cGUuSXNNYXRoZW1hdGljYWxseUVxdWl2YWxlbnRUbyA9IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTWF0aEV4cHJlc3Npb24uZnJvbUxhdGV4KGFuc3dlci5sYXRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdCYWQgZXhwcmVzc2lvbiBpbiBhbnN3ZXIubGF0ZXg6ICcgKyBlLm1lc3NhZ2UoKSArICcgaW5wdXRzOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhbnN3ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTWF0aEV4cHJlc3Npb24uZnJvbUxhdGV4KGlucHV0cy54KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0JhZCBleHByZXNzaW9uIGluIGlucHV0cy54OiAnICsgZS5tZXNzYWdlKCkgKyAnIGlucHV0czogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoaW5wdXRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChNYXRoRXhwcmVzc2lvbi5mcm9tTGF0ZXgoYW5zd2VyLmxhdGV4KS5lcXVhbHMoTWF0aEV4cHJlc3Npb24uZnJvbUxhdGV4KGlucHV0cy54KSkpO1xuICAgIH07XG4gICAgTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSlcbiAgICBdLCBNYXRoRXhwcmVzc2lvbklucHV0UnVsZXNTZXJ2aWNlKTtcbiAgICByZXR1cm4gTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLk1hdGhFeHByZXNzaW9uSW5wdXRSdWxlc1NlcnZpY2UgPSBNYXRoRXhwcmVzc2lvbklucHV0UnVsZXNTZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmFsaWRhdG9yIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiaW50ZXJhY3Rpb25zL2Jhc2UtaW50ZXJhY3Rpb24tdmFsaWRhdGlvbi5zZXJ2aWNlXCIpO1xudmFyIGFwcF9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJhcHAuY29uc3RhbnRzXCIpO1xudmFyIE1hdGhFeHByZXNzaW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MgPSBmdW5jdGlvbiAoY3VzdG9taXphdGlvbkFyZ3MpIHtcbiAgICAgICAgLy8gVE9ETyhqdWFuc2FiYSk6IEltcGxlbWVudCBjdXN0b21pemF0aW9uIGFyZ3MgdmFsaWRhdGlvbnMuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIE1hdGhFeHByZXNzaW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QWxsV2FybmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKSk7XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBlYWNoIHJ1bGUgaGFzIGEgdmFsaWQgbWF0aCBleHByZXNzaW9uLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuc3dlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIE1hdGhFeHByZXNzaW9uLmZyb21MYXRleChydWxlc1tqXS5pbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnVGhlIG1hdGggZXhwcmVzc2lvbiB1c2VkIGluIHJ1bGUgJyArIFN0cmluZyhqICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaW4gZ3JvdXAgJyArIFN0cmluZyhpICsgMSkgKyAnIGlzIGludmFsaWQuJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgTWF0aEV4cHJlc3Npb25JbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290J1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5NYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2UgPSBNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdNYXRoRXhwcmVzc2lvbklucHV0VmFsaWRhdGlvblNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKE1hdGhFeHByZXNzaW9uSW5wdXRWYWxpZGF0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBNYXRoRXhwcmVzc2lvbklucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL01hdGhFeHByZXNzaW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnbWF0aC1leHByZXNzaW9uLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2V4cGxvcmF0aW9uLXBsYXllci1wYWdlL3NlcnZpY2VzL2N1cnJlbnQtaW50ZXJhY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9EZXZpY2VJbmZvU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9XaW5kb3dEaW1lbnNpb25zU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvRGVib3VuY2VyU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVNYXRoRXhwcmVzc2lvbklucHV0JywgW1xuICAgICdNYXRoRXhwcmVzc2lvbklucHV0UnVsZXNTZXJ2aWNlJyxcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChNYXRoRXhwcmVzc2lvbklucHV0UnVsZXNTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL01hdGhFeHByZXNzaW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbWF0aC1leHByZXNzaW9uLWlucHV0LWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRzY29wZScsICckYXR0cnMnLCAnJHRpbWVvdXQnLCAnJGVsZW1lbnQnLCAnTEFCRUxfRk9SX0NMRUFSSU5HX0ZPQ1VTJyxcbiAgICAgICAgICAgICAgICAnRGVib3VuY2VyU2VydmljZScsICdEZXZpY2VJbmZvU2VydmljZScsICdXaW5kb3dEaW1lbnNpb25zU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgJHRpbWVvdXQsICRlbGVtZW50LCBMQUJFTF9GT1JfQ0xFQVJJTkdfRk9DVVMsIERlYm91bmNlclNlcnZpY2UsIERldmljZUluZm9TZXJ2aWNlLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndXBweURpdkVsdCA9ICRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJy5ndXBweS1kaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pY2FsbHkgYXNzaWducyBhIHVuaXF1ZSBpZCB0byB0aGUgZ3VwcHktZGl2XG4gICAgICAgICAgICAgICAgICAgIGd1cHB5RGl2RWx0LnNldEF0dHJpYnV0ZSgnaWQnLCAnZ3VwcHlfJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3VwcHlEaXZJZCA9IGd1cHB5RGl2RWx0LmlkO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQWRkcyBhIGJ1dHRvbiBvdmVybGF5IGFuZCBpbnZpc2libGUgdGV4dCBmaWVsZCB1c2VkIHRvIGJyaW5nIHVwXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogVE9ETyhPaXNoaWthdHRhKTogT24gaU9TL1NhZmFyaSwga2V5Ym9hcmQgbWF5IG9ubHkgYXBwZWFyIG9uIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAqIHByZXNzLiBUaGlzIG1heSBub3QgYmUgYSBzaWduaWZpY2FudCBpc3N1ZSBhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogTWF0aEV4cHJlc3Npb25JbnB1dCBpcyByZWNyZWF0ZWQgaWYgdGhlIGdpdmVuIGFuc3dlciBpcyBpbmNvcnJlY3QuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFrZUd1cHB5TW9iaWxlRnJpZW5kbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ3VwcHkgZGl2IGhhcyBhIHdpZHRoIGFuZCBoZWlnaHQgZ3JlYXRlciB0aGFuIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpZiBub3Qgc2NoZWR1bGVzIGEgdGltZW91dCB0byBydW4gYWdhaW4gYWZ0ZXIgMTAwbXMuIElmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogZ3VwcHkgZGl2IGhhcyBhIHZhbGlkIHdpZHRoL2hlaWdodCwgcG9zaXRpb24gdGhlIGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYnV0dG9uIGRpcmVjdGx5IG92ZXIgdGhlIGd1cHB5IGRpdi4gRm9yIG1vYmlsZSBicm93c2VycywgZm9jdXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICogY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGFuIG9uY2xpY2sgaGFuZGxlci4gVXNpbmcgYSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IHdhcyBtb3JlIHJlbGlhYmxlIHRoYW4gYXR0YWNoaW5nIHRoZSBoYW5kbGVyIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogZ3VwcHkgZGl2IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25CdXR0b25PdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndXBweU9mZnNldCA9ICQoZ3VwcHlEaXZFbHQpLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGd1cHB5U2l6ZSA9IGd1cHB5RGl2RWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBndXBweSBkaXYgaGFzbid0IHJlbmRlcmVkIHlldCwgcmV0cnkgYWZ0ZXIgMTAwbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGd1cHB5U2l6ZS53aWR0aCA9PT0gMCB8fCBndXBweVNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KHBvc2l0aW9uQnV0dG9uT3ZlcmxheSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNzdGFydE1hdGhJbnB1dEJ1dHRvbicpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGd1cHB5T2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGd1cHB5T2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZ3VwcHlTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBndXBweVNpemUuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkJ1dHRvbk92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2N1cygpIGNhbGwgbXVzdCBiZSBpbiBhIGNsaWNrIGV2ZW50IGhhbmRsZXIgYW5kIG9uIGEgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgdG8gbWFrZSB0aGUgbW9iaWxlIGtleWJvYXJkIGFwcGVhci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3RhcnRNb2JpbGVNYXRoSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VwcHlJbnN0YW5jZS5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWtlSW5wdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2Zha2VJbnB1dEZvck1hdGhFeHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFrZUlucHV0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIHRoZSBjdXJzb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBpbnB1dCwgc28gdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIGNhbiB1c2UgYmFja3NwYWNlIHRvIGRlbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWtlSW5wdXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKGZha2VJbnB1dEVsZW1lbnQudmFsdWUubGVuZ3RoLCBmYWtlSW5wdXRFbGVtZW50LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldEd1cHB5Q29udGVudEZyb21JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgR3VwcHkgaW5zdGFuY2UgYnkgc2V0dGluZyBpdHMgY29udGVudCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRwdXQgb2YgZ2V0X2NvbnRlbnQgd2hlbiBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndXBweUluc3RhbmNlLmltcG9ydF94bWwoJzxtPjxlPjwvZT48L20+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VwcHlJbnN0YW5jZS5yZW5kZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbnRlbnQgb2YgdGhlIHRleHQgaW5wdXQgZmllbGQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcignI2Zha2VJbnB1dEZvck1hdGhFeHByZXNzaW9uJykudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxheSBrZXkgY29tYmluYXRpb24gZm9yIGVhY2ggY2hhcmFjdGVyIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRDb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzcGFjZSwgc2VuZCBhICdyaWdodCcgdG8gZW5hYmxlIG1vYmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VycyB0byBjb21wbGV0ZSBleHByZXNzaW9ucyB3aXRob3V0IGFycm93IGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3VzZXRyYXAudHJpZ2dlcigncmlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vdXNldHJhcC50cmlnZ2VyKHRleHRDb250ZW50W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWJvdW5jZSBjbGVhci9yZWZpbGwgY3ljbGVzIHRvIDEgcGVyIDEwMG1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2Zha2VJbnB1dEZvck1hdGhFeHByZXNzaW9uJykub24oJ2lucHV0IGNoYW5nZSBjb21wb3NpdGlvbnVwZGF0ZSBrZXlkb3duJywgRGVib3VuY2VyU2VydmljZS5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0R3VwcHlDb250ZW50RnJvbUlucHV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApKS5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndXBweUluc3RhbmNlLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0R3VwcHlDb250ZW50RnJvbUlucHV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wcGlhU3ltYm9sc1VybCA9IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldFN0YXRpY0Fzc2V0VXJsKCcvb3ZlcnJpZGVzL2d1cHB5L29wcGlhX3N5bWJvbHMuanNvbicpO1xuICAgICAgICAgICAgICAgICAgICBHdXBweS5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHM6IFsnL3RoaXJkX3BhcnR5L3N0YXRpYy9ndXBweS1iNTA1NWIvc3ltL3N5bWJvbHMuanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BwaWFTeW1ib2xzVXJsXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1cHB5SW5zdGFuY2UgPSBuZXcgR3VwcHkoZ3VwcHlEaXZJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXB0eV9jb250ZW50OiAoJ1xcXFxjb2xvcntncmV5fXtcXFxcdGV4dHtcXFxcc21hbGx7VHlwZSBhIGZvcm11bGEgaGVyZS59fX0nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgdHJpZ2dlciB0aGUgZGlnZXN0IGN5Y2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIG1ha2UgYW55ICd3YXRjaGVycycgYXdhcmUgb2YgY2hhbmdlcyBpbiBhbnN3ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEZXZpY2VJbmZvU2VydmljZS5pc01vYmlsZVVzZXJBZ2VudCgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXZpY2VJbmZvU2VydmljZS5oYXNUb3VjaEV2ZW50cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vYmlsZU92ZXJsYXlJc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBzY29wZSBjaGFuZ2UgdG8gYXBwbHkuIFNpbmNlIHdlIGludGVyYWN0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBET00gZWxlbWVudHMsIHRoZXkgbmVlZCB0byBiZSBhZGRlZCBieSBhbmd1bGFyIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gVGltZW91dCBvZiAwIHRvIHdhaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGlnZXN0IGN5Y2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2UgdG8gbm90IHN0YXJ0IGEgbmV3IGRpZ2VzdCBjeWNsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbmV3IGN5Y2xlIGlzIG5vdCBuZWVkZWQgc2luY2Ugbm8gYW5ndWxhciB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZSBjaGFuZ2VkIHdpdGhpbiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChtYWtlR3VwcHlNb2JpbGVGcmllbmRseSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZ3VwcHlJbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsRm9yRm9jdXNUYXJnZXQgPSAkYXR0cnMubGFiZWxGb3JGb2N1c1RhcmdldCB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdmb2N1c09uJywgZnVuY3Rpb24gKGUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxGb3JGb2N1c1RhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBsYWJlbEZvckZvY3VzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VwcHlJbnN0YW5jZS5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gTEFCRUxfRk9SX0NMRUFSSU5HX0ZPQ1VTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VwcHlJbnN0YW5jZS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNjaWk6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXg6ICcnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNDdXJyZW50QW5zd2VyVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXhBbnN3ZXIgPSBndXBweUluc3RhbmNlLmxhdGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhFeHByZXNzaW9uLmZyb21MYXRleChsYXRleEFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5pc0N1cnJlbnRBbnN3ZXJWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyLmxhdGV4ID0gZ3VwcHlJbnN0YW5jZS5sYXRleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyLmFzY2lpID0gZ3VwcHlJbnN0YW5jZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLm9uU3VibWl0KGFuc3dlciwgTWF0aEV4cHJlc3Npb25JbnB1dFJ1bGVzU2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oY3RybC5zdWJtaXRBbnN3ZXIsIGN0cmwuaXNDdXJyZW50QW5zd2VyVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTWF0aEV4cHJlc3Npb25JbnB1dCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RpcmVjdGl2ZXMvbWF0aGpheC1iaW5kLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VNYXRoRXhwcmVzc2lvbklucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdtYXRoLWV4cHJlc3Npb24taW5wdXQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubGF0ZXhBbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKS5sYXRleDtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBNYXRoRXhwcmVzc2lvbklucHV0IHNob3J0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZGlyZWN0aXZlcy9tYXRoamF4LWJpbmQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlTWF0aEV4cHJlc3Npb25JbnB1dCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL01hdGhFeHByZXNzaW9uSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbWF0aC1leHByZXNzaW9uLWlucHV0LXNob3J0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxhdGV4QW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcikubGF0ZXg7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIE11bHRpcGxlQ2hvaWNlSW5wdXQgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L3N0YXRpYy9tdWx0aXBsZV9jaG9pY2VfaW5wdXQuY3NzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVsdGlwbGVDaG9pY2VJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdtdWx0aXBsZS1jaG9pY2UtaW5wdXQtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnbXVsdGlwbGUtY2hvaWNlLWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtaW50ZXJhY3RpdmUtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtc2hvcnQtcmVzcG9uc2UtbXVsdGlwbGUtY2hvaWNlLWlucHV0LmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ011bHRpcGxlQ2hvaWNlSW5wdXRSdWxlc1NlcnZpY2UnLCBbZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyID09PSBpbnB1dHMueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgTXVsdGlwbGVDaG9pY2VJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSA9IGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIE11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydjaG9pY2VzJ10pO1xuICAgICAgICB2YXIgYXJlQW55Q2hvaWNlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmVBbnlDaG9pY2VzRHVwbGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VlbkNob2ljZXMgPSBbXTtcbiAgICAgICAgdmFyIG51bUNob2ljZXMgPSBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hvaWNlID0gY3VzdG9taXphdGlvbkFyZ3MuY2hvaWNlcy52YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmIChjaG9pY2UudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFyZUFueUNob2ljZXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VlbkNob2ljZXMuaW5kZXhPZihjaG9pY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFyZUFueUNob2ljZXNEdXBsaWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5DaG9pY2VzLnB1c2goY2hvaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJlQW55Q2hvaWNlc0VtcHR5KSB7XG4gICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkNSSVRJQ0FMLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgZW5zdXJlIHRoZSBjaG9pY2VzIGFyZSBub25lbXB0eS4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJlQW55Q2hvaWNlc0R1cGxpY2F0ZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnN1cmUgdGhlIGNob2ljZXMgYXJlIHVuaXF1ZS4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FybmluZ3NMaXN0O1xuICAgIH07XG4gICAgTXVsdGlwbGVDaG9pY2VJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdCh0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpKTtcbiAgICAgICAgdmFyIG51bUNob2ljZXMgPSBjdXN0b21pemF0aW9uQXJncy5jaG9pY2VzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIHNlbGVjdGVkRXF1YWxzQ2hvaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuc3dlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChydWxlc1tqXS50eXBlID09PSAnRXF1YWxzJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlUHJldmlvdXNseVNlbGVjdGVkID0gKHNlbGVjdGVkRXF1YWxzQ2hvaWNlcy5pbmRleE9mKHJ1bGVzW2pdLmlucHV0cy54KSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNob2ljZVByZXZpb3VzbHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFcXVhbHNDaG9pY2VzLnB1c2gocnVsZXNbal0uaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5DUklUSUNBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVuc3VyZSBydWxlICcgKyBTdHJpbmcoaiArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpbiBncm91cCAnICsgU3RyaW5nKGkgKyAxKSArICcgaXMgbm90IGVxdWFsaW5nIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NhbWUgbXVsdGlwbGUgY2hvaWNlIG9wdGlvbiBhcyBhbm90aGVyIHJ1bGUuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzW2pdLmlucHV0cy54ID49IG51bUNob2ljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHBfY29uc3RhbnRzXzEuQXBwQ29uc3RhbnRzLldBUk5JTkdfVFlQRVMuQ1JJVElDQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnN1cmUgcnVsZSAnICsgU3RyaW5nKGogKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaW4gZ3JvdXAgJyArIFN0cmluZyhpICsgMSkgKyAnIHJlZmVycyB0byBhIHZhbGlkIGNob2ljZS4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nc0xpc3QgPSB3YXJuaW5nc0xpc3QuY29uY2F0KHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5nZXRBbnN3ZXJHcm91cFdhcm5pbmdzKGFuc3dlckdyb3Vwcywgc3RhdGVOYW1lKSk7XG4gICAgICAgIC8vIE9ubHkgcmVxdWlyZSBhIGRlZmF1bHQgcnVsZSBpZiBzb21lIGNob2ljZXMgaGF2ZSBub3QgYmVlbiB0YWtlbiBjYXJlXG4gICAgICAgIC8vIG9mIGJ5IHJ1bGVzLlxuICAgICAgICBpZiAoc2VsZWN0ZWRFcXVhbHNDaG9pY2VzLmxlbmd0aCA8IG51bUNob2ljZXMpIHtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdE91dGNvbWUgfHwgZGVmYXVsdE91dGNvbWUuaXNDb25mdXNpbmcoc3RhdGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGFkZCBzb21ldGhpbmcgZm9yIE9wcGlhIHRvIHNheSBpbiB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcIkFsbCBvdGhlciBhbnN3ZXJzXFxcIiByZXNwb25zZS4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBNdWx0aXBsZUNob2ljZUlucHV0VmFsaWRhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIE11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIE11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLk11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IE11bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ011bHRpcGxlQ2hvaWNlSW5wdXRWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoTXVsdGlwbGVDaG9pY2VJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIE11bHRpcGxlQ2hvaWNlSW5wdXQgaW50ZXJhY3Rpb24uXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9NdWx0aXBsZUNob2ljZUlucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ211bHRpcGxlLWNob2ljZS1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZU11bHRpcGxlQ2hvaWNlSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdNdWx0aXBsZUNob2ljZUlucHV0UnVsZXNTZXJ2aWNlJyxcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIE11bHRpcGxlQ2hvaWNlSW5wdXRSdWxlc1NlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTXVsdGlwbGVDaG9pY2VJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdtdWx0aXBsZS1jaG9pY2UtaW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkYXR0cnMsIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNob2ljZXMgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuY2hvaWNlc1dpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zdWJtaXRBbnN3ZXIgPSBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5zd2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyID0gcGFyc2VJbnQoYW5zd2VyLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLm9uU3VibWl0KGFuc3dlciwgTXVsdGlwbGVDaG9pY2VJbnB1dFJ1bGVzU2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24obnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBNdWx0aXBsZUNob2ljZUlucHV0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VNdWx0aXBsZUNob2ljZUlucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTXVsdGlwbGVDaG9pY2VJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdtdWx0aXBsZS1jaG9pY2UtaW5wdXQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY2hvaWNlcyA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5jaG9pY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNwb25zZSA9IF9jaG9pY2VzW19hbnN3ZXJdO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIE11bHRpcGxlQ2hvaWNlSW5wdXQgc2hvcnQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdmaWx0ZXJzL3N0cmluZy11dGlsaXR5LWZpbHRlcnMvY29udmVydC10by1wbGFpbi10ZXh0LmZpbHRlci50cycpO1xucmVxdWlyZSgnZmlsdGVycy9zdHJpbmctdXRpbGl0eS1maWx0ZXJzL3RydW5jYXRlLWF0LWZpcnN0LWxpbmUuZmlsdGVyLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlTXVsdGlwbGVDaG9pY2VJbnB1dCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL011bHRpcGxlQ2hvaWNlSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbXVsdGlwbGUtY2hvaWNlLWlucHV0LXNob3J0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRhdHRycycsICckZmlsdGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJGF0dHJzLCAkZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jaG9pY2VzID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmNob2ljZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSAkZmlsdGVyKCdjb252ZXJ0VG9QbGFpblRleHQnKShfY2hvaWNlc1tfYW5zd2VyXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucmVzcG9uc2UgPSAkZmlsdGVyKCd0cnVuY2F0ZUF0Rmlyc3RMaW5lJykocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL211bHRpcGxlX2Nob2ljZV9pbnB1dC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbXVsdGlwbGVfY2hvaWNlX2lucHV0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbXVsdGlwbGVfY2hvaWNlX2lucHV0LmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIE11c2ljTm90ZXNJbnB1dCBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9zdGF0aWMvbXVzaWNfbm90ZXNfaW5wdXQuY3NzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvbXVzaWMtbm90ZXMtaW5wdXQtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdtdXNpYy1ub3Rlcy1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtaW50ZXJhY3RpdmUtbXVzaWMtbm90ZXMtaW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXJlc3BvbnNlLW11c2ljLW5vdGVzLWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1tdXNpYy1ub3Rlcy1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG4vLyBUaGUgYmVsb3cgZmlsZSBpcyBpbXBvcnRlZCBqdXN0IGZvciBpdHMgY29uc3RhbnQuXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLWludGVyYWN0aXZlLW11c2ljLW5vdGVzLWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9ucy1leHRlbnNpb24uY29uc3RhbnRzLmFqcy50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnTXVzaWNOb3Rlc0lucHV0UnVsZXNTZXJ2aWNlJywgW1xuICAgICdOT1RFX05BTUVTX1RPX01JRElfVkFMVUVTJywgZnVuY3Rpb24gKE5PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVMpIHtcbiAgICAgICAgdmFyIF9nZXRNaWRpTm90ZVZhbHVlID0gZnVuY3Rpb24gKG5vdGUpIHtcbiAgICAgICAgICAgIGlmIChOT1RFX05BTUVTX1RPX01JRElfVkFMVUVTLmhhc093blByb3BlcnR5KG5vdGUucmVhZGFibGVOb3RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTk9URV9OQU1FU19UT19NSURJX1ZBTFVFU1tub3RlLnJlYWRhYmxlTm90ZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG11c2ljIG5vdGUgJyArIG5vdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2NvbnZlcnRTZXF1ZW5jZVRvTWlkaSA9IGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlLm1hcChmdW5jdGlvbiAobm90ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0TWlkaU5vdGVWYWx1ZShub3RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5lcXVhbHMoX2NvbnZlcnRTZXF1ZW5jZVRvTWlkaShhbnN3ZXIpLCBfY29udmVydFNlcXVlbmNlVG9NaWRpKGlucHV0cy54KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNMb25nZXJUaGFuOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnZlcnRTZXF1ZW5jZVRvTWlkaShhbnN3ZXIpLmxlbmd0aCA+IGlucHV0cy5rO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFRPRE8od3h5KTogdmFsaWRhdGUgdGhhdCBpbnB1dHMuYSA8PSBpbnB1dHMuYlxuICAgICAgICAgICAgSGFzTGVuZ3RoSW5jbHVzaXZlbHlCZXR3ZWVuOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5zd2VyTGVuZ3RoID0gX2NvbnZlcnRTZXF1ZW5jZVRvTWlkaShhbnN3ZXIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyTGVuZ3RoID49IGlucHV0cy5hICYmIGFuc3dlckxlbmd0aCA8PSBpbnB1dHMuYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc0VxdWFsVG9FeGNlcHRGb3I6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTZXF1ZW5jZSA9IF9jb252ZXJ0U2VxdWVuY2VUb01pZGkoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHZhciB1c2VyU2VxdWVuY2UgPSBfY29udmVydFNlcXVlbmNlVG9NaWRpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZXF1ZW5jZS5sZW5ndGggIT09IHRhcmdldFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBudW1Xcm9uZ05vdGVzID0gMDtcbiAgICAgICAgICAgICAgICB1c2VyU2VxdWVuY2UubWFwKGZ1bmN0aW9uIChub3RlVmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RlVmFsdWUgIT09IHRhcmdldFNlcXVlbmNlW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV3JvbmdOb3RlcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bVdyb25nTm90ZXMgPD0gaW5wdXRzLms7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNUcmFuc3Bvc2l0aW9uT2Y6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTZXF1ZW5jZSA9IF9jb252ZXJ0U2VxdWVuY2VUb01pZGkoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHZhciB1c2VyU2VxdWVuY2UgPSBfY29udmVydFNlcXVlbmNlVG9NaWRpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZXF1ZW5jZS5sZW5ndGggIT09IHRhcmdldFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyU2VxdWVuY2UuZXZlcnkoZnVuY3Rpb24gKG5vdGVWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFNlcXVlbmNlW2luZGV4XSArIGlucHV0cy55ID09PSBub3RlVmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNUcmFuc3Bvc2l0aW9uT2ZFeGNlcHRGb3I6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTZXF1ZW5jZSA9IF9jb252ZXJ0U2VxdWVuY2VUb01pZGkoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHZhciB1c2VyU2VxdWVuY2UgPSBfY29udmVydFNlcXVlbmNlVG9NaWRpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTZXF1ZW5jZS5sZW5ndGggIT09IHRhcmdldFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBudW1Xcm9uZ05vdGVzID0gMDtcbiAgICAgICAgICAgICAgICB1c2VyU2VxdWVuY2UubWFwKGZ1bmN0aW9uIChub3RlVmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTZXF1ZW5jZVtpbmRleF0gKyBpbnB1dHMueSAhPT0gbm90ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Xcm9uZ05vdGVzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtV3JvbmdOb3RlcyA8PSBpbnB1dHMuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSA9IGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIE11c2ljTm90ZXNJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIC8vIFRPRE8oanVhbnNhYmEpOiBJbXBsZW1lbnQgY3VzdG9taXphdGlvbiBhcmdzIHZhbGlkYXRpb25zLlxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QWxsV2FybmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKS5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgTXVzaWNOb3Rlc0lucHV0VmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLk11c2ljTm90ZXNJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gTXVzaWNOb3Rlc0lucHV0VmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdNdXNpY05vdGVzSW5wdXRWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoTXVzaWNOb3Rlc0lucHV0VmFsaWRhdGlvblNlcnZpY2UpKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGxheWVyIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnTXVzaWNQaHJhc2VQbGF5ZXJTZXJ2aWNlJywgW1xuICAgICckdGltZW91dCcsIGZ1bmN0aW9uICgkdGltZW91dCkge1xuICAgICAgICB2YXIgX01JRElfQ0hBTk5FTCA9IDA7XG4gICAgICAgIHZhciBfTUlESV9WRUxPQ0lUWSA9IDEyNztcbiAgICAgICAgdmFyIF9TRUNTX1RPX01JTExJU0VDUyA9IDEwMDAuMDtcbiAgICAgICAgdmFyIF9wbGF5Tm90ZSA9IGZ1bmN0aW9uIChtaWRpVmFsdWVzLCBkdXJhdGlvbkluU2VjcywgZGVsYXlJblNlY3MpIHtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBNSURJLmNob3JkT24oX01JRElfQ0hBTk5FTCwgbWlkaVZhbHVlcywgX01JRElfVkVMT0NJVFksIDApO1xuICAgICAgICAgICAgICAgIE1JREkuY2hvcmRPZmYoX01JRElfQ0hBTk5FTCwgbWlkaVZhbHVlcywgZHVyYXRpb25JblNlY3MpO1xuICAgICAgICAgICAgfSwgZGVsYXlJblNlY3MgKiBfU0VDU19UT19NSUxMSVNFQ1MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheXMgYSBtdXNpYyBwaHJhc2UuIFRoZSBpbnB1dCBpcyBnaXZlbiBhcyBhbiBBcnJheSBvZiBub3Rlcy4gRWFjaFxuICAgICAgICAgKiBub3RlIGlzIHJlcHJlc2VudGVkIGFzIGFuIG9iamVjdCB3aXRoIHRocmVlIGtleS12YWx1ZSBwYWlyczpcbiAgICAgICAgICogLSBtaWRpVmFsdWU6IEludGVnZXIuIFRoZSBtaWRpIHZhbHVlIG9mIHRoZSBub3RlLlxuICAgICAgICAgKiAtIGR1cmF0aW9uOiBGbG9hdC4gQSBkZWNpbWFsIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aGUgbm90ZSxcbiAgICAgICAgICogICAgIGluIHNlY29uZHMuXG4gICAgICAgICAqIC0gc3RhcnQ6IEZsb2F0LiBBIGRlY2ltYWwgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgdGltZSBvZmZzZXQgKGFmdGVyIHRoZVxuICAgICAgICAgKiAgICAgYmVnaW5uaW5nIG9mIHRoZSBwaHJhc2UpIGF0IHdoaWNoIHRvIHN0YXJ0IHBsYXlpbmcgdGhlIG5vdGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3BsYXlNdXNpY1BocmFzZSA9IGZ1bmN0aW9uIChub3Rlcykge1xuICAgICAgICAgICAgTUlESS5QbGF5ZXIuc3RvcCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9wbGF5Tm90ZShbbm90ZXNbaV0ubWlkaVZhbHVlXSwgbm90ZXNbaV0uZHVyYXRpb24sIG5vdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBsYXlNdXNpY1BocmFzZTogZnVuY3Rpb24gKG5vdGVzKSB7XG4gICAgICAgICAgICAgICAgX3BsYXlNdXNpY1BocmFzZShub3Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZXMgZm9yIHRoZSBNdXNpY05vdGVzSW5wdXQgaW50ZXJhY3Rpb24uXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy9tdXNpYy1ub3Rlcy1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgJ211c2ljLXBocmFzZS1wbGF5ZXIuc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9XaW5kb3dEaW1lbnNpb25zU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zLWV4dGVuc2lvbi5jb25zdGFudHMuYWpzLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVNdXNpY05vdGVzSW5wdXQnLCBbXG4gICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLCAnSHRtbEVzY2FwZXJTZXJ2aWNlJyxcbiAgICAnTXVzaWNOb3Rlc0lucHV0UnVsZXNTZXJ2aWNlJywgJ011c2ljUGhyYXNlUGxheWVyU2VydmljZScsXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICAnRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFJywgJ05PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVMnLFxuICAgIGZ1bmN0aW9uIChDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLCBIdG1sRXNjYXBlclNlcnZpY2UsIE11c2ljTm90ZXNJbnB1dFJ1bGVzU2VydmljZSwgTXVzaWNQaHJhc2VQbGF5ZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSwgRVZFTlRfTkVXX0NBUkRfQVZBSUxBQkxFLCBOT1RFX05BTUVTX1RPX01JRElfVkFMVUVTKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBnZXRMYXN0QW5zd2VyOiAnJmxhc3RBbnN3ZXInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbXVzaWMtbm90ZXMtaW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciBmb3IgdGhlIHNjb3BlIHRvIGJlIHJldHJpZXZhYmxlIGR1cmluZyBLYXJtYVxuICAgICAgICAgICAgICAgIC8vIHVuaXQgdGVzdGluZy4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI5ODMzODMyIGZvciBtb3JlXG4gICAgICAgICAgICAgICAgLy8gZGV0YWlscy5cbiAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmdldENvbnRyb2xsZXJTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGUuU09VTkRGT05UX1VSTCA9XG4gICAgICAgICAgICAgICAgICAgICcvdGhpcmRfcGFydHkvc3RhdGljL21pZGktanMtYThhODQyL2V4YW1wbGVzL3NvdW5kZm9udC8nO1xuICAgICAgICAgICAgICAgIHNjb3BlLnNlcXVlbmNlVG9HdWVzcyA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKGF0dHJzLnNlcXVlbmNlVG9HdWVzc1dpdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc2NvcGUuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA9IChzY29wZS5nZXRMYXN0QW5zd2VyKCkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLmluaXRpYWxTZXF1ZW5jZSA9IHNjb3BlLmludGVyYWN0aW9uSXNBY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaihhdHRycy5pbml0aWFsU2VxdWVuY2VXaXRoVmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZ2V0TGFzdEFuc3dlcigpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRvbihFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW50ZXJhY3Rpb25Jc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5pbml0aWFsU2VxdWVuY2UgPSBzY29wZS5nZXRMYXN0QW5zd2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlaW5pdFN0YWZmKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQSBub3RlIE9iamVjdCBoYXMgYSBiYXNlTm90ZU1pZGlOdW1iZXIgYW5kIGFuIG9mZnNldCBwcm9wZXJ0eS4gRm9yXG4gICAgICAgICAgICAgICAgICogZXhhbXBsZSwgQyM0IHdvdWxkIGJlIC0+IG5vdGUgPSB7YmFzZU5vdGVNaWRpTnVtYmVyOiA2MSwgb2Zmc2V0OiAxfTtcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEEgcmVhZGFibGVOb3RlIE9iamVjdCBoYXMgYSByZWFkYWJsZU5vdGVOYW1lIHByb3BlcnR5LiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICAgICAgICAgKiBHYjUgd291bGQgYmUgLT4gcmVhZGFibGVOb3RlID0ge3JlYWRhYmxlTm90ZU5hbWU6ICdHYjUnfTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBcnJheSB0byBob2xkIHRoZSBub3RlcyBwbGFjZWQgb24gc3RhZmYuIE5vdGVzIGFyZSByZXByZXNlbnRlZCBhc1xuICAgICAgICAgICAgICAgICAqIG9iamVjdHMgd2l0aCB0d28ga2V5czogYmFzZU5vdGVNaWRpTnVtYmVyIGFuZCBvZmZzZXQuIFRoZVxuICAgICAgICAgICAgICAgICAqIGJhc2VOb3RlTWlkaU51bWJlciBpcyBhbiBpbnRlZ2VyIHZhbHVlIGRlbm90aW5nIHRoZSBNSURJIG51bWJlciBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGFmZi1saW5lIHRoZSBub3RlIGlzIG9uLCBhbmQgdGhlIG9mZnNldCBpcyBlaXRoZXIgLTEsIDAgb3IgMSxcbiAgICAgICAgICAgICAgICAgKiBkZW5vdGluZyBhIGZsYXQsIG5hdHVyYWwgb3Igc2hhcnAgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNjb3BlLm5vdGVTZXF1ZW5jZSA9IFtdO1xuICAgICAgICAgICAgICAgIHNjb3BlLl9hZGROb3RlVG9Ob3RlU2VxdWVuY2UgPSBmdW5jdGlvbiAobm90ZSkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5ub3RlU2VxdWVuY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlOiBub3RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgc3BlY2lmaWMgbm90ZSB3aXRoIGdpdmVuIG5vdGVJZCBmcm9tIG5vdGVTZXF1ZW5jZS4gSWYgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyBub3RlSWQgaXMgbm90IGluIG5vdGVTZXF1ZW5jZSwgbm90aGluZyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgc2NvcGUuX3JlbW92ZU5vdGVzRnJvbU5vdGVTZXF1ZW5jZVdpdGhJZCA9IGZ1bmN0aW9uIChub3RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29wZS5ub3RlU2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5ub3RlU2VxdWVuY2VbaV0ubm90ZS5ub3RlSWQgPT09IG5vdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm5vdGVTZXF1ZW5jZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFNvcnRzIG5vdGVTZXF1ZW5jZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlTm90ZVN0YXJ0cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBzY29wZS5fc29ydE5vdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubm90ZVNlcXVlbmNlLnNvcnQoY29tcGFyZU5vdGVTdGFydHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ291bnRlciB0byBjcmVhdGUgdW5pcXVlIGlkIGZvciBlYWNoIG5vdGUgZHJvcHBlZCBvbiBzdGFmZi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzY29wZS5fY3VycmVudE5vdGVJZCA9IDA7XG4gICAgICAgICAgICAgICAgc2NvcGUuZ2VuZXJhdGVOb3RlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLl9jdXJyZW50Tm90ZUlkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm90ZV9pZF8nICsgKHNjb3BlLl9jdXJyZW50Tm90ZUlkIC0gMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgTk9URV9UWVBFX05BVFVSQUwgPSAwO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8od2FnbmVyZG1pa2UpOiBNb3JlIG5vdGVzIHR5cGVzIHdpbGwgYmUgYWRkZWQgdG8gTk9URV9UWVBFUy5cbiAgICAgICAgICAgICAgICB2YXIgTk9URV9UWVBFUyA9IFtOT1RFX1RZUEVfTkFUVVJBTF07XG4gICAgICAgICAgICAgICAgdmFyIE5PVEVTX09OX0xJTkVTID0gWydFNCcsICdHNCcsICdCNCcsICdENScsICdGNSddO1xuICAgICAgICAgICAgICAgIHZhciBMRURHRVJfTElORV9OT1RFUyA9IFsnQzQnLCAnQTUnXTtcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljYWxHcmlkS2V5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgODEsIDc5LCA3NywgNzYsIDc0LCA3MiwgNzEsIDY5LCA2NywgNjUsIDY0LCA2MiwgNjBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIC8vIEhpZ2hlc3QgbnVtYmVyIG9mIG5vdGVzIHRoYXQgY2FuIGZpdCBvbiB0aGUgc3RhZmYgYXQgYW55IGdpdmVuIHRpbWUuXG4gICAgICAgICAgICAgICAgdmFyIE1BWElNVU1fTk9URVNfUE9TU0lCTEUgPSA4O1xuICAgICAgICAgICAgICAgIHZhciBub3RlQ2hvaWNlc0VsdCA9IGVsZW1lbnQuZmluZCgnLm9wcGlhLW11c2ljLWlucHV0LW5vdGUtY2hvaWNlcycpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFmZkNvbnRhaW5lckVsdCA9IGVsZW1lbnQuZmluZCgnLm9wcGlhLW11c2ljLWlucHV0LXN0YWZmJyk7XG4gICAgICAgICAgICAgICAgLy8gU3RhZmYgaGFzIHRvIGJlIHJlaW5pdGlhbGl6ZWQgZXZlcnkgdGltZSB0aGF0IHRoZSBzdGFmZiBpcyByZXNpemVkIG9yXG4gICAgICAgICAgICAgICAgLy8gZGlzcGxheWVkLiBUaGUgc3RhZmZDb250YWluZXJFbHQgYW5kIGFsbCBzdWJzZXF1ZW50IG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgcmVjYWxjdWxhdGVkIGluIG9yZGVyIGZvciB0aGUgZ3JpZCB0byB3b3JrIHByb3Blcmx5LlxuICAgICAgICAgICAgICAgIHNjb3BlLnJlaW5pdFN0YWZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJykuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5vcHBpYS1tdXNpYy1pbnB1dC12YWxpZC1ub3RlLWFyZWEnKS5jc3MoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHBhZ2UgaXMgaW4gdGhlIHNtYWxsZXIgb25lIGNhcmQgZm9ybWF0LCByZWluaXRpYWxpemUgc3RhZmYgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBuYXZpZ2F0ZXMgdG8gdGhlIEludGVyYWN0aW9uIFBhbmVsLiBPdGhlcndpc2UgdGhlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIHN0YWZmIHdpbGwgYmUgaW5jb3JyZWN0bHkgY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJ3Nob3dJbnRlcmFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVpbml0U3RhZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGRyYWdnYWJsZSBub3RlcyBhbmQgZHJvcHBhYmxlIHN0YWZmLlxuICAgICAgICAgICAgICAgIHNjb3BlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLkNPTlRBSU5FUl9XSURUSCA9IHN0YWZmQ29udGFpbmVyRWx0LndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLkNPTlRBSU5FUl9IRUlHSFQgPSAwLjIgKiBzY29wZS5DT05UQUlORVJfV0lEVEg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBncmlkIHJlY3RhbmdsZSBkaW1lbnNpb25zIGRlZmluaW5nIHRoZSBncmlkIHdoaWNoIHRoZSBub3Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsIG9uLlxuICAgICAgICAgICAgICAgICAgICBzY29wZS5IT1JJWk9OVEFMX0dSSURfU1BBQ0lORyA9IHNjb3BlLkNPTlRBSU5FUl9XSURUSCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAoTUFYSU1VTV9OT1RFU19QT1NTSUJMRSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5WRVJUSUNBTF9HUklEX1NQQUNJTkcgPSBzY29wZS5DT05UQUlORVJfSEVJR0hUIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsR3JpZEtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhZmZUb3AgPSBjb21wdXRlU3RhZmZUb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWZmQm90dG9tID0gY29tcHV0ZVN0YWZmQm90dG9tKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmYXJ0aGVzdCBlZGdlIG9mIHRoZSBzdGFmZi4gSWYgYSBub3RlIGlzIHBsYWNlZCBiZXlvbmQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiwgaXQgd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBSSUdIVF9FREdFX09GX1NUQUZGX1BPU0lUSU9OID0gZWxlbWVudC5maW5kKCcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJykud2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJOb3Rlc0Zyb21TdGFmZigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFsZXR0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckRyb3BwYWJsZVN0YWZmKCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRHJvcHBhYmxlU3RhZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwYWludE5vdGVzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsIG5vdGVzIGFyZSBwbGFjZWQgb24gdGhlIHN0YWZmIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBleHBsb3JhdGlvbiBhbmQgY2FuIGJlIHJlbW92ZWQgYnkgdGhlIGxlYXJuZXIuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxpemVOb3RlU2VxdWVuY2UgPSBmdW5jdGlvbiAoaW5pdGlhbE5vdGVzVG9BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsTm90ZXNUb0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxOb3RlID0gX2NvbnZlcnRSZWFkYWJsZU5vdGVUb05vdGUoaW5pdGlhbE5vdGVzVG9BZGRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbE5vdGUgPSBPYmplY3QuYXNzaWduKGluaXRpYWxOb3RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZUlkOiBzY29wZS5nZW5lcmF0ZU5vdGVJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVTdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW06IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbjogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuX2FkZE5vdGVUb05vdGVTZXF1ZW5jZShpbml0aWFsTm90ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEdldHMgdGhlIHN0YWZmIHRvcCBieSBnZXR0aW5nIHRoZSBmaXJzdCBzdGFmZiBsaW5lJ3MgcG9zaXRpb24gYW5kXG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3Rpbmcgb25lIHZlcnRpY2FsIGdyaWQgc3BhY2UgZnJvbSBpdC5cbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZVN0YWZmVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGdldFN0YWZmTGluZVBvc2l0aW9ucygpW3ZlcnRpY2FsR3JpZEtleXNbMF1dIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLlZFUlRJQ0FMX0dSSURfU1BBQ0lORyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBHZXRzIHRoZSBzdGFmZiBib3R0b20gcG9zaXRpb24gYnkgYWRkaW5nIHRoZSBzdGFmZiB0b3AgcG9zaXRpb24gdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSB0b3RhbCBzdW0gb2YgYWxsIHRoZSB2ZXJ0aWNhbCBncmlkIHNwYWNlcyAoc3RhZmYgbGluZXMpLlxuICAgICAgICAgICAgICAgIHZhciBjb21wdXRlU3RhZmZCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlU3RhZmZUb3AoKSArIChzY29wZS5WRVJUSUNBTF9HUklEX1NQQUNJTkcgKiB2ZXJ0aWNhbEdyaWRLZXlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIGFsbCBub3RlcyBmcm9tIHN0YWZmLlxuICAgICAgICAgICAgICAgIHZhciBjbGVhck5vdGVzRnJvbVN0YWZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoJy5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2JykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIGFsbCBkcm9wcGFibGUgc3RhZmYgbGluZXMuXG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyRHJvcHBhYmxlU3RhZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZmluZCgnLm9wcGlhLW11c2ljLWlucHV0LXN0YWZmIGRpdicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBhbiBPYmplY3QgY29udGFpbmluZyB0aGUgYmFzZU5vdGVNaWRpVmFsdWVzICg4MSwgNzksIDc3Li4uKVxuICAgICAgICAgICAgICAgIC8vIGFzIGtleXMgYW5kIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIHN0YWZmIGxpbmVzIGFzIHZhbHVlcy5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0U3RhZmZMaW5lUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhZmZMaW5lUG9zaXRpb25zQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWZmTGluZVBvc2l0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoJy5vcHBpYS1tdXNpYy1pbnB1dC1zdGFmZiBkaXYub3BwaWEtbXVzaWMtc3RhZmYtcG9zaXRpb24nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWZmTGluZVBvc2l0aW9uc0FycmF5LnB1c2goJCh0aGlzKS5wb3NpdGlvbigpLnRvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWZmTGluZVBvc2l0aW9uc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFmZkxpbmVQb3NpdGlvbnNbdmVydGljYWxHcmlkS2V5c1tpXV0gPSAoc3RhZmZMaW5lUG9zaXRpb25zQXJyYXlbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFmZkxpbmVQb3NpdGlvbnM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIHRoZSBub3RlcyBhbmQgaGVscGVyLWNsb25lIG5vdGVzIGZvciB0aGUgbm90ZUNob2ljZXMgZGl2LlxuICAgICAgICAgICAgICAgIHZhciBpbml0UGFsZXR0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGVDaG9pY2VzRGl2ID0gZWxlbWVudC5maW5kKCcub3BwaWEtbXVzaWMtaW5wdXQtbm90ZS1jaG9pY2VzJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZE5vdGVBcmVhID0gZWxlbWVudC5maW5kKCcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTk9URV9UWVBFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdvcHBpYS1tdXNpYy1pbnB1dC1uYXR1cmFsLW5vdGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyRGl2ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKCdub3RlVHlwZScsIE5PVEVfVFlQRVNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGZ1bmN0aW9uIChpbmRleCwgY3VycmVudENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZENsYXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKCdub3RlVHlwZScpID09PSBOT1RFX1RZUEVfTkFUVVJBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENsYXNzID0gJ29wcGlhLW11c2ljLWlucHV0LW5hdHVyYWwtbm90ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ29wcGlhLW11c2ljLWlucHV0LW5hdHVyYWwtbm90ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkZWRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmludGVyYWN0aW9uSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckRpdi5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwcyBub3RlIGZyb20gYmVpbmcgcGxhY2VkIG9uIHRvcCBvZiB0aGUgY2xlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6IHZhbGlkTm90ZUFyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXI6ICdjbG9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAnLm9wcGlhLW11c2ljLWlucHV0LW5vdGUtY2hvaWNlcyBkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkOiBbc2NvcGUuSE9SSVpPTlRBTF9HUklEX1NQQUNJTkcsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoZXZ0LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Nsb25lT2ZmU3RhZmYoJCh1aS5oZWxwZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgdGhlIGhlbHBlciBjbG9uZSBhIG5ldyBkcmFnZ2FibGUgbm90ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVscGVyQ2xvbmUgPSAkKHVpLmhlbHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0YWlucyBvcmlnaW5hbCBub3RlIHR5cGUgKGUuZy4gbmF0dXJhbCwgZmxhdCwgc2hhcnApLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSgnbm90ZVR5cGUnLCAkKHRoaXMpLmRhdGEoJ25vdGVUeXBlJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGVmdFBvc0JlZm9yZURyYWcgaGVscHMgd2l0aCB0aGUgc29ydGluZyBvZiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdsZWZ0UG9zQmVmb3JlRHJhZycsICQodGhpcykucG9zaXRpb24oKS5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6ICcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQ6IFtzY29wZS5IT1JJWk9OVEFMX0dSSURfU1BBQ0lORywgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3BzIGhlbHBlciBjbG9uZSBmcm9tIGJlaW5nIGNsb25lZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyOiAnb3JpZ2luYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogJy5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhbmNlOiAnaW50ZXJzZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ2dhYmxlT3B0aW9ucyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3RlIGlzIG91dCBvZiBkcm9wcGFibGUgb3Igb2ZmIHN0YWZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2xvbmVPZmZTdGFmZihkcmFnZ2FibGVPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl9yZW1vdmVOb3Rlc0Zyb21Ob3RlU2VxdWVuY2VXaXRoSWQoZHJhZ2dhYmxlT3B0aW9ucy5kYXRhKCdub3RlSWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuX3NvcnROb3RlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGVPcHRpb25zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVDaG9pY2VzRGl2LmFwcGVuZChpbm5lckRpdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByZXBhaW50Tm90ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3RlQ2hvaWNlc0RpdiA9IGVsZW1lbnQuZmluZCgnLm9wcGlhLW11c2ljLWlucHV0LW5vdGUtY2hvaWNlcycpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlLm5vdGVTZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyRGl2ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKCdub3RlVHlwZScsIE5PVEVfVFlQRV9OQVRVUkFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKCdub3RlSWQnLCBzY29wZS5ub3RlU2VxdWVuY2VbaV0ubm90ZS5ub3RlSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdvcHBpYS1tdXNpYy1pbnB1dC1uYXR1cmFsLW5vdGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnb3BwaWEtbXVzaWMtaW5wdXQtb24tc3RhZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIG5vdGVzIGhvcml6b250YWxseSBieSB0aGVpciBub3RlU3RhcnQgcG9zaXRpb25zIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsbHkgYnkgdGhlIG1pZGkgdmFsdWUgdGhleSBob2xkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZ2V0VmVydGljYWxQb3NpdGlvbihzY29wZS5ub3RlU2VxdWVuY2VbaV0ubm90ZS5iYXNlTm90ZU1pZGlOdW1iZXIpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuVkVSVElDQUxfR1JJRF9TUEFDSU5HIC8gMi4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGdldEhvcml6b250YWxQb3NpdGlvbihnZXROb3RlU3RhcnRBc0Zsb2F0KHNjb3BlLm5vdGVTZXF1ZW5jZVtpXS5ub3RlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmludGVyYWN0aW9uSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckRpdi5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwcyBub3RlIGZyb20gYmVpbmcgcGxhY2VkIG9uIHRvcCBvZiB0aGUgY2xlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6ICcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAnLm9wcGlhLW11c2ljLWlucHV0LW5vdGUtY2hvaWNlcyBkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkOiBbc2NvcGUuSE9SSVpPTlRBTF9HUklEX1NQQUNJTkcsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdsZWZ0UG9zQmVmb3JlRHJhZycsICQodGhpcykucG9zaXRpb24oKS5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ2dhYmxlT3B0aW9ucyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3RlIGlzIG91dCBvZiBkcm9wcGFibGUgb3Igb2ZmIHN0YWZmLCByZW1vdmUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDbG9uZU9mZlN0YWZmKGRyYWdnYWJsZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuX3JlbW92ZU5vdGVzRnJvbU5vdGVTZXF1ZW5jZVdpdGhJZChkcmFnZ2FibGVPcHRpb25zLmRhdGEoJ25vdGVJZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5fc29ydE5vdGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZU9wdGlvbnMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVDaG9pY2VzRGl2LmFwcGVuZChpbm5lckRpdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwYWludExlZGdlckxpbmVzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGEgc3RhZmYgb2YgZHJvcHBhYmxlIGxpbmVzLlxuICAgICAgICAgICAgICAgIHZhciBidWlsZERyb3BwYWJsZVN0YWZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVZhbHVlcyA9IE9iamVjdC5rZXlzKE5PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFmZkxpbmVEaXYgPSAkKCc8ZGl2PjwvZGl2PicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdvcHBpYS1tdXNpYy1zdGFmZi1wb3NpdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnaGVpZ2h0Jywgc2NvcGUuVkVSVElDQUxfR1JJRF9TUEFDSU5HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKCdsaW5lVmFsdWUnLCBsaW5lVmFsdWVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kcm9wcGFibGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDogJy5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVyIGFuZCBvdXQgYXJlIHVzZWQgdG8gcmVtb3ZlIGhlbHBlciBjbG9uZSBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGUgaXMgbm90IHBsYWNlZCBvbiBzdGFmZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyOiBmdW5jdGlvbiAoZXZ0LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVZhbHVlID0gJChldnQudGFyZ2V0KS5kYXRhKCdsaW5lVmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHJhd3MgYSBsZWRnZXItbGluZSB3aGVuIG5vdGUgaXMgaG92ZXJpbmcgb3ZlciBzdGFmZi1saW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWRnZXJMaW5lTm90ZShsaW5lVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiBvZiBjdXJyZW50IGRyb3BwZWQgbm90ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0UG9zID0gdWkuaGVscGVyLnBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BQb3MgPSAkKGV2dC50YXJnZXQpLnBvc2l0aW9uKCkudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGVJZCA9ICQodWkuaGVscGVyKS5kYXRhKCdub3RlSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVJZCA9IHNjb3BlLmdlbmVyYXRlTm90ZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh1aS5oZWxwZXIpLmRhdGEoJ25vdGVJZCcsIG5vdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3TGVkZ2VyTGluZSh0b3BQb3MsIGxlZnRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhIGxlZGdlciBsaW5lIHdoZW4gbm90ZSBpcyBkcmFnZ2VkIG91dCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5vcHBpYS1tdXNpYy1pbnB1dC1sZWRnZXItbGluZScpLmxhc3QoKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiAnb3BwaWEtbXVzaWMtaW5wdXQtaG92ZXJlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlcyBub3RlIGRyb3BzIGFuZCBhcHBlbmRzIG5ldyBub3RlIHRvIG5vdGVTZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wOiBmdW5jdGlvbiAoZXZ0LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlcyBoZWxwZXIgY2xvbmUgbm90IGRpc2FwcGVhciB3aGVuIGRyb3BwZWQgb24gc3RhZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5vcHBpYS1tdXNpYy1pbnB1dC1sZWRnZXItbGluZScpLmxhc3QoKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIHBvc2l0aW9uIG9mIG5vdGUgb3IgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSAkKHVpLmhlbHBlcikuZGF0YSgnbGVmdFBvc0JlZm9yZURyYWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gb2YgY3VycmVudCBkcm9wcGVkIG5vdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0UG9zID0gdWkuaGVscGVyLnBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRQb3NCZWZvcmVNb3ZlID0gbGVmdFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFBvcyA9ICQoZXZ0LnRhcmdldCkucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdGFmZiBsaW5lJ3MgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lVmFsdWUgPSAkKHRoaXMpLmRhdGEoJ2xpbmVWYWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90ZVR5cGUgPSB1aS5kcmFnZ2FibGUuZGF0YSgnbm90ZVR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBub3RlIHRoYXQgaXMgZHJhZ2dlZCBmcm9tIG5vdGVDaG9pY2VzIGJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYW4gdW5kZWZpbmVkIG5vdGVJZC4gVGhpcyBzZXRzIHRoZSBpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgbm90ZSBoYXMgYW4gaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RlSWQgPSAkKHVpLmhlbHBlcikuZGF0YSgnbm90ZUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZUlkID0gc2NvcGUuZ2VuZXJhdGVOb3RlSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodWkuaGVscGVyKS5kYXRhKCdub3RlSWQnLCBub3RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgYSBub3RlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlTm90ZU1pZGlOdW1iZXI6IE5PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVNbbGluZVZhbHVlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogcGFyc2VJbnQobm90ZVR5cGUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVJZDogbm90ZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZVN0YXJ0OiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBub3RlIGlzIG1vdmVkLCBpdHMgcHJldmlvdXMgc3RhdGUgbXVzdCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG5vdGVTZXF1ZW5jZS4gT3RoZXJ3aXNlLCB0aGUgc2VxdWVuY2Ugd291bGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb25lb3VzbHkgaG9sZCBub3RlcyB0aGF0IGhhdmUgYmVlbiBtb3ZlZCB0byBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMuIEFsc28gdGhpcyBhbGxvd3MgYW4gb24tc3RhZmYgbm90ZSdzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGZyZWVkIHVwIGlmIGl0IGlzIG1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5fcmVtb3ZlTm90ZXNGcm9tTm90ZVNlcXVlbmNlV2l0aElkKG5vdGUubm90ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZXMgc3VyZSB0aGF0IGEgbm90ZSBjYW4gbW92ZSB2ZXJ0aWNhbGx5IG9uIGl0J3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFBvcyAhPT0gbGVmdFBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZXMgdGhlIG5vdGUgdG8gdGhlIG5leHQgYXZhaWxhYmxlIHNwb3Qgb24gdGhlIHN0YWZmLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YWZmIGlzIGZ1bGwsIG5vdGUgaXMgbW92ZWQgb2ZmIHN0YWZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRodXMgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGVja0lmTm90ZVBvc2l0aW9uVGFrZW4obGVmdFBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UG9zICs9IHNjb3BlLkhPUklaT05UQUxfR1JJRF9TUEFDSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh1aS5oZWxwZXIpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3BQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdFBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5mbG9vcihsZWZ0UG9zKSA+IE1hdGguZmxvb3IoZ2V0SG9yaXpvbnRhbFBvc2l0aW9uKE1BWElNVU1fTk9URVNfUE9TU0lCTEUgLSAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHVpLmhlbHBlcikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwYWludExlZGdlckxpbmVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdHMgbm90ZSBzbyBpdCBpcyByaWdodCBvbiB0b3Agb2YgdGhlIHN0YWZmIGxpbmUgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRpbmcgaGFsZiBvZiB0aGUgVkVSVElDQUxfR1JJRF9TUEFDSU5HIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdGluZyB0aGF0IGZyb20gaXRzIGN1cnJlbnQgdG9wIFBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHVpLmhlbHBlcikuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdG9wUG9zIC0gKHNjb3BlLlZFUlRJQ0FMX0dSSURfU1BBQ0lORyAvIDIuMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBub3RlU3RhcnQgcHJvcGVydHkgdG8gbm90ZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXROb3RlU3RhcnRGcm9tTGVmdFBvcyhsZWZ0UG9zKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RlLm5vdGVTdGFydCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Tm90ZVN0YXJ0RnJvbUxlZnRQb3MobGVmdFBvcykubm90ZS5ub3RlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBhaW50TGVkZ2VyTGluZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5fYWRkTm90ZVRvTm90ZVNlcXVlbmNlKG5vdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5fc29ydE5vdGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3VuZHMgdGhlIG5vdGUgd2hlbiBpdCBpcyBkcm9wcGVkIG9udG8gc3RhZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlTZXF1ZW5jZShbW19jb252ZXJ0Tm90ZVRvTWlkaVBpdGNoKG5vdGUpXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHVpLmhlbHBlcikuYWRkQ2xhc3MoJ29wcGlhLW11c2ljLWlucHV0LW9uLXN0YWZmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGFpbnRMZWRnZXJMaW5lcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5maW5kKCcub3BwaWEtbXVzaWMtaW5wdXQtc3RhZmYnKS5hcHBlbmQoc3RhZmZMaW5lRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudG9wUG9zaXRpb25Gb3JDZW50ZXJPZlRvcFN0YWZmTGluZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc3RhZmZMaW5lRGl2KS5wb3NpdGlvbigpLnRvcCArIHNjb3BlLlZFUlRJQ0FMX0dSSURfU1BBQ0lORztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RlTmFtZSA9IGxpbmVWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBub3RlTmFtZSBpcyBhIHZhbGlkIHN0YWZmIGxpbmUgYW5kIGlmIHNvLCBwYWludCBzdGFmZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOT1RFU19PTl9MSU5FUy5pbmRleE9mKG5vdGVOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFmZkxpbmVEaXYuYXBwZW5kKCQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb25zIGFuZCBjZW50ZXJzIHRoZSBzdGFmZiBsaW5lIGRpcmVjdGx5IG9uIHRvcCBvZiBpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBkcm9wcGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi10b3AnLCBzY29wZS5WRVJUSUNBTF9HUklEX1NQQUNJTkcgLyAyLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnb3BwaWEtbXVzaWMtc3RhZmYtbGluZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBjb21wYXJlTm90ZVN0YXJ0cyhhLCBiKSByZXR1cm5zIGxlc3MgdGhhbiAwLCBhIGlzIGxlc3MgdGhhbiBiLlxuICAgICAgICAgICAgICAgIC8vIFdoZW4gY29tcGFyZU5vdGVTdGFydHMoYSwgYikgcmV0dXJucyAwLCBhIGlzIGVxdWFsIHRvIGIuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBjb21wYXJlTm90ZVN0YXJ0cyhhLCBiKSByZXR1cm5zIGdyZWF0ZXIgdGhhbiAwLCBhIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgICAgICAvLyAgIHRoYW4gYi5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZU5vdGVTdGFydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5ub3RlLm5vdGVTdGFydCAmJiBiLm5vdGUubm90ZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEubm90ZS5ub3RlU3RhcnQubnVtICogYi5ub3RlLm5vdGVTdGFydC5kZW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEubm90ZS5ub3RlU3RhcnQuZGVuICogYi5ub3RlLm5vdGVTdGFydC5udW0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYS5ub3RlLm5vdGVTdGFydC5kZW4gKiBiLm5vdGUubm90ZVN0YXJ0LmRlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbm90ZSBwb3NpdGlvbiBpcyB0YWtlbiwgcmV0dXJuIHRydWUsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBwb3NpdGlvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tJZk5vdGVQb3NpdGlvblRha2VuID0gZnVuY3Rpb24gKGxlZnRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldE5vdGVTdGFydEZyb21MZWZ0UG9zKGxlZnRQb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm90ZVRvQ2hlY2sgPSBnZXROb3RlU3RhcnRGcm9tTGVmdFBvcyhsZWZ0UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdOb3RlVG9DaGVjay5ub3RlLm5vdGVTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29wZS5ub3RlU2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGVDb21wYXJpc29uID0gY29tcGFyZU5vdGVTdGFydHMoc2NvcGUubm90ZVNlcXVlbmNlW2ldLCBuZXdOb3RlVG9DaGVjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RlQ29tcGFyaXNvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnRzIGEgbm90ZSdzIGxlZnRQb3NpdGlvbiB0byBhIG5vdGVTdGFydCBvYmplY3QgYnkgY2hlY2tpbmcgaWZcbiAgICAgICAgICAgICAgICAvLyBsZWZ0UG9zIGlzIGNsb3NlIHRvIGF2YWlsYWJsZSBob3Jpem9udGFsIGdyaWQgcG9zaXRpb24uIElmIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgY2xvc2UgbWF0Y2gsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgdmFyIGdldE5vdGVTdGFydEZyb21MZWZ0UG9zID0gZnVuY3Rpb24gKGxlZnRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhJTVVNX05PVEVTX1BPU1NJQkxFOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbGVmdFBvcyBhbmQgYSBob3Jpem9udGFsR3JpZCBQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGFuIDIsIHRoZW4gdGhleSBhcmUgY2xvc2UgZW5vdWdoIHRvIHNldCBhIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyBzb21lIHdpZ2dsZSByb29tIGZvciByb3VuZGluZyBkaWZmZXJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsZWZ0UG9zIC0gZ2V0SG9yaXpvbnRhbFBvc2l0aW9uKGkpKSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZVN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW06IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW46IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogbm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXROb3RlU3RhcnRBc0Zsb2F0ID0gZnVuY3Rpb24gKG5vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdGUubm90ZVN0YXJ0Lm51bSAvIG5vdGUubm90ZVN0YXJ0LmRlbjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIG5vdGVTZXF1ZW5jZSB2YWx1ZXMgYW5kIHJlbW92ZSBhbGwgbm90ZXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgTGVkZ2VyIExpbmVzIGZyb20gdGhlIHN0YWZmLlxuICAgICAgICAgICAgICAgIHNjb3BlLmNsZWFyU2VxdWVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5vdGVTZXF1ZW5jZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoJy5vcHBpYS1tdXNpYy1pbnB1dC1vbi1zdGFmZicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZpbmQoJy5vcHBpYS1tdXNpYy1pbnB1dC1sZWRnZXItbGluZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydHMgdGhlIG1pZGlWYWx1ZSBvZiBhIGRyb3BwYWJsZSBsaW5lIHRoYXQgYSBub3RlIGlzIG9uXG4gICAgICAgICAgICAgICAgLy8gaW50byBhIHRvcCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0VmVydGljYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChiYXNlTm90ZU1pZGlOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0YWZmTGluZVBvc2l0aW9ucygpW2Jhc2VOb3RlTWlkaU51bWJlcl07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXRzIGEgaG9yaXpvbnRhbCBncmlkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwb3NpdGlvbiBvZiBub3RlLWNob2ljZXNcbiAgICAgICAgICAgICAgICAgKiBkaXYuICcub3BwaWEtbXVzaWMtaW5wdXQtbm90ZS1jaG9pY2VzIGRpdjpmaXJzdC1jaGlsZCcgKHRoZSBub3RlIHRoYXRcbiAgICAgICAgICAgICAgICAgKiBnZXRzIGNsb25lZCB0byBjcmVhdGUgYWxsIG90aGVyIHN1YnNlcXVlbnQgbm90ZXMpIGlzIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICogaG9yaXpvbnRhbCBwb3NpdGlvbiwgc28gdG8gZGV0ZXJtaW5lIHRoZSBvdGhlcnMgdmFsdWVzLCB3ZSBtdWx0aXBseVxuICAgICAgICAgICAgICAgICAqIHRoZSBNQVhJTVVNX05PVEVTX1BPU1NJQkxFIHRoYXQgd2lsbCBmaXQgb24gdGhlIHN0YWZmIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAqIHNjb3BlLkhPUklaT05UQUxfR1JJRF9TUEFDSU5HIGFuZCBzdWJ0cmFjdCB0aGF0IGZyb20gdGhlIGxhc3RcbiAgICAgICAgICAgICAgICAgKiBIb3Jpem9udGFsIFBvc2l0aW9uIHZhbHVlIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgZ2V0SG9yaXpvbnRhbFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vdGVTdGFydEFzRmxvYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RIb3Jpem9udGFsUG9zaXRpb25PZmZzZXQgPSBlbGVtZW50LmZpbmQoJy5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2OmZpcnN0LWNoaWxkJykucG9zaXRpb24oKS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IGxhc3RIb3Jpem9udGFsUG9zaXRpb25PZmZzZXQgLSAoKE1BWElNVU1fTk9URVNfUE9TU0lCTEUgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5IT1JJWk9OVEFMX0dSSURfU1BBQ0lORyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0T2Zmc2V0ICsgKG5vdGVTdGFydEFzRmxvYXQgKiBzY29wZS5IT1JJWk9OVEFMX0dSSURfU1BBQ0lORyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9uZU9mZlN0YWZmID0gZnVuY3Rpb24gKGhlbHBlckNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIShoZWxwZXJDbG9uZS5wb3NpdGlvbigpLnRvcCA+IHNjb3BlLnN0YWZmVG9wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJDbG9uZS5wb3NpdGlvbigpLnRvcCA8IHNjb3BlLnN0YWZmQm90dG9tKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNMZWRnZXJMaW5lTm90ZSA9IGZ1bmN0aW9uIChsaW5lVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExFREdFUl9MSU5FX05PVEVTLmluZGV4T2YobGluZVZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0xlZGdlckxpbmUgPSBmdW5jdGlvbiAodG9wUG9zLCBsZWZ0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWRnZXJMaW5lRGl2ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdvcHBpYS1tdXNpYy1pbnB1dC1sZWRnZXItbGluZSBvcHBpYS1tdXNpYy1pbnB1dC1uYXR1cmFsLW5vdGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRyb3BwYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6ICcub3BwaWEtbXVzaWMtaW5wdXQtbm90ZS1jaG9pY2VzIGRpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgbGVkZ2VyTGluZSBub3RlIGlzIG1vdmVkIG91dCBvZiBpdHMgZHJvcHBhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxlZGdlciBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJDbGFzczogJ29wcGlhLW11c2ljLWlucHV0LWhvdmVyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6ICcub3BwaWEtbXVzaWMtaW5wdXQtdmFsaWQtbm90ZS1hcmVhJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IGxlZGdlciBsaW5lIHRvIGJlIGNlbnRlcmVkIHdpdGggdGhlIG5vdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRQb3MgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMC40IGlzIGEgbGl0dGxlIGxlc3MgdGhhbiBoYWxmIHRvIGFsbG93IGZvciB0aGUgaGVpZ2h0IG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVkZ2VyIGxpbmUgd2hlbiBjb25zaWRlcmluZyBpdHMgcGxhY2VtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3BQb3MgKyBzY29wZS5WRVJUSUNBTF9HUklEX1NQQUNJTkcgKiAwLjRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZmluZCgnLm9wcGlhLW11c2ljLWlucHV0LXN0YWZmJykuYXBwZW5kKGxlZGdlckxpbmVEaXYpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHJlcGFpbnRMZWRnZXJMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29wZS5ub3RlU2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RlID0gc2NvcGUubm90ZVNlcXVlbmNlW2ldLm5vdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVZhbHVlID0gX2dldENvcnJlc3BvbmRpbmdOb3RlTmFtZShub3RlLmJhc2VOb3RlTWlkaU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWRnZXJMaW5lTm90ZShsaW5lVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xlZGdlckxpbmUoZ2V0VmVydGljYWxQb3NpdGlvbihub3RlLmJhc2VOb3RlTWlkaU51bWJlciksIGdldEhvcml6b250YWxQb3NpdGlvbihnZXROb3RlU3RhcnRBc0Zsb2F0KG5vdGUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q29ycmVzcG9uZGluZ05vdGVOYW1lID0gZnVuY3Rpb24gKG1pZGlOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdOb3RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5vdGVOYW1lIGluIE5PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOT1RFX05BTUVTX1RPX01JRElfVkFMVUVTW25vdGVOYW1lXSA9PT0gbWlkaU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmdOb3RlTmFtZSA9IG5vdGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZXNwb25kaW5nTm90ZU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgTUlESSBwaXRjaDogJyArIG1pZGlOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JyZXNwb25kaW5nTm90ZU5hbWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBub3RlIG9iamVjdCB3aXRoIGEgcmVhZGFibGUgbm90ZSBuYW1lLCBzdWNoIGFzIEViNSwgQTUgb3JcbiAgICAgICAgICAgICAgICAgKiBGIzQsIGdpdmVuIGEgbm90ZSBvYmplY3Qgd2l0aCBiYXNlTm90ZU1pZGlOdW1iZXIgYW5kIHNoYXJwL2ZsYXRcbiAgICAgICAgICAgICAgICAgKiBvZmZzZXQgcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIG5vdGUuYmFzZU5vdGVNaWRpTnVtYmVyID0gNjQgYW5kXG4gICAgICAgICAgICAgICAgICogbm90ZS5vZmZzZXQgPSAtMSwgdGhpcyB3aWxsIHJldHVybiB7J3JlYWRhYmxlTm90ZU5hbWUnOiAnRWI0J31cbiAgICAgICAgICAgICAgICAgKiAoc2luY2UgNjQgaXMgdGhlIGJhc2VOb3RlTWlkaU51bWJlciBmb3IgJ0UnLCBhbmQgLTEgaW5kaWNhdGVzIGFcbiAgICAgICAgICAgICAgICAgKiBmbGF0KS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgX2NvbnZlcnROb3RlVG9SZWFkYWJsZU5vdGUgPSBmdW5jdGlvbiAobm90ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90ZS5vZmZzZXQgIT09IC0xICYmIG5vdGUub2Zmc2V0ICE9PSAwICYmIG5vdGUub2Zmc2V0ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIG5vdGUgb2Zmc2V0OiAnICsgbm90ZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZXNwb25kaW5nTm90ZU5hbWUgPSBfZ2V0Q29ycmVzcG9uZGluZ05vdGVOYW1lKG5vdGUuYmFzZU5vdGVNaWRpTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY2lkZW50YWwgPSAobm90ZS5vZmZzZXQgPT09IDEgPyAnIycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZS5vZmZzZXQgPT09IDAgPyAnJyA6ICdiJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZU5vdGVOYW1lOiBjb3JyZXNwb25kaW5nTm90ZU5hbWVbMF0gKyBhY2NpZGVudGFsICsgY29ycmVzcG9uZGluZ05vdGVOYW1lWzFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBub3RlIG9iamVjdCB3aXRoIGEgYmFzZU5vdGVNaWRpTnVtYmVyIGFuZCBhblxuICAgICAgICAgICAgICAgICAqIG9mZnNldCBwcm9wZXJ0eSwgZ2l2ZW4gYSBub3RlIG9iamVjdCB3aXRoIGEgcmVhZGFibGVOb3RlTmFtZVxuICAgICAgICAgICAgICAgICAqIHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgaWYgbm90ZS5yZWFkYWJsZU5vdGVOYW1lID0gJ0ViNCcgdGhpcyB3aWxsXG4gICAgICAgICAgICAgICAgICogcmV0dXJuIHsnYmFzZU5vdGVNaWRpTnVtYmVyJzogNjQsICdvZmZzZXQnOiAtMX0gKHNpbmNlIDY0IGlzIHRoZVxuICAgICAgICAgICAgICAgICAqIGJhc2VOb3RlTWlkaU51bWJlciBmb3IgJ0UnLCBhbmQgLTEgaW5kaWNhdGVzIGEgZmxhdCkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIF9jb252ZXJ0UmVhZGFibGVOb3RlVG9Ob3RlID0gZnVuY3Rpb24gKHJlYWRhYmxlTm90ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGFibGVOb3RlTmFtZSA9IHJlYWRhYmxlTm90ZS5yZWFkYWJsZU5vdGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGFibGVOb3RlTmFtZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuYXR1cmFsIG5vdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VOb3RlTWlkaU51bWJlcjogTk9URV9OQU1FU19UT19NSURJX1ZBTFVFU1tyZWFkYWJsZU5vdGVOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZGFibGVOb3RlTmFtZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBub3RlIHdpdGggYW4gYWNjaWRlbnRhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAocmVhZGFibGVOb3RlTmFtZVsxXSA9PT0gJyMnKSA/IDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWFkYWJsZU5vdGVOYW1lWzFdID09PSAnYicpID8gLTEgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgcmVhZGFibGUgbm90ZTogJyArIHJlYWRhYmxlTm90ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlTm90ZU1pZGlOdW1iZXI6IE5PVEVfTkFNRVNfVE9fTUlESV9WQUxVRVNbcmVhZGFibGVOb3RlTmFtZVswXSArIHJlYWRhYmxlTm90ZU5hbWVbMl1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB2YWxpZCByZWFkYWJsZU5vdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHJlYWRhYmxlIG5vdGU6ICcgKyByZWFkYWJsZU5vdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBub3RlIGluIGEgc2VxdWVuY2UsIGFkZCBhIG5vdGVEdXJhdGlvbiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKHdhZ25lcmRtaWtlKTogLSBhZGQgbW9yZSBvcHRpb25zIGZvciBub3RlIGR1cmF0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgX21ha2VBbGxOb3Rlc0hhdmVEdXJhdGlvbk9uZSA9IGZ1bmN0aW9uIChub3RlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVBcnJheVtpXS5ub3RlRHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbjogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm90ZUFycmF5O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGUuc3VibWl0QW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGFibGVTZXF1ZW5jZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlLm5vdGVTZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTZXF1ZW5jZS5wdXNoKF9jb252ZXJ0Tm90ZVRvUmVhZGFibGVOb3RlKHNjb3BlLm5vdGVTZXF1ZW5jZVtpXS5ub3RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTZXF1ZW5jZSA9IF9tYWtlQWxsTm90ZXNIYXZlRHVyYXRpb25PbmUocmVhZGFibGVTZXF1ZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQocmVhZGFibGVTZXF1ZW5jZSwgTXVzaWNOb3Rlc0lucHV0UnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oc2NvcGUuc3VibWl0QW5zd2VyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbnMgaW52b2x2aW5nIE1JREkgcGxheWJhY2suXG4gICAgICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgICAgICBzY29wZS5wbGF5U2VxdWVuY2VUb0d1ZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm90ZVNlcXVlbmNlVG9HdWVzcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlLnNlcXVlbmNlVG9HdWVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZVNlcXVlbmNlVG9HdWVzcy5wdXNoKF9jb252ZXJ0UmVhZGFibGVOb3RlVG9Ob3RlKHNjb3BlLnNlcXVlbmNlVG9HdWVzc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBsYXlTZXF1ZW5jZShjb252ZXJ0U2VxdWVuY2VUb0d1ZXNzVG9NaWRpU2VxdWVuY2Uobm90ZVNlcXVlbmNlVG9HdWVzcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGUucGxheUN1cnJlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheVNlcXVlbmNlKGNvbnZlcnROb3RlU2VxdWVuY2VUb01pZGlTZXF1ZW5jZShzY29wZS5ub3RlU2VxdWVuY2UpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRha2VzIGFuIGlucHV0ID4gMCwgY29udmVydHMgdG8gYSBub3RlU3RhcnQgb2JqZWN0IGFuZCByZXR1cm5zIGFcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm90ZVN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBnZXROb3RlU3RhcnQgPSBmdW5jdGlvbiAobm90ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROb3RlU3RhcnRBc0Zsb2F0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVTdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bTogbm90ZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbjogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElucHV0IGlzIGEgbWlkaVNlcXVlbmNlLCB3aGljaCBpcyBhbiBhcnJheSBvZiBhcnJheXMsIGluIHRoZSBmb3JtIG9mXG4gICAgICAgICAgICAgICAgLy8gW1s3Ml0sIFs2Ml0sIFs2NywgNzEsIDc0XV0uIEFuIGlubmVyIGFycmF5IHdpdGggbW9yZSB0aGFuIG9uZSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIGlzIHRyZWF0ZWQgbGlrZSBhIGNob3JkIGFuZCBhbGwgaXRzIHZhbHVlcyBhcmUgcGxheWVkIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBzaW11bHRhbmVvdXNseS5cbiAgICAgICAgICAgICAgICB2YXIgcGxheVNlcXVlbmNlID0gZnVuY3Rpb24gKG1pZGlTZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm90ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWRpU2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlkaVNlcXVlbmNlW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZGlWYWx1ZTogbWlkaVNlcXVlbmNlW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZ2V0Tm90ZVN0YXJ0KGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgTXVzaWNQaHJhc2VQbGF5ZXJTZXJ2aWNlLnBsYXlNdXNpY1BocmFzZShub3Rlcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBBIE1JREkgcGl0Y2ggaXMgdGhlIGJhc2VOb3RlTWlkaU51bWJlciBvZiB0aGUgbm90ZSBwbHVzIHRoZSBvZmZzZXQuXG4gICAgICAgICAgICAgICAgdmFyIF9jb252ZXJ0Tm90ZVRvTWlkaVBpdGNoID0gZnVuY3Rpb24gKG5vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdGUuYmFzZU5vdGVNaWRpTnVtYmVyICsgbm90ZS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIE1JREkgdmFsdWUgZm9yIGVhY2ggbm90ZSBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyh3YWduZXJkbWlrZSk6IC0gYWRkIGNob3JkIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRTZXF1ZW5jZVRvR3Vlc3NUb01pZGlTZXF1ZW5jZSA9IGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkaVNlcXVlbmNlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZVtpXS5oYXNPd25Qcm9wZXJ0eSgnYmFzZU5vdGVNaWRpTnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRpU2VxdWVuY2UucHVzaChbX2NvbnZlcnROb3RlVG9NaWRpUGl0Y2goc2VxdWVuY2VbaV0pXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIG5vdGU6ICcgKyBzZXF1ZW5jZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZGlTZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgTUlESSB2YWx1ZSBmb3IgZWFjaCBub3RlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKHdhZ25lcmRtaWtlKTogLSBhZGQgY2hvcmQgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICAgICAgICB2YXIgY29udmVydE5vdGVTZXF1ZW5jZVRvTWlkaVNlcXVlbmNlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRpU2VxdWVuY2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlW2ldLmhhc093blByb3BlcnR5KCdub3RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgbm90ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRpU2VxdWVuY2UucHVzaChbX2NvbnZlcnROb3RlVG9NaWRpUGl0Y2goc2VxdWVuY2VbaV0ubm90ZSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgbm90ZTogJyArIHNlcXVlbmNlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWlkaVNlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gY29kZS5cbiAgICAgICAgICAgICAgICBpbml0aWFsaXplTm90ZVNlcXVlbmNlKHNjb3BlLmluaXRpYWxTZXF1ZW5jZSk7XG4gICAgICAgICAgICAgICAgc2NvcGUuaW5pdCgpO1xuICAgICAgICAgICAgICAgIC8vIFNldHMgZ3JpZCBwb3NpdGlvbnMsIGRpc3BsYXlzIHRoZSBzdGFmZiBhbmQgbm90ZSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBpbml0aWFsaXplcyB0aGUgdmlldyBhZnRlciBzdGFmZiBoYXMgbG9hZGVkLlxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVpbml0U3RhZmYoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlcyBmb3IgdGhlIE11c2ljTm90ZXNJbnB1dCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVJlc3BvbnNlTXVzaWNOb3Rlc0lucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ211c2ljLW5vdGVzLWlucHV0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2Fuc3dlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX25vdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2Fuc3dlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hbnN3ZXJbaV0ucmVhZGFibGVOb3RlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ub3Rlcy5wdXNoKF9hbnN3ZXJbaV0ucmVhZGFibGVOb3RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9ub3Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRpc3BsYXllZEFuc3dlciA9IF9ub3Rlcy5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5kaXNwbGF5ZWRBbnN3ZXIgPSAnTm8gYW5zd2VyIGdpdmVuLic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmVzIGZvciB0aGUgTXVzaWNOb3Rlc0lucHV0IHNob3J0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZU11c2ljTm90ZXNJbnB1dCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL011c2ljTm90ZXNJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdtdXNpYy1ub3Rlcy1pbnB1dC1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9ub3RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9hbnN3ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYW5zd2VyW2ldLnJlYWRhYmxlTm90ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbm90ZXMucHVzaChfYW5zd2VyW2ldLnJlYWRhYmxlTm90ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfbm90ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5kaXNwbGF5ZWRBbnN3ZXIgPSBfbm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZGlzcGxheWVkQW5zd2VyID0gJ05vIGFuc3dlciBnaXZlbi4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL211c2ljX25vdGVzX2lucHV0LmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9tdXNpY19ub3Rlc19pbnB1dC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL211c2ljX25vdGVzX2lucHV0LmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIE51bWJlcldpdGhVbml0cyBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9kaXJlY3RpdmVzLycgK1xuICAgICdudW1iZXItd2l0aC11bml0cy1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTnVtYmVyV2l0aFVuaXRzL2RpcmVjdGl2ZXMvJyArXG4gICAgJ251bWJlci13aXRoLXVuaXRzLXZhbGlkYXRpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1udW1iZXItd2l0aC11bml0cy5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtbnVtYmVyLXdpdGgtdW5pdHMuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTnVtYmVyV2l0aFVuaXRzL2RpcmVjdGl2ZXMvJyArXG4gICAgJ29wcGlhLXNob3J0LXJlc3BvbnNlLW51bWJlci13aXRoLXVuaXRzLmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbi8vIFRPRE8oIzc0MDMpOiBDb252ZXJ0IHRoaXMgdG8gcGFydGlhbCBpbXBvcnRzLlxudmFyIG1hdGhqc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtYXRoanNcIikpO1xucmVxdWlyZSgnZG9tYWluL29iamVjdHMvRnJhY3Rpb25PYmplY3RGYWN0b3J5LnRzJyk7XG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9OdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LnRzJyk7XG4vLyBSdWxlcyBzZXJ2aWNlIGZvciBudW1iZXIgd2l0aCB1bml0cyBpbnRlcmFjdGlvbi5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ051bWJlcldpdGhVbml0c1J1bGVzU2VydmljZScsIFtcbiAgICAnTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeScsXG4gICAgZnVuY3Rpb24gKE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuY3JlYXRlQ3VycmVuY3lVbml0cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzaW5nRXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSXNFcXVhbFRvOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHRydWUgb25seSBpZiBpbnB1dCBpcyBleGFjdGx5IGVxdWFsIHRvIGFuc3dlci5cbiAgICAgICAgICAgICAgICBhbnN3ZXIgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21EaWN0KGFuc3dlcik7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tRGljdChpbnB1dHMuZik7XG4gICAgICAgICAgICAgICAgdmFyIGFuc3dlclN0cmluZyA9IGFuc3dlci50b01hdGhqc0NvbXBhdGlibGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzU3RyaW5nID0gaW5wdXRzLnRvTWF0aGpzQ29tcGF0aWJsZVN0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBhbnN3ZXJMaXN0ID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tUmF3SW5wdXRTdHJpbmcoYW5zd2VyU3RyaW5nKS50b0RpY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzTGlzdCA9IE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuZnJvbVJhd0lucHV0U3RyaW5nKGlucHV0c1N0cmluZykudG9EaWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZXF1YWxzKGFuc3dlckxpc3QsIGlucHV0c0xpc3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElzRXF1aXZhbGVudFRvOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBhbnN3ZXIgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21EaWN0KGFuc3dlcik7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tRGljdChpbnB1dHMuZik7XG4gICAgICAgICAgICAgICAgaWYgKGFuc3dlci50eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlci50eXBlID0gJ3JlYWwnO1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXIucmVhbCA9IGFuc3dlci5mcmFjdGlvbi50b0Zsb2F0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMudHlwZSA9ICdyZWFsJztcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnJlYWwgPSBpbnB1dHMuZnJhY3Rpb24udG9GbG9hdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYW5zd2VyU3RyaW5nID0gYW5zd2VyLnRvTWF0aGpzQ29tcGF0aWJsZVN0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNTdHJpbmcgPSBpbnB1dHMudG9NYXRoanNDb21wYXRpYmxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGhqc18xLmRlZmF1bHQudW5pdChhbnN3ZXJTdHJpbmcpLmVxdWFscyhtYXRoanNfMS5kZWZhdWx0LnVuaXQoaW5wdXRzU3RyaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgbnVtYmVyIHdpdGggdW5pdHMgaW50ZXJhY3Rpb24uXG4gKi9cbi8vIFRPRE8oIzc0MDMpOiBDb252ZXJ0IHRoaXMgdG8gcGFydGlhbCBpbXBvcnRzLlxudmFyIG1hdGhqc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtYXRoanNcIikpO1xucmVxdWlyZSgnZG9tYWluL29iamVjdHMvTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL2Jhc2UtaW50ZXJhY3Rpb24tdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdOdW1iZXJXaXRoVW5pdHNWYWxpZGF0aW9uU2VydmljZScsIFtcbiAgICAnTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeScsICdiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZScsXG4gICAgJ1dBUk5JTkdfVFlQRVMnLFxuICAgIGZ1bmN0aW9uIChOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LCBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSwgV0FSTklOR19UWVBFUykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5nczogZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEFsbFdhcm5pbmdzOiBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICAgICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QgPSB3YXJuaW5nc0xpc3QuY29uY2F0KHRoaXMuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyhjdXN0b21pemF0aW9uQXJncykpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuY3JlYXRlQ3VycmVuY3lVbml0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2luZ0Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tFcXVhbGl0eSA9IGZ1bmN0aW9uIChlYXJsaWVyUnVsZSwgbGF0ZXJSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXIgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21EaWN0KGVhcmxpZXJSdWxlLmlucHV0cy5mKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0cyA9IE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuZnJvbURpY3QobGF0ZXJSdWxlLmlucHV0cy5mKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlclN0cmluZyA9IGFuc3dlci50b01hdGhqc0NvbXBhdGlibGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0c1N0cmluZyA9IGlucHV0cy50b01hdGhqc0NvbXBhdGlibGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlckxpc3QgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21SYXdJbnB1dFN0cmluZyhhbnN3ZXJTdHJpbmcpLnRvRGljdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRzTGlzdCA9IE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuZnJvbVJhd0lucHV0U3RyaW5nKGlucHV0c1N0cmluZykudG9EaWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLmVxdWFscyhhbnN3ZXJMaXN0LCBpbnB1dHNMaXN0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0VxdWl2YWxlbmN5ID0gZnVuY3Rpb24gKGVhcmxpZXJSdWxlLCBsYXRlclJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhcmxpZXJJbnB1dCA9IE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuZnJvbURpY3QoZWFybGllclJ1bGUuaW5wdXRzLmYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXJJbnB1dCA9IE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnkuZnJvbURpY3QobGF0ZXJSdWxlLmlucHV0cy5mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhcmxpZXJJbnB1dC50eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJsaWVySW5wdXQudHlwZSA9ICdyZWFsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcmxpZXJJbnB1dC5yZWFsID0gZWFybGllcklucHV0LmZyYWN0aW9uLnRvRmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF0ZXJJbnB1dC50eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlcklucHV0LnR5cGUgPSAncmVhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlcklucHV0LnJlYWwgPSBsYXRlcklucHV0LmZyYWN0aW9uLnRvRmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWFybGllcklucHV0U3RyaW5nID0gZWFybGllcklucHV0LnRvTWF0aGpzQ29tcGF0aWJsZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXJJbnB1dFN0cmluZyA9IGxhdGVySW5wdXQudG9NYXRoanNDb21wYXRpYmxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0aGpzXzEuZGVmYXVsdC51bml0KGxhdGVySW5wdXRTdHJpbmcpLmVxdWFscyhtYXRoanNfMS5kZWZhdWx0LnVuaXQoZWFybGllcklucHV0U3RyaW5nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsSW5mbyA9ICgnXFxubGF0ZXJJbnB1dDogJyArIEpTT04uc3RyaW5naWZ5KGxhdGVySW5wdXQudG9EaWN0KCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuZWFybGllcklucHV0OiAnICsgSlNPTi5zdHJpbmdpZnkoZWFybGllcklucHV0LnRvRGljdCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgKz0gYWRkaXRpb25hbEluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbnN3ZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gYW5zd2VyR3JvdXBzW2ldLnJ1bGVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlckdyb3VwSW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJbmRleDogaiArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByYW5nZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWFybGllclJ1bGUgPSBhbnN3ZXJHcm91cHNbcmFuZ2VzW2tdLmFuc3dlckdyb3VwSW5kZXggLSAxXS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNbcmFuZ2VzW2tdLnJ1bGVJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlYXJsaWVyUnVsZS50eXBlID09PSAnSXNFcXVhbFRvJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnR5cGUgPT09ICdJc0VxdWFsVG8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0VxdWFsaXR5KGVhcmxpZXJSdWxlLCBydWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFdBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdSdWxlICcgKyAoaiArIDEpICsgJyBmcm9tIGFuc3dlciBncm91cCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArICcgd2lsbCBuZXZlciBiZSBtYXRjaGVkIGJlY2F1c2UgaXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcyBtYWRlIHJlZHVuZGFudCBieSBydWxlICcgKyByYW5nZXNba10ucnVsZUluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBmcm9tIGFuc3dlciBncm91cCAnICsgcmFuZ2VzW2tdLmFuc3dlckdyb3VwSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWFybGllclJ1bGUudHlwZSA9PT0gJ0lzRXF1aXZhbGVudFRvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tFcXVpdmFsZW5jeShlYXJsaWVyUnVsZSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUnVsZSAnICsgKGogKyAxKSArICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMSkgKyAnIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZCBiZWNhdXNlIGl0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXMgbWFkZSByZWR1bmRhbnQgYnkgcnVsZSAnICsgcmFuZ2VzW2tdLnJ1bGVJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgZnJvbSBhbnN3ZXIgZ3JvdXAgJyArIHJhbmdlc1trXS5hbnN3ZXJHcm91cEluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0ID0gd2FybmluZ3NMaXN0LmNvbmNhdChiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZS5nZXRBbGxPdXRjb21lV2FybmluZ3MoYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSwgc3RhdGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhcm5pbmdzTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTnVtYmVyV2l0aFVuaXRzIGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9OdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvZGlyZWN0aXZlcy8nICtcbiAgICAnbnVtYmVyLXdpdGgtdW5pdHMtcnVsZXMuc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhSW50ZXJhY3RpdmVOdW1iZXJXaXRoVW5pdHMnLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbnVtYmVyLXdpdGgtdW5pdHMtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRhdHRycycsICckdWliTW9kYWwnLCAnTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeScsXG4gICAgICAgICAgICAgICAgJ051bWJlcldpdGhVbml0c1J1bGVzU2VydmljZScsICdOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUycsXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLCBmdW5jdGlvbiAoJHNjb3BlLCAkYXR0cnMsICR1aWJNb2RhbCwgTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeSwgTnVtYmVyV2l0aFVuaXRzUnVsZXNTZXJ2aWNlLCBOVU1CRVJfV0lUSF9VTklUU19QQVJTSU5HX0VSUk9SUywgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubGFiZWxGb3JGb2N1c1RhcmdldCA9ICRhdHRycy5sYWJlbEZvckZvY3VzVGFyZ2V0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFiZWwgZm9yIGVycm9ycyBjYXVzZWQgd2hpbHN0IHBhcnNpbmcgbnVtYmVyIHdpdGggdW5pdHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBGT1JNX0VSUk9SX1RZUEUgPSAnTlVNQkVSX1dJVEhfVU5JVFNfRk9STUFUX0VSUk9SJztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5OVU1CRVJfV0lUSF9VTklUU19GT1JNX1NDSEVNQSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmljb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpX2NvbmZpZzoge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRXYXJuaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmNyZWF0ZUN1cnJlbmN5VW5pdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2luZ0Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnJGN0cmwuYW5zd2VyJywgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1iZXJXaXRoVW5pdHMgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21SYXdJbnB1dFN0cmluZyhuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5OdW1iZXJXaXRoVW5pdHNGb3JtLmFuc3dlci4kc2V0VmFsaWRpdHkoRk9STV9FUlJPUl9UWVBFLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBwYXJzaW5nRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLk51bWJlcldpdGhVbml0c0Zvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyID0gZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyV2l0aFVuaXRzID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tUmF3SW5wdXRTdHJpbmcoYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLm9uU3VibWl0KG51bWJlcldpdGhVbml0cywgTnVtYmVyV2l0aFVuaXRzUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBwYXJzaW5nRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLk51bWJlcldpdGhVbml0c0Zvcm0uYW5zd2VyLiRzZXRWYWxpZGl0eShGT1JNX0VSUk9SX1RZUEUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pc0Fuc3dlclZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuTnVtYmVyV2l0aFVuaXRzRm9ybSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFjdHJsLk51bWJlcldpdGhVbml0c0Zvcm0uJGludmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0QW5zd2VyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlcihjdHJsLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oc3VibWl0QW5zd2VyRm4sIGN0cmwuaXNBbnN3ZXJWYWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2hvd0hlbHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWwub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyLXdpdGgtdW5pdHMtaGVscC1tb2RhbC5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRzY29wZScsICckdWliTW9kYWxJbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICR1aWJNb2RhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpYk1vZGFsSW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZXN1bHQudGhlbihmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTnVtYmVyV2l0aFVuaXRzIHJlc3BvbnNlLlxuICovXG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9OdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFSZXNwb25zZU51bWJlcldpdGhVbml0cycsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ051bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnknLFxuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnksIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTnVtYmVyV2l0aFVuaXRzL2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ251bWJlci13aXRoLXVuaXRzLXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tRGljdChhbnN3ZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTnVtYmVyV2l0aFVuaXRzIHNob3J0IHJlc3BvbnNlLlxuICovXG5yZXF1aXJlKCdkb21haW4vb2JqZWN0cy9OdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlTnVtYmVyV2l0aFVuaXRzJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeScsXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9OdW1iZXJXaXRoVW5pdHMvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbnVtYmVyLXdpdGgtdW5pdHMtc2hvcnQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21EaWN0KGFuc3dlcikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1aXJlcyBmb3IgTnVtZXJpY0lucHV0IGludGVyYWN0aW9uLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTnVtZXJpY0lucHV0L2RpcmVjdGl2ZXMvbnVtZXJpYy1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTnVtZXJpY0lucHV0L2RpcmVjdGl2ZXMvbnVtZXJpYy1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtaW50ZXJhY3RpdmUtbnVtZXJpYy1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtcmVzcG9uc2UtbnVtZXJpYy1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtc2hvcnQtcmVzcG9uc2UtbnVtZXJpYy1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdOdW1lcmljSW5wdXRSdWxlc1NlcnZpY2UnLCBbZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyID09PSBpbnB1dHMueDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc0xlc3NUaGFuOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyIDwgaW5wdXRzLng7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNHcmVhdGVyVGhhbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlciA+IGlucHV0cy54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElzTGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIgPD0gaW5wdXRzLng7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSXNHcmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlciA+PSBpbnB1dHMueDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc0luY2x1c2l2ZWx5QmV0d2VlbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh3eHkpOiBoYXZlIGZyb250ZW5kIHZhbGlkYXRpb24gYXQgY3JlYXRpb24gdGltZSB0byBjaGVjayB0aGF0XG4gICAgICAgICAgICAgICAgLy8gaW5wdXRzLmEgPD0gaW5wdXRzLmJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyID49IGlucHV0cy5hICYmIGFuc3dlciA8PSBpbnB1dHMuYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc1dpdGhpblRvbGVyYW5jZTogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlciA+PSBpbnB1dHMueCAtIGlucHV0cy50b2wgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyIDw9IGlucHV0cy54ICsgaW5wdXRzLnRvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBWYWxpZGF0b3Igc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG52YXIgc3RhdGljXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvYmFzZS1pbnRlcmFjdGlvbi12YWxpZGF0aW9uLnNlcnZpY2VcIik7XG52YXIgYXBwX2NvbnN0YW50c18xID0gcmVxdWlyZShcImFwcC5jb25zdGFudHNcIik7XG52YXIgTnVtZXJpY0lucHV0VmFsaWRhdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtZXJpY0lucHV0VmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBOdW1lcmljSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VzdG9taXphdGlvbkFyZ3NXYXJuaW5ncyA9IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBOdW1lcmljSW5wdXRWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QWxsV2FybmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICB2YXIgd2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIHdhcm5pbmdzTGlzdCA9IHdhcm5pbmdzTGlzdC5jb25jYXQodGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKSk7XG4gICAgICAgIC8qXG4gICAgICAgIFN0b3JlIGFuIGFuc3dlciByYW5nZSBmb3IgZXZlcnkgcnVsZSwgdGhlbiBjaGVjayBmb3IgcmVkdW5kYW50XG4gICAgICAgIHJhbmdlcy4gQSByYW5nZSBpcyBhbiBvYmplY3Qgb2YgdGhlIGZvcm06XG4gICAgICAgIHtcbiAgICAgICAgICBsYjogZmxvYXQsIGxvd2VyIGJvdW5kXG4gICAgICAgICAgdWI6IGZsb2F0LCB1cHBlciBib3VuZFxuICAgICAgICAgIGxiaTogYm9vbCwgaXMgbG93ZXIgYm91bmQgaW5jbHVzaXZlXG4gICAgICAgICAgdWJpOiBib29sLCBpcyB1cHBlciBib3VuZCBpbmNsdXNpdmVcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB2YXIgc2V0TG93ZXJBbmRVcHBlckJvdW5kcyA9IGZ1bmN0aW9uIChyYW5nZSwgbGIsIHViLCBsYmksIHViaSkge1xuICAgICAgICAgICAgcmFuZ2UubGIgPSBsYjtcbiAgICAgICAgICAgIHJhbmdlLnViID0gdWI7XG4gICAgICAgICAgICByYW5nZS5sYmkgPSBsYmk7XG4gICAgICAgICAgICByYW5nZS51YmkgPSB1Ymk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0VuY2xvc2VkQnkgPSBmdW5jdGlvbiAocmEsIHJiKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgcmFuZ2UgcmEgaXMgZW5jbG9zZWQgYnkgcmFuZ2UgcmIuXG4gICAgICAgICAgICB2YXIgbG93ZXJCb3VuZENvbmRpdGlvbklzU2F0aXNmaWVkID0gKHJiLmxiIDwgcmEubGIpIHx8IChyYi5sYiA9PT0gcmEubGIgJiYgKCFyYS5sYmkgfHwgcmIubGJpKSk7XG4gICAgICAgICAgICB2YXIgdXBwZXJCb3VuZENvbmRpdGlvbklzU2F0aXNmaWVkID0gKHJiLnViID4gcmEudWIpIHx8IChyYi51YiA9PT0gcmEudWIgJiYgKCFyYS51YmkgfHwgcmIudWJpKSk7XG4gICAgICAgICAgICByZXR1cm4gbG93ZXJCb3VuZENvbmRpdGlvbklzU2F0aXNmaWVkICYmXG4gICAgICAgICAgICAgICAgdXBwZXJCb3VuZENvbmRpdGlvbklzU2F0aXNmaWVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5zd2VyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBhbnN3ZXJHcm91cHNbaV0ucnVsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlckdyb3VwSW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICBydWxlSW5kZXg6IGogKyAxLFxuICAgICAgICAgICAgICAgICAgICBsYjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdWI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxiaTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHViaTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJ1bGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFcXVhbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBydWxlLmlucHV0cy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TG93ZXJBbmRVcHBlckJvdW5kcyhyYW5nZSwgeCwgeCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNJbmNsdXNpdmVseUJldHdlZW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBydWxlLmlucHV0cy5hO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBydWxlLmlucHV0cy5iO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TG93ZXJBbmRVcHBlckJvdW5kcyhyYW5nZSwgYSwgYiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNHcmVhdGVyVGhhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJ1bGUuaW5wdXRzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRMb3dlckFuZFVwcGVyQm91bmRzKHJhbmdlLCB4LCBJbmZpbml0eSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdJc0dyZWF0ZXJUaGFuT3JFcXVhbFRvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcnVsZS5pbnB1dHMueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldExvd2VyQW5kVXBwZXJCb3VuZHMocmFuZ2UsIHgsIEluZmluaXR5LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNMZXNzVGhhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJ1bGUuaW5wdXRzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRMb3dlckFuZFVwcGVyQm91bmRzKHJhbmdlLCAtSW5maW5pdHksIHgsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSXNMZXNzVGhhbk9yRXF1YWxUbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJ1bGUuaW5wdXRzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRMb3dlckFuZFVwcGVyQm91bmRzKHJhbmdlLCAtSW5maW5pdHksIHgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdJc1dpdGhpblRvbGVyYW5jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJ1bGUuaW5wdXRzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9sID0gcnVsZS5pbnB1dHMudG9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TG93ZXJBbmRVcHBlckJvdW5kcyhyYW5nZSwgeCAtIHRvbCwgeCArIHRvbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByYW5nZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW5jbG9zZWRCeShyYW5nZSwgcmFuZ2VzW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1J1bGUgJyArIChqICsgMSkgKyAnIGZyb20gYW5zd2VyIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSArIDEpICsgJyB3aWxsIG5ldmVyIGJlIG1hdGNoZWQgYmVjYXVzZSBpdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lzIG1hZGUgcmVkdW5kYW50IGJ5IHJ1bGUgJyArIHJhbmdlc1trXS5ydWxlSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGZyb20gYW5zd2VyIGdyb3VwICcgKyByYW5nZXNba10uYW5zd2VyR3JvdXBJbmRleCArICcuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nc0xpc3QgPSB3YXJuaW5nc0xpc3QuY29uY2F0KHRoaXMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZS5nZXRBbGxPdXRjb21lV2FybmluZ3MoYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSwgc3RhdGVOYW1lKSk7XG4gICAgICAgIHJldHVybiB3YXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgTnVtZXJpY0lucHV0VmFsaWRhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIE51bWVyaWNJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKTtcbiAgICByZXR1cm4gTnVtZXJpY0lucHV0VmFsaWRhdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5OdW1lcmljSW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IE51bWVyaWNJbnB1dFZhbGlkYXRpb25TZXJ2aWNlO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnTnVtZXJpY0lucHV0VmFsaWRhdGlvblNlcnZpY2UnLCBzdGF0aWNfMS5kb3duZ3JhZGVJbmplY3RhYmxlKE51bWVyaWNJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIE51bWVyaWNJbnB1dCBpbnRlcmFjdGlvbi5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvZGlyZWN0aXZlcy9udW1lcmljLWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3BhZ2VzL2V4cGxvcmF0aW9uLXBsYXllci1wYWdlL3NlcnZpY2VzL2N1cnJlbnQtaW50ZXJhY3Rpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvY29udGV4dHVhbC9XaW5kb3dEaW1lbnNpb25zU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvc3RhdGVmdWwvRm9jdXNNYW5hZ2VyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYUludGVyYWN0aXZlTnVtZXJpY0lucHV0JywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL051bWVyaWNJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdudW1lcmljLWlucHV0LWludGVyYWN0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRhdHRycycsICdGb2N1c01hbmFnZXJTZXJ2aWNlJywgJ051bWVyaWNJbnB1dFJ1bGVzU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlJywgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkYXR0cnMsIEZvY3VzTWFuYWdlclNlcnZpY2UsIE51bWVyaWNJbnB1dFJ1bGVzU2VydmljZSwgV2luZG93RGltZW5zaW9uc1NlcnZpY2UsIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxhYmVsRm9yRm9jdXNUYXJnZXQgPSAkYXR0cnMubGFiZWxGb3JGb2N1c1RhcmdldCB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLk5VTUVSSUNfSU5QVVRfRk9STV9TQ0hFTUEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlfY29uZmlnOiB7fVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNBbnN3ZXJWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3RybC5hbnN3ZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyICE9PSBudWxsICYmIGN0cmwuYW5zd2VyICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyID0gZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5zd2VyVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoYW5zd2VyLCBOdW1lcmljSW5wdXRSdWxlc1NlcnZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0QW5zd2VyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlcihjdHJsLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oc3VibWl0QW5zd2VyRm4sIGlzQW5zd2VyVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgTnVtZXJpY0lucHV0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VOdW1lcmljSW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnbnVtZXJpYy1pbnB1dC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFuc3dlciBpcyBhbiBpbnRlZ2VyLCBvbWl0IHRoZSBmcmFjdGlvbmFsIHBhcnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFuc3dlciAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gTWF0aC5yb3VuZChjdHJsLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBOdW1lcmljSW5wdXQgc2hvcnQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFTaG9ydFJlc3BvbnNlTnVtZXJpY0lucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvTnVtZXJpY0lucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ251bWVyaWMtaW5wdXQtc2hvcnQtcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhbnN3ZXIgaXMgYW4gaW50ZWdlciwgb21pdCB0aGUgZnJhY3Rpb25hbCBwYXJ0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5hbnN3ZXIgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9IE1hdGgucm91bmQoY3RybC5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIFBlbmNpbENvZGVFZGl0b3IgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvJyArXG4gICAgJ3BlbmNpbC1jb2RlLWVkaXRvci1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICdwZW5jaWwtY29kZS1lZGl0b3ItdmFsaWRhdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS1wZW5jaWwtY29kZS1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1yZXNwb25zZS1wZW5jaWwtY29kZS1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS1wZW5jaWwtY29kZS1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIFBlbmNpbENvZGVFZGl0b3IgaW50ZXJhY3Rpb24uXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvJyArXG4gICAgJ3BlbmNpbC1jb2RlLWVkaXRvci1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9jb250ZXh0dWFsL1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL3N0YXRlZnVsL0ZvY3VzTWFuYWdlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZVBlbmNpbENvZGVFZGl0b3InLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsICdFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlLCBFVkVOVF9ORVdfQ0FSRF9BVkFJTEFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0TGFzdEFuc3dlcjogJyZsYXN0QW5zd2VyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ3BlbmNpbC1jb2RlLWVkaXRvci1pbnRlcmFjdGlvbi5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICckc2NvcGUnLCAnJGF0dHJzJywgJyRlbGVtZW50JywgJyR0aW1lb3V0JywgJyR1aWJNb2RhbCcsXG4gICAgICAgICAgICAgICAgJ0ZvY3VzTWFuYWdlclNlcnZpY2UnLCAnUGVuY2lsQ29kZUVkaXRvclJ1bGVzU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgJGVsZW1lbnQsICR0aW1lb3V0LCAkdWliTW9kYWwsIEZvY3VzTWFuYWdlclNlcnZpY2UsIFBlbmNpbENvZGVFZGl0b3JSdWxlc1NlcnZpY2UsIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmludGVyYWN0aW9uSXNBY3RpdmUgPSAoY3RybC5nZXRMYXN0QW5zd2VyKCkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmluaXRpYWxDb2RlID0gY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5pbml0aWFsQ29kZVdpdGhWYWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRMYXN0QW5zd2VyKCkuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlmcmFtZURpdiA9ICRlbGVtZW50LmZpbmQoJy5wZW5jaWwtY29kZS1lZGl0b3ItaWZyYW1lJykuZ2V0KDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGNlID0gbmV3IFBlbmNpbENvZGVFbWJlZChpZnJhbWVEaXYpO1xuICAgICAgICAgICAgICAgICAgICBwY2UuYmVnaW5Mb2FkKGN0cmwuaW5pdGlhbENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKEVWRU5UX05FV19DQVJEX0FWQUlMQUJMRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbnRlcmFjdGlvbklzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwY2UuaGlkZU1pZGRsZUJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNlLmhpZGVUb2dnbGVCdXR0b24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjZS5zZXRSZWFkT25seSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGNlLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZXMgdGhlIGVycm9yIGNvbnNvbGUgYXQgdGhlIGJvdHRvbSByaWdodCwgYW5kIHByZXZlbnRzIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHNob3dpbmcgdXAgZXZlbiBpZiB0aGUgY29kZSBoYXMgYW4gZXJyb3IuIEFsc28sIGhpZGVzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHVydGxlLCBhbmQgcmVkZWZpbmVzIHNheSgpIHRvIGFsc28gd3JpdGUgdGhlIHRleHQgb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY3JlZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICBwY2Uuc2V0dXBTY3JpcHQoW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24oKSB7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgIHJldHVybiB0cnVlOycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfTsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RlYnVnLmhpZGUoKTsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZGVidWcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0KCk7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29sZHNheSA9IHdpbmRvdy5zYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NheSA9IGZ1bmN0aW9uKHgpIHsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgd3JpdGUoeCk7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgIG9sZHNheSh4KTsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ307J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjZS5zaG93RWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwY2UuaGlkZVRvZ2dsZUJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaW50ZXJhY3Rpb25Jc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjZS5zZXRFZGl0YWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGNlLmhpZGVNaWRkbGVCdXR0b24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwY2Uuc2V0UmVhZE9ubHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlbmNpbCBDb2RlIGF1dG9tYXRpY2FsbHkgdGFrZXMgdGhlIGZvY3VzIG9uIGxvYWQsIHNvIHdlIGNsZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEZvY3VzTWFuYWdlclNlcnZpY2UuY2xlYXJGb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR1aWJNb2RhbC5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGVuY2lsLWNvZGUtcmVzZXQtY29uZmlybWF0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6ICdzdGF0aWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckc2NvcGUnLCAnJHVpYk1vZGFsSW5zdGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkdWliTW9kYWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlc2V0Q29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlc3VsdC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwY2Uuc2V0Q29kZShjdHJsLmluaXRpYWxDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Tm9ybWFsaXplZENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0cyB0YWJzIHRvIHNwYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwY2UuZ2V0Q29kZSgpLnJlcGxhY2UoL1xcdC9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySXNIYXBwZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1N1Ym1pdHRlZEFuc3dlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwY2Uub24oJ3N0YXJ0RXhlY3V0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1Ym1pdHRlZEFuc3dlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGNlLm9uKCdleGVjdXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ySXNIYXBwZW5pbmcgfHwgaGFzU3VibWl0dGVkQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGNlLmV2YWwoJ2RvY3VtZW50LmJvZHkuaW5uZXJIVE1MJywgZnVuY3Rpb24gKHBlbmNpbENvZGVIdG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRDb2RlID0gZ2V0Tm9ybWFsaXplZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBkaXZzLCBhbmQgZXh0cmFjdCB0aGVpciB0ZXh0dWFsIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICQubWFwKCQocGVuY2lsQ29kZUh0bWwpLmZpbHRlcignZGl2JyksIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKGVsZW0pLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNTdWJtaXR0ZWRBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBub3JtYWxpemVkQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBQZW5jaWxDb2RlRWRpdG9yUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1N1Ym1pdHRlZEFuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQ29kZSA9IGdldE5vcm1hbGl6ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcklzSGFwcGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1Ym1pdHRlZEFuc3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLm9uU3VibWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBub3JtYWxpemVkQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBQZW5jaWxDb2RlRWRpdG9yUnVsZXNTZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcklzSGFwcGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24obnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBQZW5jaWxDb2RlRWRpdG9yIHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VQZW5jaWxDb2RlRWRpdG9yJywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9kaXJlY3RpdmVzLycgK1xuICAgICAgICAgICAgICAgICdwZW5jaWwtY29kZS1lZGl0b3ItcmVzcG9uc2UuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJGF0dHJzJywgZnVuY3Rpb24gKCRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYW5zd2VyQ29kZSA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpLmNvZGU7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgUGVuY2lsQ29kZUVkaXRvciBzaG9ydCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy90cnVuY2F0ZS1hdC1maXJzdC1saW5lLmZpbHRlci50cycpO1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhU2hvcnRSZXNwb25zZVBlbmNpbENvZGVFZGl0b3InLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9QZW5jaWxDb2RlRWRpdG9yL2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ3BlbmNpbC1jb2RlLWVkaXRvci1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXJDb2RlID0gSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLmFuc3dlcikuY29kZTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy9ub3JtYWxpemUtd2hpdGVzcGFjZS5maWx0ZXIudHMnKTtcbnJlcXVpcmUoJ2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy8nICtcbiAgICAnbm9ybWFsaXplLXdoaXRlc3BhY2UtcHVuY3R1YXRpb24tYW5kLWNhc2UuZmlsdGVyLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9Db2RlTm9ybWFsaXplclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1BlbmNpbENvZGVFZGl0b3JSdWxlc1NlcnZpY2UnLCBbXG4gICAgJyRmaWx0ZXInLCAnQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoJGZpbHRlciwgQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBDb2RlRXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZENvZGUgPSBDb2RlTm9ybWFsaXplclNlcnZpY2UuZ2V0Tm9ybWFsaXplZENvZGUoYW5zd2VyLmNvZGUpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkRXhwZWN0ZWRDb2RlID0gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLmdldE5vcm1hbGl6ZWRDb2RlKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZENvZGUgPT09IG5vcm1hbGl6ZWRFeHBlY3RlZENvZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ29kZUNvbnRhaW5zOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZENvZGUgPSBDb2RlTm9ybWFsaXplclNlcnZpY2UuZ2V0Tm9ybWFsaXplZENvZGUoYW5zd2VyLmNvZGUpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkU25pcHBldCA9IENvZGVOb3JtYWxpemVyU2VydmljZS5nZXROb3JtYWxpemVkQ29kZShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRDb2RlLmluZGV4T2Yobm9ybWFsaXplZFNuaXBwZXQpICE9PSAtMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb2RlRG9lc05vdENvbnRhaW46IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQ29kZSA9IENvZGVOb3JtYWxpemVyU2VydmljZS5nZXROb3JtYWxpemVkQ29kZShhbnN3ZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRTbmlwcGV0ID0gQ29kZU5vcm1hbGl6ZXJTZXJ2aWNlLmdldE5vcm1hbGl6ZWRDb2RlKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZENvZGUuaW5kZXhPZihub3JtYWxpemVkU25pcHBldCkgPT09IC0xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE91dHB1dEVxdWFsczogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRPdXRwdXQgPSAkZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlJykoYW5zd2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRFeHBlY3RlZE91dHB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRPdXRwdXQgPT09IG5vcm1hbGl6ZWRFeHBlY3RlZE91dHB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBPdXRwdXRSb3VnaGx5RXF1YWxzOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZE91dHB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2VQdW5jdHVhdGlvbkFuZENhc2UnKShhbnN3ZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEV4cGVjdGVkT3V0cHV0ID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZVB1bmN0dWF0aW9uQW5kQ2FzZScpKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZE91dHB1dCA9PT0gbm9ybWFsaXplZEV4cGVjdGVkT3V0cHV0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFJlc3VsdHNJbkVycm9yOiBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGFuc3dlci5lcnJvci50cmltKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEVycm9yQ29udGFpbnM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkRXJyb3IgPSAkZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlJykoYW5zd2VyLmVycm9yKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFNuaXBwZXQgPSAkZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlJykoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRXJyb3IuaW5kZXhPZihub3JtYWxpemVkU25pcHBldCkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmFsaWRhdG9yIHNlcnZpY2UgZm9yIHRoZSBpbnRlcmFjdGlvbi5cbiAqL1xudmFyIHN0YXRpY18xID0gcmVxdWlyZShcIkBhbmd1bGFyL3VwZ3JhZGUvc3RhdGljXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGJhc2VfaW50ZXJhY3Rpb25fdmFsaWRhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiaW50ZXJhY3Rpb25zL2Jhc2UtaW50ZXJhY3Rpb24tdmFsaWRhdGlvbi5zZXJ2aWNlXCIpO1xudmFyIFBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZW5jaWxDb2RlRWRpdG9yVmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBQZW5jaWxDb2RlRWRpdG9yVmFsaWRhdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MgPSBmdW5jdGlvbiAoY3VzdG9taXphdGlvbkFyZ3MpIHtcbiAgICAgICAgLy8gVE9ETyhqdWFuc2FiYSk6IEltcGxlbWVudCBjdXN0b21pemF0aW9uIGFyZ3MgdmFsaWRhdGlvbnMuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNzYpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2N1c3RvbWl6YXRpb25BcmdzJyBpcyBhIGRpY3Qgd2l0aCBwb3NzaWJsZSB1bmRlcnNjb3JlX2Nhc2VkXG4gICAgLy8ga2V5cyB3aGljaCBnaXZlIHRzbGludCBlcnJvcnMgYWdhaW5zdCB1bmRlcnNjb3JlX2Nhc2luZyBpbiBmYXZvciBvZlxuICAgIC8vIGNhbWVsQ2FzaW5nLlxuICAgIFBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QWxsV2FybmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzKGN1c3RvbWl6YXRpb25BcmdzKS5jb25jYXQodGhpcy5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlLmdldEFsbE91dGNvbWVXYXJuaW5ncyhhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKTtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBQZW5jaWxDb2RlRWRpdG9yVmFsaWRhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIFBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIFBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZSA9IFBlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1BlbmNpbENvZGVFZGl0b3JWYWxpZGF0aW9uU2VydmljZScsIHN0YXRpY18xLmRvd25ncmFkZUluamVjdGFibGUoUGVuY2lsQ29kZUVkaXRvclZhbGlkYXRpb25TZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBTZXRJbnB1dCBpbnRlcmFjdGlvbi5cbiAqL1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL1NldElucHV0L2RpcmVjdGl2ZXMvc2V0LWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzL3NldC1pbnB1dC12YWxpZGF0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzL29wcGlhLWludGVyYWN0aXZlLXNldC1pbnB1dC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1yZXNwb25zZS1zZXQtaW5wdXQuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvU2V0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAnb3BwaWEtc2hvcnQtcmVzcG9uc2Utc2V0LWlucHV0LmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBTZXRJbnB1dCBpbnRlcmFjdGlvbi5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9TZXRJbnB1dC9kaXJlY3RpdmVzL3NldC1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvV2luZG93RGltZW5zaW9uc1NlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFJbnRlcmFjdGl2ZVNldElucHV0JywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL1NldElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ3NldC1pbnB1dC1pbnRlcmFjdGlvbi5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICAgICAgICckYXR0cnMnLCAnJHRyYW5zbGF0ZScsICdTZXRJbnB1dFJ1bGVzU2VydmljZScsXG4gICAgICAgICAgICAgICAgJ1dpbmRvd0RpbWVuc2lvbnNTZXJ2aWNlJywgJ0N1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkYXR0cnMsICR0cmFuc2xhdGUsIFNldElucHV0UnVsZXNTZXJ2aWNlLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5pY29kZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1aV9jb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pbGkpOiBUcmFuc2xhdGUgdGhpcyBpbiB0aGUgSFRNTC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfZWxlbWVudF90ZXh0OiAkdHJhbnNsYXRlLmluc3RhbnQoJ0kxOE5fSU5URVJBQ1RJT05TX1NFVF9JTlBVVF9BRERfSVRFTScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZHMgYW4gaW5wdXQgZmllbGQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9IFsnJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNEdXBsaWNhdGVzID0gZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbnN3ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5lcXVhbHMoYW5zd2VyW2ldLCBhbnN3ZXJbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0JsYW5rT3B0aW9uID0gZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlci5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50ID09PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zdWJtaXRBbnN3ZXIgPSBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRHVwbGljYXRlcyhhbnN3ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvck1lc3NhZ2UgPSAoJ0kxOE5fSU5URVJBQ1RJT05TX1NFVF9JTlBVVF9EVVBMSUNBVEVTX0VSUk9SJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2Uub25TdWJtaXQoYW5zd2VyLCBTZXRJbnB1dFJ1bGVzU2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNBbnN3ZXJWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3RybC5hbnN3ZXIubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoYXNCbGFua09wdGlvbihjdHJsLmFuc3dlcikpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWl0QW5zd2VyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlcihjdHJsLmFuc3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRJbnRlcmFjdGlvblNlcnZpY2UucmVnaXN0ZXJDdXJyZW50SW50ZXJhY3Rpb24oc3VibWl0QW5zd2VyRm4sIGN0cmwuaXNBbnN3ZXJWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBTZXQgSW5wdXQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9IdG1sRXNjYXBlclNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnb3BwaWFSZXNwb25zZVNldElucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvU2V0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAnc2V0LWlucHV0LXJlc3BvbnNlLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbJyRhdHRycycsIGZ1bmN0aW9uICgkYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFuc3dlciA9IEh0bWxFc2NhcGVyU2VydmljZS5lc2NhcGVkSnNvblRvT2JqKCRhdHRycy5hbnN3ZXIpO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgdGhlIFNldCBJbnB1dCBzaG9ydCByZXNwb25zZS5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIG5hbWluZyBjb252ZW50aW9uIGZvciBjdXN0b21pemF0aW9uIGFyZ3MgdGhhdCBhcmUgcGFzc2VkXG4gKiBpbnRvIHRoZSBkaXJlY3RpdmUgaXM6IHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIGZvbGxvd2VkIGJ5ICdXaXRoJyxcbiAqIGZvbGxvd2VkIGJ5IHRoZSBuYW1lIG9mIHRoZSBhcmcuXG4gKi9cbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VTZXRJbnB1dCcsIFtcbiAgICAnSHRtbEVzY2FwZXJTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoSHRtbEVzY2FwZXJTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL1NldElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ3NldC1pbnB1dC1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5kaXNwbGF5ZWRBbnN3ZXIgPSAoX2Fuc3dlci5sZW5ndGggPiAwID8gX2Fuc3dlci5qb2luKCcsICcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdJMThOX0lOVEVSQUNUSU9OU19TRVRfSU5QVVRfTk9fQU5TV0VSJyk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZXMgc2VydmljZSBmb3IgdGhlIGludGVyYWN0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdTZXRJbnB1dFJ1bGVzU2VydmljZScsIFtmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFcXVhbHM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIubGVuZ3RoID09PSBpbnB1dHMueC5sZW5ndGggJiYgaW5wdXRzLnguZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyLmluZGV4T2YodmFsKSA+PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIElzU3Vic2V0T2Y6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIubGVuZ3RoIDwgaW5wdXRzLngubGVuZ3RoICYmIGFuc3dlci5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dHMueC5pbmRleE9mKHZhbCkgPj0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc1N1cGVyc2V0T2Y6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIubGVuZ3RoID4gaW5wdXRzLngubGVuZ3RoICYmIGlucHV0cy54LmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlci5pbmRleE9mKHZhbCkgPj0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBIYXNFbGVtZW50c0luOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRzLnguc29tZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIuaW5kZXhPZih2YWwpID49IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSGFzRWxlbWVudHNOb3RJbjogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlci5zb21lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0cy54LmluZGV4T2YodmFsKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgT21pdHNFbGVtZW50c0luOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRzLnguc29tZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIuaW5kZXhPZih2YWwpID09PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJc0Rpc2pvaW50RnJvbTogZnVuY3Rpb24gKGFuc3dlciwgaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0cy54LmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlci5pbmRleE9mKHZhbCkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcImludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZVwiKTtcbnZhciBTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldElucHV0VmFsaWRhdGlvblNlcnZpY2UoYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2VJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZUluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXN0b21pemF0aW9uQXJnc1dhcm5pbmdzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25BcmdzKSB7XG4gICAgICAgIC8vIFRPRE8oanVhbnNhYmEpOiBJbXBsZW1lbnQgY3VzdG9taXphdGlvbiBhcmdzIHZhbGlkYXRpb25zLlxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvLyBUT0RPKCM3MTc2KTogUmVwbGFjZSAnYW55JyB3aXRoIHRoZSBleGFjdCB0eXBlLiBUaGlzIGhhcyBiZWVuIGtlcHQgYXNcbiAgICAvLyAnYW55JyBiZWNhdXNlICdjdXN0b21pemF0aW9uQXJncycgaXMgYSBkaWN0IHdpdGggcG9zc2libGUgdW5kZXJzY29yZV9jYXNlZFxuICAgIC8vIGtleXMgd2hpY2ggZ2l2ZSB0c2xpbnQgZXJyb3JzIGFnYWluc3QgdW5kZXJzY29yZV9jYXNpbmcgaW4gZmF2b3Igb2ZcbiAgICAvLyBjYW1lbENhc2luZy5cbiAgICBTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxXYXJuaW5ncyA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUsIGN1c3RvbWl6YXRpb25BcmdzLCBhbnN3ZXJHcm91cHMsIGRlZmF1bHRPdXRjb21lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpLmNvbmNhdCh0aGlzLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlSW5zdGFuY2UuZ2V0QWxsT3V0Y29tZVdhcm5pbmdzKGFuc3dlckdyb3VwcywgZGVmYXVsdE91dGNvbWUsIHN0YXRlTmFtZSkpO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIFNldElucHV0VmFsaWRhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkluamVjdGFibGUoe1xuICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgYmFzZV9pbnRlcmFjdGlvbl92YWxpZGF0aW9uX3NlcnZpY2VfMS5iYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBiYXNlX2ludGVyYWN0aW9uX3ZhbGlkYXRpb25fc2VydmljZV8xLmJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIFNldElucHV0VmFsaWRhdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU2V0SW5wdXRWYWxpZGF0aW9uU2VydmljZSA9IFNldElucHV0VmFsaWRhdGlvblNlcnZpY2U7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShTZXRJbnB1dFZhbGlkYXRpb25TZXJ2aWNlKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBUZXh0SW5wdXQgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvdGV4dC1pbnB1dC1wcmVkaWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy90ZXh0LWlucHV0LXJ1bGVzLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy90ZXh0LWlucHV0LXZhbGlkYXRpb24uc2VydmljZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL1RleHRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1pbnRlcmFjdGl2ZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL1RleHRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1yZXNwb25zZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL1RleHRJbnB1dC9kaXJlY3RpdmVzLycgK1xuICAgICdvcHBpYS1zaG9ydC1yZXNwb25zZS10ZXh0LWlucHV0LmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBUZXh0SW5wdXQgaW50ZXJhY3Rpb24uXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvVGV4dElucHV0L2RpcmVjdGl2ZXMvdGV4dC1pbnB1dC1ydWxlcy5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdwYWdlcy9leHBsb3JhdGlvbi1wbGF5ZXItcGFnZS9zZXJ2aWNlcy9jdXJyZW50LWludGVyYWN0aW9uLnNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL2NvbnRleHR1YWwvV2luZG93RGltZW5zaW9uc1NlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvc3RhdGVmdWwvRm9jdXNNYW5hZ2VyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYUludGVyYWN0aXZlVGV4dElucHV0JywgW1xuICAgICdIdG1sRXNjYXBlclNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChIdG1sRXNjYXBlclNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvVGV4dElucHV0L2RpcmVjdGl2ZXMvJyArXG4gICAgICAgICAgICAgICAgJ3RleHQtaW5wdXQtaW50ZXJhY3Rpb24uZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJGF0dHJzJywgJ0ZvY3VzTWFuYWdlclNlcnZpY2UnLCAnVGV4dElucHV0UnVsZXNTZXJ2aWNlJyxcbiAgICAgICAgICAgICAgICAnV2luZG93RGltZW5zaW9uc1NlcnZpY2UnLCAnQ3VycmVudEludGVyYWN0aW9uU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRhdHRycywgRm9jdXNNYW5hZ2VyU2VydmljZSwgVGV4dElucHV0UnVsZXNTZXJ2aWNlLCBXaW5kb3dEaW1lbnNpb25zU2VydmljZSwgQ3VycmVudEludGVyYWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucGxhY2Vob2xkZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMucGxhY2Vob2xkZXJXaXRoVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnJvd3MgPSAoSHRtbEVzY2FwZXJTZXJ2aWNlLmVzY2FwZWRKc29uVG9PYmooJGF0dHJzLnJvd3NXaXRoVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5sYWJlbEZvckZvY3VzVGFyZ2V0ID0gJGF0dHJzLmxhYmVsRm9yRm9jdXNUYXJnZXQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5pY29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aV9jb25maWc6IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNjaGVtYS51aV9jb25maWcucGxhY2Vob2xkZXIgPSBjdHJsLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnJvd3MgJiYgY3RybC5yb3dzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNjaGVtYS51aV9jb25maWcucm93cyA9IGN0cmwucm93cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHJsLnN1Ym1pdEFuc3dlciA9IGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgQ3VycmVudEludGVyYWN0aW9uU2VydmljZS5vblN1Ym1pdChhbnN3ZXIsIFRleHRJbnB1dFJ1bGVzU2VydmljZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJtaXRBbnN3ZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc3VibWl0QW5zd2VyKGN0cmwuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkaXR5Q2hlY2tGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLmFuc3dlci5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBDdXJyZW50SW50ZXJhY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyQ3VycmVudEludGVyYWN0aW9uKHN1Ym1pdEFuc3dlckZuLCB2YWxpZGl0eUNoZWNrRm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB0aGUgVGV4dElucHV0IHJlc3BvbnNlLlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbWl6YXRpb24gYXJncyB0aGF0IGFyZSBwYXNzZWRcbiAqIGludG8gdGhlIGRpcmVjdGl2ZSBpczogdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgZm9sbG93ZWQgYnkgJ1dpdGgnLFxuICogZm9sbG93ZWQgYnkgdGhlIG5hbWUgb2YgdGhlIGFyZy5cbiAqL1xucmVxdWlyZSgnZG9tYWluL3V0aWxpdGllcy9VcmxJbnRlcnBvbGF0aW9uU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvSHRtbEVzY2FwZXJTZXJ2aWNlLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ29wcGlhUmVzcG9uc2VUZXh0SW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAndGV4dC1pbnB1dC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHRoZSBUZXh0SW5wdXQgc2hvcnQgcmVzcG9uc2UuXG4gKlxuICogSU1QT1JUQU5UIE5PVEU6IFRoZSBuYW1pbmcgY29udmVudGlvbiBmb3IgY3VzdG9taXphdGlvbiBhcmdzIHRoYXQgYXJlIHBhc3NlZFxuICogaW50byB0aGUgZGlyZWN0aXZlIGlzOiB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLCBmb2xsb3dlZCBieSAnV2l0aCcsXG4gKiBmb2xsb3dlZCBieSB0aGUgbmFtZSBvZiB0aGUgYXJnLlxuICovXG5yZXF1aXJlKCdmaWx0ZXJzL3N0cmluZy11dGlsaXR5LWZpbHRlcnMvdHJ1bmNhdGUtYXQtZmlyc3QtbGluZS5maWx0ZXIudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0h0bWxFc2NhcGVyU2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdvcHBpYVNob3J0UmVzcG9uc2VUZXh0SW5wdXQnLCBbXG4gICAgJ0h0bWxFc2NhcGVyU2VydmljZScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKEh0bWxFc2NhcGVyU2VydmljZSwgVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvZGlyZWN0aXZlcy8nICtcbiAgICAgICAgICAgICAgICAndGV4dC1pbnB1dC1zaG9ydC1yZXNwb25zZS5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckYXR0cnMnLCBmdW5jdGlvbiAoJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbnN3ZXIgPSBIdG1sRXNjYXBlclNlcnZpY2UuZXNjYXBlZEpzb25Ub09iaigkYXR0cnMuYW5zd2VyKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTkgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSdWxlcyBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ZpbHRlcnMvc3RyaW5nLXV0aWxpdHktZmlsdGVycy9ub3JtYWxpemUtd2hpdGVzcGFjZS5maWx0ZXIudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ1RleHRJbnB1dFJ1bGVzU2VydmljZScsIFtcbiAgICAnJGZpbHRlcicsIGZ1bmN0aW9uICgkZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFcXVhbHM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQW5zd2VyID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbnN3ZXIudG9Mb3dlckNhc2UoKSA9PT0gbm9ybWFsaXplZElucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRnV6enlFcXVhbHM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQW5zd2VyID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgdmFyIGFuc3dlclN0cmluZyA9IG5vcm1hbGl6ZWRBbnN3ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGlucHV0cy54KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRTdHJpbmcgPSBub3JtYWxpemVkSW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRTdHJpbmcgPT09IGFuc3dlclN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVkaXREaXN0YW5jZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGlucHV0U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXREaXN0YW5jZS5wdXNoKFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGFuc3dlclN0cmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBlZGl0RGlzdGFuY2VbMF0ucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gaW5wdXRTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gYW5zd2VyU3RyaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTdHJpbmcuY2hhckF0KGkgLSAxKSA9PT0gYW5zd2VyU3RyaW5nLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0RGlzdGFuY2VbaV1bal0gPSBlZGl0RGlzdGFuY2VbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXREaXN0YW5jZVtpXVtqXSA9IE1hdGgubWluKGVkaXREaXN0YW5jZVtpIC0gMV1baiAtIDFdLCBlZGl0RGlzdGFuY2VbaV1baiAtIDFdLCBlZGl0RGlzdGFuY2VbaSAtIDFdW2pdKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXREaXN0YW5jZVtpbnB1dFN0cmluZy5sZW5ndGhdW2Fuc3dlclN0cmluZy5sZW5ndGhdID09PSAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENhc2VTZW5zaXRpdmVFcXVhbHM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQW5zd2VyID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbnN3ZXIgPT09IG5vcm1hbGl6ZWRJbnB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTdGFydHNXaXRoOiBmdW5jdGlvbiAoYW5zd2VyLCBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEFuc3dlciA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShhbnN3ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSAkZmlsdGVyKCdub3JtYWxpemVXaGl0ZXNwYWNlJykoaW5wdXRzLngpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQW5zd2VyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihub3JtYWxpemVkSW5wdXQudG9Mb3dlckNhc2UoKSkgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ29udGFpbnM6IGZ1bmN0aW9uIChhbnN3ZXIsIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkQW5zd2VyID0gJGZpbHRlcignbm9ybWFsaXplV2hpdGVzcGFjZScpKGFuc3dlcik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9ICRmaWx0ZXIoJ25vcm1hbGl6ZVdoaXRlc3BhY2UnKShpbnB1dHMueCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbnN3ZXIudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5vcm1hbGl6ZWRJbnB1dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFZhbGlkYXRvciBzZXJ2aWNlIGZvciB0aGUgaW50ZXJhY3Rpb24uXG4gKi9cbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9iYXNlLWludGVyYWN0aW9uLXZhbGlkYXRpb24uc2VydmljZS50cycpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZmFjdG9yeSgnVGV4dElucHV0VmFsaWRhdGlvblNlcnZpY2UnLCBbXG4gICAgJ2Jhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlJywgJ0lOVEVSQUNUSU9OX1NQRUNTJywgJ1dBUk5JTkdfVFlQRVMnLFxuICAgIGZ1bmN0aW9uIChiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSwgSU5URVJBQ1RJT05fU1BFQ1MsIFdBUk5JTkdfVFlQRVMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3M6IGZ1bmN0aW9uIChjdXN0b21pemF0aW9uQXJncykge1xuICAgICAgICAgICAgICAgIHZhciB3YXJuaW5nc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZS5yZXF1aXJlQ3VzdG9taXphdGlvbkFyZ3VtZW50cyhjdXN0b21pemF0aW9uQXJncywgWydwbGFjZWhvbGRlcicsICdyb3dzJ10pO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGN1c3RvbWl6YXRpb25BcmdzLnBsYWNlaG9sZGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5pc1N0cmluZyhwbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnUGxhY2Vob2xkZXIgdGV4dCBtdXN0IGJlIGEgc3RyaW5nLicpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaXNJbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5pc051bWJlcihuKSAmJiBuICUgMSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gY3VzdG9taXphdGlvbkFyZ3Mucm93cy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnQocm93cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRTcGVjcyA9IElOVEVSQUNUSU9OX1NQRUNTLlRleHRJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbWl6YXRpb25BcmdTcGVjcyA9IHRleHRTcGVjcy5jdXN0b21pemF0aW9uX2FyZ19zcGVjcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3NTcGVjcyA9IGN1c3RvbWl6YXRpb25BcmdTcGVjc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblJvd3MgPSByb3dzU3BlY3Muc2NoZW1hLnZhbGlkYXRvcnNbMF0ubWluX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Um93cyA9IHJvd3NTcGVjcy5zY2hlbWEudmFsaWRhdG9yc1sxXS5tYXhfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dzIDwgbWluUm93cyB8fCByb3dzID4gbWF4Um93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFdBUk5JTkdfVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdOdW1iZXIgb2Ygcm93cyBtdXN0IGJlIGJldHdlZW4gJyArIG1pblJvd3MgKyAnIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4Um93cyArICcuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdOdW1iZXIgb2Ygcm93cyBtdXN0IGJlIGludGVncmFsLicpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2FybmluZ3NMaXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEFsbFdhcm5pbmdzOiBmdW5jdGlvbiAoc3RhdGVOYW1lLCBjdXN0b21pemF0aW9uQXJncywgYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1c3RvbWl6YXRpb25BcmdzV2FybmluZ3MoY3VzdG9taXphdGlvbkFyZ3MpLmNvbmNhdChiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZS5nZXRBbGxPdXRjb21lV2FybmluZ3MoYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSwgc3RhdGVOYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRleHRJbnB1dCBpbnRlcmFjdGlvbiBwcmVkaWN0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBJTVBPUlRBTlQgTk9URTogVGhlIHByZWRpY3Rpb24gZnVuY3Rpb24gdXNlcyB0aGUgY2xhc3NpZmllciBkYXRhXG4gKiBvZiB0cmFpbmVkIG1vZGVsICh0ZXh0IGNsYXNzaWZpZXIgbW9kZWwpIGZvciBpbmZlcmVuY2UuIFRoZXNlIGZ1bmN0aW9uc1xuICogbXVzdCBiZSBjaGFuZ2VkIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlcyBpbiBjb3JyZXNwb25kaW5nIGNsYXNzaWZpZXIgdHJhaW5pbmdcbiAqIGZ1bmN0aW9uIG9uIE9wcGlhLW1sLlxuICovXG5yZXF1aXJlKCdjbGFzc2lmaWVycy9zdm0tcHJlZGljdGlvbi5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdjbGFzc2lmaWVycy90ZXh0LWlucHV0LnRva2VuaXplci50cycpO1xucmVxdWlyZSgnY2xhc3NpZmllcnMvY291bnQtdmVjdG9yaXplci5zZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zLWV4dGVuc2lvbi5jb25zdGFudHMuYWpzLnRzJyk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5mYWN0b3J5KCdUZXh0SW5wdXRQcmVkaWN0aW9uU2VydmljZScsIFtcbiAgICAnQ291bnRWZWN0b3JpemVyU2VydmljZScsICdTVk1QcmVkaWN0aW9uU2VydmljZScsXG4gICAgJ1RleHRJbnB1dFRva2VuaXplcicsICdURVhUX0lOUFVUX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQnLCBmdW5jdGlvbiAoQ291bnRWZWN0b3JpemVyU2VydmljZSwgU1ZNUHJlZGljdGlvblNlcnZpY2UsIFRleHRJbnB1dFRva2VuaXplciwgVEVYVF9JTlBVVF9QUkVESUNUSU9OX1NFUlZJQ0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVkaWN0OiBmdW5jdGlvbiAoY2xhc3NpZmllckRhdGEsIHRleHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciBjdlZvY2FidWxhcnkgPSBjbGFzc2lmaWVyRGF0YS5jdl92b2NhYnVsYXJ5O1xuICAgICAgICAgICAgICAgIHZhciBzdm1EYXRhID0gY2xhc3NpZmllckRhdGEuU1ZNO1xuICAgICAgICAgICAgICAgIC8vIFRva2VuaXplIHRoZSB0ZXh0IGlucHV0LlxuICAgICAgICAgICAgICAgIHRleHRJbnB1dCA9IHRleHRJbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0SW5wdXRUb2tlbnMgPSBUZXh0SW5wdXRUb2tlbml6ZXIuZ2VuZXJhdGVUb2tlbnModGV4dElucHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZlY3RvciA9IENvdW50VmVjdG9yaXplclNlcnZpY2UudmVjdG9yaXplKHRleHRJbnB1dFRva2VucywgY3ZWb2NhYnVsYXJ5KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZGljdGlvblJlc3VsdCA9IFNWTVByZWRpY3Rpb25TZXJ2aWNlLnByZWRpY3Qoc3ZtRGF0YSwgdGV4dFZlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY3Rpb25SZXN1bHQucHJlZGljdGlvbkNvbmZpZGVuY2UgPlxuICAgICAgICAgICAgICAgICAgICBURVhUX0lOUFVUX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY3Rpb25SZXN1bHQucHJlZGljdGlvbkxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJhc2UgdmFsaWRhdGlvbiBzZXJ2aWNlIGZvciBpbnRlcmFjdGlvbnMuXG4gKi9cbnZhciBzdGF0aWNfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci91cGdyYWRlL3N0YXRpY1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBhcHBfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiYXBwLmNvbnN0YW50c1wiKTtcbnZhciBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSgpIHtcbiAgICB9XG4gICAgLy8gJ2FyZ05hbWVzJyBpcyBhbiBhcnJheSBvZiB0b3AtbGV2ZWwgY3VzdG9taXphdGlvbiBhcmd1bWVudCBuYW1lcyAoc3VjaFxuICAgIC8vIGFzICdjaG9jaWVzJykgdXNlZCB0byB2ZXJpZnkgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXRcbiAgICAvLyBjdXN0b21pemF0aW9uIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UucHJvdG90eXBlLnJlcXVpcmVDdXN0b21pemF0aW9uQXJndW1lbnRzID0gZnVuY3Rpb24gKGN1c3RvbWl6YXRpb25Bcmd1bWVudHMsIGFyZ05hbWVzKSB7XG4gICAgICAgIHZhciBtaXNzaW5nQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbWl6YXRpb25Bcmd1bWVudHMuaGFzT3duUHJvcGVydHkoYXJnTmFtZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0FyZ3MucHVzaChhcmdOYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pc3NpbmdBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nQXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgY3VzdG9taXphdGlvbiBhcmd1bWVudHMgdG8gaGF2ZSBwcm9wZXJ0eTogJyArXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdBcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGN1c3RvbWl6YXRpb24gYXJndW1lbnRzIHRvIGhhdmUgcHJvcGVydGllczogJyArXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdBcmdzLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE8oIzcxNjUpOiBSZXBsYWNlICdhbnknIHdpdGggdGhlIGV4YWN0IHR5cGUuIFRoaXMgaGFzIGJlZW4ga2VwdCBhc1xuICAgIC8vICdhbnknIGJlY2F1c2UgJ2Fuc3dlckdyb3VwcycgaXMgYW4gYW5zd2VyIGdyb3VwIGRvbWFpbiBvYmplY3QgYW5kIGNhbiBiZVxuICAgIC8vIHR5cGVkIGFmdGVyIEFuc3dlckdyb3VwT2JqZWN0RmFjdG9yeS50cyBpcyB1cGdyYWRlZC5cbiAgICBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0QW5zd2VyR3JvdXBXYXJuaW5ncyA9IGZ1bmN0aW9uIChhbnN3ZXJHcm91cHMsIHN0YXRlTmFtZSkge1xuICAgICAgICB2YXIgcGFydGlhbFdhcm5pbmdzTGlzdCA9IFtdO1xuICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIHRoZSBkZWZhdWx0IG91dGNvbWUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5zd2VyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYW5zd2VyR3JvdXBzW2ldLm91dGNvbWUuaXNDb25mdXNpbmcoc3RhdGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxXYXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKCdQbGVhc2Ugc3BlY2lmeSB3aGF0IE9wcGlhIHNob3VsZCBkbyBpbiBhbnN3ZXIgZ3JvdXAgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcoaSArIDEpICsgJy4nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuc3dlckdyb3Vwc1tpXS5vdXRjb21lLmRlc3QgPT09IHN0YXRlTmFtZSAmJlxuICAgICAgICAgICAgICAgIGFuc3dlckdyb3Vwc1tpXS5vdXRjb21lLmxhYmVsbGVkQXNDb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbFdhcm5pbmdzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ0luIGFuc3dlciBncm91cCAnICsgU3RyaW5nKGkgKyAxKSArICcsIHNlbGYtbG9vcHMgc2hvdWxkICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBiZSBsYWJlbGxlZCBhcyBjb3JyZWN0LicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRpYWxXYXJuaW5nc0xpc3Q7XG4gICAgfTtcbiAgICBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0RGVmYXVsdE91dGNvbWVXYXJuaW5ncyA9IGZ1bmN0aW9uIChkZWZhdWx0T3V0Y29tZSwgc3RhdGVOYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsV2FybmluZ3NMaXN0ID0gW107XG4gICAgICAgIGlmIChkZWZhdWx0T3V0Y29tZSAmJiBkZWZhdWx0T3V0Y29tZS5pc0NvbmZ1c2luZyhzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgICBwYXJ0aWFsV2FybmluZ3NMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFwcF9jb25zdGFudHNfMS5BcHBDb25zdGFudHMuV0FSTklOR19UWVBFUy5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAoJ1BsZWFzZSBhZGQgZmVlZGJhY2sgZm9yIHRoZSB1c2VyIGluIHRoZSBbQWxsIG90aGVyIGFuc3dlcnNdICcgK1xuICAgICAgICAgICAgICAgICAgICAncnVsZS4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRPdXRjb21lICYmIGRlZmF1bHRPdXRjb21lLmRlc3QgPT09IHN0YXRlTmFtZSAmJlxuICAgICAgICAgICAgZGVmYXVsdE91dGNvbWUubGFiZWxsZWRBc0NvcnJlY3QpIHtcbiAgICAgICAgICAgIHBhcnRpYWxXYXJuaW5nc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXBwX2NvbnN0YW50c18xLkFwcENvbnN0YW50cy5XQVJOSU5HX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnSW4gdGhlIFtBbGwgb3RoZXIgYW5zd2Vyc10gZ3JvdXAsIHNlbGYtbG9vcHMgc2hvdWxkIG5vdCBiZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xhYmVsbGVkIGFzIGNvcnJlY3QuJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0aWFsV2FybmluZ3NMaXN0O1xuICAgIH07XG4gICAgLy8gVE9ETygjNzE2NSk6IFJlcGxhY2UgJ2FueScgd2l0aCB0aGUgZXhhY3QgdHlwZS4gVGhpcyBoYXMgYmVlbiBrZXB0IGFzXG4gICAgLy8gJ2FueScgYmVjYXVzZSAnYW5zd2VyR3JvdXBzJyBpcyBhbiBhbnN3ZXIgZ3JvdXAgZG9tYWluIG9iamVjdCBhbmQgY2FuIGJlXG4gICAgLy8gdHlwZWQgYWZ0ZXIgQW5zd2VyR3JvdXBPYmplY3RGYWN0b3J5LnRzIGlzIHVwZ3JhZGVkLlxuICAgIGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRBbGxPdXRjb21lV2FybmluZ3MgPSBmdW5jdGlvbiAoYW5zd2VyR3JvdXBzLCBkZWZhdWx0T3V0Y29tZSwgc3RhdGVOYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRBbnN3ZXJHcm91cFdhcm5pbmdzKGFuc3dlckdyb3Vwcywgc3RhdGVOYW1lKS5jb25jYXQodGhpcy5nZXREZWZhdWx0T3V0Y29tZVdhcm5pbmdzKGRlZmF1bHRPdXRjb21lLCBzdGF0ZU5hbWUpKSk7XG4gICAgfTtcbiAgICBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgfSlcbiAgICBdLCBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSk7XG4gICAgcmV0dXJuIGJhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuYmFzZUludGVyYWN0aW9uVmFsaWRhdGlvblNlcnZpY2UgPSBiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmZhY3RvcnkoJ2Jhc2VJbnRlcmFjdGlvblZhbGlkYXRpb25TZXJ2aWNlJywgc3RhdGljXzEuZG93bmdyYWRlSW5qZWN0YWJsZShiYXNlSW50ZXJhY3Rpb25WYWxpZGF0aW9uU2VydmljZSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgZm9yIGludGVyYWN0aW9ucyBleHRlbnNpb25zLlxuICovXG4vLyBUT0RPKCM3MDkyKTogRGVsZXRlIHRoaXMgZmlsZSBvbmNlIG1pZ3JhdGlvbiBpcyBjb21wbGV0ZSBhbmQgdGhlc2UgQW5ndWxhckpTXG4vLyBlcXVpdmFsZW50cyBvZiB0aGUgQW5ndWxhciBjb25zdGFudHMgYXJlIG5vIGxvbmdlciBuZWVkZWQuXG52YXIgaW50ZXJhY3Rpb25zX2V4dGVuc2lvbl9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCJpbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25zLWV4dGVuc2lvbi5jb25zdGFudHNcIik7XG4vLyBNaW5pbXVtIGNvbmZpZGVuY2UgcmVxdWlyZWQgZm9yIGEgcHJlZGljdGVkIGFuc3dlciBncm91cCB0byBiZSBzaG93biB0byB1c2VyLlxuLy8gR2VuZXJhbGx5IGEgdGhyZXNob2xkIG9mIDAuNy0wLjggaXMgYXNzdW1lZCB0byBiZSBhIGdvb2Qgb25lIGluIHByYWN0aWNlLFxuLy8gaG93ZXZlciB2YWx1ZSBuZWVkIG5vdCBiZSBpbiB0aG9zZSBib3VuZHMuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnQ09ERV9SRVBMX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQnLCBpbnRlcmFjdGlvbnNfZXh0ZW5zaW9uX2NvbnN0YW50c18xLkludGVyYWN0aW9uc0V4dGVuc2lvbnNDb25zdGFudHMuQ09ERV9SRVBMX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQpO1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuY29uc3RhbnQoJ0dSQVBIX0lOUFVUX0xFRlRfTUFSR0lOJywgaW50ZXJhY3Rpb25zX2V4dGVuc2lvbl9jb25zdGFudHNfMS5JbnRlcmFjdGlvbnNFeHRlbnNpb25zQ29uc3RhbnRzLkdSQVBIX0lOUFVUX0xFRlRfTUFSR0lOKTtcbi8vIEdpdmVzIHRoZSBzdGFmZi1saW5lcyBodW1hbiByZWFkYWJsZSB2YWx1ZXMuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5jb25zdGFudCgnTk9URV9OQU1FU19UT19NSURJX1ZBTFVFUycsIGludGVyYWN0aW9uc19leHRlbnNpb25fY29uc3RhbnRzXzEuSW50ZXJhY3Rpb25zRXh0ZW5zaW9uc0NvbnN0YW50cy5OT1RFX05BTUVTX1RPX01JRElfVkFMVUVTKTtcbi8vIE1pbmltdW0gY29uZmlkZW5jZSByZXF1aXJlZCBmb3IgYSBwcmVkaWN0ZWQgYW5zd2VyIGdyb3VwIHRvIGJlIHNob3duIHRvIHVzZXIuXG4vLyBHZW5lcmFsbHkgYSB0aHJlc2hvbGQgb2YgMC43LTAuOCBpcyBhc3N1bWVkIHRvIGJlIGEgZ29vZCBvbmUgaW4gcHJhY3RpY2UsXG4vLyBob3dldmVyIHZhbHVlIG5lZWQgbm90IGJlIGluIHRob3NlIGJvdW5kcy5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmNvbnN0YW50KCdURVhUX0lOUFVUX1BSRURJQ1RJT05fU0VSVklDRV9USFJFU0hPTEQnLCBpbnRlcmFjdGlvbnNfZXh0ZW5zaW9uX2NvbnN0YW50c18xLkludGVyYWN0aW9uc0V4dGVuc2lvbnNDb25zdGFudHMuVEVYVF9JTlBVVF9QUkVESUNUSU9OX1NFUlZJQ0VfVEhSRVNIT0xEKTtcbiIsIi8vIENvcHlyaWdodCAyMDE5IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWlyZXMgZm9yIGFsbCB0aGUgaW50ZXJhY3Rpb25zLlxuICovXG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvQ29kZVJlcGwvQ29kZVJlcGwudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9Db250aW51ZS9Db250aW51ZS50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL0RyYWdBbmREcm9wU29ydElucHV0L0RyYWdBbmREcm9wU29ydElucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvRW5kRXhwbG9yYXRpb24vRW5kRXhwbG9yYXRpb24udHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9GcmFjdGlvbklucHV0L0ZyYWN0aW9uSW5wdXQudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9HcmFwaElucHV0L0dyYXBoSW5wdXQudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JbWFnZUNsaWNrSW5wdXQvSW1hZ2VDbGlja0lucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvSW50ZXJhY3RpdmVNYXAudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9JdGVtU2VsZWN0aW9uSW5wdXQvSXRlbVNlbGVjdGlvbklucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTG9naWNQcm9vZi9Mb2dpY1Byb29mLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTWF0aEV4cHJlc3Npb25JbnB1dC9NYXRoRXhwcmVzc2lvbklucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVsdGlwbGVDaG9pY2VJbnB1dC9NdWx0aXBsZUNob2ljZUlucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L011c2ljTm90ZXNJbnB1dC50cycpO1xucmVxdWlyZSgnaW50ZXJhY3Rpb25zL051bWJlcldpdGhVbml0cy9OdW1iZXJXaXRoVW5pdHMudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9OdW1lcmljSW5wdXQvTnVtZXJpY0lucHV0LnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvUGVuY2lsQ29kZUVkaXRvci9QZW5jaWxDb2RlRWRpdG9yLnRzJyk7XG5yZXF1aXJlKCdpbnRlcmFjdGlvbnMvU2V0SW5wdXQvU2V0SW5wdXQudHMnKTtcbnJlcXVpcmUoJ2ludGVyYWN0aW9ucy9UZXh0SW5wdXQvVGV4dElucHV0LnRzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IExvYWRzIHNjcmlwdHMgbmVlZGVkIGZvciB1aS1sZWFmbGV0LlxuICovXG5yZXF1aXJlKCdzdGF0aWMvbGVhZmxldC0xLjQuMC9sZWFmbGV0LmpzJyk7XG5yZXF1aXJlKCdzdGF0aWMvYW5ndWxhci11aS1sZWFmbGV0LTEuMC4zL3VpLWxlYWZsZXQubWluLm5vLWhlYWRlci5qcycpO1xucmVxdWlyZSgnc3RhdGljL2FuZ3VsYXItc2ltcGxlLWxvZ2dlci0wLjEuNy9hbmd1bGFyLXNpbXBsZS1sb2dnZXIubWluLmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOSBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVpcmVzIGZvciBhbGwgdGhlIG9iamVjdCB0ZW1wbGF0ZXMuXG4gKi9cbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2Jvb2xlYW4tZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvY29kZS1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvY29vcmQtdHdvLWRpbS1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9kcmFnLWFuZC1kcm9wLWh0bWwtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2RyYWctYW5kLWRyb3AtcG9zaXRpdmUtaW50LWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2ZpbGVwYXRoLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2ZyYWN0aW9uLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2dyYXBoLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2dyYXBoLXByb3BlcnR5LWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2h0bWwtZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvaW1hZ2Utd2l0aC1yZWdpb25zLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2ludC1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9saXN0LW9mLXNldHMtb2YtaHRtbC1zdHJpbmdzLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2xpc3Qtb2YtdGFicy1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9saXN0LW9mLXVuaWNvZGUtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2xvZ2ljLWVycm9yLWNhdGVnb3J5LWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL2xvZ2ljLXF1ZXN0aW9uLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL21hdGgtbGF0ZXgtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL211c2ljLXBocmFzZS1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9ub25uZWdhdGl2ZS1pbnQtZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvbm9ybWFsaXplZC1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvbnVtYmVyLXdpdGgtdW5pdHMtZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvcGFyYW1ldGVyLW5hbWUtZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvcmVhbC1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9zYW5pdGl6ZWQtdXJsLWVkaXRvci5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ29iamVjdHMvdGVtcGxhdGVzL3NldC1vZi1odG1sLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdvYmplY3RzL3RlbXBsYXRlcy9zZXQtb2YtdW5pY29kZS1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xucmVxdWlyZSgnb2JqZWN0cy90ZW1wbGF0ZXMvdW5pY29kZS1zdHJpbmctZWRpdG9yLmRpcmVjdGl2ZS50cycpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGJvb2xlYW4gZWRpdG9yLlxuICovXG4vLyBUaGUgdmFsdWUgZm9yIHRoaXMgZWRpdG9yIGlzIGFsd2F5cyBlZGl0YWJsZS5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnYm9vbGVhbkVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvbXBvbmVudCBlYWNoIHRpbWUgdGhlIHZhbHVlIGNoYW5nZXMgKGUuZy4gaWYgdGhpcyBpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGFuIGVkaXRhYmxlIGxpc3QpLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZScsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuZXdWYWx1ZSB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmxvY2FsVmFsdWUubGFiZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9ib29sZWFuLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGNvZGUgc3RyaW5nIGVkaXRvci5cbiAqL1xuLy8gRXZlcnkgZWRpdG9yIGRpcmVjdGl2ZSBzaG91bGQgaW1wbGVtZW50IGFuIGFsd2F5c0VkaXRhYmxlIG9wdGlvbi4gVGhlcmVcbi8vIG1heSBiZSBhZGRpdGlvbmFsIGN1c3RvbWl6YXRpb24gb3B0aW9ucyBmb3IgdGhlIGVkaXRvciB0aGF0IHNob3VsZCBiZSBwYXNzZWRcbi8vIGluIHZpYSBpbml0QXJncy5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnY29kZVN0cmluZ0VkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBnZXRBbHdheXNFZGl0YWJsZTogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9jb2RlLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWx3YXlzRWRpdGFibGUgPSBjdHJsLmdldEFsd2F5c0VkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0V2FybmluZ1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5sb2NhbFZhbHVlLmxhYmVsLmluZGV4T2YoJ1xcdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ29kZSBtYXkgbm90IGNvbnRhaW4gdGFiIGNoYXJhY3RlcnMuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvbXBvbmVudCBlYWNoIHRpbWUgdGhlIHZhbHVlIGNoYW5nZXMgKGUuZy4gaWYgdGhpcyBpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGFuIGVkaXRhYmxlIGxpc3QpLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogY3RybC52YWx1ZSB8fCAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmxvY2FsVmFsdWUubGFiZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBjb29yZCB0d28gZGltIGVkaXRvci5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdjb29yZFR3b0RpbUVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5tYXBDZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IGN0cmwudmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsbmc6IGN0cmwudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubWFwTWFya2VycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5NYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IGN0cmwudmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBjdHJsLnZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25Vcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvaW50ZXJhY3Rpb25zL0ludGVyYWN0aXZlTWFwL3N0YXRpYy9tYXJrZXItaWNvbi5wbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU2l6ZTogWzI1LCA0MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkFuY2hvcjogWzEyLCA0MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1VybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvc3RhdGljL21hcmtlci1zaGFkb3cucG5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dTaXplOiBbNDEsIDQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0FuY2hvcjogWzEzLCA0MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uUmV0aW5hVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL2ludGVyYWN0aW9ucy9JbnRlcmFjdGl2ZU1hcC9zdGF0aWMvbWFya2VyLWljb24tMngucG5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1JldGluYVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9pbnRlcmFjdGlvbnMvSW50ZXJhY3RpdmVNYXAvc3RhdGljL21hcmtlci1zaGFkb3cucG5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubWFwRXZlbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiBbJ2NsaWNrJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naWM6ICdlbWl0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IFsnZHJhZ2VuZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljOiAnZW1pdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignbGVhZmxldERpcmVjdGl2ZU1hcC5jb29yZFR3b0RpbUVkaXRvci5jbGljaycsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdMYXQgPSBhcmdzLmxlYWZsZXRFdmVudC5sYXRsbmcubGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xuZyA9IGFyZ3MubGVhZmxldEV2ZW50LmxhdGxuZy5sbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gW25ld0xhdCwgbmV3TG5nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1hcmtlcihuZXdMYXQsIG5ld0xuZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdsZWFmbGV0RGlyZWN0aXZlTWFya2VyLmNvb3JkVHdvRGltRWRpdG9yLmRyYWdlbmQnLCBmdW5jdGlvbiAoZXZ0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gW2FyZ3MubW9kZWwubGF0LCBhcmdzLm1vZGVsLmxuZ107XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlTWFya2VyID0gZnVuY3Rpb24gKGxhdCwgbG5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1hcE1hcmtlcnMubWFpbk1hcmtlci5sYXQgPSBsYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1hcE1hcmtlcnMubWFpbk1hcmtlci5sbmcgPSBsbmc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9jb29yZC10d28tZGltLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGRyYWcgYW5kIGRyb3AgSFRNTCBzdHJpbmcgZWRpdG9yLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2RyYWdBbmREcm9wSHRtbFN0cmluZ0VkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBnZXRJbml0QXJnczogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9kcmFnLWFuZC1kcm9wLWh0bWwtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm5hbWUgPSBtYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdEFyZ3MgPSBjdHJsLmdldEluaXRBcmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2hvaWNlcyA9IGN0cmwuaW5pdEFyZ3MuY2hvaWNlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLnZhbHVlIHx8IGN0cmwudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gY3RybC5jaG9pY2VzWzBdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRJdGVtID0gY3RybC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gc2VsZWN0ZWRJdGVtO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgZHJhZyBhbmQgZHJvcCBwb3NpdGl2ZSBpbnQgZWRpdG9yLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2RyYWdBbmREcm9wUG9zaXRpdmVJbnRFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0SW5pdEFyZ3M6ICcmJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvZHJhZ19hbmRfZHJvcF9wb3NpdGl2ZV9pbnQtZWRpdG9yLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VJbnQoY3RybC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5zZWxlY3RlZFJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRSYW5rID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbGxvd2VkUmFua3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0QXJncyA9IGN0cmwuZ2V0SW5pdEFyZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jaG9pY2VzID0gY3RybC5pbml0QXJncy5jaG9pY2VzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwuY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hbGxvd2VkUmFua3MucHVzaChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0ZWRSYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gcGFyc2VJbnQoc2VsZWN0ZWRSYW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGZpbGVwYXRoIGVkaXRvci5cbiAqL1xuLy8gVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgY29udGV4dCBvZiBhbiBleHBsb3JhdGlvbi5cbnJlcXVpcmUoJ2NvbXBvbmVudHMvZm9ybXMvY3VzdG9tLWZvcm1zLWRpcmVjdGl2ZXMvaW1hZ2UtdXBsb2FkZXIuZGlyZWN0aXZlLnRzJyk7XG5yZXF1aXJlKCdkb21haW4vdXRpbGl0aWVzL1VybEludGVycG9sYXRpb25TZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9BbGVydHNTZXJ2aWNlLnRzJyk7XG5yZXF1aXJlKCdzZXJ2aWNlcy9Bc3NldHNCYWNrZW5kQXBpU2VydmljZS50cycpO1xucmVxdWlyZSgnc2VydmljZXMvQ29udGV4dFNlcnZpY2UudHMnKTtcbnJlcXVpcmUoJ3NlcnZpY2VzL0NzcmZUb2tlblNlcnZpY2UudHMnKTtcbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnZmlsZXBhdGhFZGl0b3InLCBbXG4gICAgJyRzY2UnLCAnQWxlcnRzU2VydmljZScsICdBc3NldHNCYWNrZW5kQXBpU2VydmljZScsXG4gICAgJ0NvbnRleHRTZXJ2aWNlJywgJ0NzcmZUb2tlblNlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uICgkc2NlLCBBbGVydHNTZXJ2aWNlLCBBc3NldHNCYWNrZW5kQXBpU2VydmljZSwgQ29udGV4dFNlcnZpY2UsIENzcmZUb2tlblNlcnZpY2UsIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9maWxlcGF0aC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNT0RFX0VNUFRZID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIE1PREVfVVBMT0FERUQgPSAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTU9ERV9TQVZFRCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdXNlIFBORyBmb3JtYXQgc2luY2UgdGhhdCBpcyB3aGF0IGNhbnZhcyBjYW4gZXhwb3J0IHRvIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhzbGwpOiBTZWUgaWYgd2UgY2FuIGFkZCBzdXBwb3J0IGZvciBvdGhlciBpbWFnZSBmb3JtYXRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgT1VUUFVUX0lNQUdFX0ZPUk1BVCA9ICdwbmcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgT1VUUFVUX0lNQUdFX01BWF9XSURUSF9QWCA9IDQ5MDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIENST1BfQk9SREVSX01BUkdJTl9QWCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgQ1JPUF9BUkVBX01JTl9XSURUSF9QWCA9IDQwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgQ1JPUF9BUkVBX01JTl9IRUlHSFRfUFggPSA0MDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F0ZWdvcml6ZSBtb3VzZSBwb3NpdGlvbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBjcm9wIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9UT1BfTEVGVCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9UT1AgPSAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTU9VU0VfVE9QX1JJR0hUID0gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX1JJR0hUID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX0JPVFRPTV9SSUdIVCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9CT1RUT00gPSA2O1xuICAgICAgICAgICAgICAgICAgICB2YXIgTU9VU0VfQk9UVE9NX0xFRlQgPSA3O1xuICAgICAgICAgICAgICAgICAgICB2YXIgTU9VU0VfTEVGVCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9JTlNJREUgPSA5O1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZpbmUgdGhlIGN1cnNvcnMgZm9yIHRoZSBjcm9wIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgIHZhciBDUk9QX0NVUlNPUlMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgQ1JPUF9DVVJTT1JTW01PVVNFX1RPUF9MRUZUXSA9ICdud3NlLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIENST1BfQ1VSU09SU1tNT1VTRV9UT1BdID0gJ25zLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIENST1BfQ1VSU09SU1tNT1VTRV9UT1BfUklHSFRdID0gJ25lc3ctcmVzaXplJztcbiAgICAgICAgICAgICAgICAgICAgQ1JPUF9DVVJTT1JTW01PVVNFX1JJR0hUXSA9ICdldy1yZXNpemUnO1xuICAgICAgICAgICAgICAgICAgICBDUk9QX0NVUlNPUlNbTU9VU0VfQk9UVE9NX1JJR0hUXSA9ICdud3NlLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIENST1BfQ1VSU09SU1tNT1VTRV9CT1RUT01dID0gJ25zLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIENST1BfQ1VSU09SU1tNT1VTRV9CT1RUT01fTEVGVF0gPSAnbmVzdy1yZXNpemUnO1xuICAgICAgICAgICAgICAgICAgICBDUk9QX0NVUlNPUlNbTU9VU0VfTEVGVF0gPSAnZXctcmVzaXplJztcbiAgICAgICAgICAgICAgICAgICAgQ1JPUF9DVVJTT1JTW01PVVNFX0lOU0lERV0gPSAnbW92ZSc7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbnMgKG5vdCB2aXNpYmxlIGluIHRoZSB2aWV3KSAqL1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogUmVzYW1wbGVzIGFuIGltYWdlIHRvIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW1hZ2VEYXRhVVJJIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGlucHV0IGltYWdlIGRhdGEgVVJJLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgb3V0cHV0IHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIG91dHB1dCBoZWlnaHQuXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gQSBET01TdHJpbmcgY29udGFpbmluZyB0aGUgb3V0cHV0IGltYWdlIGRhdGEgVVJJLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJlc2FtcGxlZEltYWdlRGF0YSA9IGZ1bmN0aW9uIChpbWFnZURhdGFVUkksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBJbWFnZSBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpbWFnZURhdGFVUkk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBDYW52YXMgYW5kIGRyYXcgdGhlIGltYWdlIG9uIGl0LCByZXNhbXBsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvJyArIE9VVFBVVF9JTUFHRV9GT1JNQVQsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ3JvcHMgYW4gaW1hZ2UgdG8gdGhlIHNwZWNpZmllZCByZWN0YW5ndWxhciByZWdpb24uXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpbWFnZURhdGFVUkkgQSBET01TdHJpbmcgY29udGFpbmluZyB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBVUkkuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB4IFRoZSB4IGNvb3JpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHkgVGhlIHkgY29vcmluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNyb3AgcmVnaW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiBBIERPTVN0cmluZyBjb250YWluaW5nIHRoZSBvdXRwdXQgaW1hZ2UgZGF0YSBVUkkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Q3JvcHBlZEltYWdlRGF0YSA9IGZ1bmN0aW9uIChpbWFnZURhdGFVUkksIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgb3JpZ2luYWwgaW1hZ2UgaW4gYSBjYW52YXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1hZ2VEYXRhVVJJO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBmb3IgYSBjcm9wcGVkIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERyYXcgb24gYSBzZXBhcmF0ZSBjYW52YXMgYW5kIHJldHVybiB0aGUgZGF0YVVSTC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcm9wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcm9wQ3R4ID0gY3JvcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JvcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyBPVVRQVVRfSU1BR0VfRk9STUFULCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRJbWFnZURhdGFUb0ltYWdlRmlsZSA9IGZ1bmN0aW9uIChkYXRhVVJJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGJhc2U2NC9VUkxFbmNvZGVkIGRhdGEgY29tcG9uZW50IHRvIHJhdyBiaW5hcnkgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVsZCBpbiBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW1lID0gZGF0YVVSSS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGEgdHlwZWQgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2lhXSwgeyB0eXBlOiBtaW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2IudHlwZS5tYXRjaCgnaW1hZ2UnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Iuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0RXZlbnRDb29yaW5kYXRlc1JlbGF0aXZlVG9JbWFnZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgZXZlbnQgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byB0aGUgaW1hZ2UgY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50cyBzZWVtIHRvIGJlIHJlcG9ydGVkIHdpdGggJ3RhcmdldCcgc2V0IHRvIHRoZSBkZWVwZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC4gSW4gb3RoZXIgd29yZHMsIGlmIHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXJyZWQgb3V0c2lkZSBvZiB0aGUgY3JvcCBhcmVhLCB0aGVuIHRoZSAoeCwgeSkgcmVwb3J0ZWQgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9uZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGltYWdlIGNvbnRhaW5lciwgYnV0IGlmIHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXJzIGluc2lkZSB0aGUgY3JvcCBhcmVhLCB0aGVuIHRoZSAoeCwgeSkgcmVwb3J0ZWQgd2lsbCBiZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGNyb3AgYXJlYSBpdHNlbGYuIFNvIHRoaXMgZnVuY3Rpb24gZG9lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBvbiB0aGUgKHgsIHkpIHZhbHVlcyBzbyB0aGF0IHRoZXkgYXJlIGFsd2F5cyByZXBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBpbWFnZSBjb250YWluZXIgKG1ha2VzIGNhbGN1bGF0aW9ucyBlYXNpZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJDbGFzcyA9ICdmaWxlcGF0aC1lZGl0b3ItaW1hZ2UtY3JvcC1jb250YWluZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY29udGFpbmVyQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBub2RlLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZU1vdXNlTW92ZVdoaWxlRHJhZ2dpbmdDcm9wQXJlYSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeERvd24gPSBjdHJsLmxhc3RNb3VzZURvd25FdmVudENvb3JkaW5hdGVzLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeURvd24gPSBjdHJsLmxhc3RNb3VzZURvd25FdmVudENvb3JkaW5hdGVzLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDFXaGVuRG93biA9IGN0cmwuY3JvcEFyZWFYV2hlbkxhc3REb3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkxV2hlbkRvd24gPSBjdHJsLmNyb3BBcmVhWVdoZW5MYXN0RG93bjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgcG9zaXRpb24gb2YgdGhlIGNyb3AgYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHgxV2hlbkRvd24gKyAoeCAtIHhEb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHkxV2hlbkRvd24gKyAoeSAtIHlEb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgZm9yIGJvdW5kYXJpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGN0cmwuY2FsY3VsYXRlVGFyZ2V0SW1hZ2VEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JvcFdpZHRoID0gY3RybC5jcm9wQXJlYS54MiAtIGN0cmwuY3JvcEFyZWEueDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JvcEhlaWdodCA9IGN0cmwuY3JvcEFyZWEueTIgLSBjdHJsLmNyb3BBcmVhLnkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjbGFtcCh4MSwgMCwgZGltZW5zaW9ucy53aWR0aCAtIGNyb3BXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNsYW1wKHkxLCAwLCBkaW1lbnNpb25zLmhlaWdodCAtIGNyb3BIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNyb3AgYXJlYSBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEueDEgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEueTEgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEueDIgPSB4MSArIGNyb3BXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEueTIgPSB5MSArIGNyb3BIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVNb3VzZU1vdmVXaGlsZVJlc2l6aW5nQ3JvcEFyZWEgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBjdHJsLmNhbGN1bGF0ZVRhcmdldEltYWdlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGN0cmwuY3JvcEFyZWFSZXNpemVEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0UmVzaXplTGVmdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNyb3AgYXJlYSB4MSB2YWx1ZSwgY29ycmVjdGluZyBmb3IgYm91bmRhcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhLngxID0gY2xhbXAoeCwgMCwgY3RybC5jcm9wQXJlYS54MiAtIENST1BfQVJFQV9NSU5fV0lEVEhfUFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RSZXNpemVSaWdodCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNyb3AgYXJlYSB4MiB2YWx1ZSwgY29ycmVjdGluZyBmb3IgYm91bmRhcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhLngyID0gY2xhbXAoeCwgQ1JPUF9BUkVBX01JTl9XSURUSF9QWCArIGN0cmwuY3JvcEFyZWEueDEsIGRpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RSZXNpemVUb3AgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjcm9wIGFyZWEgeTEgdmFsdWUsIGNvcnJlY3RpbmcgZm9yIGJvdW5kYXJpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jcm9wQXJlYS55MSA9IGNsYW1wKHksIDAsIGN0cmwuY3JvcEFyZWEueTIgLSBDUk9QX0FSRUFfTUlOX0hFSUdIVF9QWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdFJlc2l6ZUJvdHRvbSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNyb3AgYXJlYSB5MiB2YWx1ZSwgY29ycmVjdGluZyBmb3IgYm91bmRhcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhLnkyID0gY2xhbXAoeSwgQ1JPUF9BUkVBX01JTl9IRUlHSFRfUFggKyBjdHJsLmNyb3BBcmVhLnkxLCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1PVVNFX1RPUF9MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVUb3AoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFJlc2l6ZUxlZnQoeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTU9VU0VfVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVUb3AoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTU9VU0VfVE9QX1JJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVUb3AoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFJlc2l6ZVJpZ2h0KHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1PVVNFX1JJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVSaWdodCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNT1VTRV9CT1RUT01fUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFJlc2l6ZUJvdHRvbSh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0UmVzaXplUmlnaHQoeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTU9VU0VfQk9UVE9NOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVCb3R0b20oeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTU9VU0VfQk9UVE9NX0xFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFJlc2l6ZUJvdHRvbSh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0UmVzaXplTGVmdCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNT1VTRV9MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RSZXNpemVMZWZ0KHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBvc2l0aW9uV2l0aGluQ3JvcEFyZWEgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IENST1BfQk9SREVSX01BUkdJTl9QWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeDEgPSBjdHJsLmNyb3BBcmVhLngxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5MSA9IGN0cmwuY3JvcEFyZWEueTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3gyID0gY3RybC5jcm9wQXJlYS54MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeTIgPSBjdHJsLmNyb3BBcmVhLnkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhPbkxlZnRCb3JkZXIgPSB4ID4gY3gxIC0gbWFyZ2luICYmIHggPCBjeDEgKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE9uUmlnaHRCb3JkZXIgPSB4ID4gY3gyIC0gbWFyZ2luICYmIHggPCBjeDIgKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9uVG9wQm9yZGVyID0geSA+IGN5MSAtIG1hcmdpbiAmJiB5IDwgY3kxICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlPbkJvdHRvbUJvcmRlciA9IHkgPiBjeTIgLSBtYXJnaW4gJiYgeSA8IGN5MiArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4SW5zaWRlID0geCA+IGN4MSAmJiB4IDwgY3gyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlJbnNpZGUgPSB5ID4gY3kxICYmIHkgPCBjeTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHBvaW50ZXIgcG9zaXRpb24gZm9yIGNvcm5lcnMgZmlyc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY29uZGl0aW9ucyBvdmVybGFwLiBJbiBvdGhlciB3b3JkcywgdGhlIHBvaW50ZXIgY2FuIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgdG9wIGJvcmRlciBhbmQgYXQgdGhlIHRvcC1yaWdodCBjb3JuZXIgYXQgdGhlIHNhbWUgdGltZSwgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byByZWNvZ25pemUgdGhlIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4T25MZWZ0Qm9yZGVyICYmIHlPblRvcEJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIGxlZnQgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfVE9QX0xFRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4T25SaWdodEJvcmRlciAmJiB5T25Ub3BCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcHBlciByaWdodCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVBvc2l0aW9uV2l0aGluQ3JvcEFyZWEgPSBNT1VTRV9UT1BfUklHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4T25MZWZ0Qm9yZGVyICYmIHlPbkJvdHRvbUJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvd2VyIGxlZnQgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfQk9UVE9NX0xFRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4T25SaWdodEJvcmRlciAmJiB5T25Cb3R0b21Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciByaWdodCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVBvc2l0aW9uV2l0aGluQ3JvcEFyZWEgPSBNT1VTRV9CT1RUT01fUklHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh5T25Ub3BCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3AgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfVE9QO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeE9uTGVmdEJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfTEVGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhPblJpZ2h0Qm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfUklHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh5T25Cb3R0b21Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3R0b20gYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhID0gTU9VU0VfQk9UVE9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeEluc2lkZSAmJiB5SW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zaWRlIHRoZSBjcm9wIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVBvc2l0aW9uV2l0aGluQ3JvcEFyZWEgPSBNT1VTRV9JTlNJREU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlUG9zaXRpb25XaXRoaW5Dcm9wQXJlYSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRUcnVzdGVkUmVzb3VyY2VVcmxGb3JJbWFnZUZpbGVOYW1lID0gZnVuY3Rpb24gKGltYWdlRmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkRmlsZXBhdGggPSB3aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50KGltYWdlRmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKEFzc2V0c0JhY2tlbmRBcGlTZXJ2aWNlLmdldEltYWdlVXJsRm9yUHJldmlldyhjdHJsLmVudGl0eVR5cGUsIGN0cmwuZW50aXR5SWQsIGVuY29kZWRGaWxlcGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKiogU2NvcGUgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnMgKHZpc2libGVzIHRvIHRoZSB2aWV3KSAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY29tcG9uZW50IGVhY2ggdGltZSB0aGUgdmFsdWUgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAvLyAoZS5nLiBpZiB0aGlzIGlzIHBhcnQgb2YgYW4gZWRpdGFibGUgbGlzdCkuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLnZhbHVlJywgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNldFNhdmVkSW1hZ2VGaWxlbmFtZShuZXdWYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNldEZpbGVQYXRoRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5kYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IE1PREVfRU1QVFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZVJlc2l6ZVJhdGlvID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC52YWxpZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tb2RlID09PSBNT0RFX1NBVkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tZXRhZGF0YS5zYXZlZEltYWdlRmlsZW5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1ldGFkYXRhLnNhdmVkSW1hZ2VGaWxlbmFtZS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzVXNlckNyb3BwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBjdHJsLmNhbGN1bGF0ZVRhcmdldEltYWdlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3BXaWR0aCA9IGN0cmwuY3JvcEFyZWEueDIgLSBjdHJsLmNyb3BBcmVhLngxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3BIZWlnaHQgPSBjdHJsLmNyb3BBcmVhLnkyIC0gY3RybC5jcm9wQXJlYS55MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9wV2lkdGggPCBkaW1lbnNpb25zLndpZHRoIHx8IGNyb3BIZWlnaHQgPCBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbk1vdXNlTW92ZU9uSW1hZ2VBcmVhID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBnZXRFdmVudENvb3JpbmRhdGVzUmVsYXRpdmVUb0ltYWdlQ29udGFpbmVyKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudXNlcklzRHJhZ2dpbmdDcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZVdoaWxlRHJhZ2dpbmdDcm9wQXJlYShjb29yZHMueCwgY29vcmRzLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC51c2VySXNSZXNpemluZ0Nyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VNb3ZlV2hpbGVSZXNpemluZ0Nyb3BBcmVhKGNvb3Jkcy54LCBjb29yZHMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbldpdGhpbkNyb3BBcmVhKGNvb3Jkcy54LCBjb29yZHMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlTGFzdEtub3duQ29vcmRpbmF0ZXMgPSB7IHg6IGNvb3Jkcy54LCB5OiBjb29yZHMueSB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uTW91c2VEb3duT25Dcm9wQXJlYSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gZ2V0RXZlbnRDb29yaW5kYXRlc1JlbGF0aXZlVG9JbWFnZUNvbnRhaW5lcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBNT1VTRV9JTlNJREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxhc3RNb3VzZURvd25FdmVudENvb3JkaW5hdGVzID0geyB4OiBjb29yZHMueCwgeTogY29vcmRzLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhWFdoZW5MYXN0RG93biA9IGN0cmwuY3JvcEFyZWEueDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jcm9wQXJlYVlXaGVuTGFzdERvd24gPSBjdHJsLmNyb3BBcmVhLnkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlcklzRHJhZ2dpbmdDcm9wQXJlYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFzdE1vdXNlRG93bkV2ZW50Q29vcmRpbmF0ZXMgPSB7IHg6IGNvb3Jkcy54LCB5OiBjb29yZHMueSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlcklzUmVzaXppbmdDcm9wQXJlYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jcm9wQXJlYVJlc2l6ZURpcmVjdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uTW91c2VVcE9uQ3JvcEFyZWEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNEcmFnZ2luZ0Nyb3BBcmVhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc1Jlc2l6aW5nQ3JvcEFyZWEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRNYWluQ29udGFpbmVyRHluYW1pY1N0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IE9VVFBVVF9JTUFHRV9NQVhfV0lEVEhfUFg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3dpZHRoOiAnICsgd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldEltYWdlQ29udGFpbmVyRHluYW1pY1N0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmRhdGEubW9kZSA9PT0gTU9ERV9FTVBUWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYm9yZGVyOiAxcHggZG90dGVkICM4ODgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdib3JkZXI6IG5vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldFRvb2xiYXJEeW5hbWljU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaXNVc2VyQ3JvcHBpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndmlzaWJpbGl0eTogaGlkZGVuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndmlzaWJpbGl0eTogdmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q3JvcEJ1dHRvbkJhckR5bmFtaWNTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQ6ICcgKyBjdHJsLmNyb3BBcmVhLngyICsgJ3B4OycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b3A6ICcgKyBjdHJsLmNyb3BBcmVhLnkxICsgJ3B4Oyc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q3JvcEFyZWFEeW5hbWljU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3BXaWR0aCA9IGN0cmwuY3JvcEFyZWEueDIgLSBjdHJsLmNyb3BBcmVhLngxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3BIZWlnaHQgPSBjdHJsLmNyb3BBcmVhLnkyIC0gY3RybC5jcm9wQXJlYS55MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGN0cmwubW91c2VQb3NpdGlvbldpdGhpbkNyb3BBcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24sIHNpemUsIGN1cnNvciBhbmQgYmFja2dyb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY3RybC5jcm9wQXJlYS54MSArICdweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjdHJsLmNyb3BBcmVhLnkxICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3JvcFdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNyb3BIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogQ1JPUF9DVVJTT1JTW3Bvc2l0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbHVjZW50IGJhY2tncm91bmQgbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pc1VzZXJDcm9wcGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAndXJsKCcgKyBjdHJsLmRhdGEubWV0YWRhdGEudXBsb2FkZWRJbWFnZURhdGEgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLmJhY2tncm91bmQgPSBkYXRhICsgJyBuby1yZXBlYXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gY3RybC5jcm9wQXJlYS54MSArIDM7IC8vIEFkZCBjcm9wIGFyZWEgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gY3RybC5jcm9wQXJlYS55MSArIDM7IC8vIEFkZCBjcm9wIGFyZWEgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1snYmFja2dyb3VuZC1wb3NpdGlvbiddID0gJy0nICsgeCArICdweCAtJyArIHkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gY3RybC5jYWxjdWxhdGVUYXJnZXRJbWFnZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbJ2JhY2tncm91bmQtc2l6ZSddID0gZGltZW5zaW9ucy53aWR0aCArICdweCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgJzogJyArIHN0eWxlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRVcGxvYWRlZEltYWdlRHluYW1pY1N0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gY3RybC5jYWxjdWxhdGVUYXJnZXRJbWFnZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3dpZHRoOiAnICsgdyArICdweDsgaGVpZ2h0OiAnICsgaCArICdweDsnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNvbmZpcm1Dcm9wSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGNvb3JkaW5hdGVzIG9mIHRoZSBjcm9wcGVkIGFyZWEgd2l0aGluIG9yaWdpbmFsIGltYWdlIHNjYWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBjdHJsLmNhbGN1bGF0ZVRhcmdldEltYWdlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjdHJsLmRhdGEubWV0YWRhdGEub3JpZ2luYWxXaWR0aCAvIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBjdHJsLmNyb3BBcmVhLngxICogcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IGN0cmwuY3JvcEFyZWEueTEgKiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gKGN0cmwuY3JvcEFyZWEueDIgLSBjdHJsLmNyb3BBcmVhLngxKSAqIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGN0cmwuY3JvcEFyZWEueTIgLSBjdHJsLmNyb3BBcmVhLnkxKSAqIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgaW1hZ2UgZGF0YSBhbmQgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbWFnZURhdGEgPSBnZXRDcm9wcGVkSW1hZ2VEYXRhKGN0cmwuZGF0YS5tZXRhZGF0YS51cGxvYWRlZEltYWdlRGF0YSwgeDEsIHkxLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbWFnZUZpbGUgPSBjb252ZXJ0SW1hZ2VEYXRhVG9JbWFnZUZpbGUobmV3SW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbWFnZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5kYXRhLm1ldGFkYXRhLnVwbG9hZGVkRmlsZSA9IG5ld0ltYWdlRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZGF0YS5tZXRhZGF0YS51cGxvYWRlZEltYWdlRGF0YSA9IG5ld0ltYWdlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZGF0YS5tZXRhZGF0YS5vcmlnaW5hbFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhdGEubWV0YWRhdGEub3JpZ2luYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1jYWxjdWxhdGUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJhc2UgaW1hZ2UgYW5kIHJlc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGNyb3AgYXJlYSB0byB0aGUgYm91bmRhcmllcyBvZiB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGN0cmwuY2FsY3VsYXRlVGFyZ2V0SW1hZ2VEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBkaW1lbnNpb25zLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jYW5jZWxDcm9wSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGN0cmwuY2FsY3VsYXRlVGFyZ2V0SW1hZ2VEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhLngxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEueTEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jcm9wQXJlYS54MiA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNyb3BBcmVhLnkyID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0SW1hZ2VTaXplSGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVdpZHRoID0gY3RybC5kYXRhLm1ldGFkYXRhLm9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5pbWFnZVJlc2l6ZVJhdGlvID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA+IE9VVFBVVF9JTUFHRV9NQVhfV0lEVEhfUFgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgaW1hZ2UgaGFzIGJlZW4gYXV0b21hdGljYWxseSBkb3duc2l6ZWQgdG8gZW5zdXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhhdCBpdCB3aWxsIGZpdCBpbiB0aGUgY2FyZC4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNOb0ltYWdlVXBsb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC5kYXRhLm1vZGUgPT09IE1PREVfRU1QVFk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaXNJbWFnZVVwbG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmwuZGF0YS5tb2RlID09PSBNT0RFX1VQTE9BREVEO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmlzSW1hZ2VTYXZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLmRhdGEubW9kZSA9PT0gTU9ERV9TQVZFRDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRDdXJyZW50UmVzaXplUGVyY2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKDEwMCAqIGN0cmwuaW1hZ2VSZXNpemVSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZGVjcmVhc2VSZXNpemVQZXJjZW50ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IHRvIGRlY3JlYXNlIHNpemUgYmVsb3cgMTAlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZVJlc2l6ZVJhdGlvID0gTWF0aC5tYXgoMC4xLCBjdHJsLmltYWdlUmVzaXplUmF0aW8gLSBhbW91bnQgLyAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmluY3JlYXNlUmVzaXplUGVyY2VudCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyB0byBpbmNyZWFzZSBzaXplIGFib3ZlIDEwMCUgKG9ubHkgZG93bnNpemUgYWxsb3dlZCkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmltYWdlUmVzaXplUmF0aW8gPSBNYXRoLm1pbigxLCBjdHJsLmltYWdlUmVzaXplUmF0aW8gKyBhbW91bnQgLyAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNhbGN1bGF0ZVRhcmdldEltYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGN0cmwuZGF0YS5tZXRhZGF0YS5vcmlnaW5hbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGN0cmwuZGF0YS5tZXRhZGF0YS5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IE9VVFBVVF9JTUFHRV9NQVhfV0lEVEhfUFgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IE9VVFBVVF9JTUFHRV9NQVhfV0lEVEhfUFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQod2lkdGggKiBjdHJsLmltYWdlUmVzaXplUmF0aW8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChoZWlnaHQgKiBjdHJsLmltYWdlUmVzaXplUmF0aW8pXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNldFVwbG9hZGVkRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBNT0RFX1VQTE9BREVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRJbWFnZURhdGE6IGUudGFyZ2V0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFdpZHRoOiBpbWcubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBpbWcubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGN0cmwuY2FsY3VsYXRlVGFyZ2V0SW1hZ2VEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI6IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogZGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IChlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnNldFNhdmVkSW1hZ2VGaWxlbmFtZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgdXBkYXRlUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogTU9ERV9TQVZFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlZEltYWdlRmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlZEltYWdlVXJsOiBnZXRUcnVzdGVkUmVzb3VyY2VVcmxGb3JJbWFnZUZpbGVOYW1lKGZpbGVuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnRzU2VydmljZS5jbGVhcldhcm5pbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uRmlsZUNoYW5nZWQgPSBmdW5jdGlvbiAoZmlsZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0VXBsb2FkZWRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmRpc2NhcmRVcGxvYWRlZEZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlc2V0RmlsZVBhdGhFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zYXZlVXBsb2FkZWRGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnRzU2VydmljZS5jbGVhcldhcm5pbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuZGF0YS5tZXRhZGF0YS51cGxvYWRlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGVydHNTZXJ2aWNlLmFkZFdhcm5pbmcoJ05vIGltYWdlIGZpbGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBjdHJsLmNhbGN1bGF0ZVRhcmdldEltYWdlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2FtcGxlZEltYWdlRGF0YSA9IGdldFJlc2FtcGxlZEltYWdlRGF0YShjdHJsLmRhdGEubWV0YWRhdGEudXBsb2FkZWRJbWFnZURhdGEsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNhbXBsZWRGaWxlID0gY29udmVydEltYWdlRGF0YVRvSW1hZ2VGaWxlKHJlc2FtcGxlZEltYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzYW1wbGVkRmlsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsZXJ0c1NlcnZpY2UuYWRkV2FybmluZygnQ291bGQgbm90IGdldCByZXNhbXBsZWQgZmlsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoJ2ltYWdlJywgcmVzYW1wbGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZCgncGF5bG9hZCcsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogY3RybC5nZW5lcmF0ZUltYWdlRmlsZW5hbWUoZGltZW5zaW9ucy5oZWlnaHQsIGRpbWVuc2lvbnMud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VVcGxvYWRVcmxUZW1wbGF0ZSA9ICcvY3JlYXRlaGFuZGxlci9pbWFnZXVwbG9hZC8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGVudGl0eV90eXBlPi88ZW50aXR5X2lkPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBDc3JmVG9rZW5TZXJ2aWNlLmdldFRva2VuQXN5bmMoKS50aGVuKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKCdjc3JmX3Rva2VuJywgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuaW50ZXJwb2xhdGVVcmwoaW1hZ2VVcGxvYWRVcmxUZW1wbGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5X3R5cGU6IGN0cmwuZW50aXR5VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eV9pZDogY3RybC5lbnRpdHlJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgWFNTSSBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWREYXRhID0gZGF0YS5zdWJzdHJpbmcoNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0cmFuc2Zvcm1lZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ3RleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmUtbG9hZCBpbWFnZSBiZWZvcmUgbWFya2luZyB0aGUgaW1hZ2UgYXMgc2F2ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0U2F2ZWRJbWFnZUZpbGVuYW1lKGRhdGEuZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gZ2V0VHJ1c3RlZFJlc291cmNlVXJsRm9ySW1hZ2VGaWxlTmFtZShkYXRhLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgWFNTSSBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZERhdGEgPSBkYXRhLnJlc3BvbnNlVGV4dC5zdWJzdHJpbmcoNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UodHJhbnNmb3JtZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnRzU2VydmljZS5hZGRXYXJuaW5nKHBhcnNlZFJlc3BvbnNlLmVycm9yIHx8ICdFcnJvciBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZW5lcmF0ZUltYWdlRmlsZW5hbWUgPSBmdW5jdGlvbiAoaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbWdfJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJzAnICsgKGRhdGUuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnMCcgKyBkYXRlLmdldERhdGUoKSkuc2xpY2UoLTIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnMCcgKyBkYXRlLmdldEhvdXJzKCkpLnNsaWNlKC0yKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCcwJyArIGRhdGUuZ2V0TWludXRlcygpKS5zbGljZSgtMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnMCcgKyBkYXRlLmdldFNlY29uZHMoKSkuc2xpY2UoLTIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdfaGVpZ2h0XycgKyBoZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdfd2lkdGhfJyArIHdpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLicgKyBPVVRQVVRfSU1BR0VfRk9STUFUO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHZhcmlhYmxlIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbWFnZSB1cGxvYWQgZmxvdy5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhbHdheXMgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSAnbW9kZScgYW5kICdtZXRhZGF0YScgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGJlbG93IGEgZGVzY3JpcHRpb24gb2YgZWFjaCBtb2RlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBNT0RFX0VNUFRZOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIFRoZSB1c2VyIGhhcyBub3QgdXBsb2FkZWQgYW4gaW1hZ2UgeWV0LlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEluIHRoaXMgbW9kZSwgZGF0YS5tZXRhZGF0YSB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHt9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIE1PREVfVVBMT0FERUQ6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgVGhlIHVzZXIgaGFzIHVwbG9hZGVkIGFuIGltYWdlIGJ1dCBpdCBpcyBub3QgeWV0IHNhdmVkLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEFsbCB0aGUgY3JvcCBhbmQgcmVzaXppbmcgaGFwcGVucyBhdCB0aGlzIHN0YWdlLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEluIHRoaXMgbW9kZSwgZGF0YS5tZXRhZGF0YSB3aWxsIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBpbmZvOlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB1cGxvYWRlZEZpbGU6IDxhIEZpbGUgb2JqZWN0PixcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgdXBsb2FkZWRJbWFnZURhdGE6IDxiaW5hcnkgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbWFnZT4sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIG9yaWdpbmFsV2lkdGg6IDxvcmlnaW5hbCB3aWR0aCBvZiB0aGUgdXBsb2FkZWQgaW1hZ2U+LFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBvcmlnaW5hbEhlaWdodDogPG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgdXBsb2FkZWQgaW1hZ2U+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIE1PREVfU0FWRUQ6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgVGhlIHVzZXIgaGFzIHNhdmVkIHRoZSBmaW5hbCBpbWFnZSBmb3IgdXNlIGluIE9wcGlhLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEF0IHRoaXMgc3RhZ2UsIHRoZSB1c2VyIGNhbiBjbGljayBvbiB0aGUgdHJhc2ggdG8gc3RhcnQgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gICBJbiB0aGlzIG1vZGUsIGRhdGEubWV0YWRhdGEgd2lsbCBjb250YWluIHRoZSBmb2xsb3dpbmcgaW5mbzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc2F2ZWRJbWFnZUZpbGVuYW1lOiA8RmlsZSBuYW1lIG9mIHRoZSByZXNvdXJjZSBmb3IgdGhlIGltYWdlPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzYXZlZEltYWdlVXJsOiA8VHJ1c3RlZCByZXNvdXJjZSBVcmwgZm9yIHRoZSBpbWFnZT5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5kYXRhID0geyBtb2RlOiBNT0RFX0VNUFRZLCBtZXRhZGF0YToge30gfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzaXppbmcgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbWFnZVJlc2l6ZVJhdGlvID0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JvcHBpbmcgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgY3RybC5jcm9wQXJlYSA9IHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVBvc2l0aW9uV2l0aGluQ3JvcEFyZWEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlTGFzdEtub3duQ29vcmRpbmF0ZXMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5sYXN0TW91c2VEb3duRXZlbnRDb29yZGluYXRlcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0RyYWdnaW5nQ3JvcEFyZWEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNSZXNpemluZ0Nyb3BBcmVhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY3JvcEFyZWFSZXNpemVEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVudGl0eUlkID0gQ29udGV4dFNlcnZpY2UuZ2V0RW50aXR5SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5lbnRpdHlUeXBlID0gQ29udGV4dFNlcnZpY2UuZ2V0RW50aXR5VHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLnJlc2V0RmlsZVBhdGhFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNEcmFnZ2luZ0Nyb3BBcmVhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc1Jlc2l6aW5nQ3JvcEFyZWEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgZnJhY3Rpb24gZWRpdG9yLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2ZyYWN0aW9uRWRpdG9yJywgW1xuICAgICdGcmFjdGlvbk9iamVjdEZhY3RvcnknLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChGcmFjdGlvbk9iamVjdEZhY3RvcnksIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9mcmFjdGlvbi1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uU3RyaW5nID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRGcmFjdGlvbiA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tRGljdChjdHJsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uU3RyaW5nID0gZGVmYXVsdEZyYWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZyYWN0aW9uU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmxvY2FsVmFsdWUubGFiZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IEZyYWN0aW9uT2JqZWN0RmFjdG9yeS5mcm9tUmF3SW5wdXRTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHBhcnNpbmdFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHBhcnNpbmdFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRXYXJuaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBncmFwaCBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2dyYXBoRWRpdG9yJywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9ncmFwaC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbHdheXNFZGl0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBncmFwaCBwcm9wZXJ0eSBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2dyYXBoUHJvcGVydHlFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2dyYXBoLXByb3BlcnR5LWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbHdheXNFZGl0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ3JhcGhQcm9wZXJ0aWVzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVndWxhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZU5hbWU6ICdyZWd1bGFyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhY3ljbGljJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodW1hblJlYWRhYmxlTmFtZTogJ2FjeWNsaWMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0cm9uZ2x5X2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZU5hbWU6ICdzdHJvbmdseSBjb25uZWN0ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3dlYWtseV9jb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bWFuUmVhZGFibGVOYW1lOiAnd2Vha2x5IGNvbm5lY3RlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogY3RybC5ncmFwaFByb3BlcnRpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLmdyYXBoUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuZ3JhcGhQcm9wZXJ0aWVzW2ldLm5hbWUgPT09IGN0cmwudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWUucHJvcGVydHkgPSBjdHJsLmdyYXBoUHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC5sb2NhbFZhbHVlLnByb3BlcnR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IGN0cmwubG9jYWxWYWx1ZS5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIEhUTUwgZWRpdG9yLlxuICovXG4vLyBFdmVyeSBlZGl0b3IgZGlyZWN0aXZlIHNob3VsZCBpbXBsZW1lbnQgYW4gYWx3YXlzRWRpdGFibGUgb3B0aW9uLiBUaGVyZVxuLy8gbWF5IGJlIGFkZGl0aW9uYWwgY3VzdG9taXphdGlvbiBvcHRpb25zIGZvciB0aGUgZWRpdG9yIHRoYXQgc2hvdWxkIGJlIHBhc3NlZFxuLy8gaW4gdmlhIGluaXRBcmdzLlxuLy9cbi8vIFRoaXMgZGlyZWN0aXZlIGlzIGJhc2VkIG9uIHRoZSBVbmljb2RlU3RyaW5nIGRpcmVjdGl2ZS5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnaHRtbEVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvaHRtbC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGltYWdlIHdpdGggcmVnaW9ucyBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG4vLyBUT0RPKGN6eCk6IFVuaXF1aWZ5IHRoZSBsYWJlbHMgb2YgaW1hZ2UgcmVnaW9uc1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdpbWFnZVdpdGhSZWdpb25zRWRpdG9yJywgW1xuICAgICdBc3NldHNCYWNrZW5kQXBpU2VydmljZScsXG4gICAgJ0NvbnRleHRTZXJ2aWNlJywgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJywgJ0VOVElUWV9UWVBFJyxcbiAgICBmdW5jdGlvbiAoQXNzZXRzQmFja2VuZEFwaVNlcnZpY2UsIENvbnRleHRTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSwgRU5USVRZX1RZUEUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2ltYWdlLXdpdGgtcmVnaW9ucy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgICAgICAgICAnJHNjb3BlJywgJyRlbGVtZW50JywgJyR1aWJNb2RhbCcsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICR1aWJNb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWx3YXlzRWRpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljYWxseSBkZWZpbmVzIHRoZSBDU1Mgc3R5bGUgZm9yIHRoZSByZWdpb24gcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldFJlZ2lvblN0eWxlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGN0cmwuc2VsZWN0ZWRSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2ZpbGw6ICMwMGY7IG9wYWNpdHk6IDAuNTsgc3Ryb2tlOiAjMDBkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmlsbDogd2hpdGU7IG9wYWNpdHk6IDAuNTsgc3Ryb2tlOiAjZGRkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pY2FsbHkgZGVmaW5lcyB0aGUgQ1NTIHN0eWxlIGZvciB0aGUgcmVnaW9uIHRyYXNoIGljb24uXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0UmVnaW9uVHJhc2hTdHlsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBjdHJsLnNlbGVjdGVkUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmaWxsOiAjZWVlOyBvcGFjaXR5OiAwLjcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmaWxsOiAjMzMzOyBvcGFjaXR5OiAwLjcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljYWxseSBkZWZpbmVzIHRoZSBDU1Mgc3R5bGUgZm9yIHRoZSByZWdpb24gbGFiZWwuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0UmVnaW9uTGFiZWxTdHlsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1vblN0eWxlcyA9ICdmb250LXNpemU6IDE0cHg7IHBvaW50ZXItZXZlbnRzOiBub25lOyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGN0cmwuc2VsZWN0ZWRSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uU3R5bGVzICsgJyBmaWxsOiAjZWVlOyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25TdHlsZXMgKyAnIGZpbGw6ICMzMzM7IHZpc2liaWxpdHk6IHZpc2libGU7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pY2FsbHkgZGVmaW5lcyB0aGUgQ1NTIHN0eWxlIGZvciB0aGUgcmVnaW9uIGxhYmVsIHRleHQgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0UmVnaW9uTGFiZWxFZGl0b3JTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnNlbGVjdGVkUmVnaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5OiBub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmVhID0gY29ybmVyQW5kRGltZW5zaW9uc0Zyb21SZWdpb25BcmVhKGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnNbY3RybC5zZWxlY3RlZFJlZ2lvbl0ucmVnaW9uLmFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdsZWZ0OiAnICsgKGFyZWEueCArIDYpICsgJ3B4OyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wOiAnICsgKGFyZWEueSArIDI2KSArICdweDsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoOiAnICsgKGFyZWEud2lkdGggLSAxMikgKyAncHg7JztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0aWFsaXplRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNvb3JkaW5hdGVzIGhhdmUgb3JpZ2luIGF0IHRvcC1sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2luZyBpbiB4IHRvIHRoZSByaWdodCBhbmQgaW5jcmVhc2luZyBpbiB5IGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgbW91c2UgcG9zaXRpb24gaW4gU1ZHIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBtb3VzZSBjbGljayBwb3NpdGlvbiBmb3IgcmVjdGFuZ2xlIGRyYXdpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsTW91c2VYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3JpZ2luYWxNb3VzZVkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgZm9yIGRyYWdnZWQgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5vcmlnaW5hbFJlY3RBcmVhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb29yZGluYXRlcyBmb3IgY3VycmVudGx5IGRyYXduIHJlY3RhbmdsZSAod2hlbiB1c2VyIGlzIGRyYWdnaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZWN0WCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlY3RZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVjdFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVjdEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB1c2VyIGN1cnJlbnRseSBkcmF3aW5nIGEgbmV3IHJlZ2lvbj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlcklzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgdXNlciBjdXJyZW50bHkgZHJhZ2dpbmcgYW4gZXhpc3RpbmcgcmVnaW9uP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNDdXJyZW50bHlEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgdXNlciBjdXJyZW50bHkgcmVzaXppbmcgYW4gZXhpc3RpbmcgcmVnaW9uP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNDdXJyZW50bHlSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGFsb25nIHdoaWNoIHVzZXIgcmVzaXplIG9jY3Vycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgLT4gTGVmdCAgICAgLTEgLT4gUmlnaHQgICAgIDAgLT4gTm8gcmVzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnhEaXJlY3Rpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZlcnRpY2FsIGRpcmVjdGlvbiBhbG9uZyB3aGljaCB1c2VyIHJlc2l6ZSBvY2N1cnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxIC0+IFRvcCAgICAgLTEgLT4gQm90dG9tICAgICAwIC0+IE5vIHJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC55RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWdzIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGRpcmVjdGlvbiBjaGFuZ2VzIHdoaWxlIHJlc2l6aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC55RGlyZWN0aW9uVG9nZ2xlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uVG9nZ2xlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBib29sZWFuIHRoYXQgaXMgc2V0IHdoZW5ldmVyIHRoZSBjdXJzb3IgbW92ZXMgb3V0IG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdGFuZ3VsYXIgcmVnaW9uIHdoaWxlIHJlc2l6aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3ZlZE91dE9mUmVnaW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVnaW9uIGFsb25nIGJvcmRlcnMgdGhhdCB3aWxsIGRpc3BsYXkgdGhlIHJlc2l6ZSBjdXJzb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlc2l6YWJsZUJvcmRlcldpZHRoUHggPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpbWVuc2lvbnMgb2Ygb3JpZ2luYWwgaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsSW1hZ2VXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsSW1hZ2VIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggb2YgcmVnaW9uIGN1cnJlbnRseSBob3ZlcmVkIG92ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhvdmVyZWRSZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggb2YgcmVnaW9uIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRSZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVzc2FnZSB0byBkaXNwbGF5ZSB3aGVuIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvclRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0aWFsaXplRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlLCBhc3N1bWluZyB0aGF0IHRoZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgaW1hZ2UgaXMgc2NhbGVkIGRvd24gdG8gZml0IHRoZSBzdmcgZWxlbWVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfY2FsY3VsYXRlSW1hZ2VEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSAkKCRlbGVtZW50KS5maW5kKCcub3BwaWEtaW1hZ2Utd2l0aC1yZWdpb25zLWVkaXRvci1zdmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5ZWRJbWFnZVdpZHRoID0gTWF0aC5taW4oc3ZnRWxlbWVudC53aWR0aCgpLCBjdHJsLm9yaWdpbmFsSW1hZ2VXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGluZ1JhdGlvID0gZGlzcGxheWVkSW1hZ2VXaWR0aCAvIGN0cmwub3JpZ2luYWxJbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHNjYWxpbmdSYXRpbyBtYXkgYmUgTmFOIGlmIGN0cmwub3JpZ2luYWxJbWFnZVdpZHRoIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXllZEltYWdlSGVpZ2h0ID0gKGN0cmwub3JpZ2luYWxJbWFnZVdpZHRoID09PSAwID8gMC4wIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsSW1hZ2VIZWlnaHQgKiBzY2FsaW5nUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZGlzcGxheWVkSW1hZ2VXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGRpc3BsYXllZEltYWdlSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlc2UgdHdvIGZ1bmN0aW9ucyB0byBnZXQgdGhlIGNhbGN1bGF0ZWQgaW1hZ2Ugd2lkdGggYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlaWdodC5cbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRJbWFnZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVJbWFnZURpbWVuc2lvbnMoKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRJbWFnZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlSW1hZ2VEaW1lbnNpb25zKCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldFByZXZpZXdVcmwgPSBmdW5jdGlvbiAoaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBc3NldHNCYWNrZW5kQXBpU2VydmljZS5nZXRJbWFnZVVybEZvclByZXZpZXcoRU5USVRZX1RZUEUuRVhQTE9SQVRJT04sIENvbnRleHRTZXJ2aWNlLmdldEV4cGxvcmF0aW9uSWQoKSwgZW5jb2RlVVJJQ29tcG9uZW50KGltYWdlVXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxlZCB3aGVuIHRoZSBpbWFnZSBpcyBjaGFuZ2VkIHRvIGNhbGN1bGF0ZSB0aGUgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCwgZXNwZWNpYWxseSBmb3IgbGFyZ2UgaW1hZ2VzLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZS5pbWFnZVBhdGgnLCBmdW5jdGlvbiAobmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWRzIHRoZSBpbWFnZSBpbiBoYW5naW5nIDxpbWc+IHRhZyBzbyBhcyB0byBnZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8aW1nLz4nKS5hdHRyKCdzcmMnLCBjdHJsLmdldFByZXZpZXdVcmwobmV3VmFsKSkub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3JpZ2luYWxJbWFnZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5vcmlnaW5hbEltYWdlSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNEdXBsaWNhdGVzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG9yaWdpbmFsQXJyYXkuc2xpY2UoMCkuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheVtpIC0gMV0gPT09IGFycmF5W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZWdpb25MYWJlbEdldHRlclNldHRlciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZS5sYWJlbGVkUmVnaW9uc1tpbmRleF0ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnMubWFwKGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRHVwbGljYXRlcyhsYWJlbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVycm9yVGV4dCA9ICdXYXJuaW5nOiBMYWJlbCBcIicgKyBsYWJlbCArICdcIiBhbHJlYWR5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdleGlzdHMhIFBsZWFzZSB1c2UgYSBkaWZmZXJlbnQgbGFiZWwuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3JUZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnNbaW5kZXhdLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRDb29yZHNUb0ZyYWN0aW9uID0gZnVuY3Rpb24gKGNvb3JkcywgZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjb29yZHNbMF0gLyBkaW1lbnNpb25zWzBdLCBjb29yZHNbMV0gLyBkaW1lbnNpb25zWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBhbmQgZnJvbSByZWdpb24gYXJlYSAod2hpY2ggaXMgc3RvcmVkIGFzIGEgZnJhY3Rpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCkgYW5kIGFjdHVhbCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uQXJlYUZyb21Db3JuZXJBbmREaW1lbnNpb25zID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydENvb3Jkc1RvRnJhY3Rpb24oW3gsIHldLCBbY3RybC5nZXRJbWFnZVdpZHRoKCksIGN0cmwuZ2V0SW1hZ2VIZWlnaHQoKV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRDb29yZHNUb0ZyYWN0aW9uKFt4ICsgd2lkdGgsIHkgKyBoZWlnaHRdLCBbY3RybC5nZXRJbWFnZVdpZHRoKCksIGN0cmwuZ2V0SW1hZ2VIZWlnaHQoKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ybmVyQW5kRGltZW5zaW9uc0Zyb21SZWdpb25BcmVhID0gZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogYXJlYVswXVswXSAqIGN0cmwuZ2V0SW1hZ2VXaWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGFyZWFbMF1bMV0gKiBjdHJsLmdldEltYWdlSGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChhcmVhWzFdWzBdIC0gYXJlYVswXVswXSkgKiBjdHJsLmdldEltYWdlV2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IChhcmVhWzFdWzFdIC0gYXJlYVswXVsxXSkgKiBjdHJsLmdldEltYWdlSGVpZ2h0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxlZFJlZ2lvbnMgPSBjdHJsLnZhbHVlLmxhYmVsZWRSZWdpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZWRSZWdpb24gPSBsYWJlbGVkUmVnaW9uc1tjdHJsLnNlbGVjdGVkUmVnaW9uXS5yZWdpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gY3RybC5tb3VzZVggLSBjdHJsLm9yaWdpbmFsTW91c2VYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGN0cmwubW91c2VZIC0gY3RybC5vcmlnaW5hbE1vdXNlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gY3RybC5vcmlnaW5hbFJlY3RBcmVhLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGN0cmwub3JpZ2luYWxSZWN0QXJlYS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gY3RybC5vcmlnaW5hbFJlY3RBcmVhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGN0cmwub3JpZ2luYWxSZWN0QXJlYS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSB3aWR0aCAtIGN0cmwueERpcmVjdGlvbiAqIGRlbHRhWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBoZWlnaHQgLSBjdHJsLnlEaXJlY3Rpb24gKiBkZWx0YVk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB3aGVyZSB0aGUgbW91c2Ugd2FzIGZpcnN0IGNsaWNrZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIHRoZSByZXNpemUgYWN0aW9uIGFuZCB0aGUgbGVmdC1tb3N0IHggY28tb3JkaW5hdGUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5YID0gTWF0aC5hYnMoY3RybC5vcmlnaW5hbFJlY3RBcmVhLnggLSBjdHJsLm9yaWdpbmFsTW91c2VYKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHdoZXJlIHRoZSBtb3VzZSB3YXMgZmlyc3QgY2xpY2tlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgdGhlIHJlc2l6ZSBhY3Rpb24gYW5kIHRoZSB0b3AtbW9zdCB5IGNvLW9yZGluYXRlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luWSA9IE1hdGguYWJzKGN0cmwub3JpZ2luYWxSZWN0QXJlYS55IC0gY3RybC5vcmlnaW5hbE1vdXNlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SGVpZ2h0IDw9IDAgJiYgIWN0cmwueURpcmVjdGlvblRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnlEaXJlY3Rpb25Ub2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld0hlaWdodCA+PSAwICYmIGN0cmwueURpcmVjdGlvblRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnlEaXJlY3Rpb25Ub2dnbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC55RGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBjdHJsLnlEaXJlY3Rpb25Ub2dnbGVkID8gKGhlaWdodCArIG1hcmdpblkpIDogZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC55RGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gY3RybC55RGlyZWN0aW9uVG9nZ2xlZCAqIChkZWx0YVkgKyBtYXJnaW5ZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdXaWR0aCA8PSAwICYmICFjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uVG9nZ2xlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdXaWR0aCA+PSAwICYmIGN0cmwueERpcmVjdGlvblRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC54RGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkID8gKHdpZHRoICsgbWFyZ2luWCkgOiBkZWx0YVg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnhEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkICogKGRlbHRhWCArIG1hcmdpblgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgdGhlIGRpcmVjdGlvbiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBuZXdIZWlnaHQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXdXaWR0aCBjb21wdXRlZCBpcyBuZWdhdGl2ZSwgaGVuY2UgdGhlIGFic29sdXRlIHZhbHVlIGlzIHRha2VuLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplZFJlZ2lvbi5hcmVhID0gcmVnaW9uQXJlYUZyb21Db3JuZXJBbmREaW1lbnNpb25zKHgsIHksIE1hdGguYWJzKG5ld1dpZHRoKSwgTWF0aC5hYnMobmV3SGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25TdmdNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnRWxlbWVudCA9ICQoJGVsZW1lbnQpLmZpbmQoJy5vcHBpYS1pbWFnZS13aXRoLXJlZ2lvbnMtZWRpdG9yLXN2ZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3VzZVggPSBldnQucGFnZVggLSBzdmdFbGVtZW50Lm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdXNlWSA9IGV2dC5wYWdlWSAtIHN2Z0VsZW1lbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudXNlcklzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVjdFggPSBNYXRoLm1pbihjdHJsLm9yaWdpbmFsTW91c2VYLCBjdHJsLm1vdXNlWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZWN0WSA9IE1hdGgubWluKGN0cmwub3JpZ2luYWxNb3VzZVksIGN0cmwubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlY3RXaWR0aCA9IE1hdGguYWJzKGN0cmwub3JpZ2luYWxNb3VzZVggLSBjdHJsLm1vdXNlWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZWN0SGVpZ2h0ID0gTWF0aC5hYnMoY3RybC5vcmlnaW5hbE1vdXNlWSAtIGN0cmwubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwudXNlcklzQ3VycmVudGx5RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxlZFJlZ2lvbnMgPSBjdHJsLnZhbHVlLmxhYmVsZWRSZWdpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnZ2VkUmVnaW9uID0gbGFiZWxlZFJlZ2lvbnNbY3RybC5zZWxlY3RlZFJlZ2lvbl0ucmVnaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBjdHJsLm1vdXNlWCAtIGN0cmwub3JpZ2luYWxNb3VzZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGN0cmwubW91c2VZIC0gY3RybC5vcmlnaW5hbE1vdXNlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WDEgPSBjdHJsLm9yaWdpbmFsUmVjdEFyZWEueCArIGRlbHRhWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WTEgPSBjdHJsLm9yaWdpbmFsUmVjdEFyZWEueSArIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WDIgPSBuZXdYMSArIGN0cmwub3JpZ2luYWxSZWN0QXJlYS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WTIgPSBuZXdZMSArIGN0cmwub3JpZ2luYWxSZWN0QXJlYS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1gxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1gyID0gY3RybC5vcmlnaW5hbFJlY3RBcmVhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3WTEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1kxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WTIgPSBjdHJsLm9yaWdpbmFsUmVjdEFyZWEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3WDIgPiBjdHJsLmdldEltYWdlV2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYMiA9IGN0cmwuZ2V0SW1hZ2VXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYMSA9IG5ld1gyIC0gY3RybC5vcmlnaW5hbFJlY3RBcmVhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3WTIgPiBjdHJsLmdldEltYWdlSGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WTIgPSBjdHJsLmdldEltYWdlSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1kxID0gbmV3WTIgLSBjdHJsLm9yaWdpbmFsUmVjdEFyZWEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkUmVnaW9uLmFyZWEgPSByZWdpb25BcmVhRnJvbUNvcm5lckFuZERpbWVuc2lvbnMobmV3WDEsIG5ld1kxLCBjdHJsLm9yaWdpbmFsUmVjdEFyZWEud2lkdGgsIGN0cmwub3JpZ2luYWxSZWN0QXJlYS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC51c2VySXNDdXJyZW50bHlSZXNpemluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZVJlZ2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLm9uU3ZnTW91c2VEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsTW91c2VYID0gY3RybC5tb3VzZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsTW91c2VZID0gY3RybC5tb3VzZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5ob3ZlcmVkUmVnaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZWN0V2lkdGggPSBjdHJsLnJlY3RIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlcklzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25TdmdNb3VzZVVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaG92ZXJlZFJlZ2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRSZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwueURpcmVjdGlvblRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnlEaXJlY3Rpb24gPSAoY3RybC55RGlyZWN0aW9uID09PSAxKSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uID0gKGN0cmwueERpcmVjdGlvbiA9PT0gMSkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5tb3ZlZE91dE9mUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnlEaXJlY3Rpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudXNlcklzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnJlY3RXaWR0aCAhPT0gMCAmJiBjdHJsLnJlY3RIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnMubWFwKGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2hlcyBudW1iZXJzIHN0YXJ0aW5nIGZyb20gMSB0byBmaW5kIGEgdmFsaWQgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBjdXJyZW50bHkgZXhpc3RpbmcgbGFiZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsYWJlbHMubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlTGFiZWwgPSAnUmVnaW9uJyArIGkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbHMuaW5kZXhPZihjYW5kaWRhdGVMYWJlbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGFiZWwgPSBjYW5kaWRhdGVMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVnaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5ld0xhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uVHlwZTogJ1JlY3RhbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogcmVnaW9uQXJlYUZyb21Db3JuZXJBbmREaW1lbnNpb25zKGN0cmwucmVjdFgsIGN0cmwucmVjdFksIGN0cmwucmVjdFdpZHRoLCBjdHJsLnJlY3RIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnMucHVzaChuZXdSZWdpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGVkUmVnaW9uID0gKGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNDdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0N1cnJlbnRseURyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0N1cnJlbnRseVJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm1vdmVkT3V0T2ZSZWdpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwueURpcmVjdGlvblRvZ2dsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwueERpcmVjdGlvblRvZ2dsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbk1vdXNlb3ZlclJlZ2lvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaG92ZXJlZFJlZ2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaG92ZXJlZFJlZ2lvbiA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3ZlZE91dE9mUmVnaW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25Nb3VzZU1vdmVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC51c2VySXNDdXJyZW50bHlEcmFnZ2luZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudXNlcklzQ3VycmVudGx5UmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gY29ybmVyQW5kRGltZW5zaW9uc0Zyb21SZWdpb25BcmVhKGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnNbY3RybC5ob3ZlcmVkUmVnaW9uXS5yZWdpb24uYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwueERpcmVjdGlvblRvZ2dsZWQgJiYgIWN0cmwueURpcmVjdGlvblRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5tb3VzZVkgPD0gcmVnaW9uLnkgKyBjdHJsLnJlc2l6YWJsZUJvcmRlcldpZHRoUHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC55RGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC5tb3VzZVkgPj0gcmVnaW9uLmhlaWdodCArIHJlZ2lvbi55IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNpemFibGVCb3JkZXJXaWR0aFB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwueURpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC55RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwubW91c2VYIDw9IHJlZ2lvbi54ICsgY3RybC5yZXNpemFibGVCb3JkZXJXaWR0aFB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwueERpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwubW91c2VYID49IHJlZ2lvbi53aWR0aCArIHJlZ2lvbi54IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZXNpemFibGVCb3JkZXJXaWR0aFB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwueERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwub25Nb3VzZW91dFJlZ2lvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuaG92ZXJlZFJlZ2lvbiA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmhvdmVyZWRSZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLnVzZXJJc0N1cnJlbnRseVJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC54RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnlEaXJlY3Rpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tb3ZlZE91dE9mUmVnaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5vbk1vdXNlZG93blJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnhEaXJlY3Rpb24gfHwgY3RybC55RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC51c2VySXNDdXJyZW50bHlSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0N1cnJlbnRseURyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2VsZWN0ZWRSZWdpb24gPSBjdHJsLmhvdmVyZWRSZWdpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9yaWdpbmFsUmVjdEFyZWEgPSBjb3JuZXJBbmREaW1lbnNpb25zRnJvbVJlZ2lvbkFyZWEoY3RybC52YWx1ZS5sYWJlbGVkUmVnaW9uc1tjdHJsLmhvdmVyZWRSZWdpb25dLnJlZ2lvbi5hcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5yZWdpb25MYWJlbEVkaXRvck1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0N1cnJlbnRseURyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnVzZXJJc0N1cnJlbnRseVJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZ2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeERpcmVjdGlvbkN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlEaXJlY3Rpb25DdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnhEaXJlY3Rpb24gfHwgY3RybC55RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBpcyByZXNpemluZywgc28gd2UgZmlndXJlIG91dCB0aGUgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3RybC54RGlyZWN0aW9uID09PSAxICYmICFjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3RybC54RGlyZWN0aW9uID09PSAtMSAmJiBjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4RGlyZWN0aW9uQ3Vyc29yID0gJ3cnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoY3RybC54RGlyZWN0aW9uID09PSAtMSAmJiAhY3RybC54RGlyZWN0aW9uVG9nZ2xlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN0cmwueERpcmVjdGlvbiA9PT0gMSAmJiBjdHJsLnhEaXJlY3Rpb25Ub2dnbGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4RGlyZWN0aW9uQ3Vyc29yID0gJ2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeERpcmVjdGlvbkN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN0cmwueURpcmVjdGlvbiA9PT0gMSAmJiAhY3RybC55RGlyZWN0aW9uVG9nZ2xlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN0cmwueURpcmVjdGlvbiA9PT0gLTEgJiYgY3RybC55RGlyZWN0aW9uVG9nZ2xlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeURpcmVjdGlvbkN1cnNvciA9ICduJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGN0cmwueURpcmVjdGlvbiA9PT0gLTEgJiYgIWN0cmwueURpcmVjdGlvblRvZ2dsZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdHJsLnlEaXJlY3Rpb24gPT09IDEgJiYgY3RybC55RGlyZWN0aW9uVG9nZ2xlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeURpcmVjdGlvbkN1cnNvciA9ICdzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlEaXJlY3Rpb25DdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlEaXJlY3Rpb25DdXJzb3IgKyB4RGlyZWN0aW9uQ3Vyc29yICsgJy1yZXNpemUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3RybC5ob3ZlcmVkUmVnaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBpcyBub3QgcmVzaXppbmcgYnV0IGN1cnNvciBpcyBvdmVyIGEgcmVnaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Nyb3NzaGFpcic7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucmVzZXRFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWwub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbWFnZS13aXRoLXJlZ2lvbnMtcmVzZXQtY29uZmlybWF0aW9uLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6ICdzdGF0aWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckc2NvcGUnLCAnJHVpYk1vZGFsSW5zdGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkdWliTW9kYWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbmZpcm1DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWliTW9kYWxJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlc3VsdC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlLmltYWdlUGF0aCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUubGFiZWxlZFJlZ2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmluaXRpYWxpemVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmRlbGV0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc2VsZWN0ZWRSZWdpb24gPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3RlZFJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLnNlbGVjdGVkUmVnaW9uID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGVkUmVnaW9uLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5ob3ZlcmVkUmVnaW9uID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaG92ZXJlZFJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHJsLmhvdmVyZWRSZWdpb24gPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaG92ZXJlZFJlZ2lvbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZS5sYWJlbGVkUmVnaW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBpbnQgZWRpdG9yLlxuICovXG4vLyBFdmVyeSBlZGl0b3IgZGlyZWN0aXZlIHNob3VsZCBpbXBsZW1lbnQgYW4gYWx3YXlzRWRpdGFibGUgb3B0aW9uLiBUaGVyZVxuLy8gbWF5IGJlIGFkZGl0aW9uYWwgY3VzdG9taXphdGlvbiBvcHRpb25zIGZvciB0aGUgZWRpdG9yIHRoYXQgc2hvdWxkIGJlIHBhc3NlZFxuLy8gaW4gdmlhIGluaXRBcmdzLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdpbnRFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2ludC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5TQ0hFTUEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaXNfaW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBsaXN0IG9mIHNldHMgb2YgaHRtbCBzdHJpbmdzIGVkaXRvci5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdsaXN0T2ZTZXRzT2ZIdG1sU3RyaW5nc0VkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBnZXRJbml0QXJnczogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy8nICtcbiAgICAgICAgICAgICAgICAnbGlzdC1vZi1zZXRzLW9mLWh0bWwtc3RyaW5ncy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwuc2VsZWN0ZWRSYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNlbGVjdGVkUmFuayA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC5tYXhQcmV2SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubWF4UHJldkluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHJsLmluaXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0QXJncyA9IGN0cmwuZ2V0SW5pdEFyZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jaG9pY2VzID0gY3RybC5pbml0QXJncy5jaG9pY2VzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudmFsdWVbMF0gPT09IHVuZGVmaW5lZCB8fCBjdHJsLnZhbHVlWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IFtbXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwuY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWVbMF0ucHVzaChjdHJsLmNob2ljZXNbaV0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdFZhbHVlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLmNob2ljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN0cmwudmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IGN0cmwuY2hvaWNlc1tpXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudmFsdWVbal0uaW5kZXhPZihjaG9pY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5pbml0VmFsdWVzLnB1c2goaiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tYXhQcmV2SW5kZXggPSBtYXRoLm1heChjdHJsLm1heFByZXZJbmRleCwgaiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc2VsZWN0ZWRSYW5rICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5tYXhQcmV2SW5kZXggPSBtYXRoLm1heChwYXJzZUludChjdHJsLnNlbGVjdGVkUmFuayksIGN0cmwubWF4UHJldkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHJsLmFsbG93ZWRDaG9pY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG93ZWRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBtYXRoLm1pbihjdHJsLm1heFByZXZJbmRleCwgY3RybC5jaG9pY2VzLmxlbmd0aCAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkTGlzdC5wdXNoKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd2VkTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3RlZEl0ZW0gPSBmdW5jdGlvbiAoY2hvaWNlTGlzdEluZGV4LCBzZWxlY3RlZFJhbmtTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaG9pY2VIdG1sID0gY3RybC5jaG9pY2VzW2Nob2ljZUxpc3RJbmRleF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRSYW5rID0gcGFyc2VJbnQoc2VsZWN0ZWRSYW5rU3RyaW5nKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlb3JkZXIgdGhlIGN0cmwuY2hvaWNlcyBhcnJheSB0byBtYWtlIGl0IGNvbnNpc3RlbnQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkIHJhbmsuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdHJsLmNob2ljZXMuc3BsaWNlKHNlbGVjdGVkUmFuaywgMCwgY3RybC5jaG9pY2VzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNob2ljZUxpc3RJbmRleCwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZUh0bWxIYXNCZWVuQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubWF4UHJldkluZGV4ID0gbWF0aC5tYXgoc2VsZWN0ZWRSYW5rICsgMSwgY3RybC5tYXhQcmV2SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlSHRtbEhhc0JlZW5BZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaG9pY2VIdG1sSW5kZXggPSBjdHJsLnZhbHVlW2ldLmluZGV4T2YoY2hvaWNlSHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNob2ljZUh0bWxJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBzZWxlY3RlZFJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWVbaV0uc3BsaWNlKGNob2ljZUh0bWxJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC52YWx1ZVtzZWxlY3RlZFJhbmtdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlW3NlbGVjdGVkUmFua10gPSBbY2hvaWNlSHRtbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlW3NlbGVjdGVkUmFua10ucHVzaChjaG9pY2VIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaG9pY2VIdG1sSGFzQmVlbkFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudmFsdWVbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBjdHJsLnZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGVtcHR5IGxpc3QgYXQgdGhlIGxhc3QsIHBvcCBpdCBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWl0eSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICgnTm8gY2hvaWNlKHMpIGlzIGFzc2lnbmVkIGF0IHBvc2l0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyhpICsgMSkgKyAnLiBQbGVhc2UgYXNzaWduIHNvbWUgY2hvaWNlIGF0IHRoaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaG9pY2VIdG1sSGFzQmVlbkFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudmFsdWVbc2VsZWN0ZWRSYW5rXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWVbc2VsZWN0ZWRSYW5rXSA9IFtjaG9pY2VIdG1sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWVbc2VsZWN0ZWRSYW5rXS5wdXNoKGNob2ljZUh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5nZXRXYXJuaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMtSVMnIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIGxpc3Qgb2YgdGFicyBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2xpc3RPZlRhYnNFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2xpc3QtZWRpdG9yLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuU0NIRU1BID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGljdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RhYiB0aXRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5pY29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaXNfbm9uZW1wdHknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGFiIGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpX2NvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlX2NvbXBsZXhfZXh0ZW5zaW9uczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1aV9jb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfZWxlbWVudF90ZXh0OiAnQWRkIG5ldyB0YWInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBsaXN0IG9mIHVuaWNvZGUgc3RyaW5nIGVkaXRvci5cbiAqL1xuLy8gRXZlcnkgZWRpdG9yIGRpcmVjdGl2ZSBzaG91bGQgaW1wbGVtZW50IGFuIGFsd2F5c0VkaXRhYmxlIG9wdGlvbi4gVGhlcmVcbi8vIG1heSBiZSBhZGRpdGlvbmFsIGN1c3RvbWl6YXRpb24gb3B0aW9ucyBmb3IgdGhlIGVkaXRvciB0aGF0IHNob3VsZCBiZSBwYXNzZWRcbi8vIGluIHZpYSBpbml0QXJncy5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnbGlzdE9mVW5pY29kZVN0cmluZ0VkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvbGlzdC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5TQ0hFTUEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmljb2RlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cmwudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgbG9naWMgZXJyb3IgY2F0ZWdvcnkgZWRpdG9yLlxuICovXG4vLyBFdmVyeSBlZGl0b3IgZGlyZWN0aXZlIHNob3VsZCBpbXBsZW1lbnQgYW4gYWx3YXlzRWRpdGFibGUgb3B0aW9uLiBUaGVyZVxuLy8gbWF5IGJlIGFkZGl0aW9uYWwgY3VzdG9taXphdGlvbiBvcHRpb25zIGZvciB0aGUgZWRpdG9yIHRoYXQgc2hvdWxkIGJlIHBhc3NlZFxuLy8gaW4gdmlhIGluaXRBcmdzLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdsb2dpY0Vycm9yQ2F0ZWdvcnlFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2xvZ2ljLWVycm9yLWNhdGVnb3J5LWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbHdheXNFZGl0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3JDYXRlZ29yaWVzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGFyc2luZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZTogJ1VucGFyc2VhYmxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bWFuUmVhZGFibGU6ICdJbGwtdHlwZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bWFuUmVhZGFibGU6ICdJbmNvcnJlY3QgbGluZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodW1hblJlYWRhYmxlOiAnV3JvbmcgaW5kZW50aW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd2YXJpYWJsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bWFuUmVhZGFibGU6ICdWYXJpYWJsZXMgZXJyb3InXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xvZ2ljJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodW1hblJlYWRhYmxlOiAnSW52YWxpZCBkZWR1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZTogJ1RhcmdldCBub3QgcHJvdmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtaXN0YWtlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodW1hblJlYWRhYmxlOiAnVW5zcGVjaWZpZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGN0cmwuZXJyb3JDYXRlZ29yaWVzWzBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC5lcnJvckNhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmVycm9yQ2F0ZWdvcmllc1tpXS5uYW1lID09PSBjdHJsLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlLmNhdGVnb3J5ID0gY3RybC5lcnJvckNhdGVnb3JpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnJGN0cmwubG9jYWxWYWx1ZS5jYXRlZ29yeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBjdHJsLmxvY2FsVmFsdWUuY2F0ZWdvcnkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBsb2dpYyBxdWVzdGlvbiBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG52YXIgc2hhcmVkX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9zaGFyZWQudHNcIikpO1xudmFyIHRlYWNoZXJfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL3RlYWNoZXIudHNcIikpO1xudmFyIGRhdGFfdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2RhdGEudHNcIikpO1xudmFyIGNvbnZlcnNpb25fdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW50ZXJhY3Rpb25zL0xvZ2ljUHJvb2Yvc3RhdGljL2pzL2NvbnZlcnNpb24udHNcIikpO1xudmFyIGdlbmVyYXRlZERlZmF1bHREYXRhX3RzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludGVyYWN0aW9ucy9Mb2dpY1Byb29mL3N0YXRpYy9qcy9nZW5lcmF0ZWREZWZhdWx0RGF0YS50c1wiKSk7XG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ2xvZ2ljUXVlc3Rpb25FZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL2xvZ2ljLXF1ZXN0aW9uLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmFsd2F5c0VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzdW1wdGlvbnNTdHJpbmc6IHNoYXJlZF90c18xLmRlZmF1bHQuZGlzcGxheUV4cHJlc3Npb25BcnJheShjdHJsLnZhbHVlLmFzc3VtcHRpb25zLCBkYXRhX3RzXzEuZGVmYXVsdC5CQVNFX1NUVURFTlRfTEFOR1VBR0Uub3BlcmF0b3JzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0cmluZzogc2hhcmVkX3RzXzEuZGVmYXVsdC5kaXNwbGF5RXhwcmVzc2lvbihjdHJsLnZhbHVlLnJlc3VsdHNbMF0sIGRhdGFfdHNfMS5kZWZhdWx0LkJBU0VfU1RVREVOVF9MQU5HVUFHRS5vcGVyYXRvcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb29mU3RyaW5nOiBjdHJsLnZhbHVlLmRlZmF1bHRfcHJvb2Zfc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHVzZSBuZy1jaGFuZ2UgcmF0aGVyIHRoYW4gJHdhdGNoIGJlY2F1c2UgdGhlIGxhdHRlciBydW5zIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIHRvIGFueSBjaGFuZ2UgdG8gdGhlIHdhdGNoZWQgdmFsdWUsIGFuZCB3ZSBvbmx5IHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB0byBjaGFuZ2VzIG1hZGUgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2hhbmdlQXNzdW1wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNvbnZlcnRUaGVuQnVpbGQoJ2xvZ2ljUXVlc3Rpb25Bc3N1bXB0aW9ucycsICdhc3N1bXB0aW9uc1N0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmNoYW5nZVRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29udmVydFRoZW5CdWlsZCgnbG9naWNRdWVzdGlvblRhcmdldCcsICd0YXJnZXRTdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5jaGFuZ2VQcm9vZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY29udmVydFRoZW5CdWlsZCgnbG9naWNRdWVzdGlvblByb29mJywgJ3Byb29mU3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY29udmVydFRoZW5CdWlsZCA9IGZ1bmN0aW9uIChlbGVtZW50SUQsIG5hbWVPZlN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gZWxlbWVudC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWVbbmFtZU9mU3RyaW5nXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvbl90c18xLmRlZmF1bHQuY29udmVydFRvTG9naWNDaGFyYWN0ZXJzKGN0cmwubG9jYWxWYWx1ZVtuYW1lT2ZTdHJpbmddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuYnVpbGRRdWVzdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogYW5ndWxhciB3aWxsIHJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGFmdGVyIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHJ1bnMsIHNvIHdlIG5lZWQgdG8gZGVsYXkgb3VyIHJlLXJlc2V0dGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0aW9uRW5kID0gY3Vyc29yUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5idWlsZFF1ZXN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVpbHRRdWVzdGlvbiA9IGFuZ3VsYXIuY29weSh0ZWFjaGVyX3RzXzEuZGVmYXVsdC5idWlsZFF1ZXN0aW9uKGN0cmwubG9jYWxWYWx1ZS5hc3N1bXB0aW9uc1N0cmluZywgY3RybC5sb2NhbFZhbHVlLnRhcmdldFN0cmluZywgZ2VuZXJhdGVkRGVmYXVsdERhdGFfdHNfMS5kZWZhdWx0LnZvY2FidWxhcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3N1bXB0aW9uczogYnVpbHRRdWVzdGlvbi5hc3N1bXB0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogYnVpbHRRdWVzdGlvbi5yZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X3Byb29mX3N0cmluZzogY3RybC5sb2NhbFZhbHVlLnByb29mU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWUuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlLmVycm9yTWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgbWF0aCBsYXRleCBzdHJpbmcgZWRpdG9yLlxuICovXG5yZXF1aXJlKCdkaXJlY3RpdmVzL21hdGhqYXgtYmluZC5kaXJlY3RpdmUudHMnKTtcbnJlcXVpcmUoJ2RvbWFpbi91dGlsaXRpZXMvVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UudHMnKTtcbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ21hdGhMYXRleFN0cmluZ0VkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBnZXRBbHdheXNFZGl0YWJsZTogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9tYXRoLWxhdGV4LXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwucGxhY2Vob2xkZXJUZXh0ID0gJ1xcXFxmcmFje3h9e3l9JztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hbHdheXNFZGl0YWJsZSA9IGN0cmwuZ2V0QWx3YXlzRWRpdGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvbXBvbmVudCBlYWNoIHRpbWUgdGhlIHZhbHVlIGNoYW5nZXMgKGUuZy4gaWYgdGhpcyBpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGFuIGVkaXRhYmxlIGxpc3QpLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogY3RybC52YWx1ZSB8fCAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFsd2F5c0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC5sb2NhbFZhbHVlLmxhYmVsJywgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLm9wZW5FZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2xvc2VFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlcGxhY2VWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jbG9zZUVkaXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ2V4dGVybmFsU2F2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5yZXBsYWNlVmFsdWUoY3RybC5sb2NhbFZhbHVlLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlICRzY29wZS4kYXBwbHkoKSBjYWxsIGlzIG5lZWRlZCB0byBwcm9wYWdhdGUgdGhlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNsb3NlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTIgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIG11c2ljIHBocmFzZSBlZGl0b3IuXG4gKi9cbi8vIFRoaXMgZGlyZWN0aXZlIGlzIGFsd2F5cyBlZGl0YWJsZS5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnbXVzaWNQaHJhc2VFZGl0b3InLCBbXG4gICAgJ0FsZXJ0c1NlcnZpY2UnLCAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChBbGVydHNTZXJ2aWNlLCBVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvbXVzaWMtcGhyYXNlLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vdGVzIGFsbG93ZWQgaW4gYSBtdXNpYyBwaHJhc2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfTUFYX05PVEVTX0lOX1BIUkFTRSA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5pY29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQzQnLCAnRDQnLCAnRTQnLCAnRjQnLCAnRzQnLCAnQTQnLCAnQjQnLCAnQzUnLCAnRDUnLCAnRTUnLCAnRjUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRzUnLCAnQTUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpX2NvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9lbGVtZW50X3RleHQ6ICdBZGQgTm90ZSDimaknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdoYXNfbGVuZ3RoX2F0X21vc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfdmFsdWU6IF9NQVhfTk9URVNfSU5fUEhSQVNFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvbXBvbmVudCBlYWNoIHRpbWUgdGhlIHZhbHVlIGNoYW5nZXMgKGUuZy4gaWYgdGhpcyBpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGFuIGVkaXRhYmxlIGxpc3QpLlxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZScsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhzbGwpOiBDaGVjayB0aGF0ICRjdHJsLnZhbHVlIGlzIGEgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWUucHVzaChuZXdWYWx1ZVtpXS5yZWFkYWJsZU5vdGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC5sb2NhbFZhbHVlJywgZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICYmIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlLmxlbmd0aCA+IF9NQVhfTk9URVNfSU5fUEhSQVNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsZXJ0c1NlcnZpY2UuYWRkV2FybmluZygnVGhlcmUgYXJlIHRvbyBtYW55IG5vdGVzIG9uIHRoZSBzdGFmZi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlTm90ZU5hbWU6IG5ld1ZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVEdXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW06IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbjogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBwYXJlbnRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTIgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIG5vbiBuZWdhdGl2ZSBpbnQgZWRpdG9yLlxuICovXG4vLyBFdmVyeSBlZGl0b3IgZGlyZWN0aXZlIHNob3VsZCBpbXBsZW1lbnQgYW4gYWx3YXlzRWRpdGFibGUgb3B0aW9uLiBUaGVyZVxuLy8gbWF5IGJlIGFkZGl0aW9uYWwgY3VzdG9taXphdGlvbiBvcHRpb25zIGZvciB0aGUgZWRpdG9yIHRoYXQgc2hvdWxkIGJlIHBhc3NlZFxuLy8gaW4gdmlhIGluaXRBcmdzLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdub25uZWdhdGl2ZUludEVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvbm9ubmVnYXRpdmUtaW50LWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLlNDSEVNQSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpc19hdF9sZWFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbl92YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpc19pbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIG5vcm1hbGl6ZWQgc3RyaW5nIGVkaXRvci5cbiAqL1xuLy8gVGhpcyBpcyBhIGNvcHkgb2YgdGhlIFVuaWNvZGVTdHJpbmdFZGl0b3IuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ25vcm1hbGl6ZWRTdHJpbmdFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0QWx3YXlzRWRpdGFibGU6ICcmJyxcbiAgICAgICAgICAgICAgICBnZXRJbml0QXJnczogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy91bmljb2RlLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWx3YXlzRWRpdGFibGUgPSBjdHJsLmdldEFsd2F5c0VkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdEFyZ3MgPSBjdHJsLmdldEluaXRBcmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubGFyZ2VJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC5pbml0QXJncycsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sYXJnZUlucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgJiYgbmV3VmFsdWUubGFyZ2VJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFyZ2VJbnB1dCA9IG5ld1ZhbHVlLmxhcmdlSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY29tcG9uZW50IGVhY2ggdGltZSB0aGUgdmFsdWUgY2hhbmdlcyAoZS5nLiBpZiB0aGlzIGlzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYW4gZWRpdGFibGUgbGlzdCkuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLnZhbHVlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBjdHJsLnZhbHVlIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuYWx3YXlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmxvY2FsVmFsdWUubGFiZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3BlbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jbG9zZUVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbmV3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNsb3NlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignZXh0ZXJuYWxTYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlcGxhY2VWYWx1ZShjdHJsLmxvY2FsVmFsdWUubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgJHNjb3BlLiRhcHBseSgpIGNhbGwgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSB0aGUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2xvc2VFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxOCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgbnVtYmVyIHdpdGggdW5pdHMgZWRpdG9yLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ251bWJlcldpdGhVbml0c0VkaXRvcicsIFtcbiAgICAnTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeScsICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKE51bWJlcldpdGhVbml0c09iamVjdEZhY3RvcnksIFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9udW1iZXItd2l0aC11bml0cy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlcldpdGhVbml0c1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHROdW1iZXJXaXRoVW5pdHMgPSBOdW1iZXJXaXRoVW5pdHNPYmplY3RGYWN0b3J5LmZyb21EaWN0KGN0cmwudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyV2l0aFVuaXRzU3RyaW5nID0gZGVmYXVsdE51bWJlcldpdGhVbml0cy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBudW1iZXJXaXRoVW5pdHNTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnJGN0cmwubG9jYWxWYWx1ZS5sYWJlbCcsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyV2l0aFVuaXRzID0gTnVtYmVyV2l0aFVuaXRzT2JqZWN0RmFjdG9yeS5mcm9tUmF3SW5wdXRTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBudW1iZXJXaXRoVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2luZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcGFyc2luZ0Vycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmdldFdhcm5pbmdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbl0pO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhlIE9wcGlhIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEaXJlY3RpdmUgZm9yIHBhcmFtZXRlciBuYW1lIGVkaXRvci5cbiAqL1xuLy8gTk9URSBUTyBERVZFTE9QRVJTOiBUaGlzIGVkaXRvciByZXF1aXJlcyBFeHBsb3JhdGlvblBhcmFtU3BlY3NTZXJ2aWNlIHRvIGJlXG4vLyBhdmFpbGFibGUgaW4gdGhlIGNvbnRleHQgaW4gd2hpY2ggaXQgaXMgdXNlZC5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgncGFyYW1ldGVyTmFtZUVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvcGFyYW1ldGVyLW5hbWUtZWRpdG9yLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgICAgICAgJyRzY29wZScsICckYXR0cnMnLCAnRXhwbG9yYXRpb25QYXJhbVNwZWNzU2VydmljZScsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJGF0dHJzLCBFeHBsb3JhdGlvblBhcmFtU3BlY3NTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hdmFpbGFibGVQYXJhbU5hbWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEV4cGxvcmF0aW9uUGFyYW1TcGVjc1NlcnZpY2Uuc2F2ZWRNZW1lbnRvLmdldFBhcmFtTmFtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuYXZhaWxhYmxlUGFyYW1OYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmxvY2FsVmFsdWUgPSBjdHJsLmF2YWlsYWJsZVBhcmFtTmFtZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3RybC52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3RybC5hdmFpbGFibGVQYXJhbU5hbWVzLmxlbmd0aCA9PT0gMCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuU0NIRU1BID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuaWNvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlczogY3RybC5hdmFpbGFibGVQYXJhbU5hbWVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb21wb25lbnQgZWFjaCB0aW1lIHRoZSB2YWx1ZSBjaGFuZ2VzIChlLmcuIGlmIHRoaXMgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiBhbiBlZGl0YWJsZSBsaXN0KS5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnJGN0cmwudmFsdWUnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubG9jYWxWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnJGN0cmwubG9jYWxWYWx1ZScsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3IgcmVhbCBlZGl0b3IuXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgncmVhbEVkaXRvcicsIFtcbiAgICAnVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uIChVcmxJbnRlcnBvbGF0aW9uU2VydmljZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvcmVhbC1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC52YWx1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbmV3IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBzYW5pdGl6ZWQgVVJMIGVkaXRvci5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdzYW5pdGl6ZWRVcmxFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgLy8gRWRpdGFibGUgVVJMIGRpcmVjdGl2ZS5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBVcmxJbnRlcnBvbGF0aW9uU2VydmljZS5nZXRFeHRlbnNpb25SZXNvdXJjZVVybCgnL29iamVjdHMvdGVtcGxhdGVzL3Nhbml0aXplZC11cmwtZWRpdG9yLmRpcmVjdGl2ZS5odG1sJyksXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICckY3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuU0NIRU1BID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuaWNvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpc19ub25lbXB0eSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpX2NvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDEyIFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciBzZXQgb2YgSFRNTCBzdHJpbmcgZWRpdG9yLlxuICovXG4vLyBFdmVyeSBlZGl0b3IgZGlyZWN0aXZlIHNob3VsZCBpbXBsZW1lbnQgYW4gYWx3YXlzRWRpdGFibGUgb3B0aW9uLiBUaGVyZVxuLy8gbWF5IGJlIGFkZGl0aW9uYWwgY3VzdG9taXphdGlvbiBvcHRpb25zIGZvciB0aGUgZWRpdG9yIHRoYXQgc2hvdWxkIGJlIHBhc3NlZFxuLy8gaW4gdmlhIGluaXRBcmdzLlxuYW5ndWxhci5tb2R1bGUoJ29wcGlhJykuZGlyZWN0aXZlKCdzZXRPZkh0bWxTdHJpbmdFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0SW5pdEFyZ3M6ICcmJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IFVybEludGVycG9sYXRpb25TZXJ2aWNlLmdldEV4dGVuc2lvblJlc291cmNlVXJsKCcvb2JqZWN0cy90ZW1wbGF0ZXMvc2V0LW9mLWh0bWwtc3RyaW5nLWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLlNDSEVNQSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdEFyZ3MgPSBjdHJsLmdldEluaXRBcmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2hvaWNlcyA9IGN0cmwuaW5pdEFyZ3MuY2hvaWNlcztcbiAgICAgICAgICAgICAgICAgICAgY3RybC5zZWxlY3Rpb25zID0gY3RybC5jaG9pY2VzLm1hcChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC52YWx1ZS5pbmRleE9mKGNob2ljZS5pZCkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgdG8gaW5zZXJ0IGVsZW1lbnRzIGludG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuc3dlciBncm91cHMgZm9yIHRoZSBJdGVtIFNlbGVjdGlvbiBXaWRnZXQuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwudG9nZ2xlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGNob2ljZUxpc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZUh0bWwgPSBjdHJsLmNob2ljZXNbY2hvaWNlTGlzdEluZGV4XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZENob2ljZXNJbmRleCA9IGN0cmwudmFsdWUuaW5kZXhPZihjaG9pY2VIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZENob2ljZXNJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZS5zcGxpY2Uoc2VsZWN0ZWRDaG9pY2VzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZS5wdXNoKGNob2ljZUh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBUaGUgT3BwaWEgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpcmVjdGl2ZSBmb3Igc2V0IG9mIHVuaWNvZGUgc3RyaW5nIGVkaXRvci5cbiAqL1xuLy8gRXZlcnkgZWRpdG9yIGRpcmVjdGl2ZSBzaG91bGQgaW1wbGVtZW50IGFuIGFsd2F5c0VkaXRhYmxlIG9wdGlvbi4gVGhlcmVcbi8vIG1heSBiZSBhZGRpdGlvbmFsIGN1c3RvbWl6YXRpb24gb3B0aW9ucyBmb3IgdGhlIGVkaXRvciB0aGF0IHNob3VsZCBiZSBwYXNzZWRcbi8vIGluIHZpYSBpbml0QXJncy5cbmFuZ3VsYXIubW9kdWxlKCdvcHBpYScpLmRpcmVjdGl2ZSgnc2V0T2ZVbmljb2RlU3RyaW5nRWRpdG9yJywgW1xuICAgICdVcmxJbnRlcnBvbGF0aW9uU2VydmljZScsXG4gICAgZnVuY3Rpb24gKFVybEludGVycG9sYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHt9LFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy9saXN0LWVkaXRvci5kaXJlY3RpdmUuaHRtbCcpLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAnJGN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLlNDSEVNQSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuaWNvZGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpc191bmlxdWlmaWVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3RybC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFRoZSBPcHBpYSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlyZWN0aXZlIGZvciB1bmljb2RlIHN0cmluZyBlZGl0b3IuXG4gKi9cbi8vIEV2ZXJ5IGVkaXRvciBkaXJlY3RpdmUgc2hvdWxkIGltcGxlbWVudCBhbiBhbHdheXNFZGl0YWJsZSBvcHRpb24uIFRoZXJlXG4vLyBtYXkgYmUgYWRkaXRpb25hbCBjdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBlZGl0b3IgdGhhdCBzaG91bGQgYmUgcGFzc2VkXG4vLyBpbiB2aWEgaW5pdEFyZ3MuXG5hbmd1bGFyLm1vZHVsZSgnb3BwaWEnKS5kaXJlY3RpdmUoJ3VuaWNvZGVTdHJpbmdFZGl0b3InLCBbXG4gICAgJ1VybEludGVycG9sYXRpb25TZXJ2aWNlJyxcbiAgICBmdW5jdGlvbiAoVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgZ2V0QWx3YXlzRWRpdGFibGU6ICcmJyxcbiAgICAgICAgICAgICAgICBnZXRJbml0QXJnczogJyYnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogVXJsSW50ZXJwb2xhdGlvblNlcnZpY2UuZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoJy9vYmplY3RzL3RlbXBsYXRlcy91bmljb2RlLXN0cmluZy1lZGl0b3IuZGlyZWN0aXZlLmh0bWwnKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJyRjdHJsJyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWx3YXlzRWRpdGFibGUgPSBjdHJsLmdldEFsd2F5c0VkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdEFyZ3MgPSBjdHJsLmdldEluaXRBcmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwubGFyZ2VJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCckY3RybC5pbml0QXJncycsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sYXJnZUlucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgJiYgbmV3VmFsdWUubGFyZ2VJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwubGFyZ2VJbnB1dCA9IG5ld1ZhbHVlLmxhcmdlSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY29tcG9uZW50IGVhY2ggdGltZSB0aGUgdmFsdWUgY2hhbmdlcyAoZS5nLiBpZiB0aGlzIGlzIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYW4gZWRpdGFibGUgbGlzdCkuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLnZhbHVlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBjdHJsLnZhbHVlIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuYWx3YXlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJyRjdHJsLmxvY2FsVmFsdWUubGFiZWwnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwub3BlbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5jbG9zZUVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwucmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5sb2NhbFZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbmV3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmNsb3NlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignZXh0ZXJuYWxTYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnJlcGxhY2VWYWx1ZShjdHJsLmxvY2FsVmFsdWUubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgJHNjb3BlLiRhcHBseSgpIGNhbGwgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSB0aGUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuY2xvc2VFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxuXSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jb2RlLXJlcGwtaW5wdXQtYm94IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxufVxcbi5jb2RlLXJlcGwtbGFuZ3VhZ2Uge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgZm9udC1zaXplOiAwLjhlbTtcXG4gIG1hcmdpbi10b3A6IDhweDtcXG59XFxuLmNvZGUtcmVwbC10ZXJtaW5hbCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjIyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBtYXgtaGVpZ2h0OiA2MDBweDtcXG59XFxuLmNvZGUtcmVwbC10ZXJtaW5hbC1lcnJvciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjIyO1xcbiAgY29sb3I6IHJlZDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uY20tcy1wcmV2aWV3LkNvZGVNaXJyb3Ige1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG59XFxuLmNtLXMtcHJldmlldyAuQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIC8qIFdpdGhvdXQgdGhpcywgTGluZS1udW1iZXIgaW4gcHJldmlldyBDb2RlUmVwbCB3aWxsIGJlIG92ZXJsYXBwZWQuICovXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4uY20tcy1wcmV2aWV3IC5Db2RlTWlycm9yLWNvZGUgcHJlIHtcXG4gIC8qIFdpdGhvdXQgdGhpcywgdW5kZXJzY29yZSBjaGFyYWN0ZXJzIGFyZSBub3QgdmlzaWJsZS4gKi9cXG4gIGhlaWdodDogMS4wNGVtO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5jbS1zLXByZXZpZXcgLkNvZGVNaXJyb3ItY29kZSAuY29kZS1yZXBsLW5vbmVkaXRhYmxlLWxpbmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIG9wYWNpdHk6IDAuODtcXG59XFxuLkNvZGVNaXJyb3ItbGluZXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcbi5jb2RlLXJlcGwtY29udGFpbmVyIHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwYWRkaW5nOiA4cHg7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogVGhlIGZvbGxvd2luZyBpcyBuZWVkZWQgc28gdGhhdCB0aGUgcmFkaW8gYnV0dG9uIGRvZXMgbm90IHNob3cuICovXFxuLml0ZW0tc2VsZWN0aW9uLWlucHV0LXJhZGlvLWJ1dHRvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uaXRlbS1zZWxlY3Rpb24taW5wdXQtY2hlY2tib3gge1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIG1hcmdpbjogMnB4O1xcbn1cXG5cXG5tZC1jaGVja2JveC5pdGVtLXNlbGVjdGlvbi1pbnB1dC1jaGVja2JveC5tZC1kZWZhdWx0LXRoZW1lIC5tZC1pY29uIHtcXG4gIGJvcmRlci1jb2xvcjogIzBkNDhhMTtcXG4gIHRvcDogMnB4O1xcbn1cXG5tZC1jaGVja2JveC5pdGVtLXNlbGVjdGlvbi1pbnB1dC1jaGVja2JveC5tZC1kZWZhdWx0LXRoZW1lLm1kLWNoZWNrZWQgLm1kLWljb24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMDIsIDE4NywgMTA2LCAwLjg3KTtcXG59XFxubWQtY2hlY2tib3guaXRlbS1zZWxlY3Rpb24taW5wdXQtY2hlY2tib3ggLm1kLWxhYmVsIHtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxufVxcblxcbi5pdGVtLXNlbGVjdGlvbi1pbnB1dC1mb3JtLWNvbnRhaW5lciB7XFxuICBtYXJnaW4tdG9wOiAtNXB4O1xcbn1cXG4uaXRlbS1zZWxlY3Rpb24taW5wdXQtaXRlbSB7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgY29sb3I6ICMwZDQ4YTE7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgLyogVGhpcyBpcyBuZWVkZWQgc28gdGhhdCBpbWFnZXMgc3RheSBib3VuZGVkIGJ5IHRoZSBjb250YWluZXIgaW4gRmlyZWZveC4gKi9cXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4uaXRlbS1zZWxlY3Rpb24taW5wdXQtY29udGFpbmVyIHtcXG4gIHBhZGRpbmctYm90dG9tOiA1cHg7XFxufVxcblxcbi5pdGVtLXNlbGVjdGlvbi1pbnB1dC1jb250YWluZXIgbWQtaW5wdXQtZ3JvdXAubWQtZGVmYXVsdC10aGVtZSBsYWJlbCB7XFxuICBib3JkZXItYm90dG9tOiAwcHg7XFxufVxcblxcbi5pdGVtLXNlbGVjdGlvbi1pbnB1dC1jb250YWluZXIgaW1nIHtcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbn1cXG5cXG4ubXVsdGlwbGUtY2hvaWNlLW9wdGlvbi1jb250YWluZXIge1xcbiAgcGFkZGluZzogNHB4IDA7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2Utb3B0aW9uIHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogIzBENDhBMTtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICAvKiBUaGlzIGlzIG5lZWRlZCBzbyB0aGF0IGltYWdlcyBzdGF5IGJvdW5kZWQgYnkgdGhlIGNvbnRhaW5lciBpbiBGaXJlZm94LiAqL1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2UtcmFkaW8tYnV0dG9uLWNvbnRhaW5lcixcXG4ubXVsdGlwbGUtY2hvaWNlLWNvbnRlbnQtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2Utb3B0aW9uOmhvdmVyIHtcXG4gIGNvbG9yOiAjMTE1RkQ0O1xcbn1cXG5cXG4ubXVsdGlwbGUtY2hvaWNlLW9wdGlvbjpob3ZlciAubXVsdGlwbGUtY2hvaWNlLWlubmVyLXJhZGlvLWJ1dHRvbixcXG4ubXVsdGlwbGUtY2hvaWNlLW9wdGlvbjpmb2N1cyAubXVsdGlwbGUtY2hvaWNlLWlubmVyLXJhZGlvLWJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTE1RkQ0O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDhweDtcXG4gIG1hcmdpbjogMnB4O1xcbiAgd2lkdGg6IDhweDtcXG59XFxuXFxuLm11bHRpcGxlLWNob2ljZS1vcHRpb246aG92ZXIgLm11bHRpcGxlLWNob2ljZS1vdXRlci1hZGlvLWJ1dHRvbiB7XFxuICBib3JkZXItY29sb3I6ICMxMTVGRDQ7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2Utb3V0ZXItcmFkaW8tYnV0dG9uIHtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMwRDQ4QTE7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICBtYXJnaW4tYm90dG9tOiAtN3B4O1xcbiAgbWFyZ2luLXJpZ2h0OiAxMnB4O1xcbiAgd2lkdGg6IDE2cHg7XFxufVxcblwiLCBcIlwiXSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5sb2dpYy1wcm9vZi1pbnB1dC1ib3gge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG59XFxuLmxvZ2ljLXByb29mLWVycm9uZW91cy1saW5lIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4ubG9naWMtcHJvb2YtZXJyb3ItbWVzc2FnZSB7XFxuICBjb2xvcjogcmVkO1xcbn1cXG5cIiwgXCJcIl0pO1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubXVsdGlwbGUtY2hvaWNlLW9wdGlvbi1jb250YWluZXIge1xcbiAgcGFkZGluZzogNHB4IDA7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2Utb3B0aW9uIHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogIzBENDhBMTtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICAvKiBUaGlzIGlzIG5lZWRlZCBzbyB0aGF0IGltYWdlcyBzdGF5IGJvdW5kZWQgYnkgdGhlIGNvbnRhaW5lciBpbiBGaXJlZm94LiAqL1xcbiAgLyogVGhpcyBhbHNvIGxpbWl0cyB0aGUgc2VsZWN0aW9uIGFyZWEgb2YgdGhlIG9wdGlvbiB0byB0aGUgdGV4dCBhbmQgcmFkaW8gYnV0dG9uLiAqL1xcbiAgd2lkdGg6IGF1dG87XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2UtcmFkaW8tYnV0dG9uLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbn1cXG5cXG4ubXVsdGlwbGUtY2hvaWNlLWNvbnRlbnQtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbn1cXG5cXG4ubXVsdGlwbGUtY2hvaWNlLW9wdGlvbjpob3ZlciB7XFxuICBjb2xvcjogIzExNUZENDtcXG59XFxuXFxuLm11bHRpcGxlLWNob2ljZS1vcHRpb246aG92ZXIgLm11bHRpcGxlLWNob2ljZS1pbm5lci1yYWRpby1idXR0b24sXFxuLm11bHRpcGxlLWNob2ljZS1vcHRpb246Zm9jdXMgLm11bHRpcGxlLWNob2ljZS1pbm5lci1yYWRpby1idXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzExNUZENDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiA4cHg7XFxuICBtYXJnaW46IDJweDtcXG4gIHdpZHRoOiA4cHg7XFxufVxcblxcbi5tdWx0aXBsZS1jaG9pY2Utb3B0aW9uOmhvdmVyIC5tdWx0aXBsZS1jaG9pY2Utb3V0ZXItcmFkaW8tYnV0dG9uLFxcbi5tdWx0aXBsZS1jaG9pY2Utb3B0aW9uOmZvY3VzIC5tdWx0aXBsZS1jaG9pY2Utb3V0ZXItcmFkaW8tYnV0dG9uIHtcXG4gIGJvcmRlci1jb2xvcjogIzExNUZENDtcXG59XFxuXFxuLm11bHRpcGxlLWNob2ljZS1vdXRlci1yYWRpby1idXR0b24ge1xcbiAgYm9yZGVyOiAycHggc29saWQgIzBENDhBMTtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMTZweDtcXG4gIG1hcmdpbi1ib3R0b206IC03cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDEycHg7XFxuICB3aWR0aDogMTZweDtcXG59XFxuXCIsIFwiXCJdKTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogVGhlIGNvbnRhaW5lciBhcm91bmQgdGhlIHN0YWZmIGFuZCBub3RlQ2hvaWNlcy5cXG4gKiBUaGlzIGtlZXBzIHRoZSBub3RlIGZyb20gZHJvcHBpbmcgb24gdG9wIG9mIHRoZSBjbGVmLlxcbiAqL1xcblxcbi5vcHBpYS1tdXNpYy1pbnB1dC12YWxpZC1ub3RlLWFyZWEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZmxvYXQ6bGVmdDtcXG4gIG1hcmdpbjogMCAwIDAgMTEuMDc4NCU7XFxuICB3aWR0aDogODcuMzQ1MjUlO1xcbiAgaGVpZ2h0OiA0MyU7XFxuICAvKiBIaWRlIHZhbGlkIG5vdGUgYXJlYSB1bnRpbCBwYWdlIGxvYWRzICovXFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcblxcbi8qIFRoZSBib3ggYXJvdW5kIHN0YWZmICovXFxuXFxuLm9wcGlhLW11c2ljLWlucHV0LXN0YWZmIHtcXG4gIGNsZWFyOiBib3RoO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBtYXgtd2lkdGg6IDY3M3B4O1xcbn1cXG5cXG4vKiBUaGUgYm94IGFyb3VuZCBub3RlIGNob2ljZXMgKi9cXG5cXG4ub3BwaWEtbXVzaWMtaW5wdXQtbm90ZS1jaG9pY2VzIHtcXG4gIGNsZWFyOiBib3RoO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA0KTsgLyogQ29sb3Igb2Ygbm90ZUNob2ljZXMgYm94ICovXFxuICB3aWR0aDogNSU7XFxuICBwYWRkaW5nOiAyLjMlIDklIDUuODMlIDEuMSU7XFxuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xcbiAgYm9yZGVyOiAwLjJlbSBzb2xpZCAjMzMzO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAxMSU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDExJTtcXG4gIGJvcmRlci1yYWRpdXM6IDExJTtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi8qIFRoZSBpbnZpc2libGUgYm94IGFyb3VuZCBkcm9wcGFibGUgc3RhZmYgKi9cXG5cXG4ub3BwaWEtbXVzaWMtaW5wdXQtc3RhZmYge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGNsZWFyOiBib3RoO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgd2lkdGg6IDExMC4xJTtcXG4gIHBhZGRpbmc6IDEuNSUgMCAzJSAwO1xcbn1cXG5cXG4vKiBUaGUgc3RhZmYgbGluZXMgYW5kIGxlZGdlciBsaW5lcyAqL1xcblxcbi5vcHBpYS1tdXNpYy1pbnB1dC1zdGFmZiBkaXYub3BwaWEtbXVzaWMtc3RhZmYtcG9zaXRpb24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW46IDAgMDtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4ub3BwaWEtbXVzaWMtaW5wdXQtc3RhZmYgZGl2Lm9wcGlhLW11c2ljLWlucHV0LWhvdmVyZWQge1xcbiAgYmFja2dyb3VuZDogI2FhYTtcXG59XFxuXFxuLm9wcGlhLW11c2ljLWlucHV0LXN0YWZmIGRpdi5vcHBpYS1tdXNpYy1zdGFmZi1saW5lIHtcXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA7XFxuICBoZWlnaHQ6IDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4ub3BwaWEtbXVzaWMtaW5wdXQtc3RhZmYge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC9leHRlbnNpb25zL2ludGVyYWN0aW9ucy9NdXNpY05vdGVzSW5wdXQvc3RhdGljL2ltYWdlcy90cmVibGVfY2xlZi5wbmcpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDAuMSUgNjIlO1xcbiAgYmFja2dyb3VuZC1zaXplOiA4LjUlIDg5JTtcXG59XFxuXFxuLyogSW5kaXZpZHVhbCBub3RlcyAqL1xcblxcbi5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2IHtcXG4gIHdpZHRoOiA3LjglO1xcbiAgaGVpZ2h0OiA5LjIlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi5vcHBpYS1tdXNpYy1pbnB1dC1ub3RlLWNob2ljZXMgZGl2Lm9wcGlhLW11c2ljLWlucHV0LW5hdHVyYWwtbm90ZSB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvZXh0ZW5zaW9ucy9pbnRlcmFjdGlvbnMvTXVzaWNOb3Rlc0lucHV0L3N0YXRpYy9pbWFnZXMvd2hvbGVfbm90ZS5wbmcpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogNzElO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4ub3BwaWEtbXVzaWMtaW5wdXQtc3RhZmYgLm9wcGlhLW11c2ljLWlucHV0LWxlZGdlci1saW5lIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA4JTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjM1JTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDAwMDA7XFxufVxcblxcbi5vcHBpYS1tdXNpYy1pbnB1dC1vbi1zdGFmZiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAvKiBNYXhpbXVtIDE0LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBhYm92ZVxcbiAgICAgdGhlIHR1dG9yY2FyZCBpZiB2aWV3cG9ydCBpcyBsZXNzIHRoYW4gOTYwICovXFxuICB6LWluZGV4OiAxNDtcXG59XFxuXFxuLm9wcGlhLW11c2ljLWlucHV0LWNvbnRyb2wtYnV0dG9ucyB7XFxuICBwYWRkaW5nOiA0MCUgMCA1JSAyJTtcXG59XFxuXFxuLm9wcGlhLW11c2ljLWlucHV0LWJ0biB7XFxuICBwYWRkaW5nOiA2cHggMTBweDtcXG59XFxuXFxuLm9wcGlhLW11c2ljLWlucHV0LXBsYXktYnRuIHtcXG4gIG1hcmdpbi1sZWZ0OiAtNTVweDtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcblwiLCBcIlwiXSk7XG4iXSwic291cmNlUm9vdCI6IiJ9