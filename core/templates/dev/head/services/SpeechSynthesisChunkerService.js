// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service to chunk a piece of text into smaller parts
 * to feed into SpeechSynthesis, because SpeechSynthesis always times
 * out after 200-300 characters.
 *
 * Code is adapted from:
 * https://gist.github.com/woollsta/2d146f13878a301b36d7
 *
 * Credits to Peter Woolley and Brett Zamir.
 */

oppia.factory('SpeechSynthesisChunkerService', [
  '$timeout', 'rteHelperService', function($timeout, rteHelperService) {
    // Max number of characters to fit into one chunk.
    var CHUNK_LENGTH = 160;

    var _speechSynthesis = window.speechSynthesis;

    // Punctuation marks that should result in an audible pause when playing
    // back autogenerated audio.
    var PUNCTUATION_MARKS_TO_END_CHUNKS = '.!?:;';
    // Punctuation marks that we don't want to influence the playing back of
    // autogenerated audio.
    var PUNCTUATION_MARKS_TO_IGNORE = '"';

    /**
     * Takes an utterance, and plays it in separate utterances each of at
     *    most 160 characters in length.
     * @param {SpeechSynthesisUtterance} utterance - The original utterance
     *    that contains the whole message to speak.
     * @param {Number} offset - An integer indicating what offset in the text
     *    to begin the next chunked utterance.
     * @param {requestCallback} - Callback that is activated when the last
     *    chunked utterance finishes playing.
     */
    var _speechUtteranceChunker = function(utterance, offset, callback) {
      var newUtterance;
      var text = (offset !== undefined ?
          utterance.text.substring(offset) : utterance.text);

      // This regex pattern finds the next string at most 160
      // characters in length that ends on a punctuation mark in
      // PUNCTUATION_MARKS_TO_END_CHUNKS.
      var delimitChunkRegex = new RegExp('^[\\s\\S]{' +
        Math.floor(CHUNK_LENGTH / 4) + ',' + CHUNK_LENGTH + '}[' +
        PUNCTUATION_MARKS_TO_END_CHUNKS + ']{1}|^[\\s\\S]{1,' +
        CHUNK_LENGTH + '}$|^[\\s\\S]{1,' + CHUNK_LENGTH + '} ');
      var chunkArray = text.match(delimitChunkRegex);
      if (chunkArray == null ||
          chunkArray[0] === undefined ||
          chunkArray[0].length <= 2) {
        // Call once all text has been spoken.
        if (callback !== undefined) {
          callback();
        }
        return;
      }
      var chunk = chunkArray[0];
      newUtterance = new SpeechSynthesisUtterance(chunk);

      // Copy properties from the current utterance to the next utterance,
      // excluding the text being spoken.
      for (var property in utterance) {
        if (property !== 'text') {
          newUtterance[property] = utterance[property];
        }
      }
      newUtterance.onend = function() {
        if (_speechUtteranceChunker.cancel) {
          _speechUtteranceChunker.cancel = false;
          return;
        }
        offset += chunk.length;
        _speechUtteranceChunker(utterance, offset, callback);
      }

      // IMPORTANT!! Do not remove: Logging the object out fixes some onend
      // firing issues. Placing the speak invocation inside a callback
      // fixes ordering and onend issues.
      console.log(newUtterance);
      $timeout(function () {
        speechSynthesis.speak(newUtterance);
      }, 0);
    };

    var _convertToSpeakableText = function(html) {
      // Replace certain HTML elements with periods to indicate
      // pauses in speaking. Also, for some reason, there's a lot
      // of whitespace (like hundreds of characters) so we trim
      // it off to avoid blank chunks.
      console.log(html);
      html = rteHelperService.convertHtmlToRte(html);
      console.log(html);
      html = html.replace(new RegExp('</li>', 'g'), '.').trim();
      // Strip away HTML tags.
      var tmp = $("<div></div>")
      tmp.html(html);
      var textToSpeak = tmp.text();

      // Insert a space after punctuation marks to ensure that chunking will
      // end on the desired punctuation marks so that SpeechSynthesis will
      // pause more naturally. Remove any punctuation marks that have no
      // effect on speaking.
      for (var i = 0; i < textToSpeak.length; i++) {
        if (PUNCTUATION_MARKS_TO_END_CHUNKS.indexOf(
            textToSpeak.charAt(i)) > -1) {
          textToSpeak = _insertSpaceAfterIndex(textToSpeak, i);
          i++;
        }
        if (PUNCTUATION_MARKS_TO_IGNORE.indexOf(
            textToSpeak.charAt(i)) > -1) {
          textToSpeak = _removeCharacterAtIndex(textToSpeak, i);
        }
      }

      return textToSpeak;
    };

    var _insertSpaceAfterIndex = function(targetString, index) {
      return targetString.substr(0, index + 1) + ' ' +
        targetString.substr(index + 1);
    };

    var _removeCharacterAtIndex = function(targetString, index) {
      return targetString.substr(0, index) + targetString.substr(index + 1);
    };

    return {
      speak: function(utterance, settings, callback) {
        _speechUtteranceChunker.cancel = false;
        _speechUtteranceChunker(utterance, settings, callback);
      },
      cancel: function() {
        _speechSynthesis.cancel();
        _speechUtteranceChunker.cancel = true;
      },
      convertToSpeakableText: function(html) {
        return _convertToSpeakableText(html);
      }
    }
  }
]);
