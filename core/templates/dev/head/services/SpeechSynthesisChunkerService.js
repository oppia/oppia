// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service to chunk a piece of text into smaller parts
 * to feed into SpeechSynthesis, because SpeechSynthesis always times
 * out after 200-300 characters.
 * 
 * Code is adapted from:
 * https://gist.github.com/woollsta/2d146f13878a301b36d7
 * 
 * Credits to Peter Woolley and Brett Zamir.
 */

oppia.factory('SpeechSynthesisChunkerService', [
  '$timeout', function($timeout) {
    var _speechSynthesis = window.speechSynthesis;

    // Punctuation marks that should result in an audible pause when playing
    // back autogenerated audio.
    var PUNCTUATION_MARKS_TO_END_CHUNKS = '.!?:;';
    // Punctuation marks that we don't want to influence the playing back of
    // autogenerated audio.
    var PUNCTUATION_MARKS_TO_IGNORE = '"';

    var _speechUtteranceChunker = function(utt, settings, callback) {
      settings = settings || {};
      var newUtt;
      var txt = (settings && settings.offset !== undefined ?
          utt.text.substring(settings.offset) : utt.text);
      if (utt.voice && utt.voice.voiceURI === 'native') {
        // Not part of the spec
        newUtt = utt;
        newUtt.text = txt;
        newUtt.addEventListener('end', function () {
          if (_speechUtteranceChunker.cancel) {
            _speechUtteranceChunker.cancel = false;
          }
          if (callback !== undefined) {
            callback();
          }
        });
      }
      else {
        var chunkLength = (settings && settings.chunkLength) || 160;
        var pattRegex = new RegExp('^[\\s\\S]{' +
          Math.floor(chunkLength / 4) + ',' + chunkLength + '}[' +
          PUNCTUATION_MARKS_TO_END_CHUNKS + ']{1}|^[\\s\\S]{1,' +
          chunkLength + '}$|^[\\s\\S]{1,' + chunkLength + '} ');
        var chunkArr = txt.match(pattRegex);
        if (chunkArr == null ||
            chunkArr[0] === undefined ||
            chunkArr[0].length <= 2) {
          // Call once all text has been spoken.
          if (callback !== undefined) {
            callback();
          }
          return;
        }
        var chunk = chunkArr[0];
        newUtt = new SpeechSynthesisUtterance(chunk);
        var x;
        for (x in utt) {
          if (x !== 'text') {
            newUtt[x] = utt[x];
          }
        }
        newUtt.onend = function() {
          if (_speechUtteranceChunker.cancel) {
            _speechUtteranceChunker.cancel = false;
            return;
          }
          settings.offset = settings.offset || 0;
          settings.offset += chunk.length;
          _speechUtteranceChunker(utt, settings, callback);
        }
      }
   
      if (settings.modifier) {
        settings.modifier(newUtt);
      }

      // IMPORTANT!! Do not remove: Logging the object out fixes some onend
      // firing issues. Placing the speak invocation inside a callback
      // fixes ordering and onend issues.
      console.log(newUtt);
      $timeout(function () {
        speechSynthesis.speak(newUtt);
      }, 0);
    };

    var _preprocessHtmlForChunking = function(html) {
      // Replace certain HTML elements with periods to indicate
      // pauses in speaking. Also, for some reason, there's a lot
      // of whitespace (like hundreds of characters) so we trim
      // it off to avoid blank chunks.
      html = html.replace(new RegExp('</li>', 'g'), '.').trim();
      // Strip away HTML tags.
      var tmp = document.createElement('div');
      tmp.innerHTML = html;
      var textToSpeak = tmp.textContent || tmp.innerText || '';

      // Insert a space after punctuation marks to ensure that chunking will
      // end on the desired punctuation marks so that SpeechSynthesis will
      // pause more naturally. Remove any punctuation marks that have no
      // effect on speaking.
      for (var i = 0; i < textToSpeak.length; i++) {
        if (PUNCTUATION_MARKS_TO_END_CHUNKS.indexOf(
            textToSpeak.charAt(i)) > -1) {
          textToSpeak = _insertSpaceAfterIndex(textToSpeak, i);
          i++;
        }
        if (PUNCTUATION_MARKS_TO_IGNORE.indexOf(
            textToSpeak.charAt(i)) > -1) {
          textToSpeak = _removeCharacterAtIndex(textToSpeak, i);
        }
      }

      return textToSpeak;
    };

    var _insertSpaceAfterIndex = function(targetString, index) {
      return targetString.substr(0, index + 1) + ' ' +
        targetString.substr(index + 1);
    };

    var _removeCharacterAtIndex = function(targetString, index) {
      return targetString.substr(0, index) + targetString.substr(index + 1);
    };

    return {
      speak: function(utterance, settings, callback) {
        _speechUtteranceChunker.cancel = false;
        _speechUtteranceChunker(utterance, settings, callback);
      },
      cancel: function() {
        _speechSynthesis.cancel();
        _speechUtteranceChunker.cancel = true;
      },
      preprocessHtmlForChunking: function(html) {
        return _preprocessHtmlForChunking(html);
      }
    }
  }
]);
