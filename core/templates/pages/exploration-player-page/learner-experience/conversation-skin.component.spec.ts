// Copyright 2022 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for Conversation skin component.
 */

import {HttpClientTestingModule} from '@angular/common/http/testing';
import {EventEmitter, NO_ERRORS_SCHEMA} from '@angular/core';
import {
  ComponentFixture,
  fakeAsync,
  TestBed,
  tick,
  waitForAsync,
  flush,
} from '@angular/core/testing';
import {TranslateService} from '@ngx-translate/core';
import {MockTranslateService} from 'components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';
import {QuestionPlayerStateService} from 'components/question-directives/question-player/services/question-player-state.service';
import {Collection} from 'domain/collection/collection.model';
import {GuestCollectionProgressService} from 'domain/collection/guest-collection-progress.service';
import {ReadOnlyCollectionBackendApiService} from 'domain/collection/read-only-collection-backend-api.service';
import {
  Interaction,
  InteractionObjectFactory,
} from 'domain/exploration/InteractionObjectFactory';
import {
  FetchExplorationBackendResponse,
  ReadOnlyExplorationBackendApiService,
} from 'domain/exploration/read-only-exploration-backend-api.service';
import {BindableVoiceovers} from 'domain/exploration/recorded-voiceovers.model';
import {SubtitledHtml} from 'domain/exploration/subtitled-html.model';
import {ConceptCardBackendApiService} from 'domain/skill/concept-card-backend-api.service';
import {ConceptCard} from 'domain/skill/concept-card.model';
import {StateObjectFactory} from 'domain/state/StateObjectFactory';
import {StateCard} from 'domain/state_card/state-card.model';
import {ReadOnlyStoryNode} from 'domain/story_viewer/read-only-story-node.model';
import {StoryPlaythrough} from 'domain/story_viewer/story-playthrough.model';
import {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';
import {
  ExplorationSummaryBackendApiService,
  ExplorationSummaryDict,
} from 'domain/summary/exploration-summary-backend-api.service';
import {UserInfo} from 'domain/user/user-info.model';
import {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';
import {CollectionPlayerBackendApiService} from 'pages/collection-player-page/services/collection-player-backend-api.service';
import {AlertsService} from 'services/alerts.service';
import {AudioPlayerService} from 'services/audio-player.service';
import {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';
import {ContextService} from 'services/context.service';
import {UrlService} from 'services/contextual/url.service';
import {WindowDimensionsService} from 'services/contextual/window-dimensions.service';
import {WindowRef} from 'services/contextual/window-ref.service';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {LoaderService} from 'services/loader.service';
import {LocalStorageService} from 'services/local-storage.service';
import {MessengerService} from 'services/messenger.service';
import {SiteAnalyticsService} from 'services/site-analytics.service';
import {FocusManagerService} from 'services/stateful/focus-manager.service';
import {UserService} from 'services/user.service';
import {MockTranslatePipe} from 'tests/unit-test-utils';
import {ExplorationPlayerConstants} from '../exploration-player-page.constants';
import {
  AnswerClassificationService,
  InteractionRulesService,
} from '../services/answer-classification.service';
import {ContentTranslationManagerService} from '../services/content-translation-manager.service';
import {CurrentInteractionService} from '../services/current-interaction.service';
import {ExplorationEngineService} from '../services/exploration-engine.service';
import {ExplorationPlayerStateService} from '../services/exploration-player-state.service';
import {ExplorationRecommendationsService} from '../services/exploration-recommendations.service';
import {FatigueDetectionService} from '../services/fatigue-detection.service';
import {HintsAndSolutionManagerService} from '../services/hints-and-solution-manager.service';
import {ImagePreloaderService} from '../services/image-preloader.service';
import {LearnerAnswerInfoService} from '../services/learner-answer-info.service';
import {LearnerParamsService} from '../services/learner-params.service';
import {NumberAttemptsService} from '../services/number-attempts.service';
import {PlayerPositionService} from '../services/player-position.service';
import {PlayerTranscriptService} from '../services/player-transcript.service';
import {QuestionPlayerEngineService} from '../services/question-player-engine.service';
import {RefresherExplorationConfirmationModalService} from '../services/refresher-exploration-confirmation-modal.service';
import {StatsReportingService} from '../services/stats-reporting.service';
import {ConversationSkinComponent} from './conversation-skin.component';
import {PlatformFeatureService} from 'services/platform-feature.service';
import {LearnerDashboardBackendApiService} from 'domain/learner_dashboard/learner-dashboard-backend-api.service';
import {EditableExplorationBackendApiService} from 'domain/exploration/editable-exploration-backend-api.service';
import {DiagnosticTestTopicTrackerModel} from 'pages/diagnostic-test-player-page/diagnostic-test-topic-tracker.model';
import {AudioTranslationLanguageService} from '../services/audio-translation-language.service';
import {ConceptCardManagerService} from '../services/concept-card-manager.service';
import {SolutionObjectFactory} from 'domain/exploration/SolutionObjectFactory';
import {ConversationFlowService} from '../services/conversation-flow.service';
import {VoiceoverPlayerService} from '../services/voiceover-player.service';

class MockWindowRef {
  nativeWindow = {
    location: {
      pathname: '/path/name',
      reload: () => {},
    },
    onresize: () => {},
    addEventListener(event: string, callback) {
      callback({returnValue: null});
    },
    scrollTo: (x, y) => {},
  };
}

class MockPlatformFeatureService {
  get status(): object {
    return {
      EndChapterCelebration: {
        isEnabled: true,
      },
    };
  }
}

describe('Conversation skin component', () => {
  let fixture: ComponentFixture<ConversationSkinComponent>;
  let componentInstance: ConversationSkinComponent;
  let alertsService: AlertsService;
  let audioPlayerService: AudioPlayerService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let collectionPlayerBackendApiService: CollectionPlayerBackendApiService;
  let conceptCardBackendApiService: ConceptCardBackendApiService;
  let contentTranslationManagerService: ContentTranslationManagerService;
  let contextService: ContextService;
  let conversationFlowService: ConversationFlowService;
  let currentInteractionService: CurrentInteractionService;
  let editableExplorationBackendApiService: EditableExplorationBackendApiService;
  let explorationEngineService: ExplorationEngineService;
  let explorationPlayerStateService: ExplorationPlayerStateService;
  let explorationRecommendationsService: ExplorationRecommendationsService;
  let explorationSummaryBackendApiService: ExplorationSummaryBackendApiService;
  let fatigueDetectionService: FatigueDetectionService;
  let focusManagerService: FocusManagerService;
  let guestCollectionProgressService: GuestCollectionProgressService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let imagePreloaderService: ImagePreloaderService;
  let learnerAnswerInfoService: LearnerAnswerInfoService;
  let learnerParamsService: LearnerParamsService;
  let loaderService: LoaderService;
  let localStorageService: LocalStorageService;
  let messengerService: MessengerService;
  let numberAttemptsService: NumberAttemptsService;
  let interactionObjectFactory: InteractionObjectFactory;
  let playerPositionService: PlayerPositionService;
  let playerTranscriptService: PlayerTranscriptService;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let questionPlayerStateService: QuestionPlayerStateService;
  let answerClassificationService: AnswerClassificationService;
  let readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService;
  let refresherExplorationConfirmationModalService: RefresherExplorationConfirmationModalService;
  let siteAnalyticsService: SiteAnalyticsService;
  let statsReportingService: StatsReportingService;
  let storyViewerBackendApiService: StoryViewerBackendApiService;
  let urlInterpolationService: UrlInterpolationService;
  let urlService: UrlService;
  let userService: UserService;
  let windowDimensionsService: WindowDimensionsService;
  let windowRef: WindowRef;
  let readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService;
  let stateObjectFactory: StateObjectFactory;
  let platformFeatureService: PlatformFeatureService;
  let translateService: TranslateService;
  let learnerDashboardBackendApiService: LearnerDashboardBackendApiService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let conceptCardManagerService: ConceptCardManagerService;
  let solutionObjectFactory: SolutionObjectFactory;
  let voiceoverPlayerService: VoiceoverPlayerService;

  let displayedCard = new StateCard(
    null,
    null,
    null,
    new Interaction([], [], null, null, [], '', null),
    [],
    null,
    '',
    null
  );

  let explorationDict = {
    states: {
      Start: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            ca_placeholder_0: {},
            feedback_1: {},
            rule_input_2: {},
            content: {},
            default_outcome: {},
          },
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1,
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0',
              },
            },
            catchMisspellings: {
              value: false,
            },
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: '<p>Good Job</p>',
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'Mid',
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: ['answer'],
                      contentId: 'rule_input_2',
                    },
                  },
                  rule_type: 'FuzzyEquals',
                },
              ],
              tagged_skill_misconception_id: null,
            },
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>Try again.</p>',
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Start',
          },
        },
        param_changes: [],
        card_is_checkpoint: true,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>First Question</p>',
        },
      },
      End: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            content: {},
          },
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'EndExploration',
          hints: [],
          customization_args: {
            recommendedExplorationIds: {
              value: ['recommnendedExplorationId'],
            },
          },
          answer_groups: [],
          default_outcome: null,
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: 'Congratulations, you have finished!',
        },
      },
      Mid: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            ca_placeholder_0: {},
            feedback_1: {},
            rule_input_2: {},
            content: {},
            default_outcome: {},
          },
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1,
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0',
              },
            },
            catchMisspellings: {
              value: false,
            },
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: ' <p>Good Job</p>',
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'End',
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: ['answer'],
                      contentId: 'rule_input_2',
                    },
                  },
                  rule_type: 'FuzzyEquals',
                },
              ],
              tagged_skill_misconception_id: null,
            },
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>try again.</p>',
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Mid',
          },
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>Second Question</p>',
        },
      },
    },
    auto_tts_enabled: true,
    version: 2,
    draft_change_list_id: 9,
    is_version_of_draft_valid: null,
    title: 'Exploration',
    language_code: 'en',
    init_state_name: 'Start',
    param_changes: [],
    next_content_id_index: 4,
    param_specs: null,
    draft_changes: null,
  };

  let explorationResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index,
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      edits_allowed: true,
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: 'Mid',
    most_recently_reached_checkpoint_exp_version: 2,
  };

  let sampleExpResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index,
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      edits_allowed: true,
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: null,
    most_recently_reached_checkpoint_exp_version: 2,
  };
  let uniqueProgressIdResponse = '123456';

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      declarations: [ConversationSkinComponent, MockTranslatePipe],
      providers: [
        SolutionObjectFactory,
        {
          provide: WindowRef,
          useClass: MockWindowRef,
        },
        {
          provide: PlatformFeatureService,
          useClass: MockPlatformFeatureService,
        },
        {
          provide: TranslateService,
          useClass: MockTranslateService,
        },
      ],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();

    fixture = TestBed.createComponent(ConversationSkinComponent);
    componentInstance = fixture.componentInstance;

    alertsService = TestBed.inject(AlertsService);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService
    );
    collectionPlayerBackendApiService = TestBed.inject(
      CollectionPlayerBackendApiService
    );
    conceptCardBackendApiService = TestBed.inject(ConceptCardBackendApiService);
    contentTranslationManagerService = TestBed.inject(
      ContentTranslationManagerService
    );
    contextService = TestBed.inject(ContextService);
    conversationFlowService = TestBed.inject(ConversationFlowService);
    currentInteractionService = TestBed.inject(CurrentInteractionService);
    editableExplorationBackendApiService = TestBed.inject(
      EditableExplorationBackendApiService
    );
    explorationEngineService = TestBed.inject(ExplorationEngineService);
    explorationPlayerStateService = TestBed.inject(
      ExplorationPlayerStateService
    );
    explorationRecommendationsService = TestBed.inject(
      ExplorationRecommendationsService
    );
    explorationSummaryBackendApiService = TestBed.inject(
      ExplorationSummaryBackendApiService
    );
    fatigueDetectionService = TestBed.inject(FatigueDetectionService);
    interactionObjectFactory = TestBed.inject(InteractionObjectFactory);
    focusManagerService = TestBed.inject(FocusManagerService);
    audioTranslationLanguageService = TestBed.inject(
      AudioTranslationLanguageService
    );
    guestCollectionProgressService = TestBed.inject(
      GuestCollectionProgressService
    );
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService
    );
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    imagePreloaderService = TestBed.inject(ImagePreloaderService);
    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);
    learnerParamsService = TestBed.inject(LearnerParamsService);
    loaderService = TestBed.inject(LoaderService);
    localStorageService = TestBed.inject(LocalStorageService);
    messengerService = TestBed.inject(MessengerService);
    numberAttemptsService = TestBed.inject(NumberAttemptsService);
    playerPositionService = TestBed.inject(PlayerPositionService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    questionPlayerStateService = TestBed.inject(QuestionPlayerStateService);
    readOnlyCollectionBackendApiService = TestBed.inject(
      ReadOnlyCollectionBackendApiService
    );
    refresherExplorationConfirmationModalService = TestBed.inject(
      RefresherExplorationConfirmationModalService
    );
    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);
    statsReportingService = TestBed.inject(StatsReportingService);
    solutionObjectFactory = TestBed.inject(SolutionObjectFactory);
    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);
    urlInterpolationService = TestBed.inject(UrlInterpolationService);
    urlService = TestBed.inject(UrlService);
    userService = TestBed.inject(UserService);
    windowDimensionsService = TestBed.inject(WindowDimensionsService);
    windowRef = TestBed.inject(WindowRef);
    readOnlyExplorationBackendApiService = TestBed.inject(
      ReadOnlyExplorationBackendApiService
    );
    stateObjectFactory = TestBed.inject(StateObjectFactory);
    answerClassificationService = TestBed.inject(AnswerClassificationService);
    platformFeatureService = TestBed.inject(PlatformFeatureService);
    conceptCardManagerService = TestBed.inject(ConceptCardManagerService);
    translateService = TestBed.inject(TranslateService);
    learnerDashboardBackendApiService = TestBed.inject(
      LearnerDashboardBackendApiService
    );
    audioTranslationLanguageService = TestBed.inject(
      AudioTranslationLanguageService
    );
    voiceoverPlayerService = TestBed.inject(VoiceoverPlayerService);
  }));

  it('should create && adjust page height on resize of window', fakeAsync(() => {
    spyOn(componentInstance, 'adjustPageHeight').and.stub();
    componentInstance.adjustPageHeightOnresize();

    expect(componentInstance).toBeDefined();

    windowRef.nativeWindow.onresize(null);
    tick(200);

    expect(componentInstance.adjustPageHeight).toHaveBeenCalled();
  }));

  it('should initialize component', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = true;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    let newStateName = 'newState';
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(
      isInPreviewMode
    );
    spyOn(
      explorationPlayerStateService,
      'getCurrentEngineService'
    ).and.returnValue(explorationEngineService);
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(
      explorationPlayerStateService,
      'isInQuestionPlayerMode'
    ).and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(componentInstance, 'fetchCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );
    spyOn(
      componentInstance,
      'doesCollectionAllowsGuestProgress'
    ).and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(explorationResponse));
    spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue([
      'Start',
      'Mid',
    ]);
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(
      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})
    );

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      explorationPlayerStateService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    mockOnNewCardOpened.emit(componentInstance.nextCard);
    mockOnHintsExhausted.emit();
    mockOnLearnerGetsReallyStuck.emit();
    mockOnLearnerReallyStuck.emit();
    mockOnHintConsumed.emit();
    mockOnSolutionViewedEventEmitter.emit();
    mockOnPlayerStateChange.emit();
    mockOnPlayerStateChange.emit(newStateName);
    tick(100);

    componentInstance.redirectToRefresherExplorationConfirmed = true;

    spyOn(alertsService, 'addWarning');
    componentInstance.ngOnInit();

    windowRef.nativeWindow.onresize(null);
    tick(1000);
  }));

  it('should initialize component as logged in user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(componentInstance, 'fetchCompletedChaptersCount').and.callThrough();
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync'
    ).and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      })
    );
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(
      isInPreviewMode
    );
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(
      explorationPlayerStateService,
      'isInQuestionPlayerMode'
    ).and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );
    spyOn(
      componentInstance,
      'doesCollectionAllowsGuestProgress'
    ).and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(sampleExpResponse));

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      explorationPlayerStateService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = true;
    componentInstance.isIframed = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it('should initialize component as logged out user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    let expResponse = sampleExpResponse;
    expResponse.is_logged_in = false;
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', false)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(
      isInPreviewMode
    );
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(
      explorationPlayerStateService,
      'isInQuestionPlayerMode'
    ).and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(componentInstance, 'fetchCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );
    spyOn(
      componentInstance,
      'doesCollectionAllowsGuestProgress'
    ).and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(expResponse));
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(
      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})
    );

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      explorationPlayerStateService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = false;
    componentInstance.isIframed = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it(
    'should convert logged out progress to logged in progress when user ' +
      'signs in',
    fakeAsync(() => {
      let collectionId = 'id';
      let expId = 'exp_id';
      let isInPreviewMode = false;
      let isIframed = false;
      let collectionSummary = {
        is_admin: true,
        summaries: [],
        user_email: '',
        is_topic_manager: false,
        username: true,
      };
      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(
          new UserInfo([], false, false, false, false, false, '', '', '', true)
        )
      );
      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
        collectionId,
        null
      );
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

      spyOn(
        readOnlyCollectionBackendApiService,
        'loadCollectionAsync'
      ).and.returnValue(
        Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
      );
      spyOn(explorationEngineService, 'getExplorationId').and.returnValue(
        expId
      );
      spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(
        isInPreviewMode
      );
      spyOn(urlService, 'isIframed').and.returnValue(isIframed);
      spyOn(loaderService, 'showLoadingScreen');
      spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
        'oppia_avatar_url'
      );
      spyOn(
        explorationPlayerStateService,
        'isInQuestionPlayerMode'
      ).and.returnValues(true, false);
      spyOn(componentInstance, 'initializePage');
      spyOn(
        collectionPlayerBackendApiService,
        'fetchCollectionSummariesAsync'
      ).and.returnValue(Promise.resolve(collectionSummary));
      spyOn(questionPlayerStateService, 'hintUsed');
      spyOn(questionPlayerEngineService, 'getCurrentQuestion');
      spyOn(questionPlayerStateService, 'solutionViewed');
      spyOn(imagePreloaderService, 'onStateChange');
      spyOn(statsReportingService, 'recordExplorationCompleted');
      spyOn(statsReportingService, 'recordExplorationActuallyStarted');
      spyOn(
        guestCollectionProgressService,
        'recordExplorationCompletedInCollection'
      );
      spyOn(
        componentInstance,
        'doesCollectionAllowsGuestProgress'
      ).and.returnValue(true);
      spyOn(statsReportingService, 'recordMaybeLeaveEvent');
      spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
      spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
      spyOn(messengerService, 'sendMessage');
      spyOn(
        readOnlyExplorationBackendApiService,
        'loadLatestExplorationAsync'
      ).and.returnValue(Promise.resolve(sampleExpResponse));
      spyOn(
        editableExplorationBackendApiService,
        'changeLoggedOutProgressToLoggedInProgressAsync'
      ).and.returnValue(Promise.resolve());

      let mockOnHintConsumed = new EventEmitter();
      let mockOnSolutionViewedEventEmitter = new EventEmitter();
      let mockOnPlayerStateChange = new EventEmitter();
      let mockOnNewCardOpened = new EventEmitter();
      let mockOnHintsExhausted = new EventEmitter();
      let mockOnLearnerReallyStuck = new EventEmitter();
      let mockOnLearnerGetsReallyStuck = new EventEmitter();

      spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
        mockOnNewCardOpened
      );
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onHintsExhausted'
      ).and.returnValue(mockOnHintsExhausted);
      spyOnProperty(
        conceptCardManagerService,
        'onLearnerGetsReallyStuck'
      ).and.returnValue(mockOnLearnerGetsReallyStuck);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onLearnerReallyStuck'
      ).and.returnValue(mockOnLearnerReallyStuck);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onHintConsumed'
      ).and.returnValue(mockOnHintConsumed);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onSolutionViewedEventEmitter'
      ).and.returnValue(mockOnSolutionViewedEventEmitter);
      spyOnProperty(
        explorationPlayerStateService,
        'onPlayerStateChange'
      ).and.returnValue(mockOnPlayerStateChange);
      spyOn(
        localStorageService,
        'getUniqueProgressIdOfLoggedOutLearner'
      ).and.returnValue('abcdef');
      spyOn(localStorageService, 'removeUniqueProgressIdOfLoggedOutLearner');

      componentInstance.nextCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        null,
        '',
        null
      );
      componentInstance.isLoggedIn = true;
      componentInstance.isIframed = false;
      componentInstance.hasInteractedAtLeastOnce = true;
      componentInstance.displayedCard = displayedCard;

      componentInstance.ngOnInit();
      tick(100);

      expect(
        editableExplorationBackendApiService.changeLoggedOutProgressToLoggedInProgressAsync
      ).toHaveBeenCalled();
      expect(
        localStorageService.removeUniqueProgressIdOfLoggedOutLearner
      ).toHaveBeenCalled();
    })
  );

  it('should show alert when collection summaries are not loaded', fakeAsync(() => {
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(true);
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(
      'collection_id'
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
    spyOn(
      localStorageService,
      'getUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(null);
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.reject());
    spyOn(alertsService, 'addWarning');

    componentInstance.ngOnInit();
    tick();

    expect(contextService.isInExplorationEditorPage).toHaveBeenCalled();
    expect(urlService.getCollectionIdFromExplorationUrl).toHaveBeenCalled();
    expect(
      collectionPlayerBackendApiService.fetchCollectionSummariesAsync
    ).toHaveBeenCalled();
    expect(alertsService.addWarning).toHaveBeenCalledWith(
      'There was an error while fetching the collection ' + 'summary.'
    );
  }));

  it('should tell if submit button is disabled', () => {
    let displayedCardIndex = 1;
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      displayedCardIndex
    );
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(currentInteractionService, 'isSubmitButtonDisabled').and.returnValue(
      true
    );

    expect(componentInstance.isSubmitButtonDisabled()).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled()).toBeFalse();
  });

  it(
    'should release solution when the learner gets stuck' +
      ' if no stuck state exists after a predetermined time',
    fakeAsync(() => {
      // Release solution if stuck state is null.
      componentInstance.nextCardIfStuck = null;
      let solutionSpy = spyOn(
        hintsAndSolutionManagerService,
        'releaseSolution'
      );
      let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');
      componentInstance.solutionForState = solutionObjectFactory.createNew(
        true,
        'answer',
        'Html',
        'XyzID'
      );
      componentInstance.numberOfIncorrectSubmissions = 3;
      componentInstance.triggerIfLearnerStuckAction();
      tick(
        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC
      );
      tick(ExplorationPlayerConstants.WAIT_BEFORE_REALLY_STUCK_MSEC);

      expect(solutionSpy).toHaveBeenCalled();
      expect(redirectionSpy).not.toHaveBeenCalled();
      flush();
    })
  );

  it(
    'should direct the learner to the stuck' +
      ' when the learner gets stuck and such a state exists after a' +
      ' predetermined time',
    fakeAsync(() => {
      spyOn(componentInstance, 'showPendingCard');
      spyOn(translateService, 'instant').and.callThrough();
      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');

      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        false
      );
      componentInstance.nextCardIfStuck = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        null,
        '',
        null
      );
      componentInstance.triggerIfLearnerStuckAction();
      tick(
        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC
      );

      expect(translateService.instant).toHaveBeenCalledWith(
        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'
      );
      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        true
      );
      flush();
    })
  );

  it(
    'should immediately release solution when the learner gets stuck' +
      ' if no stuck state exists',
    fakeAsync(() => {
      // Release solution if stuck state is null.
      componentInstance.nextCardIfStuck = null;
      let solutionSpy = spyOn(
        hintsAndSolutionManagerService,
        'releaseSolution'
      );
      let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');
      componentInstance.solutionForState = solutionObjectFactory.createNew(
        true,
        'answer',
        'Html',
        'XyzID'
      );
      componentInstance.numberOfIncorrectSubmissions = 3;
      componentInstance.triggerIfLearnerStuckActionDirectly();

      expect(solutionSpy).toHaveBeenCalled();
      expect(redirectionSpy).not.toHaveBeenCalled();
    })
  );

  it(
    'should immediately direct the learner to the stuck' +
      ' when the learner gets stuck and such a state exists',
    fakeAsync(() => {
      spyOn(translateService, 'instant').and.callThrough();
      spyOn(componentInstance, 'showPendingCard');
      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');
      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        false
      );
      componentInstance.nextCardIfStuck = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        null,
        '',
        null
      );
      componentInstance.triggerIfLearnerStuckActionDirectly();

      expect(translateService.instant).toHaveBeenCalledWith(
        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'
      );
      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        true
      );
    })
  );

  it('should redirect the learner to stuck state', fakeAsync(() => {
    spyOn(componentInstance, 'showPendingCard');
    componentInstance.nextCardIfStuck = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );

    componentInstance.triggerRedirectionToStuckState();

    expect(componentInstance.nextCard).toEqual(
      componentInstance.nextCardIfStuck
    );
    expect(componentInstance.showPendingCard).toHaveBeenCalled();
  }));

  it('should fetch completed chapters count if user is logged in', fakeAsync(() => {
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync'
    ).and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      })
    );
    componentInstance.isLoggedIn = false;

    componentInstance.fetchCompletedChaptersCount();
    tick();

    expect(
      learnerDashboardBackendApiService.fetchLearnerCompletedChaptersCountDataAsync
    ).not.toHaveBeenCalled();
    expect(componentInstance.completedChaptersCount).toBeUndefined();

    componentInstance.isLoggedIn = true;

    componentInstance.fetchCompletedChaptersCount();
    tick();

    expect(
      learnerDashboardBackendApiService.fetchLearnerCompletedChaptersCountDataAsync
    ).toHaveBeenCalled();

    expect(componentInstance.completedChaptersCount).toEqual(1);
  }));

  it('should tell if collection allows guest progress', () => {
    expect(componentInstance.doesCollectionAllowsGuestProgress('')).toBeFalse();
  });

  it('should change card', () => {
    spyOn(playerPositionService, 'recordNavigationButtonClick');
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(explorationEngineService.onUpdateActiveStateIfInEditor, 'emit');
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'state_name'
    );
    spyOn(playerPositionService, 'changeCurrentQuestion');

    componentInstance.changeCard(1);

    expect(
      playerPositionService.recordNavigationButtonClick
    ).toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex).toHaveBeenCalled();
    expect(
      explorationEngineService.onUpdateActiveStateIfInEditor.emit
    ).toHaveBeenCalled();
    expect(playerPositionService.getCurrentStateName).toHaveBeenCalled();
    expect(playerPositionService.changeCurrentQuestion).toHaveBeenCalled();
  });

  it(
    'should navigate to the most recently reached checkpoint ' +
      'on page load if user is logged in',
    fakeAsync(() => {
      let stateCardNames = ['Start', 'Mid', 'End'];
      let stateCards: StateCard[] = [];
      for (let stateName in stateCardNames) {
        stateCards.push(
          new StateCard(
            stateName,
            '<p>Testing</p>',
            null,
            new Interaction([], [], null, null, [], 'Continue', null),
            [],
            null,
            'content',
            null
          )
        );
      }
      let alertMessageElement = document.createElement('div');
      alertMessageElement.className = 'oppia-exploration-checkpoints-message';
      const expResponse = explorationResponse;
      expResponse.exploration.states.Mid.card_is_checkpoint = true;

      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(
          new UserInfo([], false, false, false, false, false, '', '', '', true)
        )
      );
      spyOn(playerPositionService, 'init').and.callFake(callb => {
        callb();
      });
      componentInstance.questionPlayerConfig = {};
      spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');
      spyOn(playerPositionService.onLoadedMostRecentCheckpoint, 'emit');
      spyOn(focusManagerService, 'setFocusIfOnDesktop');
      spyOn(loaderService, 'hideLoadingScreen');
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
      spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValues(
        'en',
        'en',
        'en',
        'pq'
      );
      spyOn(
        explorationPlayerStateService,
        'initializeQuestionPlayer'
      ).and.callFake((config, callb, questionAreAvailable) => {
        callb(displayedCard, 'label');
      });
      spyOn(
        explorationPlayerStateService,
        'isInQuestionPlayerMode'
      ).and.returnValue(false);
      spyOn(componentInstance, 'adjustPageHeight');
      spyOn(playerPositionService.onNewCardOpened, 'emit');
      componentInstance.isIframed = true;
      spyOn(playerPositionService, 'setDisplayedCardIndex');
      spyOn(playerPositionService, 'getCurrentStateName').and.returnValues(
        'Start',
        'Mid',
        'End'
      );
      spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
      spyOn(
        readOnlyExplorationBackendApiService,
        'loadLatestExplorationAsync'
      ).and.returnValue(Promise.resolve(expResponse));
      spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue(
        ['Start', 'Mid']
      );

      spyOn(explorationEngineService, 'getStateCardByName').and.returnValues(
        stateCards[0],
        stateCards[1],
        stateCards[2]
      );

      spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
      spyOn(explorationEngineService, 'getState').and.returnValue(
        stateObjectFactory.createFromBackendDict(
          'Mid',
          expResponse.exploration.states.Mid
        )
      );
      spyOn(document, 'querySelector')
        .withArgs('.oppia-exploration-checkpoints-message')
        .and.returnValue(alertMessageElement);

      componentInstance.explorationId = expResponse.exploration_id;
      componentInstance.displayedCard = displayedCard;
      componentInstance.isLoggedIn = true;
      componentInstance.isIframed = false;
      componentInstance.alertMessageTimeout = 5;

      componentInstance.initializePage();
      tick(100);

      expect(componentInstance.prevSessionStatesProgress).toEqual(['Start']);
      expect(componentInstance.mostRecentlyReachedCheckpoint).toBe('Mid');
    })
  );

  it(
    'should display the exploration after the the progress reminder modal' +
      'has loaded',
    () => {
      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
      spyOn(contextService, 'isInExplorationPlayerPage').and.returnValue(true);
      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(
        null
      );
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
      spyOn(explorationEngineService, 'getExplorationId').and.returnValue(
        'expl_1'
      );
      spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(false);
      spyOn(urlService, 'isIframed').and.returnValue(false);

      componentInstance.ngOnInit();
      expect(componentInstance.hasFullyLoaded).toBe(false);
      explorationPlayerStateService.onShowProgressModal.emit();
      expect(componentInstance.hasFullyLoaded).toBe(true);
    }
  );

  it('should determine if chapter was completed for the first time', fakeAsync(() => {
    componentInstance.isLoggedIn = true;
    componentInstance.completedChaptersCount = 0;
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'scrollToTop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(
      'en'
    );
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(contentTranslationManagerService, 'displayTranslations');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
    spyOn(
      explorationPlayerStateService,
      'isInStoryChapterMode'
    ).and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId',
    });
    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
    let readOnlyStoryNode = new ReadOnlyStoryNode(
      'nodeId',
      '',
      '',
      [],
      [],
      [],
      '',
      false,
      '',
      null,
      false,
      '',
      ''
    );
    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync').and.returnValue(
      Promise.resolve(
        new StoryPlaythrough(
          'nodeId',
          [readOnlyStoryNode, readOnlyStoryNode],
          '',
          '',
          '',
          ''
        )
      )
    );
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync'
    ).and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      })
    );
    spyOn(
      storyViewerBackendApiService,
      'recordChapterCompletionAsync'
    ).and.returnValue(
      Promise.resolve({
        readyForReviewTest: true,
        nextNodeId: '',
        summaries: [],
      })
    );

    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = true;
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(false, true, true, false);
    spyOn(componentInstance, 'animateToOneCard').and.callFake(callb => {
      callb();
    });

    componentInstance.showPendingCard();
    tick(1000);

    expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(true);
    expect(componentInstance.completedChaptersCount).toBe(1);

    componentInstance.completedChaptersCount = 1;
    componentInstance.chapterIsCompletedForTheFirstTime = false;

    componentInstance.showPendingCard();
    tick(1000);

    expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(false);

    flush();
  }));

  it('should unsubscribe on destroy', () => {
    spyOn(componentInstance.directiveSubscriptions, 'unsubscribe');

    componentInstance.ngOnDestroy();

    expect(
      componentInstance.directiveSubscriptions.unsubscribe
    ).toHaveBeenCalled();
  });

  it('should always ask learner for answer details', () => {
    spyOn(
      explorationEngineService,
      'getAlwaysAskLearnerForAnswerDetails'
    ).and.returnValues(true, false);

    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeTrue();
    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeFalse();
  });

  it('should get can ask learner for answer info', () => {
    spyOn(
      learnerAnswerInfoService,
      'getCanAskLearnerForAnswerInfo'
    ).and.returnValues(true, false);

    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeTrue();
    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeFalse();
  });

  it('should initialize learner answer info service', () => {
    spyOn(learnerAnswerInfoService, 'initLearnerAnswerInfoService');

    componentInstance.initLearnerAnswerInfoService(
      null,
      null,
      null,
      null,
      false
    );

    expect(
      learnerAnswerInfoService.initLearnerAnswerInfoService
    ).toHaveBeenCalled();
  });

  it('should tell if correctness footer is enabled', () => {
    componentInstance.answerIsCorrect = true;

    spyOn(
      playerPositionService,
      'hasLearnerJustSubmittedAnAnswer'
    ).and.returnValue(true);

    expect(componentInstance.isCorrectnessFooterEnabled()).toBeTrue();
  });

  it('should get static image url', () => {
    let imageUrl = 'image_url';
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      imageUrl
    );

    expect(componentInstance.getStaticImageUrl('')).toEqual(imageUrl);
  });

  it('should get content focus label', () => {
    let index = 1;

    expect(componentInstance.getContentFocusLabel(index)).toEqual(
      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index
    );
  });

  it('should reload exploration', () => {
    spyOn(windowRef.nativeWindow.location, 'reload');

    componentInstance.reloadExploration();

    expect(windowRef.nativeWindow.location.reload).toHaveBeenCalled();
  });

  it('should tell if display card is terminal', () => {
    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );

    expect(componentInstance.isOnTerminalCard()).toBeTrue();
  });

  it('should return to exploration after concept card is compeleted', () => {
    let numCards = 20;
    spyOn(playerTranscriptService, 'addPreviousCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(numCards);
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.returnToExplorationAfterConceptCard();

    expect(playerTranscriptService.addPreviousCard).toHaveBeenCalled();
    expect(playerTranscriptService.getNumCards).toHaveBeenCalled();
    expect(
      playerPositionService.setDisplayedCardIndex
    ).toHaveBeenCalledOnceWith(numCards - 1);
  });

  it('should tell if current is at end of transcript', () => {
    let index = 1;
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      index
    );

    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeTrue();
    expect(playerTranscriptService.isLastCard).toHaveBeenCalledWith(index);
  });

  it('should hide loading screen if question are not available', () => {
    spyOn(loaderService, 'hideLoadingScreen');

    componentInstance.showQuestionAreNotAvailable();

    expect(loaderService.hideLoadingScreen).toHaveBeenCalled();
  });

  it('should initialize page', fakeAsync(() => {
    spyOn(playerPositionService, 'init').and.callFake(callb => {
      callb();
    });
    spyOn(urlService, 'getUrlParams').and.returnValues(
      {
        lang: 'pq',
      },
      {
        lang: 'en',
      },
      {
        lang: 'en',
      },
      {
        lang: 'pq',
      }
    );
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    componentInstance.questionPlayerConfig = {};
    spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(loaderService, 'hideLoadingScreen');
    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValues(
      'pq',
      'en',
      'en',
      'pq'
    );
    spyOn(
      explorationPlayerStateService,
      'initializeQuestionPlayer'
    ).and.callFake((config, callb, questionAreAvailable) => {
      callb(displayedCard, 'label');
    });
    spyOn(componentInstance, 'adjustPageHeight');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    componentInstance.isIframed = true;
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);

    componentInstance.explorationId = explorationResponse.exploration_id;
    componentInstance.displayedCard = displayedCard;

    componentInstance.initializePage();
    tick(100);
    expect(componentInstance.hasInteractedAtLeastOnce).toBeFalse();
    expect(componentInstance.recommendedExplorationSummaries).toEqual([]);
    expect(playerPositionService.init).toHaveBeenCalled();

    componentInstance.questionPlayerConfig = null;
    spyOn(playerPositionService, 'getDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(componentInstance, 'getContentFocusLabel');
    spyOn(explorationPlayerStateService, 'initializePlayer').and.callFake(
      callb => {
        callb(displayedCard, 'label');
      }
    );

    componentInstance._nextFocusLabel = 'focus_label';
    componentInstance.initializePage();
    tick(100);

    componentInstance.questionPlayerConfig = null;
    let topicIdToPrerequisiteTopicIds = {
      topicId1: [],
      topicId2: ['topicId1'],
      topicId3: ['topicId2'],
    };

    componentInstance.diagnosticTestTopicTrackerModel =
      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds);

    spyOn(explorationPlayerStateService, 'initializeDiagnosticPlayer');

    componentInstance.initializePage();
    tick(100);

    expect(playerPositionService.init).toHaveBeenCalled();
    expect(
      explorationPlayerStateService.initializeDiagnosticPlayer
    ).toHaveBeenCalled();
  }));

  it('should register analytics when user visit using iframe', () => {
    spyOn(siteAnalyticsService, 'registerVisitOppiaFromIframeEvent');

    componentInstance.onNavigateFromIframe();

    expect(
      siteAnalyticsService.registerVisitOppiaFromIframeEvent
    ).toHaveBeenCalled();
  });

  it('should submit answer from progress nav and toggle submit clicked', () => {
    componentInstance.displayedCard = displayedCard;
    spyOn(displayedCard, 'toggleSubmitClicked');
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(currentInteractionService, 'submitAnswer');

    componentInstance.submitAnswerFromProgressNav();

    expect(currentInteractionService.submitAnswer).toHaveBeenCalled();
    expect(displayedCard.toggleSubmitClicked).toHaveBeenCalledOnceWith(true);
  });

  it('should show learn again button', () => {
    componentInstance.displayedCard = {
      getStateName: () => null,
    } as StateCard;

    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false,
      true,
      true,
      true
    );

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = displayedCard;

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'Continue', null),
      [],
      null,
      '',
      null
    );

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'ImageClickInput', null),
      [],
      null,
      '',
      null
    );

    componentInstance.pendingCardWasSeenBefore = true;
    componentInstance.answerIsCorrect = false;

    expect(componentInstance.isLearnAgainButton()).toBeTrue();
  });

  it('should jump to the revision state via changing card', () => {
    const currentCard = new StateCard(
      'currentCard',
      null,
      null,
      new Interaction([], [], null, null, [], 'Continue', null),
      [],
      null,
      '',
      null
    );
    componentInstance.displayedCard = currentCard;

    componentInstance.nextCard = new StateCard(
      'revisionState',
      null,
      null,
      new Interaction([], [], null, null, [], 'ImageClickInput', null),
      [],
      null,
      '',
      null
    );
    spyOn(componentInstance, 'isLearnAgainButton').and.returnValue(true);
    spyOn(playerTranscriptService, 'findIndexOfLatestStateWithName')
      .withArgs('revisionState')
      .and.returnValue(2);
    const changeCard = spyOn(componentInstance, 'changeCard');
    const recordNewCardAdded = spyOn(
      explorationPlayerStateService,
      'recordNewCardAdded'
    );

    componentInstance.showUpcomingCard();

    expect(currentCard.isCompleted()).toBeFalse();
    expect(recordNewCardAdded).not.toHaveBeenCalled();
    expect(changeCard).toHaveBeenCalledWith(2);
  });

  it('should adjust page height on scroll', fakeAsync(() => {
    componentInstance.lastRequestedHeight = document.body.scrollHeight + 100;
    componentInstance.lastRequestedScroll = false;
    spyOn(messengerService, 'sendMessage');

    let callbSpy = jasmine.createSpy('adjust page height callback');
    let scrollValue = true;

    componentInstance.adjustPageHeight(scrollValue, callbSpy);
    tick(150);

    expect(messengerService.sendMessage).toHaveBeenCalled();
    expect(componentInstance.lastRequestedScroll).toEqual(scrollValue);
    expect(callbSpy).toHaveBeenCalled();
  }));

  it('should get exploration link', () => {
    componentInstance.recommendedExplorationSummaries = [{id: ''}];

    expect(componentInstance.getExplorationLink()).toEqual('#');

    let expId = '123';
    let collectionId = '980';
    let storyUrlFragment = 'story_fragment';
    let nodeId = 'node_id';
    let topicUrlFragment = 'topic_url_fragment';
    let classroomUrlFragment = 'classroom_fragment';
    componentInstance.recommendedExplorationSummaries = [
      {
        id: expId,
        parentExplorationIds: ['4566', 's9af0'],
        nextNodeId: nodeId,
      },
    ];
    spyOn(urlService, 'getUrlParams').and.returnValues(
      {
        collection_id: collectionId,
      },
      {
        story_url_fragment: storyUrlFragment,
        node_id: nodeId,
        topic_url_fragment: topicUrlFragment,
        classroom_url_fragment: classroomUrlFragment,
      },
      {
        story_url_fragment: storyUrlFragment,
        node_id: nodeId,
        topic_url_fragment: topicUrlFragment,
        classroom_url_fragment: classroomUrlFragment,
      }
    );

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' +
        expId +
        '?collection_id=' +
        collectionId +
        '&parent=' +
        componentInstance.recommendedExplorationSummaries[0]
          .parentExplorationIds[0]
    );
    expect(urlService.getUrlParams).toHaveBeenCalled();

    componentInstance.parentExplorationIds = null;
    componentInstance.storyNodeIdToAdd = nodeId;

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' +
        expId +
        '?parent=' +
        componentInstance.recommendedExplorationSummaries[0]
          .parentExplorationIds[0] +
        '&topic_url_fragment=' +
        topicUrlFragment +
        '&classroom_url_fragment=' +
        classroomUrlFragment +
        '&story_url_fragment=' +
        storyUrlFragment +
        '&node_id=' +
        nodeId
    );

    spyOn(urlService, 'getPathname').and.returnValue(
      '/story/story-url-fragment'
    );
    spyOn(urlService, 'getStoryUrlFragmentFromLearnerUrl').and.returnValue(
      storyUrlFragment
    );
    spyOn(urlService, 'getTopicUrlFragmentFromLearnerUrl').and.returnValue(
      topicUrlFragment
    );
    spyOn(urlService, 'getClassroomUrlFragmentFromLearnerUrl').and.returnValue(
      classroomUrlFragment
    );

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' +
        expId +
        '?parent=' +
        componentInstance.recommendedExplorationSummaries[0]
          .parentExplorationIds[0] +
        '&topic_url_fragment=' +
        topicUrlFragment +
        '&classroom_url_fragment=' +
        classroomUrlFragment +
        '&story_url_fragment=' +
        storyUrlFragment +
        '&node_id=' +
        nodeId
    );
    expect(urlService.getPathname).toHaveBeenCalled();
    expect(urlService.getStoryUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getTopicUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getClassroomUrlFragmentFromLearnerUrl).toHaveBeenCalled();
  });

  it('should tell if current supplemental card is non empty', () => {
    componentInstance.displayedCard = displayedCard;
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(true, false);

    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeTrue();
    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeFalse();
  });

  it('should tell if supplemental nav is shown', () => {
    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'NumberWithUnits', null),
      [],
      null,
      '',
      null
    );
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false,
      true
    );
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(
      true
    );
    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
    expect(componentInstance.isSupplementalNavShown()).toBeTrue();
  });

  it('should show pending card', fakeAsync(() => {
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'scrollToTop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(
      'en'
    );
    spyOn(conversationFlowService, 'addNewCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
    spyOn(
      explorationPlayerStateService,
      'isInStoryChapterMode'
    ).and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId',
    });
    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
    let readOnlyStoryNode = new ReadOnlyStoryNode(
      'nodeId',
      '',
      '',
      [],
      [],
      [],
      '',
      false,
      '',
      null,
      false,
      '',
      ''
    );
    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync').and.returnValue(
      Promise.resolve(
        new StoryPlaythrough(
          'nodeId',
          [readOnlyStoryNode, readOnlyStoryNode],
          '',
          '',
          '',
          ''
        )
      )
    );
    spyOn(
      storyViewerBackendApiService,
      'recordChapterCompletionAsync'
    ).and.returnValues(
      Promise.resolve({
        readyForReviewTest: true,
        nextNodeId: '',
        summaries: [],
      })
    );

    componentInstance.alertMessageTimeout = 5;

    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = true;
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(false, true, true, false);
    spyOn(componentInstance, 'animateToOneCard').and.callFake(callb => {
      callb();
    });

    componentInstance.showPendingCard();
    tick(1000);

    componentInstance.isLoggedIn = false;

    componentInstance.showPendingCard();
    tick(1000);

    expect(explorationPlayerStateService.recordNewCardAdded).toHaveBeenCalled();
  }));

  it('should scroll to bottom', fakeAsync(() => {
    componentInstance.scrollToBottom();
    tick(200);

    spyOn(window, '$').and.returnValue({
      offset: () => {
        return {top: 10};
      },
      outerHeight: () => 10,
      scrollTop: () => 0,
      height: () => 0,
      animate: () => {},
    } as unknown as JQLite);

    componentInstance.scrollToBottom();
    tick(200);
    expect(window.$).toHaveBeenCalled();
  }));

  it('should scroll to top', fakeAsync(() => {
    let animateSpy = jasmine.createSpy('jquery spy');
    spyOn(window, '$').and.returnValue({
      animate: animateSpy,
    } as unknown as JQLite);
    componentInstance.scrollToTop();
    tick(1000);
    expect(animateSpy).toHaveBeenCalled();
  }));

  it('should determine if endChapterCelebrationFeature is enabled or not', () => {
    const featureSpy = spyOnProperty(
      platformFeatureService,
      'status',
      'get'
    ).and.callThrough();

    expect(componentInstance.isEndChapterCelebrationFeatureEnabled()).toBe(
      true
    );

    featureSpy.and.returnValue({
      EndChapterCelebration: {
        isEnabled: false,
      },
    });

    expect(componentInstance.isEndChapterCelebrationFeatureEnabled()).toBe(
      false
    );
  });

  it('should show upcoming card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(displayedCard, 'getStateName').and.returnValue(null);
    componentInstance.displayedCard = displayedCard;
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false,
      true,
      true,
      true,
      true
    );
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(
      true,
      false,
      false,
      false,
      false
    );
    spyOn(componentInstance, 'returnToExplorationAfterConceptCard');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = true;
    spyOn(questionPlayerStateService.onQuestionSessionCompleted, 'emit');
    spyOn(questionPlayerStateService, 'getQuestionPlayerStateData');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = false;
    componentInstance.moveToExploration = true;
    spyOn(explorationPlayerStateService, 'moveToExploration');

    componentInstance.showUpcomingCard();

    componentInstance.moveToExploration = false;
    let stateCard = new StateCard(
      'stateName',
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    stateCard.markAsCompleted();
    componentInstance.displayedCard = stateCard;
    componentInstance.nextCard = stateCard;
    componentInstance.conceptCard = new ConceptCard(
      new SubtitledHtml('', ''),
      [],
      null
    );
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(conversationFlowService, 'addNewCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(false, true);
    spyOn(playerTranscriptService, 'getCard');
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(componentInstance, 'animateToTwoCards').and.callFake(callb => {
      callb();
    });
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(componentInstance, 'showPendingCard');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(
      explorationEngineService,
      'getAuthorRecommendedExpIdsByStateName'
    ).and.returnValue([]);
    spyOn(
      explorationPlayerStateService,
      'isInStoryChapterMode'
    ).and.returnValue(true);
    spyOn(userService, 'setReturnUrl');
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId',
    });

    componentInstance.isLoggedIn = false;

    componentInstance.showUpcomingCard();

    componentInstance.conceptCard = null;
    componentInstance.answerIsCorrect = true;

    componentInstance.showUpcomingCard();
  });

  it('should submit answer and reset current answer state', fakeAsync(() => {
    spyOn(displayedCard, 'updateCurrentAnswer');
    componentInstance.displayedCard = displayedCard;
    componentInstance.answerIsBeingProcessed = true;

    componentInstance.submitAnswer('', null);

    expect(displayedCard.updateCurrentAnswer).toHaveBeenCalledOnceWith(null);
    componentInstance.answerIsBeingProcessed = false;
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(
      true
    );
    let explorationModeSpy = spyOn(
      explorationPlayerStateService,
      'isPresentingIsolatedQuestions'
    );
    explorationModeSpy.and.returnValue(false);
    componentInstance.isInPreviewMode = false;
    spyOn(fatigueDetectionService, 'recordSubmissionTimestamp');
    spyOn(fatigueDetectionService, 'isSubmittingTooFast').and.returnValues(
      true,
      false
    );
    spyOn(fatigueDetectionService, 'displayTakeBreakMessage');
    let lastCardInteraction = interactionObjectFactory.createFromBackendDict({
      id: 'TextInput',
      answer_groups: [],
      default_outcome: null,
      confirmed_unclassified_answers: [],
      customization_args: {
        rows: {
          value: true,
        },
        placeholder: {
          value: 1,
        },
      },
      hints: [],
      solution: null,
    });
    let lastCard = StateCard.createNewCard(
      'Card 1',
      'Content html',
      'Interaction text',
      lastCardInteraction,
      null,
      'content_id',
      audioTranslationLanguageService
    );
    spyOn(playerTranscriptService, 'getLastCard').and.returnValue(lastCard);
    spyOn(explorationPlayerStateService.onOppiaFeedbackAvailable, 'emit');
    spyOn(componentInstance, 'showPendingCard');
    componentInstance.submitAnswer('', null);

    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false,
      false,
      false,
      true
    );
    spyOn(componentInstance, 'initLearnerAnswerInfoService');
    spyOn(explorationEngineService, 'getState');
    spyOn(numberAttemptsService, 'submitAttempt');
    spyOn(playerTranscriptService, 'addNewInput');
    spyOn(componentInstance, 'getCanAskLearnerForAnswerInfo').and.returnValues(
      true,
      false
    );
    spyOn(playerTranscriptService, 'addNewResponse');
    spyOn(learnerAnswerInfoService, 'getSolicitAnswerDetailsQuestion');
    spyOn(playerPositionService.onHelpCardAvailable, 'emit');
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.submitAnswer('', null);
    tick(200);

    spyOn(playerPositionService, 'recordAnswerSubmission');
    spyOn(
      explorationPlayerStateService,
      'getCurrentEngineService'
    ).and.returnValue(explorationEngineService);
    spyOn(explorationPlayerStateService, 'getLanguageCode').and.returnValue(
      'en'
    );

    let callback = (
      answer: string,
      interactionRulesService: InteractionRulesService,
      successCallback: (
        nextCard: StateCard,
        refreshInteraction: boolean,
        feedbackHtml: string,
        feedbackAudioTranslations: BindableVoiceovers,
        refresherExplorationId: string,
        missingPrerequisiteSkillId: string,
        remainOnCurrentCard: boolean,
        taggedSkillMisconceptionId: string,
        wasOldStateInitial: boolean,
        isFirstHit: boolean,
        isFinalQuestion: boolean,
        nextCardIfReallyStuck: StateCard | null,
        focusLabel: string
      ) => void
    ) => {
      let stateCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        null,
        '',
        null
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        null,
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        true,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        '',
        null,
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        true,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        null,
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        '',
        null,
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        null,
        '',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      explorationModeSpy.and.returnValue(true);
      componentInstance.displayedCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'TextInput', null),
        [],
        null,
        '',
        null
      );
      spyOn(
        explorationPlayerStateService,
        'isInDiagnosticTestPlayerMode'
      ).and.returnValue(true);
      successCallback(
        stateCard,
        true,
        'feedback',
        null,
        '',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      componentInstance.displayedCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'ImageClickInput', null),
        [],
        null,
        '',
        null
      );
      explorationModeSpy.and.returnValue(false);
      successCallback(
        stateCard,
        true,
        'feedback',
        null,
        'refresherId',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      return false;
    };
    spyOn(
      answerClassificationService,
      'isAnswerOnlyMisspelled'
    ).and.returnValue(true);
    spyOn(explorationEngineService, 'submitAnswer').and.callFake(callback);
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'oldState'
    );
    spyOn(statsReportingService, 'recordStateTransition');
    spyOn(learnerParamsService, 'getAllParams');
    spyOn(statsReportingService, 'recordStateCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      explorationPlayerStateService,
      'isInQuestionPlayerMode'
    ).and.returnValue(true);
    spyOn(componentInstance, 'showUpcomingCard');
    spyOn(fatigueDetectionService, 'reset');
    spyOn(numberAttemptsService, 'reset');
    spyOn(questionPlayerStateService, 'answerSubmitted');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(playerTranscriptService, 'updateLatestInteractionHtml');
    spyOn(
      conceptCardBackendApiService,
      'loadConceptCardsAsync'
    ).and.returnValue(
      Promise.resolve([new ConceptCard(new SubtitledHtml('', ''), [], null)])
    );

    spyOn(
      explorationSummaryBackendApiService,
      'loadPublicExplorationSummariesAsync'
    ).and.returnValue(
      Promise.resolve({
        summaries: [{} as ExplorationSummaryDict],
      })
    );
    spyOn(
      refresherExplorationConfirmationModalService,
      'displayRedirectConfirmationModal'
    ).and.callFake((id, callb) => {
      callb();
    });
    spyOn(statsReportingService, 'recordLeaveForRefresherExp');
    spyOn(playerTranscriptService, 'hasEncounteredStateBefore').and.returnValue(
      true
    );
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');

    componentInstance.explorationActuallyStarted = false;

    componentInstance.submitAnswer('', null);
    tick(2000);
  }));

  it('should be able to set active voiceover content ID', fakeAsync(() => {
    spyOn(voiceoverPlayerService, 'setActiveVoiceover');
    let interaction = interactionObjectFactory.createFromBackendDict({
      id: 'TextInput',
      answer_groups: [],
      default_outcome: {
        missing_prerequisite_skill_id: null,
        refresher_exploration_id: null,
        labelled_as_correct: false,
        feedback: {
          content_id: 'default_outcome',
          html: 'Wrong answer',
        },
        param_changes: [],
        dest_if_really_stuck: null,
        dest: 'Start',
      },
      confirmed_unclassified_answers: [],
      customization_args: {
        rows: {
          value: true,
        },
        placeholder: {
          value: 1,
        },
      },
      hints: [],
      solution: null,
    });

    let displayedCard = new StateCard(
      null,
      null,
      null,
      interaction,
      [],
      null,
      '',
      null
    );

    componentInstance.displayedCard = displayedCard;

    componentInstance.setActiveVoiceover('Wrong answer');
    expect(voiceoverPlayerService.setActiveVoiceover).toHaveBeenCalledWith(
      'default_outcome'
    );
  }));

  it('should get recommended summaries when exploration in story chapter mode', fakeAsync(() => {
    let alertMessageElement = document.createElement('div');
    alertMessageElement.className = 'oppia-exploration-checkpoints-message';
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'scrollToTop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(conversationFlowService, 'addNewCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValue(false);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(
      explorationEngineService,
      'getAuthorRecommendedExpIdsByStateName'
    ).and.returnValue([]);
    spyOn(
      explorationPlayerStateService,
      'isInStoryChapterMode'
    ).and.returnValue(false);
    spyOn(
      explorationRecommendationsService,
      'getRecommendedSummaryDicts'
    ).and.callFake((ids, recommendations, callb) => {
      callb(null);
    });
    spyOn(document, 'querySelector')
      .withArgs('.oppia-exploration-checkpoints-message')
      .and.returnValue(alertMessageElement);

    componentInstance.alertMessageTimeout = 5;

    componentInstance.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );

    componentInstance.nextCard = displayedCard;
    componentInstance.showPendingCard();
    tick(2000);
  }));

  it('should check whether hacky translations are displayed or not', () => {
    spyOn(
      i18nLanguageCodeService,
      'isHackyTranslationAvailable'
    ).and.returnValues(false, true);
    spyOn(i18nLanguageCodeService, 'isCurrentLanguageEnglish').and.returnValues(
      false,
      false
    );

    let expId = 'exp_id';

    let hackyStoryTitleTranslationIsDisplayed =
      componentInstance.isHackyExpTitleTranslationDisplayed(expId);
    expect(hackyStoryTitleTranslationIsDisplayed).toBe(false);
    hackyStoryTitleTranslationIsDisplayed =
      componentInstance.isHackyExpTitleTranslationDisplayed(expId);
    expect(hackyStoryTitleTranslationIsDisplayed).toBe(true);
  });

  it('should check if current card was completed in a previous session', () => {
    let mockStateCard = new StateCard(
      'Temp2',
      '',
      '',
      new Interaction([], [], null, null, [], null, null),
      [],
      null,
      '',
      null
    );
    componentInstance.displayedCard = mockStateCard;
    componentInstance.prevSessionStatesProgress = ['Temp1', 'Temp2'];
    expect(
      componentInstance.isDisplayedCardCompletedInPrevSession()
    ).toBeTrue();
    componentInstance.prevSessionStatesProgress = ['Temp1'];
    expect(
      componentInstance.isDisplayedCardCompletedInPrevSession()
    ).toBeFalse();
  });

  it('should tell if progress clearance message is shown or not', () => {
    expect(componentInstance.isProgressClearanceMessageShown()).toBeFalse();

    componentInstance.showProgressClearanceMessage = true;

    expect(componentInstance.isProgressClearanceMessageShown()).toBeTrue();
  });

  it('should update when submit button is enabled', () => {
    componentInstance.submitButtonIsDisabled = false;
    spyOn(componentInstance, 'isSubmitButtonDisabled').and.returnValue(
      !componentInstance.submitButtonIsDisabled
    );

    componentInstance.ngAfterViewChecked();

    expect(componentInstance.submitButtonIsDisabled).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled).toHaveBeenCalled();
  });

  it('should be able to set appropriate flags for the diagnostic test', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = true;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode').and.returnValue(
      isInPreviewMode
    );
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(
      explorationPlayerStateService,
      'isInQuestionPlayerMode'
    ).and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(componentInstance, 'fetchCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );
    spyOn(
      componentInstance,
      'doesCollectionAllowsGuestProgress'
    ).and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(explorationResponse));
    spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue([
      'Start',
      'Mid',
    ]);
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(
      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})
    );

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();

    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      explorationPlayerStateService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      null,
      '',
      null
    );
    componentInstance.isLoggedIn = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    expect(componentInstance.feedbackIsEnabled).toBeTrue();
    expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeFalse();
    expect(componentInstance.inputOutputHistoryIsShown).toBeTrue();
    expect(componentInstance.navigationThroughCardHistoryIsEnabled).toBeTrue();
    expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeTrue();
    expect(componentInstance.skipButtonIsShown).toBeFalse();

    const topicIdToPrerequisiteTopicIds = {
      topicId1: [],
      topicId2: ['topicId1'],
      topicId3: ['topicId2'],
    };

    componentInstance.diagnosticTestTopicTrackerModel =
      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds);
    tick();

    componentInstance.ngOnInit();
    tick(2000);

    expect(componentInstance.feedbackIsEnabled).toBeFalse();
    expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeTrue();
    expect(componentInstance.inputOutputHistoryIsShown).toBeFalse();
    expect(componentInstance.navigationThroughCardHistoryIsEnabled).toBeFalse();
    expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeFalse();
    expect(componentInstance.skipButtonIsShown).toBeTrue();
  }));

  it('should be able to skip the current question', fakeAsync(() => {
    let sampleCard = StateCard.createNewCard(
      'State 2',
      '<p>Content</p>',
      '',
      // This throws "Type null is not assignable to type
      // 'string'." We need to suppress this error
      // because of the need to test validations. This
      // throws an error only in the frontend test and
      // not in the frontend.
      // @ts-ignore
      null,
      null,
      'content',
      audioTranslationLanguageService
    );

    let callback = (successCallback: (nextCard: StateCard) => void) => {
      successCallback(sampleCard);
    };
    spyOn(explorationPlayerStateService, 'skipCurrentQuestion').and.callFake(
      callback
    );
    spyOn(componentInstance, 'showPendingCard');

    componentInstance.skipCurrentQuestion();

    expect(
      explorationPlayerStateService.skipCurrentQuestion
    ).toHaveBeenCalled();
    expect(componentInstance.showPendingCard).toHaveBeenCalled();
  }));

  it('should tell if window can show two cards', () => {
    spyOn(windowDimensionsService, 'getWidth').and.returnValue(
      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX + 1
    );

    expect(componentInstance.canWindowShowTwoCards()).toBeTrue();
  });

  it('should animate to one card', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToOneCard(doneCallbackSpy);

    tick(600);
    expect(componentInstance.isAnimatingToOneCard).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));

  it('should animate to two cards', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToTwoCards(doneCallbackSpy);

    tick(1000);
    expect(componentInstance.isAnimatingToTwoCards).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));
});
