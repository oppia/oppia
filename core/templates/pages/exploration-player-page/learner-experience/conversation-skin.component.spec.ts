// Copyright 2022 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for Conversation skin component.
 */

import { HttpClientTestingModule } from '@angular/common/http/testing';
import { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core';
import { ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing';
import { QuestionPlayerStateService } from 'components/question-directives/question-player/services/question-player-state.service';
import { Collection } from 'domain/collection/collection.model';
import { GuestCollectionProgressService } from 'domain/collection/guest-collection-progress.service';
import { ReadOnlyCollectionBackendApiService } from 'domain/collection/read-only-collection-backend-api.service';
import { Interaction } from 'domain/exploration/InteractionObjectFactory';
import { BindableVoiceovers } from 'domain/exploration/recorded-voiceovers.model';
import { SubtitledHtml } from 'domain/exploration/subtitled-html.model';
import { ExplorationRecommendationsBackendApiService } from 'domain/recommendations/exploration-recommendations-backend-api.service';
import { ConceptCardBackendApiService } from 'domain/skill/concept-card-backend-api.service';
import { ConceptCard } from 'domain/skill/ConceptCardObjectFactory';
import { StateCard } from 'domain/state_card/state-card.model';
import { ReadOnlyStoryNode } from 'domain/story_viewer/read-only-story-node.model';
import { StoryPlaythrough } from 'domain/story_viewer/story-playthrough.model';
import { StoryViewerBackendApiService } from 'domain/story_viewer/story-viewer-backend-api.service';
import { ExplorationSummaryBackendApiService, ExplorationSummaryDict } from 'domain/summary/exploration-summary-backend-api.service';
import { UserInfo } from 'domain/user/user-info.model';
import { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';
import { CollectionPlayerBackendApiService } from 'pages/collection-player-page/services/collection-player-backend-api.service';
import { AlertsService } from 'services/alerts.service';
import { AudioPlayerService } from 'services/audio-player.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { ContextService } from 'services/context.service';
import { UrlService } from 'services/contextual/url.service';
import { WindowDimensionsService } from 'services/contextual/window-dimensions.service';
import { WindowRef } from 'services/contextual/window-ref.service';
import { I18nLanguageCodeService } from 'services/i18n-language-code.service';
import { LoaderService } from 'services/loader.service';
import { MessengerService } from 'services/messenger.service';
import { SiteAnalyticsService } from 'services/site-analytics.service';
import { FocusManagerService } from 'services/stateful/focus-manager.service';
import { UserService } from 'services/user.service';
import { MockTranslatePipe } from 'tests/unit-test-utils';
import { ExplorationPlayerConstants } from '../exploration-player-page.constants';
import { InteractionRulesService } from '../services/answer-classification.service';
import { AudioTranslationLanguageService } from '../services/audio-translation-language.service';
import { ContentTranslationLanguageService } from '../services/content-translation-language.service';
import { ContentTranslationManagerService } from '../services/content-translation-manager.service';
import { CurrentInteractionService } from '../services/current-interaction.service';
import { ExplorationEngineService } from '../services/exploration-engine.service';
import { ExplorationPlayerStateService } from '../services/exploration-player-state.service';
import { ExplorationRecommendationsService } from '../services/exploration-recommendations.service';
import { FatigueDetectionService } from '../services/fatigue-detection.service';
import { HintsAndSolutionManagerService } from '../services/hints-and-solution-manager.service';
import { ImagePreloaderService } from '../services/image-preloader.service';
import { LearnerAnswerInfoService } from '../services/learner-answer-info.service';
import { LearnerParamsService } from '../services/learner-params.service';
import { NumberAttemptsService } from '../services/number-attempts.service';
import { PlayerCorrectnessFeedbackEnabledService } from '../services/player-correctness-feedback-enabled.service';
import { PlayerPositionService } from '../services/player-position.service';
import { PlayerTranscriptService } from '../services/player-transcript.service';
import { QuestionPlayerEngineService } from '../services/question-player-engine.service';
import { RefresherExplorationConfirmationModalService } from '../services/refresher-exploration-confirmation-modal.service';
import { StatsReportingService } from '../services/stats-reporting.service';
import { ConversationSkinComponent } from './conversation-skin.component';

class MockWindowRef {
  nativeWindow = {
    location: {
      pathname: '/path/name',
      reload: () => {}
    },
    addEventListener(event: string, callback) {
      callback({returnValue: null});
    },
    scrollTo: (x, y) => {}
  };
}

describe('Conversation skin component', () => {
  let fixture: ComponentFixture<ConversationSkinComponent>;
  let componentInstance: ConversationSkinComponent;
  let alertsService: AlertsService;
  let audioPlayerService: AudioPlayerService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let collectionPlayerBackendApiService: CollectionPlayerBackendApiService;
  let conceptCardBackendApiService: ConceptCardBackendApiService;
  let contentTranslationLanguageService: ContentTranslationLanguageService;
  let contentTranslationManagerService: ContentTranslationManagerService;
  let contextService: ContextService;
  let currentInteractionService: CurrentInteractionService;
  let explorationEngineService: ExplorationEngineService;
  let explorationPlayerStateService: ExplorationPlayerStateService;
  let explorationRecommendationsService:
  ExplorationRecommendationsBackendApiService;
  let explorationSummaryBackendApiService: ExplorationSummaryBackendApiService;
  let fatigueDetectionService: FatigueDetectionService;
  let focusManagerService: FocusManagerService;
  let guestCollectionProgressService: GuestCollectionProgressService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let imagePreloaderService: ImagePreloaderService;
  let learnerAnswerInfoService: LearnerAnswerInfoService;
  let learnerParamsService: LearnerParamsService;
  let loaderService: LoaderService;
  let messengerService: MessengerService;
  let numberAttemptsService: NumberAttemptsService;
  let playerCorrectnessFeedbackEnabledService:
  PlayerCorrectnessFeedbackEnabledService;
  let playerPositionService: PlayerPositionService;
  let playerTranscriptService: PlayerTranscriptService;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let questionPlayerStateService: QuestionPlayerStateService;
  let readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService;
  let refresherExplorationConfirmationModalService:
  RefresherExplorationConfirmationModalService;
  let siteAnalyticsService: SiteAnalyticsService;
  let statsReportingService: StatsReportingService;
  let storyViewerBackendApiService: StoryViewerBackendApiService;
  let urlInterpolationService: UrlInterpolationService;
  let urlService: UrlService;
  let userService: UserService;
  let windowDimensionsService: WindowDimensionsService;
  let windowRef: WindowRef;

  let displayedCard = new StateCard(
    null, null, null, new Interaction(
      [], [], null, null, [], '', null),
    [], null, null, '', null);

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      declarations: [
        ConversationSkinComponent,
        MockTranslatePipe
      ],
      providers: [
        {
          provide: WindowRef,
          useClass: MockWindowRef
        }
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();

    fixture = TestBed.createComponent(ConversationSkinComponent);
    componentInstance = fixture.componentInstance;

    alertsService = TestBed.inject(AlertsService);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    audioTranslationLanguageService = TestBed.inject(
      AudioTranslationLanguageService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService);
    collectionPlayerBackendApiService = TestBed.inject(
      CollectionPlayerBackendApiService);
    conceptCardBackendApiService = TestBed.inject(ConceptCardBackendApiService);
    contentTranslationLanguageService = TestBed.inject(
      ContentTranslationLanguageService);
    contentTranslationManagerService = TestBed.inject(
      ContentTranslationManagerService);
    contextService = TestBed.inject(ContextService);
    currentInteractionService = TestBed.inject(CurrentInteractionService);
    explorationEngineService = TestBed.inject(ExplorationEngineService);
    explorationPlayerStateService = TestBed.inject(
      ExplorationPlayerStateService);
    explorationRecommendationsService = TestBed.inject(
      ExplorationRecommendationsService);
    explorationSummaryBackendApiService = TestBed.inject(
      ExplorationSummaryBackendApiService);
    fatigueDetectionService = TestBed.inject(FatigueDetectionService);
    focusManagerService = TestBed.inject(FocusManagerService);
    guestCollectionProgressService = TestBed.inject(
      GuestCollectionProgressService);
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService);
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    imagePreloaderService = TestBed.inject(ImagePreloaderService);
    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);
    learnerParamsService = TestBed.inject(LearnerParamsService);
    loaderService = TestBed.inject(LoaderService);
    messengerService = TestBed.inject(MessengerService);
    numberAttemptsService = TestBed.inject(NumberAttemptsService);
    playerCorrectnessFeedbackEnabledService = TestBed.inject(
      PlayerCorrectnessFeedbackEnabledService);
    playerPositionService = TestBed.inject(PlayerPositionService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    questionPlayerStateService = TestBed.inject(QuestionPlayerStateService);
    readOnlyCollectionBackendApiService = TestBed.inject(
      ReadOnlyCollectionBackendApiService);
    refresherExplorationConfirmationModalService = TestBed.inject(
      RefresherExplorationConfirmationModalService);
    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);
    statsReportingService = TestBed.inject(StatsReportingService);
    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);
    urlInterpolationService = TestBed.inject(UrlInterpolationService);
    urlService = TestBed.inject(UrlService);
    userService = TestBed.inject(UserService);
    windowDimensionsService = TestBed.inject(WindowDimensionsService);
    windowRef = TestBed.inject(WindowRef);
  }));

  it('should create', () => {
    expect(componentInstance).toBeDefined();
  });

  it('should initialize component', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = true;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true
    };
    let newStateName = 'newState';
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    spyOn(urlService, 'getCollectionIdFromExplorationUrl')
      .and.returnValues(collectionId, null);

    spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
      .and.returnValue(Promise.resolve(new Collection(
        '', '', '', '', [], null, '', 6, 8, [])));
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode')
      .and.returnValue(isInPreviewMode);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValue('oppia_avatar_url');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
      .and.returnValue(
        Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService, 'recordExplorationCompletedInCollection');
    spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
      .and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();

    spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
      .and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
      .and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
      .and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, null, '', null);
    componentInstance.isLoggedIn = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();

    mockOnHintConsumed.emit();
    mockOnSolutionViewedEventEmitter.emit();
    mockOnPlayerStateChange.emit();
    mockOnPlayerStateChange.emit(newStateName);
    tick(100);

    componentInstance.redirectToRefresherExplorationConfirmed = true;

    spyOn(alertsService, 'addWarning');
    componentInstance.ngOnInit();

    TestBed.inject(WindowRef).nativeWindow.onresize(null);
    tick(1000);
  }));

  it('should tell if submit button is disabled', () => {
    let displayedCardIndex = 1;
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      displayedCardIndex);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(currentInteractionService, 'isSubmitButtonDisabled').and.returnValue(
      true);

    expect(componentInstance.isSubmitButtonDisabled()).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled()).toBeFalse();
  });

  it('should tell if collection allows guest progress', () => {
    expect(componentInstance.doesCollectionAllowsGuestProgress('')).toBeFalse();
  });

  it('should change card', () => {
    spyOn(playerPositionService, 'recordNavigationButtonClick');
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(explorationEngineService.onUpdateActiveStateIfInEditor, 'emit');
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'state_name');
    spyOn(playerPositionService, 'changeCurrentQuestion');

    componentInstance.changeCard(1);

    expect(playerPositionService.recordNavigationButtonClick)
      .toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex).toHaveBeenCalled();
    expect(explorationEngineService.onUpdateActiveStateIfInEditor.emit)
      .toHaveBeenCalled();
    expect(playerPositionService.getCurrentStateName).toHaveBeenCalled();
    expect(playerPositionService.changeCurrentQuestion).toHaveBeenCalled();
  });

  it('should unsubscribe on destroy', () => {
    spyOn(componentInstance.directiveSubscriptions, 'unsubscribe');

    componentInstance.ngOnDestroy();

    expect(componentInstance.directiveSubscriptions.unsubscribe)
      .toHaveBeenCalled();
  });

  it('should always ask learner for answer details', () => {
    spyOn(explorationEngineService, 'getAlwaysAskLearnerForAnswerDetails')
      .and.returnValues(true, false);

    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeTrue();
    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeFalse();
  });

  it('should get can ask learner for answer info', () => {
    spyOn(learnerAnswerInfoService, 'getCanAskLearnerForAnswerInfo')
      .and.returnValues(true, false);

    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeTrue();
    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeFalse();
  });

  it('should initialize learner answer info service', () => {
    spyOn(learnerAnswerInfoService, 'initLearnerAnswerInfoService');

    componentInstance.initLearnerAnswerInfoService(
      null, null, null, null, false);

    expect(learnerAnswerInfoService.initLearnerAnswerInfoService)
      .toHaveBeenCalled();
  });

  it('should tell if correctness feedback is enabled', () => {
    spyOn(playerCorrectnessFeedbackEnabledService, 'isEnabled');

    componentInstance.isCorrectnessFeedbackEnabled();

    expect(playerCorrectnessFeedbackEnabledService.isEnabled)
      .toHaveBeenCalled();
  });

  it('should tell if correctness footer is enabled', () => {
    componentInstance.answerIsCorrect = true;

    spyOn(componentInstance, 'isCorrectnessFeedbackEnabled').and.returnValue(
      true);
    spyOn(playerPositionService, 'hasLearnerJustSubmittedAnAnswer')
      .and.returnValue(true);

    expect(componentInstance.isCorrectnessFooterEnabled()).toBeTrue();
  });

  it('should tell if learn again button should be visible', () => {
    //
  });

  it('should get static image url', () => {
    let imageUrl = 'image_url';
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      imageUrl);

    expect(componentInstance.getStaticImageUrl('')).toEqual(imageUrl);
  });

  it('should get content focus label', () => {
    let index = 1;

    expect(componentInstance.getContentFocusLabel(index)).toEqual(
      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index);
  });

  it('should tell if language is RTL', () => {
    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL')
      .and.returnValue(true);

    expect(componentInstance.isLanguageRTL()).toBeTrue();
  });

  it('should reload exploration', () => {
    spyOn(windowRef.nativeWindow.location, 'reload');

    componentInstance.reloadExploration();

    expect(windowRef.nativeWindow.location.reload).toHaveBeenCalled();
  });

  it('should tell if display card is terminal', () => {
    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, null, '', null);

    expect(componentInstance.isOnTerminalCard()).toBeTrue();
  });

  it('should tell if supplemental card is non empty', () => {
    expect(componentInstance.isSupplementalCardNonempty(displayedCard))
      .toBeFalse();
  });

  it('should return to exploration after concept card is compeleted', () => {
    let numCards = 20;
    spyOn(playerTranscriptService, 'addPreviousCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(numCards);
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.returnToExplorationAfterConceptCard();

    expect(playerTranscriptService.addPreviousCard).toHaveBeenCalled();
    expect(playerTranscriptService.getNumCards).toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex)
      .toHaveBeenCalledOnceWith(numCards - 1);
  });

  it('should tell if current is at end of transcript', () => {
    let index = 1;
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      index);

    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeTrue();
    expect(playerTranscriptService.isLastCard).toHaveBeenCalledWith(index);
  });

  it('should hide loading screen if question are not available', () => {
    spyOn(loaderService, 'hideLoadingScreen');

    componentInstance.showQuestionAreNotAvailable();

    expect(loaderService.hideLoadingScreen).toHaveBeenCalled();
  });

  it('should initialize page', fakeAsync(() => {
    spyOn(playerPositionService, 'init').and.callFake((callb) => {
      callb();
    });
    componentInstance.questionPlayerConfig = {};
    spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(loaderService, 'hideLoadingScreen');
    let getLanguageSpy = spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');
    spyOn(explorationPlayerStateService, 'initializeQuestionPlayer')
      .and.callFake((config, callb, questionAreAvailable) => {
        callb(displayedCard, 'label');
      });
    spyOn(componentInstance, 'adjustPageHeight');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    componentInstance.isIframed = true;
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.initializePage();
    tick(100);
    expect(componentInstance.hasInteractedAtLeastOnce).toBeFalse();
    expect(componentInstance.recommendedExplorationSummaries).toEqual([]);
    expect(playerPositionService.init).toHaveBeenCalled();

    componentInstance.questionPlayerConfig = null;
    spyOn(explorationPlayerStateService, 'initializePlayer');
    spyOn(playerPositionService, 'getDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'getContentFocusLabel');

    getLanguageSpy.and.returnValue('pq');
    componentInstance.initializePage();

    tick(100);
    componentInstance.initializePage();

    expect(explorationPlayerStateService.initializePlayer).toHaveBeenCalled();
  }));

  it('should tell if window can show two cards', () => {
    spyOn(windowDimensionsService, 'getWidth').and.returnValue(
      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX + 1);

    expect(componentInstance.canWindowShowTwoCards()).toBeTrue();
  });

  it('should register analytics when user visit using iframe', () => {
    spyOn(siteAnalyticsService, 'registerVisitOppiaFromIframeEvent');

    componentInstance.onNavigateFromIframe();

    expect(siteAnalyticsService.registerVisitOppiaFromIframeEvent)
      .toHaveBeenCalled();
  });

  it('should submit answer from progress nav', () => {
    spyOn(currentInteractionService, 'submitAnswer');

    componentInstance.submitAnswerFromProgressNav();

    expect(currentInteractionService.submitAnswer).toHaveBeenCalled();
  });

  it('should show learn again button', () => {
    componentInstance.displayedCard = {
      getStateName: () => null
    } as StateCard;

    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true, true, true);

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = displayedCard;

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'Continue', null),
      [], null, null, '', null);

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'ImageClickInput', null),
      [], null, null, '', null);

    componentInstance.pendingCardWasSeenBefore = true;
    componentInstance.answerIsCorrect = false;
    spyOn(componentInstance, 'isCorrectnessFeedbackEnabled')
      .and.returnValue(true);

    expect(componentInstance.isLearnAgainButton()).toBeTrue();
  });

  it('should adjust page height on scroll', fakeAsync(() => {
    componentInstance.lastRequestedHeight = document.body.scrollHeight + 100;
    componentInstance.lastRequestedScroll = false;
    spyOn(messengerService, 'sendMessage');

    let callbSpy = jasmine.createSpy('adjust page height callback');
    let scrollValue = true;

    componentInstance.adjustPageHeight(scrollValue, callbSpy);
    tick(150);

    expect(messengerService.sendMessage).toHaveBeenCalled();
    expect(componentInstance.lastRequestedScroll).toEqual(scrollValue);
    expect(callbSpy).toHaveBeenCalled();
  }));

  it('should get exploration link', () => {
    componentInstance.recommendedExplorationSummaries = [{id: ''}];

    expect(componentInstance.getExplorationLink()).toEqual('#');

    let expId = '123';
    let collectionId = '980';
    let storyUrlFragment = 'story_fragment';
    let nodeId = 'node_id';
    let topicUrlFragment = 'topic_url_fragment';
    let classroomUrlFragment = 'classroom_fragment';
    componentInstance.recommendedExplorationSummaries = [{
      id: expId,
      parentExplorationIds: ['4566', 's9af0'],
      nextNodeId: nodeId
    }];
    spyOn(urlService, 'getUrlParams').and.returnValues({
      collection_id: collectionId
    }, {
      story_url_fragment: storyUrlFragment,
      node_id: nodeId,
      topic_url_fragment: topicUrlFragment,
      classroom_url_fragment: classroomUrlFragment
    }, {
      story_url_fragment: storyUrlFragment,
      node_id: nodeId,
      topic_url_fragment: topicUrlFragment,
      classroom_url_fragment: classroomUrlFragment
    });

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?collection_id=' + collectionId +
      '&parent=' + componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0]);
    expect(urlService.getUrlParams).toHaveBeenCalled();

    componentInstance.parentExplorationIds = null;
    componentInstance.storyNodeIdToAdd = nodeId;

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?parent=' +
      componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0] + '&topic_url_fragment=' + topicUrlFragment +
        '&classroom_url_fragment=' + classroomUrlFragment +
        '&story_url_fragment=' + storyUrlFragment + '&node_id=' + nodeId
    );

    spyOn(urlService, 'getPathname').and.returnValue(
      '/story/story-url-fragment');
    spyOn(urlService, 'getStoryUrlFragmentFromLearnerUrl').and.returnValue(
      storyUrlFragment);
    spyOn(urlService, 'getTopicUrlFragmentFromLearnerUrl').and.returnValue(
      topicUrlFragment);
    spyOn(urlService, 'getClassroomUrlFragmentFromLearnerUrl').and.returnValue(
      classroomUrlFragment);

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?parent=' +
      componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0] + '&topic_url_fragment=' + topicUrlFragment +
        '&classroom_url_fragment=' + classroomUrlFragment +
        '&story_url_fragment=' + storyUrlFragment + '&node_id=' + nodeId
    );
    expect(urlService.getPathname).toHaveBeenCalled();
    expect(urlService.getStoryUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getTopicUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getClassroomUrlFragmentFromLearnerUrl).toHaveBeenCalled();
  });

  it('should tell if current supplemental card is non empty', () => {
    componentInstance.displayedCard = displayedCard;
    spyOn(componentInstance, 'isSupplementalCardNonempty').and.returnValues(
      true, false);

    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeTrue();
    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeFalse();
  });

  it('should tell if supplemental nav is shown', () => {
    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'NumberWithUnits', null),
      [], null, null, '', null);
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true);
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript')
      .and.returnValue(true);
    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
    expect(componentInstance.isSupplementalNavShown()).toBeTrue();
  });

  it('should animate to two cards', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToTwoCards(doneCallbackSpy);

    tick(1000);
    expect(componentInstance.isAnimatingToTwoCards).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));

  it('should animate to one card', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToOneCard(doneCallbackSpy);

    tick(600);
    expect(componentInstance.isAnimatingToOneCard).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));

  it('should show pending card', fakeAsync(() => {
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'scrollToTop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(contentTranslationManagerService, 'displayTranslations');
    spyOn(componentInstance, 'isSupplementalCardNonempty');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(componentInstance, 'canWindowShowTwoCards');
    spyOn(componentInstance, 'animateToOneCard');
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
    spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
      .and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId'
    });
    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
    let readOnlyStoryNode = new ReadOnlyStoryNode(
      '', '', '', [], [], [], '', false, '', null, false, '', '');
    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync')
      .and.returnValue(Promise.resolve(
        new StoryPlaythrough(
          'nodeId', [readOnlyStoryNode, readOnlyStoryNode], '', '', '', '')
      ));
    spyOn(storyViewerBackendApiService, 'recordChapterCompletionAsync')
      .and.returnValues(Promise.resolve({
        readyForReviewTest: true,
        nextNodeId: '',
        summaries: []
      }));

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, null, '', null);
    componentInstance.isLoggedIn = true;

    componentInstance.showPendingCard();
    tick(1000);

    expect(explorationPlayerStateService.recordNewCardAdded).toHaveBeenCalled();
  }));

  it('should scroll to bottom', fakeAsync(() => {
    componentInstance.scrollToBottom();
    tick(200);

    spyOn(window, '$').and.returnValue({
      offset: () => {
        return {top: 10};
      },
      outerHeight: () => 10,
      scrollTop: () => 0,
      height: () => 0,
      animate: () => {}
    } as unknown as JQLite);

    componentInstance.scrollToBottom();
    tick(200);
    expect(window.$).toHaveBeenCalled();
  }));

  it('should scroll to top', fakeAsync(() => {
    let animateSpy = jasmine.createSpy('jquery spy');
    spyOn(window, '$').and.returnValue({
      animate: animateSpy
    } as unknown as JQLite);
    componentInstance.scrollToTop();
    tick(1000);
    expect(animateSpy).toHaveBeenCalled();
  }));

  it('should show upcoming card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(displayedCard, 'getStateName').and.returnValue(null);
    componentInstance.displayedCard = displayedCard;
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true, true, true, true);
    spyOn(playerTranscriptService, 'isLastCard')
      .and.returnValues(true, false, false, false, false);
    spyOn(componentInstance, 'returnToExplorationAfterConceptCard');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = true;
    spyOn(questionPlayerStateService.onQuestionSessionCompleted, 'emit');
    spyOn(questionPlayerStateService, 'getQuestionPlayerStateData');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = false;
    componentInstance.moveToExploration = true;
    spyOn(explorationPlayerStateService, 'moveToExploration');

    componentInstance.showUpcomingCard();

    componentInstance.moveToExploration = false;
    let stateCard = new StateCard(
      'stateName', null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, null, '', null);
    stateCard.markAsCompleted();
    componentInstance.displayedCard = stateCard;
    componentInstance.nextCard = stateCard;
    componentInstance.conceptCard = new ConceptCard(
      new SubtitledHtml('', ''), [], null);
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(playerTranscriptService, 'addNewCard');
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');
    spyOn(contentTranslationLanguageService, 'getCurrentContentLanguageCode')
      .and.returnValue('en');
    spyOn(contentTranslationManagerService, 'displayTranslations');

    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(componentInstance, 'isSupplementalCardNonempty')
      .and.returnValues(false, true);
    spyOn(playerTranscriptService, 'getCard');
    spyOn(playerTranscriptService, 'getLastCard');
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(componentInstance, 'animateToTwoCards').and.callFake((callb) => {
      callb();
    });
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(componentInstance, 'showPendingCard');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(explorationEngineService, 'getAuthorRecommendedExpIds')
      .and.returnValue([]);
    spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
      .and.returnValue(true);
    spyOn(userService, 'setReturnUrl');
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId'
    });

    componentInstance.isLoggedIn = false;

    componentInstance.showUpcomingCard();

    componentInstance.conceptCard = null;
    componentInstance.answerIsCorrect = true;

    componentInstance.showUpcomingCard();
  });

  it('should submit answer', fakeAsync(() => {
    componentInstance.answerIsBeingProcessed = true;
    componentInstance.submitAnswer('', null);

    componentInstance.answerIsBeingProcessed = false;
    componentInstance.displayedCard = displayedCard;
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(
      true);
    componentInstance.isInPreviewMode = false;
    spyOn(fatigueDetectionService, 'recordSubmissionTimestamp');
    spyOn(fatigueDetectionService, 'isSubmittingTooFast').and.returnValues(
      true, false);
    spyOn(fatigueDetectionService, 'displayTakeBreakMessage');
    spyOn(explorationPlayerStateService.onOppiaFeedbackAvailable, 'emit');
    componentInstance.submitAnswer('', null);

    spyOn(explorationPlayerStateService, 'isInQuestionMode')
      .and.returnValues(false, false, false, true);
    spyOn(componentInstance, 'initLearnerAnswerInfoService');
    spyOn(explorationEngineService, 'getState');
    spyOn(componentInstance, 'alwaysAskLearnerForAnswerDetails');
    spyOn(numberAttemptsService, 'submitAttempt');
    spyOn(playerTranscriptService, 'addNewInput');
    spyOn(componentInstance, 'getCanAskLearnerForAnswerInfo').and.returnValues(
      true, false);
    spyOn(playerTranscriptService, 'addNewResponse');
    spyOn(learnerAnswerInfoService, 'getSolicitAnswerDetailsQuestion');
    spyOn(playerPositionService.onHelpCardAvailable, 'emit');

    componentInstance.submitAnswer('', null);
    tick(200);

    spyOn(playerPositionService, 'recordAnswerSubmission');
    spyOn(explorationPlayerStateService, 'getCurrentEngineService')
      .and.returnValue(explorationEngineService);

    let callback = (
        answer: string, interactionRulesService: InteractionRulesService,
        successCallback: (
        nextCard: StateCard,
        refreshInteraction: boolean,
        feedbackHtml: string,
        feedbackAudioTranslations: BindableVoiceovers,
        refresherExplorationId: string,
        missingPrerequisiteSkillId: string,
        remainOnCurrentCard: boolean,
        taggedSkillMisconceptionId: string,
        wasOldStateInitial: boolean,
        isFirstHit: boolean,
        isFinalQuestion: boolean,
        focusLabel: string
      ) => void
    ) => {
      let stateCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'EndExploration', null),
        [], null, null, '', null);
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', '', false, '', true,
        false, true, '');
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', '', false, '', true,
        false, false, '');
      successCallback(
        stateCard, true, '', null, 'refresherId', '', false, '', true,
        false, false, '');
      successCallback(
        stateCard, true, 'feedback', null, '', 'skill_id', true, '', true,
        false, false, '');
      componentInstance.displayedCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'ImageClickInput', null),
        [], null, null, '', null);
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', 'skill_id', true,
        '', true, false, false, '');
      return false;
    };
    spyOn(explorationEngineService, 'submitAnswer').and.callFake(callback);
    spyOn(playerPositionService, 'getCurrentStateName')
      .and.returnValue('oldState');
    spyOn(statsReportingService, 'recordStateTransition');
    spyOn(learnerParamsService, 'getAllParams');
    spyOn(statsReportingService, 'recordStateCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValue(true);
    spyOn(componentInstance, 'showUpcomingCard');
    spyOn(fatigueDetectionService, 'reset');
    spyOn(numberAttemptsService, 'reset');
    spyOn(questionPlayerStateService, 'answerSubmitted');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(playerTranscriptService, 'updateLatestInteractionHtml');
    spyOn(conceptCardBackendApiService, 'loadConceptCardsAsync')
      .and.returnValue(Promise.resolve([
        new ConceptCard(
          new SubtitledHtml('', ''), [], null)
      ]));

    spyOn(
      explorationSummaryBackendApiService,
      'loadPublicExplorationSummariesAsync')
      .and.returnValue(Promise.resolve({
        summaries: [{} as ExplorationSummaryDict]
      }));
    spyOn(
      refresherExplorationConfirmationModalService,
      'displayRedirectConfirmationModal').and.callFake((id, callb) => {
      callb();
    });
    spyOn(statsReportingService, 'recordLeaveForRefresherExp');
    spyOn(playerTranscriptService, 'hasEncounteredStateBefore')
      .and.returnValue(true);
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');

    componentInstance.explorationActuallyStarted = false;

    componentInstance.submitAnswer('', null);
    tick(2000);
  }));

  it('should fix supplement card on scroll', () => {
    let addClassSpy = jasmine.createSpy('add class spy');
    spyOn(window, '$').and.returnValue({
      height: () => 30,
      scrollTop: () => 30,
      addClass: addClassSpy
    } as unknown as JQLite);

    componentInstance.fixSupplementOnScroll();

    expect(addClassSpy).toHaveBeenCalled();
    expect(window.$).toHaveBeenCalled();
  });
});
