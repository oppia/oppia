// Copyright 2022 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for Conversation skin component.
 */

import { HttpClientTestingModule } from '@angular/common/http/testing';
import { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core';
import { ComponentFixture, fakeAsync, TestBed, tick, waitForAsync, flush } from '@angular/core/testing';
import { QuestionPlayerStateService } from 'components/question-directives/question-player/services/question-player-state.service';
import { Collection } from 'domain/collection/collection.model';
import { GuestCollectionProgressService } from 'domain/collection/guest-collection-progress.service';
import { ReadOnlyCollectionBackendApiService } from 'domain/collection/read-only-collection-backend-api.service';
import { Interaction, InteractionObjectFactory } from 'domain/exploration/InteractionObjectFactory';
import { FetchExplorationBackendResponse, ReadOnlyExplorationBackendApiService } from 'domain/exploration/read-only-exploration-backend-api.service';
import { BindableVoiceovers } from 'domain/exploration/recorded-voiceovers.model';
import { SubtitledHtml } from 'domain/exploration/subtitled-html.model';
import { ConceptCardBackendApiService } from 'domain/skill/concept-card-backend-api.service';
import { ConceptCard } from 'domain/skill/concept-card.model';
import { StateObjectFactory } from 'domain/state/StateObjectFactory';
import { StateCard } from 'domain/state_card/state-card.model';
import { ReadOnlyStoryNode } from 'domain/story_viewer/read-only-story-node.model';
import { StoryPlaythrough } from 'domain/story_viewer/story-playthrough.model';
import { StoryViewerBackendApiService } from 'domain/story_viewer/story-viewer-backend-api.service';
import { ExplorationSummaryBackendApiService, ExplorationSummaryDict } from 'domain/summary/exploration-summary-backend-api.service';
import { UserInfo } from 'domain/user/user-info.model';
import { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';
import { CollectionPlayerBackendApiService } from 'pages/collection-player-page/services/collection-player-backend-api.service';
import { AlertsService } from 'services/alerts.service';
import { AudioPlayerService } from 'services/audio-player.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { ContextService } from 'services/context.service';
import { UrlService } from 'services/contextual/url.service';
import { WindowDimensionsService } from 'services/contextual/window-dimensions.service';
import { WindowRef } from 'services/contextual/window-ref.service';
import { I18nLanguageCodeService } from 'services/i18n-language-code.service';
import { LoaderService } from 'services/loader.service';
import { LocalStorageService } from 'services/local-storage.service';
import { MessengerService } from 'services/messenger.service';
import { SiteAnalyticsService } from 'services/site-analytics.service';
import { FocusManagerService } from 'services/stateful/focus-manager.service';
import { UserService } from 'services/user.service';
import { MockTranslatePipe } from 'tests/unit-test-utils';
import { ExplorationPlayerConstants } from '../exploration-player-page.constants';
import { AnswerClassificationService, InteractionRulesService } from '../services/answer-classification.service';
import { ContentTranslationLanguageService } from '../services/content-translation-language.service';
import { ContentTranslationManagerService } from '../services/content-translation-manager.service';
import { CurrentInteractionService } from '../services/current-interaction.service';
import { ExplorationEngineService } from '../services/exploration-engine.service';
import { ExplorationPlayerStateService } from '../services/exploration-player-state.service';
import { ExplorationRecommendationsService } from '../services/exploration-recommendations.service';
import { FatigueDetectionService } from '../services/fatigue-detection.service';
import { HintsAndSolutionManagerService } from '../services/hints-and-solution-manager.service';
import { ImagePreloaderService } from '../services/image-preloader.service';
import { LearnerAnswerInfoService } from '../services/learner-answer-info.service';
import { LearnerParamsService } from '../services/learner-params.service';
import { NumberAttemptsService } from '../services/number-attempts.service';
import { PlayerCorrectnessFeedbackEnabledService } from '../services/player-correctness-feedback-enabled.service';
import { PlayerPositionService } from '../services/player-position.service';
import { PlayerTranscriptService } from '../services/player-transcript.service';
import { QuestionPlayerEngineService } from '../services/question-player-engine.service';
import { RefresherExplorationConfirmationModalService } from '../services/refresher-exploration-confirmation-modal.service';
import { StatsReportingService } from '../services/stats-reporting.service';
import { ConversationSkinComponent } from './conversation-skin.component';
import { PlatformFeatureService } from 'services/platform-feature.service';
import { LearnerDashboardBackendApiService } from 'domain/learner_dashboard/learner-dashboard-backend-api.service';
import { EditableExplorationBackendApiService } from 'domain/exploration/editable-exploration-backend-api.service';
import { DiagnosticTestTopicTrackerModel } from 'pages/diagnostic-test-player-page/diagnostic-test-topic-tracker.model';
import { TranslateService } from '@ngx-translate/core';
import { MockTranslateService } from 'components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';
import { AudioTranslationLanguageService } from '../services/audio-translation-language.service';
import { ConceptCardManagerService } from '../services/concept-card-manager.service';
import { SolutionObjectFactory } from 'domain/exploration/SolutionObjectFactory';

class MockWindowRef {
  nativeWindow = {
    location: {
      pathname: '/path/name',
      reload: () => {}
    },
    onresize: () => {
    },
    addEventListener(event: string, callback) {
      callback({returnValue: null});
    },
    scrollTo: (x, y) => {}
  };
}

class MockPlatformFeatureService {
  get status(): object {
    return {
      EndChapterCelebration: {
        isEnabled: true
      }
    };
  }
}

describe('Conversation skin component', () => {
  let fixture: ComponentFixture<ConversationSkinComponent>;
  let componentInstance: ConversationSkinComponent;
  let alertsService: AlertsService;
  let audioPlayerService: AudioPlayerService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let collectionPlayerBackendApiService: CollectionPlayerBackendApiService;
  let conceptCardBackendApiService: ConceptCardBackendApiService;
  let contentTranslationLanguageService: ContentTranslationLanguageService;
  let contentTranslationManagerService: ContentTranslationManagerService;
  let contextService: ContextService;
  let currentInteractionService: CurrentInteractionService;
  let editableExplorationBackendApiService:
    EditableExplorationBackendApiService;
  let explorationEngineService: ExplorationEngineService;
  let explorationPlayerStateService: ExplorationPlayerStateService;
  let explorationRecommendationsService:
    ExplorationRecommendationsService;
  let explorationSummaryBackendApiService: ExplorationSummaryBackendApiService;
  let fatigueDetectionService: FatigueDetectionService;
  let focusManagerService: FocusManagerService;
  let guestCollectionProgressService: GuestCollectionProgressService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let imagePreloaderService: ImagePreloaderService;
  let learnerAnswerInfoService: LearnerAnswerInfoService;
  let learnerParamsService: LearnerParamsService;
  let loaderService: LoaderService;
  let localStorageService: LocalStorageService;
  let messengerService: MessengerService;
  let numberAttemptsService: NumberAttemptsService;
  let interactionObjectFactory: InteractionObjectFactory;
  let playerCorrectnessFeedbackEnabledService:
    PlayerCorrectnessFeedbackEnabledService;
  let playerPositionService: PlayerPositionService;
  let playerTranscriptService: PlayerTranscriptService;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let questionPlayerStateService: QuestionPlayerStateService;
  let answerClassificationService: AnswerClassificationService;
  let readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService;
  let refresherExplorationConfirmationModalService:
    RefresherExplorationConfirmationModalService;
  let siteAnalyticsService: SiteAnalyticsService;
  let statsReportingService: StatsReportingService;
  let storyViewerBackendApiService: StoryViewerBackendApiService;
  let urlInterpolationService: UrlInterpolationService;
  let urlService: UrlService;
  let userService: UserService;
  let windowDimensionsService: WindowDimensionsService;
  let windowRef: WindowRef;
  let readOnlyExplorationBackendApiService:
    ReadOnlyExplorationBackendApiService;
  let stateObjectFactory: StateObjectFactory;
  let platformFeatureService: PlatformFeatureService;
  let translateService: TranslateService;
  let learnerDashboardBackendApiService: LearnerDashboardBackendApiService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let conceptCardManagerService: ConceptCardManagerService;
  let solutionObjectFactory: SolutionObjectFactory;


  let displayedCard = new StateCard(
    null, null, null, new Interaction(
      [], [], null, null, [], '', null),
    [], null, '', null);

  let explorationDict = {
    states: {
      Start: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            ca_placeholder_0: {},
            feedback_1: {},
            rule_input_2: {},
            content: {},
            default_outcome: {}
          }
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0'
              }
            },
            catchMisspellings: {
              value: false
            }
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: '<p>Good Job</p>'
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'Mid'
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: [
                        'answer'
                      ],
                      contentId: 'rule_input_2'
                    }
                  },
                  rule_type: 'FuzzyEquals'
                }
              ],
              tagged_skill_misconception_id: null
            }
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>Try again.</p>'
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Start'
          }
        },
        param_changes: [],
        card_is_checkpoint: true,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>First Question</p>'
        }
      },
      End: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            content: {}
          }
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'EndExploration',
          hints: [],
          customization_args: {
            recommendedExplorationIds: {
              value: ['recommnendedExplorationId']
            }
          },
          answer_groups: [],
          default_outcome: null
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: 'Congratulations, you have finished!'
        }
      },
      Mid: {
        classifier_model_id: null,
        recorded_voiceovers: {
          voiceovers_mapping: {
            ca_placeholder_0: {},
            feedback_1: {},
            rule_input_2: {},
            content: {},
            default_outcome: {}
          }
        },
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0'
              }
            },
            catchMisspellings: {
              value: false
            }
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: ' <p>Good Job</p>'
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'End'
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: [
                        'answer'
                      ],
                      contentId: 'rule_input_2'
                    }
                  },
                  rule_type: 'FuzzyEquals'
                }
              ],
              tagged_skill_misconception_id: null
            }
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>try again.</p>'
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Mid'
          }
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>Second Question</p>'
        }
      }
    },
    auto_tts_enabled: true,
    version: 2,
    draft_change_list_id: 9,
    is_version_of_draft_valid: null,
    title: 'Exploration',
    language_code: 'en',
    correctness_feedback_enabled: true,
    init_state_name: 'Start',
    param_changes: [],
    next_content_id_index: 4,
    param_specs: null,
    draft_changes: null,
  };

  let explorationResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      correctness_feedback_enabled: true,
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      correctness_feedback_enabled: true,
      edits_allowed: true
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    correctness_feedback_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: 'Mid',
    most_recently_reached_checkpoint_exp_version: 2
  };

  let sampleExpResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      correctness_feedback_enabled: true,
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      correctness_feedback_enabled: true,
      edits_allowed: true
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    correctness_feedback_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: null,
    most_recently_reached_checkpoint_exp_version: 2
  };
  let uniqueProgressIdResponse = '123456';

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      declarations: [
        ConversationSkinComponent,
        MockTranslatePipe
      ],
      providers: [
        SolutionObjectFactory,
        {
          provide: WindowRef,
          useClass: MockWindowRef
        },
        {
          provide: PlatformFeatureService,
          useClass: MockPlatformFeatureService
        },
        {
          provide: TranslateService,
          useClass: MockTranslateService
        }
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();

    fixture = TestBed.createComponent(ConversationSkinComponent);
    componentInstance = fixture.componentInstance;

    alertsService = TestBed.inject(AlertsService);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService);
    collectionPlayerBackendApiService = TestBed.inject(
      CollectionPlayerBackendApiService);
    conceptCardBackendApiService = TestBed.inject(ConceptCardBackendApiService);
    contentTranslationLanguageService = TestBed.inject(
      ContentTranslationLanguageService);
    contentTranslationManagerService = TestBed.inject(
      ContentTranslationManagerService);
    contextService = TestBed.inject(ContextService);
    currentInteractionService = TestBed.inject(CurrentInteractionService);
    editableExplorationBackendApiService = TestBed.inject(
      EditableExplorationBackendApiService);
    explorationEngineService = TestBed.inject(ExplorationEngineService);
    explorationPlayerStateService = TestBed.inject(
      ExplorationPlayerStateService);
    explorationRecommendationsService = TestBed.inject(
      ExplorationRecommendationsService);
    explorationSummaryBackendApiService = TestBed.inject(
      ExplorationSummaryBackendApiService);
    fatigueDetectionService = TestBed.inject(FatigueDetectionService);
    interactionObjectFactory = TestBed.inject(InteractionObjectFactory);
    focusManagerService = TestBed.inject(FocusManagerService);
    audioTranslationLanguageService = (
      TestBed.inject(AudioTranslationLanguageService));
    guestCollectionProgressService = TestBed.inject(
      GuestCollectionProgressService);
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService);
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    imagePreloaderService = TestBed.inject(ImagePreloaderService);
    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);
    learnerParamsService = TestBed.inject(LearnerParamsService);
    loaderService = TestBed.inject(LoaderService);
    localStorageService = TestBed.inject(LocalStorageService);
    messengerService = TestBed.inject(MessengerService);
    numberAttemptsService = TestBed.inject(NumberAttemptsService);
    playerCorrectnessFeedbackEnabledService = TestBed.inject(
      PlayerCorrectnessFeedbackEnabledService);
    playerPositionService = TestBed.inject(PlayerPositionService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    questionPlayerStateService = TestBed.inject(QuestionPlayerStateService);
    readOnlyCollectionBackendApiService = TestBed.inject(
      ReadOnlyCollectionBackendApiService);
    refresherExplorationConfirmationModalService = TestBed.inject(
      RefresherExplorationConfirmationModalService);
    siteAnalyticsService = TestBed.inject(SiteAnalyticsService);
    statsReportingService = TestBed.inject(StatsReportingService);
    solutionObjectFactory = TestBed.inject(SolutionObjectFactory);
    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);
    urlInterpolationService = TestBed.inject(UrlInterpolationService);
    urlService = TestBed.inject(UrlService);
    userService = TestBed.inject(UserService);
    windowDimensionsService = TestBed.inject(WindowDimensionsService);
    windowRef = TestBed.inject(WindowRef);
    readOnlyExplorationBackendApiService = TestBed.inject(
      ReadOnlyExplorationBackendApiService);
    stateObjectFactory = TestBed.inject(StateObjectFactory);
    answerClassificationService = TestBed.inject(AnswerClassificationService);
    platformFeatureService = TestBed.inject(PlatformFeatureService);
    conceptCardManagerService = TestBed.inject(ConceptCardManagerService);
    translateService = TestBed.inject(TranslateService);
    learnerDashboardBackendApiService = TestBed.inject(
      LearnerDashboardBackendApiService);
    audioTranslationLanguageService = TestBed.inject(
      AudioTranslationLanguageService);

    spyOn(
      readOnlyExplorationBackendApiService,
      'fetchCheckpointsFeatureIsEnabledStatus'
    ).and.returnValue(Promise.resolve(true));
  }));

  it('should create && adjust page height on resize of window',
    fakeAsync(() => {
      spyOn(componentInstance, 'adjustPageHeight').and.stub();
      componentInstance.adjustPageHeightOnresize();

      expect(componentInstance).toBeDefined();

      windowRef.nativeWindow.onresize(null);
      tick(200);

      expect(componentInstance.adjustPageHeight).toHaveBeenCalled();
    }));

  it('should initialize component', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = true;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true
    };
    let newStateName = 'newState';
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    spyOn(urlService, 'getCollectionIdFromExplorationUrl')
      .and.returnValues(collectionId, null);
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
      .and.returnValue(Promise.resolve(new Collection(
        '', '', '', '', [], null, '', 6, 8, [])));
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode')
      .and.returnValue(isInPreviewMode);
    spyOn(explorationPlayerStateService, 'getCurrentEngineService')
      .and.returnValue(explorationEngineService);
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValue('oppia_avatar_url');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
      .and.returnValue(
        Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(componentInstance, 'fetchCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService, 'recordExplorationCompletedInCollection');
    spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
      .and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
      .and.returnValue(Promise.resolve(explorationResponse));
    spyOn(explorationEngineService, 'getShortestPathToState')
      .and.returnValue(['Start', 'Mid']);
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner')
      .and.returnValue(Promise.resolve(
        {unique_progress_url_id: uniqueProgressIdResponse}));

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened')
      .and.returnValue(mockOnNewCardOpened);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintsExhausted')
      .and.returnValue(mockOnHintsExhausted);
    spyOnProperty(conceptCardManagerService, 'onLearnerGetsReallyStuck')
      .and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onLearnerReallyStuck')
      .and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
      .and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
      .and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
      .and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.isLoggedIn = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    mockOnNewCardOpened.emit(componentInstance.nextCard);
    mockOnHintsExhausted.emit();
    mockOnLearnerGetsReallyStuck.emit();
    mockOnLearnerReallyStuck.emit();
    mockOnHintConsumed.emit();
    mockOnSolutionViewedEventEmitter.emit();
    mockOnPlayerStateChange.emit();
    mockOnPlayerStateChange.emit(newStateName);
    tick(100);

    componentInstance.redirectToRefresherExplorationConfirmed = true;

    spyOn(alertsService, 'addWarning');
    componentInstance.ngOnInit();

    windowRef.nativeWindow.onresize(null);
    tick(1000);
  }));

  it('should initialize component as logged in user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true
    };
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    spyOn(urlService, 'getCollectionIdFromExplorationUrl')
      .and.returnValues(collectionId, null);
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
      .and.returnValue(Promise.resolve(new Collection(
        '', '', '', '', [], null, '', 6, 8, [])));
    spyOn(componentInstance, 'fetchCompletedChaptersCount').and.callThrough();
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync').and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      }));
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode')
      .and.returnValue(isInPreviewMode);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValue('oppia_avatar_url');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
      .and.returnValue(
        Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService, 'recordExplorationCompletedInCollection');
    spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
      .and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
      .and.returnValue(Promise.resolve(sampleExpResponse));

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened')
      .and.returnValue(mockOnNewCardOpened);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintsExhausted')
      .and.returnValue(mockOnHintsExhausted);
    spyOnProperty(conceptCardManagerService, 'onLearnerGetsReallyStuck')
      .and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onLearnerReallyStuck')
      .and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
      .and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
      .and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
      .and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.isLoggedIn = true;
    componentInstance.isIframed = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it('should initialize component as logged out user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true
    };
    let expResponse = sampleExpResponse;
    expResponse.is_logged_in = false;
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', false)));
    spyOn(urlService, 'getCollectionIdFromExplorationUrl')
      .and.returnValues(collectionId, null);
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
      .and.returnValue(Promise.resolve(new Collection(
        '', '', '', '', [], null, '', 6, 8, [])));
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode')
      .and.returnValue(isInPreviewMode);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValue('oppia_avatar_url');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
      .and.returnValue(
        Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(componentInstance, 'fetchCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService, 'recordExplorationCompletedInCollection');
    spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
      .and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
      .and.returnValue(Promise.resolve(expResponse));
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner')
      .and.returnValue(Promise.resolve(
        {unique_progress_url_id: uniqueProgressIdResponse}));

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened')
      .and.returnValue(mockOnNewCardOpened);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintsExhausted')
      .and.returnValue(mockOnHintsExhausted);
    spyOnProperty(conceptCardManagerService, 'onLearnerGetsReallyStuck')
      .and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onLearnerReallyStuck')
      .and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
      .and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
      .and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
      .and.returnValue(mockOnPlayerStateChange);

    componentInstance.nextCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.isLoggedIn = false;
    componentInstance.isIframed = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it('should convert logged out progress to logged in progress when user ' +
  'signs in', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isInPreviewMode = false;
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true
    };
    spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    spyOn(urlService, 'getCollectionIdFromExplorationUrl')
      .and.returnValues(collectionId, null);
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
      .and.returnValue(Promise.resolve(new Collection(
        '', '', '', '', [], null, '', 6, 8, [])));
    spyOn(explorationEngineService, 'getExplorationId').and.returnValue(expId);
    spyOn(explorationEngineService, 'isInPreviewMode')
      .and.returnValue(isInPreviewMode);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValue('oppia_avatar_url');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValues(true, false);
    spyOn(componentInstance, 'initializePage');
    spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
      .and.returnValue(
        Promise.resolve(collectionSummary));
    spyOn(questionPlayerStateService, 'hintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerStateService, 'solutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService, 'recordExplorationCompletedInCollection');
    spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
      .and.returnValue(true);
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
      .and.returnValue(Promise.resolve(sampleExpResponse));
    spyOn(
      editableExplorationBackendApiService,
      'changeLoggedOutProgressToLoggedInProgressAsync')
      .and.returnValue(Promise.resolve());

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened')
      .and.returnValue(mockOnNewCardOpened);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintsExhausted')
      .and.returnValue(mockOnHintsExhausted);
    spyOnProperty(conceptCardManagerService, 'onLearnerGetsReallyStuck')
      .and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onLearnerReallyStuck')
      .and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
      .and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
      .and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
      .and.returnValue(mockOnPlayerStateChange);
    spyOn(localStorageService, 'getUniqueProgressIdOfLoggedOutLearner')
      .and.returnValue('abcdef');
    spyOn(localStorageService, 'removeUniqueProgressIdOfLoggedOutLearner');

    componentInstance.nextCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.isLoggedIn = true;
    componentInstance.isIframed = false;
    componentInstance.hasInteractedAtLeastOnce = true;
    componentInstance.displayedCard = displayedCard;

    componentInstance.ngOnInit();
    tick(100);

    expect(
      editableExplorationBackendApiService
        .changeLoggedOutProgressToLoggedInProgressAsync).toHaveBeenCalled();
    expect(
      localStorageService.
        removeUniqueProgressIdOfLoggedOutLearner).toHaveBeenCalled();
  }));

  it('should show alert when collection summaries are not loaded',
    fakeAsync(() => {
      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(new UserInfo(
          [], false, false,
          false, false, false, '', '', '', true)));
      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(true);
      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(
        'collection_id');
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
      spyOn(localStorageService, 'getUniqueProgressIdOfLoggedOutLearner')
        .and.returnValue(null);
      spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
        .and.returnValue(Promise.reject());
      spyOn(alertsService, 'addWarning');

      componentInstance.ngOnInit();
      tick();

      expect(contextService.isInExplorationEditorPage).toHaveBeenCalled();
      expect(urlService.getCollectionIdFromExplorationUrl).toHaveBeenCalled();
      expect(collectionPlayerBackendApiService.fetchCollectionSummariesAsync)
        .toHaveBeenCalled();
      expect(alertsService.addWarning).toHaveBeenCalledWith(
        'There was an error while fetching the collection ' +
              'summary.'
      );
    }));

  it('should tell if submit button is disabled', () => {
    let displayedCardIndex = 1;
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      displayedCardIndex);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(currentInteractionService, 'isSubmitButtonDisabled').and.returnValue(
      true);

    expect(componentInstance.isSubmitButtonDisabled()).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled()).toBeFalse();
  });

  it('should release solution when the learner gets stuck' +
  ' if no stuck state exists after a predetermined time', fakeAsync(() => {
    // Release solution if stuck state is null.
    componentInstance.nextCardIfStuck = null;
    let solutionSpy = spyOn(hintsAndSolutionManagerService, 'releaseSolution');
    let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');
    componentInstance.solutionForState = solutionObjectFactory.createNew(
      true, 'answer', 'Html', 'XyzID');
    componentInstance.numberOfIncorrectSubmissions = 3;
    componentInstance.triggerIfLearnerStuckAction();
    tick(
      ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC);
    tick(ExplorationPlayerConstants.WAIT_BEFORE_REALLY_STUCK_MSEC);

    expect(solutionSpy).toHaveBeenCalled();
    expect(redirectionSpy).not.toHaveBeenCalled();
    flush();
  }));

  it('should direct the learner to the stuck' +
  ' when the learner gets stuck and such a state exists after a' +
  ' predetermined time', fakeAsync(() => {
    spyOn(componentInstance, 'showPendingCard');
    spyOn(translateService, 'instant').and.callThrough();
    spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');

    expect(componentInstance.continueToReviseStateButtonIsVisible).
      toEqual(false);
    componentInstance.nextCardIfStuck = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.triggerIfLearnerStuckAction();
    tick(
      ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC);

    expect(translateService.instant).toHaveBeenCalledWith(
      'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE');
    expect(componentInstance.continueToReviseStateButtonIsVisible).
      toEqual(true);
    flush();
  }));

  it('should immediately release solution when the learner gets stuck' +
  ' if no stuck state exists', fakeAsync(() => {
    // Release solution if stuck state is null.
    componentInstance.nextCardIfStuck = null;
    let solutionSpy = spyOn(hintsAndSolutionManagerService, 'releaseSolution');
    let redirectionSpy = spyOn(componentInstance, 'showUpcomingCard');
    componentInstance.solutionForState = solutionObjectFactory.createNew(
      true, 'answer', 'Html', 'XyzID');
    componentInstance.numberOfIncorrectSubmissions = 3;
    componentInstance.triggerIfLearnerStuckActionDirectly();

    expect(solutionSpy).toHaveBeenCalled();
    expect(redirectionSpy).not.toHaveBeenCalled();
  }));

  it('should immediately direct the learner to the stuck' +
  ' when the learner gets stuck and such a state exists', fakeAsync(() => {
    spyOn(translateService, 'instant').and.callThrough();
    spyOn(componentInstance, 'showPendingCard');
    spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');
    expect(componentInstance.continueToReviseStateButtonIsVisible).
      toEqual(false);
    componentInstance.nextCardIfStuck = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.triggerIfLearnerStuckActionDirectly();

    expect(translateService.instant).toHaveBeenCalledWith(
      'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE');
    expect(componentInstance.continueToReviseStateButtonIsVisible).
      toEqual(true);
  }));

  it('should redirect the learner to stuck state', fakeAsync(() => {
    spyOn(componentInstance, 'showPendingCard');
    componentInstance.nextCardIfStuck = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);

    componentInstance.triggerRedirectionToStuckState();

    expect(componentInstance.nextCard).toEqual(
      componentInstance.nextCardIfStuck);
    expect(componentInstance.showPendingCard).toHaveBeenCalled();
  }));

  it('should fetch completed chapters count if user is logged in',
    fakeAsync(() => {
      spyOn(
        learnerDashboardBackendApiService,
        'fetchLearnerCompletedChaptersCountDataAsync').and.returnValue(
        Promise.resolve({
          completedChaptersCount: 1,
        }));
      componentInstance.isLoggedIn = false;

      componentInstance.fetchCompletedChaptersCount();
      tick();

      expect(
        learnerDashboardBackendApiService
          .fetchLearnerCompletedChaptersCountDataAsync).not.toHaveBeenCalled();
      expect(componentInstance.completedChaptersCount).toBeUndefined();

      componentInstance.isLoggedIn = true;

      componentInstance.fetchCompletedChaptersCount();
      tick();

      expect(
        learnerDashboardBackendApiService
          .fetchLearnerCompletedChaptersCountDataAsync).toHaveBeenCalled();

      expect(componentInstance.completedChaptersCount).toEqual(1);
    }));

  it('should tell if collection allows guest progress', () => {
    expect(componentInstance.doesCollectionAllowsGuestProgress('')).toBeFalse();
  });

  it('should change card', () => {
    spyOn(playerPositionService, 'recordNavigationButtonClick');
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(explorationEngineService.onUpdateActiveStateIfInEditor, 'emit');
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'state_name');
    spyOn(playerPositionService, 'changeCurrentQuestion');

    componentInstance.changeCard(1);

    expect(playerPositionService.recordNavigationButtonClick)
      .toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex).toHaveBeenCalled();
    expect(explorationEngineService.onUpdateActiveStateIfInEditor.emit)
      .toHaveBeenCalled();
    expect(playerPositionService.getCurrentStateName).toHaveBeenCalled();
    expect(playerPositionService.changeCurrentQuestion).toHaveBeenCalled();
  });

  it('should navigate to the most recently reached checkpoint ' +
  'on page load if user is logged in', fakeAsync(() => {
    let stateCardNames = ['Start', 'Mid', 'End'];
    let stateCards: StateCard[] = [];
    for (let stateName in stateCardNames) {
      stateCards.push(new StateCard(
        stateName,
        '<p>Testing</p>', null, new Interaction(
          [], [], null, null, [], 'Continue', null),
        [], null, 'content', null)
      );
    }
    let alertMessageElement = document.createElement('div');
    alertMessageElement.className =
      'oppia-exploration-checkpoints-message';
    const expResponse = explorationResponse;
    expResponse.exploration.states.Mid.card_is_checkpoint = true;

    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    spyOn(playerPositionService, 'init').and.callFake((callb) => {
      callb();
    });
    componentInstance.questionPlayerConfig = {};
    spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');
    spyOn(playerPositionService.onLoadedMostRecentCheckpoint, 'emit');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(loaderService, 'hideLoadingScreen');
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValues('en', 'en', 'en', 'pq');
    spyOn(explorationPlayerStateService, 'initializeQuestionPlayer')
      .and.callFake((config, callb, questionAreAvailable) => {
        callb(displayedCard, 'label');
      });
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValue(false);
    spyOn(componentInstance, 'adjustPageHeight');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    componentInstance.isIframed = true;
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'getCurrentStateName')
      .and.returnValues('Start', 'Mid', 'End');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
    spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
      .and.returnValue(Promise.resolve(expResponse));
    spyOn(explorationEngineService, 'getShortestPathToState')
      .and.returnValue(['Start', 'Mid']);

    spyOn(explorationEngineService, 'getStateCardByName')
      .and.returnValues(stateCards[0], stateCards[1], stateCards[2]);

    spyOn(playerPositionService, 'getDisplayedCardIndex')
      .and.returnValue(1);
    spyOn(explorationEngineService, 'getState')
      .and.returnValue(stateObjectFactory.createFromBackendDict(
        'Mid', expResponse.exploration.states.Mid
      ));
    spyOn(document, 'querySelector').withArgs(
      '.oppia-exploration-checkpoints-message')
      .and.returnValue(alertMessageElement);

    componentInstance.explorationId = expResponse.exploration_id;
    componentInstance.displayedCard = displayedCard;
    componentInstance.isLoggedIn = true;
    componentInstance.isIframed = false;
    componentInstance.alertMessageTimeout = 5;
    componentInstance.CHECKPOINTS_FEATURE_IS_ENABLED = true;

    componentInstance.initializePage();
    tick(100);

    expect(componentInstance.prevSessionStatesProgress).toEqual(
      ['Start']);
    expect(componentInstance.mostRecentlyReachedCheckpoint).toBe('Mid');
  }));

  it('should determine if chapter was completed for the first time',
    fakeAsync(() => {
      componentInstance.isLoggedIn = true;
      componentInstance.completedChaptersCount = 0;
      spyOn(explorationPlayerStateService, 'recordNewCardAdded');
      spyOn(focusManagerService, 'setFocusIfOnDesktop');
      spyOn(componentInstance, 'scrollToTop');
      spyOn(playerPositionService.onNewCardOpened, 'emit');
      spyOn(explorationPlayerStateService, 'getLanguageCode')
        .and.returnValue('en');
      spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
      spyOn(contentTranslationManagerService, 'displayTranslations');
      spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
      spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
      spyOn(playerPositionService, 'setDisplayedCardIndex');
      spyOn(playerPositionService, 'changeCurrentQuestion');
      spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
      spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
        .and.returnValue(true);
      spyOn(urlService, 'getUrlParams').and.returnValue({
        topic_url_fragment: 'topicUrlFragment',
        classroom_url_fragment: 'classroomUrlFragment',
        story_url_fragment: 'storyUrlFragment',
        node_id: 'nodeId'
      });
      spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
      let readOnlyStoryNode = new ReadOnlyStoryNode(
        'nodeId', '', '', [], [], [], '', false, '', null, false, '', '');
      spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync')
        .and.returnValue(Promise.resolve(
          new StoryPlaythrough(
            'nodeId', [readOnlyStoryNode, readOnlyStoryNode], '', '', '', '')
        ));
      spyOn(
        learnerDashboardBackendApiService,
        'fetchLearnerCompletedChaptersCountDataAsync').and.returnValue(
        Promise.resolve({
          completedChaptersCount: 1,
        }));
      spyOn(storyViewerBackendApiService, 'recordChapterCompletionAsync')
        .and.returnValue(Promise.resolve({
          readyForReviewTest: true,
          nextNodeId: '',
          summaries: []
        }));

      componentInstance.displayedCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'EndExploration', null),
        [], null, '', null);
      componentInstance.isLoggedIn = true;
      spyOn(componentInstance, 'isSupplementalCardNonempty')
        .and.returnValues(false, true, true, false);
      spyOn(componentInstance, 'animateToOneCard').and.callFake((callb) => {
        callb();
      });

      componentInstance.showPendingCard();
      tick(1000);

      expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(true);
      expect(componentInstance.completedChaptersCount).toBe(1);

      componentInstance.completedChaptersCount = 1;
      componentInstance.chapterIsCompletedForTheFirstTime = false;

      componentInstance.showPendingCard();
      tick(1000);

      expect(componentInstance.chapterIsCompletedForTheFirstTime).toBe(false);

      flush();
    }));

  it('should unsubscribe on destroy', () => {
    spyOn(componentInstance.directiveSubscriptions, 'unsubscribe');

    componentInstance.ngOnDestroy();

    expect(componentInstance.directiveSubscriptions.unsubscribe)
      .toHaveBeenCalled();
  });

  it('should always ask learner for answer details', () => {
    spyOn(explorationEngineService, 'getAlwaysAskLearnerForAnswerDetails')
      .and.returnValues(true, false);

    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeTrue();
    expect(componentInstance.alwaysAskLearnerForAnswerDetails()).toBeFalse();
  });

  it('should get can ask learner for answer info', () => {
    spyOn(learnerAnswerInfoService, 'getCanAskLearnerForAnswerInfo')
      .and.returnValues(true, false);

    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeTrue();
    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeFalse();
  });

  it('should initialize learner answer info service', () => {
    spyOn(learnerAnswerInfoService, 'initLearnerAnswerInfoService');

    componentInstance.initLearnerAnswerInfoService(
      null, null, null, null, false);

    expect(learnerAnswerInfoService.initLearnerAnswerInfoService)
      .toHaveBeenCalled();
  });

  it('should tell if correctness feedback is enabled', () => {
    spyOn(playerCorrectnessFeedbackEnabledService, 'isEnabled');

    componentInstance.isCorrectnessFeedbackEnabled();

    expect(playerCorrectnessFeedbackEnabledService.isEnabled)
      .toHaveBeenCalled();
  });

  it('should tell if correctness footer is enabled', () => {
    componentInstance.answerIsCorrect = true;

    spyOn(componentInstance, 'isCorrectnessFeedbackEnabled').and.returnValue(
      true);
    spyOn(playerPositionService, 'hasLearnerJustSubmittedAnAnswer')
      .and.returnValue(true);

    expect(componentInstance.isCorrectnessFooterEnabled()).toBeTrue();
  });

  it('should get static image url', () => {
    let imageUrl = 'image_url';
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      imageUrl);

    expect(componentInstance.getStaticImageUrl('')).toEqual(imageUrl);
  });

  it('should get content focus label', () => {
    let index = 1;

    expect(componentInstance.getContentFocusLabel(index)).toEqual(
      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index);
  });

  it('should reload exploration', () => {
    spyOn(windowRef.nativeWindow.location, 'reload');

    componentInstance.reloadExploration();

    expect(windowRef.nativeWindow.location.reload).toHaveBeenCalled();
  });

  it('should tell if display card is terminal', () => {
    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);

    expect(componentInstance.isOnTerminalCard()).toBeTrue();
  });

  it('should tell if supplemental card is non empty', () => {
    expect(componentInstance.isSupplementalCardNonempty(displayedCard))
      .toBeFalse();
  });

  it('should return to exploration after concept card is compeleted', () => {
    let numCards = 20;
    spyOn(playerTranscriptService, 'addPreviousCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(numCards);
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.returnToExplorationAfterConceptCard();

    expect(playerTranscriptService.addPreviousCard).toHaveBeenCalled();
    expect(playerTranscriptService.getNumCards).toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex)
      .toHaveBeenCalledOnceWith(numCards - 1);
  });

  it('should tell if current is at end of transcript', () => {
    let index = 1;
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      index);

    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeTrue();
    expect(playerTranscriptService.isLastCard).toHaveBeenCalledWith(index);
  });

  it('should hide loading screen if question are not available', () => {
    spyOn(loaderService, 'hideLoadingScreen');

    componentInstance.showQuestionAreNotAvailable();

    expect(loaderService.hideLoadingScreen).toHaveBeenCalled();
  });

  it('should initialize page', fakeAsync(() => {
    spyOn(playerPositionService, 'init').and.callFake((callb) => {
      callb();
    });
    spyOn(urlService, 'getUrlParams').and.returnValues({
      lang: 'pq'
    }, {
      lang: 'en'
    }, {
      lang: 'en'
    }, {
      lang: 'pq'
    });
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(new UserInfo(
        [], false, false,
        false, false, false, '', '', '', true)));
    componentInstance.questionPlayerConfig = {};
    spyOn(explorationPlayerStateService.onPlayerStateChange, 'emit');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(loaderService, 'hideLoadingScreen');
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValues('pq', 'en', 'en', 'pq');
    spyOn(explorationPlayerStateService, 'initializeQuestionPlayer')
      .and.callFake((config, callb, questionAreAvailable) => {
        callb(displayedCard, 'label');
      });
    spyOn(componentInstance, 'adjustPageHeight');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    componentInstance.isIframed = true;
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);

    componentInstance.explorationId = explorationResponse.exploration_id;
    componentInstance.displayedCard = displayedCard;

    componentInstance.initializePage();
    tick(100);
    expect(componentInstance.hasInteractedAtLeastOnce).toBeFalse();
    expect(componentInstance.recommendedExplorationSummaries).toEqual([]);
    expect(playerPositionService.init).toHaveBeenCalled();

    componentInstance.questionPlayerConfig = null;
    spyOn(playerPositionService, 'getDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(componentInstance, 'getContentFocusLabel');
    spyOn(explorationPlayerStateService, 'initializePlayer')
      .and.callFake((callb) => {
        callb(displayedCard, 'label');
      });

    componentInstance._nextFocusLabel = 'focus_label';
    componentInstance.initializePage();
    tick(100);

    componentInstance.questionPlayerConfig = null;
    let topicIdToPrerequisiteTopicIds = {
      topicId1: [],
      topicId2: ['topicId1'],
      topicId3: ['topicId2']
    };

    componentInstance.diagnosticTestTopicTrackerModel = (
      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds));

    spyOn(explorationPlayerStateService, 'initializeDiagnosticPlayer');

    componentInstance.initializePage();
    tick(100);

    expect(playerPositionService.init).toHaveBeenCalled();
    expect(explorationPlayerStateService.initializeDiagnosticPlayer)
      .toHaveBeenCalled();
  }));

  it('should tell if window can show two cards', () => {
    spyOn(windowDimensionsService, 'getWidth').and.returnValue(
      ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX + 1);

    expect(componentInstance.canWindowShowTwoCards()).toBeTrue();
  });

  it('should register analytics when user visit using iframe', () => {
    spyOn(siteAnalyticsService, 'registerVisitOppiaFromIframeEvent');

    componentInstance.onNavigateFromIframe();

    expect(siteAnalyticsService.registerVisitOppiaFromIframeEvent)
      .toHaveBeenCalled();
  });

  it('should submit answer from progress nav', () => {
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(currentInteractionService, 'submitAnswer');

    componentInstance.submitAnswerFromProgressNav();

    expect(currentInteractionService.submitAnswer).toHaveBeenCalled();
  });

  it('should show learn again button', () => {
    componentInstance.displayedCard = {
      getStateName: () => null
    } as StateCard;

    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true, true, true);

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = displayedCard;

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'Continue', null),
      [], null, '', null);

    expect(componentInstance.isLearnAgainButton()).toBeFalse();

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'ImageClickInput', null),
      [], null, '', null);

    componentInstance.pendingCardWasSeenBefore = true;
    componentInstance.answerIsCorrect = false;
    spyOn(componentInstance, 'isCorrectnessFeedbackEnabled')
      .and.returnValue(true);

    expect(componentInstance.isLearnAgainButton()).toBeTrue();
  });

  it('should adjust page height on scroll', fakeAsync(() => {
    componentInstance.lastRequestedHeight = document.body.scrollHeight + 100;
    componentInstance.lastRequestedScroll = false;
    spyOn(messengerService, 'sendMessage');

    let callbSpy = jasmine.createSpy('adjust page height callback');
    let scrollValue = true;

    componentInstance.adjustPageHeight(scrollValue, callbSpy);
    tick(150);

    expect(messengerService.sendMessage).toHaveBeenCalled();
    expect(componentInstance.lastRequestedScroll).toEqual(scrollValue);
    expect(callbSpy).toHaveBeenCalled();
  }));

  it('should get exploration link', () => {
    componentInstance.recommendedExplorationSummaries = [{id: ''}];

    expect(componentInstance.getExplorationLink()).toEqual('#');

    let expId = '123';
    let collectionId = '980';
    let storyUrlFragment = 'story_fragment';
    let nodeId = 'node_id';
    let topicUrlFragment = 'topic_url_fragment';
    let classroomUrlFragment = 'classroom_fragment';
    componentInstance.recommendedExplorationSummaries = [{
      id: expId,
      parentExplorationIds: ['4566', 's9af0'],
      nextNodeId: nodeId
    }];
    spyOn(urlService, 'getUrlParams').and.returnValues({
      collection_id: collectionId
    }, {
      story_url_fragment: storyUrlFragment,
      node_id: nodeId,
      topic_url_fragment: topicUrlFragment,
      classroom_url_fragment: classroomUrlFragment
    }, {
      story_url_fragment: storyUrlFragment,
      node_id: nodeId,
      topic_url_fragment: topicUrlFragment,
      classroom_url_fragment: classroomUrlFragment
    });

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?collection_id=' + collectionId +
      '&parent=' + componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0]);
    expect(urlService.getUrlParams).toHaveBeenCalled();

    componentInstance.parentExplorationIds = null;
    componentInstance.storyNodeIdToAdd = nodeId;

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?parent=' +
      componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0] + '&topic_url_fragment=' + topicUrlFragment +
        '&classroom_url_fragment=' + classroomUrlFragment +
        '&story_url_fragment=' + storyUrlFragment + '&node_id=' + nodeId
    );

    spyOn(urlService, 'getPathname').and.returnValue(
      '/story/story-url-fragment');
    spyOn(urlService, 'getStoryUrlFragmentFromLearnerUrl').and.returnValue(
      storyUrlFragment);
    spyOn(urlService, 'getTopicUrlFragmentFromLearnerUrl').and.returnValue(
      topicUrlFragment);
    spyOn(urlService, 'getClassroomUrlFragmentFromLearnerUrl').and.returnValue(
      classroomUrlFragment);

    expect(componentInstance.getExplorationLink()).toEqual(
      '/explore/' + expId + '?parent=' +
      componentInstance.recommendedExplorationSummaries[0]
        .parentExplorationIds[0] + '&topic_url_fragment=' + topicUrlFragment +
        '&classroom_url_fragment=' + classroomUrlFragment +
        '&story_url_fragment=' + storyUrlFragment + '&node_id=' + nodeId
    );
    expect(urlService.getPathname).toHaveBeenCalled();
    expect(urlService.getStoryUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getTopicUrlFragmentFromLearnerUrl).toHaveBeenCalled();
    expect(urlService.getClassroomUrlFragmentFromLearnerUrl).toHaveBeenCalled();
  });

  it('should tell if current supplemental card is non empty', () => {
    componentInstance.displayedCard = displayedCard;
    spyOn(componentInstance, 'isSupplementalCardNonempty').and.returnValues(
      true, false);

    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeTrue();
    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeFalse();
  });

  it('should tell if supplemental nav is shown', () => {
    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'NumberWithUnits', null),
      [], null, '', null);
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true);
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript')
      .and.returnValue(true);
    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
    expect(componentInstance.isSupplementalNavShown()).toBeTrue();
  });

  it('should animate to two cards', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToTwoCards(doneCallbackSpy);

    tick(1000);
    expect(componentInstance.isAnimatingToTwoCards).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));

  it('should animate to one card', fakeAsync(() => {
    let doneCallbackSpy = jasmine.createSpy('done callback');
    componentInstance.animateToOneCard(doneCallbackSpy);

    tick(600);
    expect(componentInstance.isAnimatingToOneCard).toBeFalse();
    expect(doneCallbackSpy).toHaveBeenCalled();
  }));

  it('should show pending card', fakeAsync(() => {
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(componentInstance, 'scrollToTop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(contentTranslationManagerService, 'displayTranslations');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
    spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
      .and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId'
    });
    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
    let readOnlyStoryNode = new ReadOnlyStoryNode(
      'nodeId', '', '', [], [], [], '', false, '', null, false, '', '');
    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync')
      .and.returnValue(Promise.resolve(
        new StoryPlaythrough(
          'nodeId', [readOnlyStoryNode, readOnlyStoryNode], '', '', '', '')
      ));
    spyOn(storyViewerBackendApiService, 'recordChapterCompletionAsync')
      .and.returnValues(Promise.resolve({
        readyForReviewTest: true,
        nextNodeId: '',
        summaries: []
      }));

    componentInstance.alertMessageTimeout = 5;

    componentInstance.displayedCard = new StateCard(
      null, null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    componentInstance.isLoggedIn = true;
    spyOn(componentInstance, 'isSupplementalCardNonempty')
      .and.returnValues(false, true, true, false);
    spyOn(componentInstance, 'animateToOneCard').and.callFake((callb) => {
      callb();
    });

    componentInstance.showPendingCard();
    tick(1000);

    componentInstance.isLoggedIn = false;

    componentInstance.showPendingCard();
    tick(1000);

    expect(explorationPlayerStateService.recordNewCardAdded).toHaveBeenCalled();
  }));

  it('should scroll to bottom', fakeAsync(() => {
    componentInstance.scrollToBottom();
    tick(200);

    spyOn(window, '$').and.returnValue({
      offset: () => {
        return {top: 10};
      },
      outerHeight: () => 10,
      scrollTop: () => 0,
      height: () => 0,
      animate: () => {}
    } as unknown as JQLite);

    componentInstance.scrollToBottom();
    tick(200);
    expect(window.$).toHaveBeenCalled();
  }));

  it('should scroll to top', fakeAsync(() => {
    let animateSpy = jasmine.createSpy('jquery spy');
    spyOn(window, '$').and.returnValue({
      animate: animateSpy
    } as unknown as JQLite);
    componentInstance.scrollToTop();
    tick(1000);
    expect(animateSpy).toHaveBeenCalled();
  }));

  it('should determine if endChapterCelebrationFeature is enabled or not',
    () => {
      const featureSpy = (
        spyOnProperty(platformFeatureService, 'status', 'get')
          .and.callThrough());

      expect(componentInstance.isEndChapterCelebrationFeatureEnabled())
        .toBe(true);

      featureSpy.and.returnValue({
        EndChapterCelebration: {
          isEnabled: false
        }
      });

      expect(componentInstance.isEndChapterCelebrationFeatureEnabled())
        .toBe(false);
    });

  it('should show upcoming card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(displayedCard, 'getStateName').and.returnValue(null);
    componentInstance.displayedCard = displayedCard;
    spyOn(explorationPlayerStateService, 'isInQuestionMode').and.returnValues(
      false, true, true, true, true);
    spyOn(playerTranscriptService, 'isLastCard')
      .and.returnValues(true, false, false, false, false);
    spyOn(componentInstance, 'returnToExplorationAfterConceptCard');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = true;
    spyOn(questionPlayerStateService.onQuestionSessionCompleted, 'emit');
    spyOn(questionPlayerStateService, 'getQuestionPlayerStateData');

    componentInstance.showUpcomingCard();

    componentInstance.questionSessionCompleted = false;
    componentInstance.moveToExploration = true;
    spyOn(explorationPlayerStateService, 'moveToExploration');

    componentInstance.showUpcomingCard();

    componentInstance.moveToExploration = false;
    let stateCard = new StateCard(
      'stateName', null, null, new Interaction(
        [], [], null, null, [], 'EndExploration', null),
      [], null, '', null);
    stateCard.markAsCompleted();
    componentInstance.displayedCard = stateCard;
    componentInstance.nextCard = stateCard;
    componentInstance.conceptCard = new ConceptCard(
      new SubtitledHtml('', ''), [], null);
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');
    spyOn(playerTranscriptService, 'addNewCard');
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');
    spyOn(contentTranslationLanguageService, 'getCurrentContentLanguageCode')
      .and.returnValue('en');
    spyOn(contentTranslationManagerService, 'displayTranslations');

    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(componentInstance, 'isSupplementalCardNonempty')
      .and.returnValues(false, true);
    spyOn(playerTranscriptService, 'getCard');
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(componentInstance, 'animateToTwoCards').and.callFake((callb) => {
      callb();
    });
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(componentInstance, 'showPendingCard');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(explorationEngineService, 'getAuthorRecommendedExpIdsByStateName')
      .and.returnValue([]);
    spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
      .and.returnValue(true);
    spyOn(userService, 'setReturnUrl');
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId'
    });

    componentInstance.isLoggedIn = false;

    componentInstance.showUpcomingCard();

    componentInstance.conceptCard = null;
    componentInstance.answerIsCorrect = true;

    componentInstance.showUpcomingCard();
  });

  it('should submit answer', fakeAsync(() => {
    componentInstance.answerIsBeingProcessed = true;
    componentInstance.submitAnswer('', null);

    componentInstance.answerIsBeingProcessed = false;
    componentInstance.displayedCard = displayedCard;
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(
      true);
    let explorationModeSpy = spyOn(
      explorationPlayerStateService, 'isPresentingIsolatedQuestions');
    explorationModeSpy.and.returnValue(false);
    componentInstance.isInPreviewMode = false;
    spyOn(fatigueDetectionService, 'recordSubmissionTimestamp');
    spyOn(fatigueDetectionService, 'isSubmittingTooFast').and.returnValues(
      true, false);
    spyOn(fatigueDetectionService, 'displayTakeBreakMessage');
    let lastCardInteraction = interactionObjectFactory.createFromBackendDict({
      id: 'TextInput',
      answer_groups: [],
      default_outcome: null,
      confirmed_unclassified_answers: [],
      customization_args: {
        rows: {
          value: true,
        },
        placeholder: {
          value: 1,
        }
      },
      hints: [],
      solution: null
    });
    let lastCard = StateCard.createNewCard(
      'Card 1', 'Content html', 'Interaction text', lastCardInteraction,
      null, 'content_id', audioTranslationLanguageService);
    spyOn(playerTranscriptService, 'getLastCard').and.returnValue(lastCard);
    spyOn(explorationPlayerStateService.onOppiaFeedbackAvailable, 'emit');
    spyOn(componentInstance, 'showPendingCard');
    componentInstance.submitAnswer('', null);

    spyOn(explorationPlayerStateService, 'isInQuestionMode')
      .and.returnValues(false, false, false, true);
    spyOn(componentInstance, 'initLearnerAnswerInfoService');
    spyOn(explorationEngineService, 'getState');
    spyOn(componentInstance, 'alwaysAskLearnerForAnswerDetails');
    spyOn(numberAttemptsService, 'submitAttempt');
    spyOn(playerTranscriptService, 'addNewInput');
    spyOn(componentInstance, 'getCanAskLearnerForAnswerInfo').and.returnValues(
      true, false);
    spyOn(playerTranscriptService, 'addNewResponse');
    spyOn(learnerAnswerInfoService, 'getSolicitAnswerDetailsQuestion');
    spyOn(playerPositionService.onHelpCardAvailable, 'emit');
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    componentInstance.submitAnswer('', null);
    tick(200);

    spyOn(playerPositionService, 'recordAnswerSubmission');
    spyOn(explorationPlayerStateService, 'getCurrentEngineService')
      .and.returnValue(explorationEngineService);
    spyOn(explorationPlayerStateService, 'getLanguageCode')
      .and.returnValue('en');

    let callback = (
        answer: string, interactionRulesService: InteractionRulesService,
        successCallback: (
        nextCard: StateCard,
        refreshInteraction: boolean,
        feedbackHtml: string,
        feedbackAudioTranslations: BindableVoiceovers,
        refresherExplorationId: string,
        missingPrerequisiteSkillId: string,
        remainOnCurrentCard: boolean,
        taggedSkillMisconceptionId: string,
        wasOldStateInitial: boolean,
        isFirstHit: boolean,
        isFinalQuestion: boolean,
        nextCardIfReallyStuck: StateCard | null,
        focusLabel: string
      ) => void
    ) => {
      let stateCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'EndExploration', null),
        [], null, '', null);
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', '', false, '', true,
        false, true, null, '');
      successCallback(
        stateCard, true, '', null, 'refresherId', '', false, '', true,
        false, true, null, '');
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', '', false, '', true,
        false, false, null, '');
      successCallback(
        stateCard, true, '', null, 'refresherId', '', false, '', true,
        false, false, null, '');
      successCallback(
        stateCard, true, 'feedback', null, '', 'skill_id', true, '', true,
        false, false, null, '');
      explorationModeSpy.and.returnValue(true);
      componentInstance.displayedCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'TextInput', null),
        [], null, '', null);
      spyOn(explorationPlayerStateService, 'isInDiagnosticTestPlayerMode')
        .and.returnValue(true);
      successCallback(
        stateCard, true, 'feedback', null, '', 'skill_id', true, '', true,
        false, false, null, '');
      componentInstance.displayedCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'ImageClickInput', null),
        [], null, '', null);
      explorationModeSpy.and.returnValue(false);
      successCallback(
        stateCard, true, 'feedback', null, 'refresherId', 'skill_id', true,
        '', true, false, false, null, '');
      return false;
    };
    spyOn(answerClassificationService, 'isAnswerOnlyMisspelled').
      and.returnValue(true);
    spyOn(explorationEngineService, 'submitAnswer').and.callFake(callback);
    spyOn(playerPositionService, 'getCurrentStateName')
      .and.returnValue('oldState');
    spyOn(statsReportingService, 'recordStateTransition');
    spyOn(learnerParamsService, 'getAllParams');
    spyOn(statsReportingService, 'recordStateCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
      .and.returnValue(true);
    spyOn(componentInstance, 'showUpcomingCard');
    spyOn(fatigueDetectionService, 'reset');
    spyOn(numberAttemptsService, 'reset');
    spyOn(questionPlayerStateService, 'answerSubmitted');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(playerTranscriptService, 'updateLatestInteractionHtml');
    spyOn(conceptCardBackendApiService, 'loadConceptCardsAsync')
      .and.returnValue(Promise.resolve([
        new ConceptCard(
          new SubtitledHtml('', ''), [], null)
      ]));

    spyOn(
      explorationSummaryBackendApiService,
      'loadPublicExplorationSummariesAsync')
      .and.returnValue(Promise.resolve({
        summaries: [{} as ExplorationSummaryDict]
      }));
    spyOn(
      refresherExplorationConfirmationModalService,
      'displayRedirectConfirmationModal').and.callFake((id, callb) => {
      callb();
    });
    spyOn(statsReportingService, 'recordLeaveForRefresherExp');
    spyOn(playerTranscriptService, 'hasEncounteredStateBefore')
      .and.returnValue(true);
    spyOn(explorationPlayerStateService, 'recordNewCardAdded');

    componentInstance.explorationActuallyStarted = false;

    componentInstance.submitAnswer('', null);
    tick(2000);
  }));

  it('should get recommended summaries when exploration in story chapter mode',
    fakeAsync(() => {
      let alertMessageElement = document.createElement('div');
      alertMessageElement.className =
        'oppia-exploration-checkpoints-message';
      spyOn(explorationPlayerStateService, 'recordNewCardAdded');
      spyOn(focusManagerService, 'setFocusIfOnDesktop');
      spyOn(componentInstance, 'scrollToTop');
      spyOn(playerPositionService.onNewCardOpened, 'emit');
      spyOn(playerTranscriptService, 'addNewCard');
      spyOn(explorationPlayerStateService, 'getLanguageCode')
        .and.returnValue('en');
      spyOn(contentTranslationLanguageService, 'getCurrentContentLanguageCode')
        .and.returnValue('es');
      spyOn(contentTranslationManagerService, 'displayTranslations')
        .and.returnValue();
      spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
      spyOn(componentInstance, 'isSupplementalCardNonempty').and.returnValue(
        false);
      spyOn(playerPositionService, 'setDisplayedCardIndex');
      spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
      spyOn(playerPositionService, 'changeCurrentQuestion');
      spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
      spyOn(explorationEngineService, 'getAuthorRecommendedExpIdsByStateName')
        .and.returnValue([]);
      spyOn(explorationPlayerStateService, 'isInStoryChapterMode')
        .and.returnValue(false);
      spyOn(explorationRecommendationsService, 'getRecommendedSummaryDicts')
        .and.callFake((ids, recommendations, callb) => {
          callb(null);
        });
      spyOn(document, 'querySelector').withArgs(
        '.oppia-exploration-checkpoints-message')
        .and.returnValue(alertMessageElement);

      componentInstance.alertMessageTimeout = 5;

      componentInstance.displayedCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'EndExploration', null),
        [], null, '', null);

      componentInstance.nextCard = displayedCard;
      componentInstance.showPendingCard();
      tick(2000);
    }));

  it('should check whether hacky translations are displayed or not', () => {
    spyOn(i18nLanguageCodeService, 'isHackyTranslationAvailable')
      .and.returnValues(false, true);
    spyOn(i18nLanguageCodeService, 'isCurrentLanguageEnglish')
      .and.returnValues(false, false);

    let expId = 'exp_id';

    let hackyStoryTitleTranslationIsDisplayed =
      componentInstance.isHackyExpTitleTranslationDisplayed(expId);
    expect(hackyStoryTitleTranslationIsDisplayed).toBe(false);
    hackyStoryTitleTranslationIsDisplayed =
      componentInstance.isHackyExpTitleTranslationDisplayed(expId);
    expect(hackyStoryTitleTranslationIsDisplayed).toBe(true);
  });

  it('should get feedback when answer is misspelled', () => {
    spyOn(Math, 'random').and.returnValue(0.45);
    spyOn(translateService, 'instant').and.callThrough();
    expect(
      componentInstance.getFeedbackHtmlWhenAnswerMisspelled())
      .toEqual('I18N_ANSWER_MISSPELLED_RESPONSE_TEXT_1');
  });

  it('should check if current card was completed in a previous session',
    () => {
      let mockStateCard = new StateCard(
        'Temp2', '', '', new Interaction([], [], null, null, [], null, null)
        , [], null, '', null);
      componentInstance.displayedCard = mockStateCard;
      componentInstance.prevSessionStatesProgress = ['Temp1', 'Temp2'];
      expect(componentInstance.isDisplayedCardCompletedInPrevSession()).
        toBeTrue();
      componentInstance.prevSessionStatesProgress = ['Temp1'];
      expect(componentInstance.isDisplayedCardCompletedInPrevSession()).
        toBeFalse();
    }
  );

  it('should tell if progress clearance message is shown or not', () => {
    expect(componentInstance.isProgressClearanceMessageShown()).toBeFalse();

    componentInstance.showProgressClearanceMessage = true;

    expect(componentInstance.isProgressClearanceMessageShown()).toBeTrue();
  });

  it('should update when submit button is enabled', () => {
    componentInstance.submitButtonIsDisabled = false;
    spyOn(componentInstance, 'isSubmitButtonDisabled').and.returnValue(
      !componentInstance.submitButtonIsDisabled);

    componentInstance.ngAfterViewChecked();

    expect(componentInstance.submitButtonIsDisabled).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled).toHaveBeenCalled();
  });

  it(
    'should be able to set appropriate flags for the diagnostic test',
    fakeAsync(() => {
      let collectionId = 'id';
      let expId = 'exp_id';
      let isInPreviewMode = false;
      let isIframed = true;
      let collectionSummary = {
        is_admin: true,
        summaries: [],
        user_email: '',
        is_topic_manager: false,
        username: true
      };
      spyOn(contextService, 'isInExplorationEditorPage').and.returnValue(false);
      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(new UserInfo(
          [], false, false,
          false, false, false, '', '', '', true)));
      spyOn(urlService, 'getCollectionIdFromExplorationUrl')
        .and.returnValues(collectionId, null);
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

      spyOn(readOnlyCollectionBackendApiService, 'loadCollectionAsync')
        .and.returnValue(Promise.resolve(new Collection(
          '', '', '', '', [], null, '', 6, 8, [])));
      spyOn(explorationEngineService, 'getExplorationId')
        .and.returnValue(expId);
      spyOn(explorationEngineService, 'isInPreviewMode')
        .and.returnValue(isInPreviewMode);
      spyOn(urlService, 'isIframed').and.returnValue(isIframed);
      spyOn(loaderService, 'showLoadingScreen');
      spyOn(urlInterpolationService, 'getStaticImageUrl')
        .and.returnValue('oppia_avatar_url');
      spyOn(explorationPlayerStateService, 'isInQuestionPlayerMode')
        .and.returnValues(true, false);
      spyOn(componentInstance, 'initializePage');
      spyOn(collectionPlayerBackendApiService, 'fetchCollectionSummariesAsync')
        .and.returnValue(Promise.resolve(collectionSummary));
      spyOn(questionPlayerStateService, 'hintUsed');
      spyOn(questionPlayerEngineService, 'getCurrentQuestion');
      spyOn(questionPlayerStateService, 'solutionViewed');
      spyOn(imagePreloaderService, 'onStateChange');
      spyOn(componentInstance, 'fetchCompletedChaptersCount');
      spyOn(statsReportingService, 'recordExplorationCompleted');
      spyOn(statsReportingService, 'recordExplorationActuallyStarted');
      spyOn(
        guestCollectionProgressService,
        'recordExplorationCompletedInCollection'
      );
      spyOn(componentInstance, 'doesCollectionAllowsGuestProgress')
        .and.returnValue(true);
      spyOn(statsReportingService, 'recordMaybeLeaveEvent');
      spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
      spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
      spyOn(messengerService, 'sendMessage');
      spyOn(readOnlyExplorationBackendApiService, 'loadLatestExplorationAsync')
        .and.returnValue(Promise.resolve(explorationResponse));
      spyOn(explorationEngineService, 'getShortestPathToState')
        .and.returnValue(['Start', 'Mid']);
      spyOn(
        editableExplorationBackendApiService,
        'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner')
        .and.returnValue(Promise.resolve(
          {unique_progress_url_id: uniqueProgressIdResponse}));

      let mockOnHintConsumed = new EventEmitter();
      let mockOnSolutionViewedEventEmitter = new EventEmitter();
      let mockOnPlayerStateChange = new EventEmitter();

      spyOnProperty(hintsAndSolutionManagerService, 'onHintConsumed')
        .and.returnValue(mockOnHintConsumed);
      spyOnProperty(
        hintsAndSolutionManagerService, 'onSolutionViewedEventEmitter')
        .and.returnValue(mockOnSolutionViewedEventEmitter);
      spyOnProperty(explorationPlayerStateService, 'onPlayerStateChange')
        .and.returnValue(mockOnPlayerStateChange);

      componentInstance.nextCard = new StateCard(
        null, null, null, new Interaction(
          [], [], null, null, [], 'EndExploration', null),
        [], null, '', null);
      componentInstance.isLoggedIn = false;
      componentInstance.hasInteractedAtLeastOnce = true;
      componentInstance.displayedCard = displayedCard;

      expect(componentInstance.feedbackIsEnabled).toBeTrue();
      expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeFalse();
      expect(componentInstance.inputOutputHistoryIsShown).toBeTrue();
      expect(componentInstance.navigationThroughCardHistoryIsEnabled)
        .toBeTrue();
      expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeTrue();
      expect(componentInstance.skipButtonIsShown).toBeFalse();

      const topicIdToPrerequisiteTopicIds = {
        topicId1: [],
        topicId2: ['topicId1'],
        topicId3: ['topicId2']
      };

      componentInstance.diagnosticTestTopicTrackerModel = (
        new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds));
      tick();

      componentInstance.ngOnInit();
      tick(2000);

      expect(componentInstance.feedbackIsEnabled).toBeFalse();
      expect(componentInstance.learnerCanOnlyAttemptQuestionOnce).toBeTrue();
      expect(componentInstance.inputOutputHistoryIsShown).toBeFalse();
      expect(componentInstance.navigationThroughCardHistoryIsEnabled)
        .toBeFalse();
      expect(componentInstance.checkpointCelebrationModalIsEnabled).toBeFalse();
      expect(componentInstance.skipButtonIsShown).toBeTrue();
    }));

  it('should be able to skip the current question', fakeAsync(() => {
    let sampleCard = StateCard.createNewCard(
      'State 2', '<p>Content</p>', '',
      // This throws "Type null is not assignable to type
      // 'string'." We need to suppress this error
      // because of the need to test validations. This
      // throws an error only in the frontend test and
      // not in the frontend.
      // @ts-ignore
      null, null, 'content', audioTranslationLanguageService);

    let callback = (successCallback: (nextCard: StateCard) => void) => {
      successCallback(sampleCard);
    };
    spyOn(explorationPlayerStateService, 'skipCurrentQuestion')
      .and.callFake(callback);
    spyOn(componentInstance, 'showPendingCard');

    componentInstance.skipCurrentQuestion();

    expect(explorationPlayerStateService.skipCurrentQuestion)
      .toHaveBeenCalled();
    expect(componentInstance.showPendingCard).toHaveBeenCalled();
  }));
});
