// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for LearnerAnswerInfoCard
 */

import { NO_ERRORS_SCHEMA } from '@angular/core';
import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { BackgroundMaskService } from 'services/stateful/background-mask.service';
import { ExplorationHtmlFormatterService } from 'services/exploration-html-formatter.service';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { PlayerTranscriptService } from '../services/player-transcript.service';
import { InputResponsePairComponent } from './input-response-pair.component';
import { MockTranslatePipe } from 'tests/unit-test-utils';
import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { RecordedVoiceovers } from 'domain/exploration/recorded-voiceovers.model';
import { StateCard } from 'domain/state_card/state-card.model';
import { InteractionObjectFactory } from 'domain/exploration/InteractionObjectFactory';
import { AudioTranslationLanguageService } from '../services/audio-translation-language.service';
import { AudioTranslationManagerService } from '../services/audio-translation-manager.service';
import { AppConstants } from 'app.constants';
import { AudioPlayerService } from 'services/audio-player.service';
import { ExplorationPlayerConstants } from '../exploration-player-page.constants';
import { I18nLanguageCodeService } from 'services/i18n-language-code.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { NumberConversionService } from 'services/number-conversion.service';

describe('InputResponsePairComponent', () => {
  let component: InputResponsePairComponent;
  let fixture: ComponentFixture<InputResponsePairComponent>;
  let explorationHtmlFormatter: ExplorationHtmlFormatterService;
  let interactionObjectFactory: InteractionObjectFactory;
  let playerTranscriptService: PlayerTranscriptService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let audioTranslationManagerService: AudioTranslationManagerService;
  let audioPlayerService: AudioPlayerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let numberConversionService: NumberConversionService;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule, NgbModule],
      declarations: [
        InputResponsePairComponent,
        MockTranslatePipe
      ],
      providers: [
        BackgroundMaskService
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();
  }));

  beforeEach(() => {
    explorationHtmlFormatter = TestBed.get(ExplorationHtmlFormatterService);
    audioPlayerService = TestBed.get(AudioPlayerService);
    playerTranscriptService = TestBed.get(PlayerTranscriptService);
    interactionObjectFactory = TestBed.get(InteractionObjectFactory);
    autogeneratedAudioPlayerService = TestBed.get(
      AutogeneratedAudioPlayerService);
    audioTranslationManagerService = TestBed.get(
      AudioTranslationManagerService);
    audioTranslationLanguageService = TestBed.get(
      AudioTranslationLanguageService);
    i18nLanguageCodeService = TestBed.get(I18nLanguageCodeService);
    numberConversionService = TestBed.inject(NumberConversionService);
    fixture = TestBed.createComponent(InputResponsePairComponent);
    component = fixture.componentInstance;

    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL').and.returnValue(
      true);

    spyOn(playerTranscriptService, 'getCard')
      .and.returnValue(StateCard.createNewCard(
        'State 2', '<p>Content</p>', '<interaction></interaction>',
        interactionObjectFactory.createFromBackendDict({
          id: 'GraphInput',
          answer_groups: [
            {
              outcome: {
                dest: 'State',
                dest_if_really_stuck: null,
                feedback: {
                  html: '',
                  content_id: 'This is a new feedback text',
                },
                refresher_exploration_id: 'test',
                missing_prerequisite_skill_id: 'test_skill_id',
                labelled_as_correct: true,
                param_changes: [],
              },
              rule_specs: [],
              training_data: [],
              tagged_skill_misconception_id: '',
            },
          ],
          default_outcome: {
            dest: 'Hola',
            dest_if_really_stuck: null,
            feedback: {
              content_id: '',
              html: '',
            },
            labelled_as_correct: true,
            param_changes: [],
            refresher_exploration_id: 'test',
            missing_prerequisite_skill_id: 'test_skill_id',
          },
          confirmed_unclassified_answers: [],
          customization_args: {
            rows: {
              value: true,
            },
            placeholder: {
              value: 1,
            },
            catchMisspellings: {
              value: false
            }
          },
          hints: [],
          solution: {
            answer_is_exclusive: true,
            correct_answer: 'test_answer',
            explanation: {
              content_id: '2',
              html: 'test_explanation1',
            },
          }
        }),
        RecordedVoiceovers.createEmpty(),
        'content', audioTranslationLanguageService
      ));
  });

  it('should check if input response contains video rte element', () => {
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true
    };

    expect(component.isVideoRteElementPresentInResponse()).toBe(true);
  });

  it('should return false if input response does not contain ' +
    'video rte element', () => {
    component.data = {
      learnerInput: '',
      oppiaResponse: null,
      isHint: true
    };

    expect(component.isVideoRteElementPresentInResponse()).toBeFalse();
  });

  it('should get answer html for the displayed card', () => {
    spyOn(explorationHtmlFormatter, 'getAnswerHtml').and.returnValue(
      '<p> HTML Answer </p>'
    );
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true
    };

    expect(component.getAnswerHtml()).toBe('<p> HTML Answer </p>');
  });

  it('should toggle popover when user clicks on it', () => {
    // This throws "Type '{ toggle: () => void; }' is missing the following
    // properties from type 'NgbPopover': _elementRef, _renderer, _ngZone,
    // _document, and 26 more.". We need to suppress this error because we have
    // to only test the toggle function.
    // @ts-expect-error
    component.popover = {
      toggle: () => {}
    };
    spyOn(component.popover, 'toggle');

    component.togglePopover();

    expect(component.popover.toggle).toHaveBeenCalled();
  });

  it('should get a short summary of the answer', () => {
    spyOn(explorationHtmlFormatter, 'getShortAnswerHtml')
      .and.returnValue('Short Answer');
    component.data = {
      // This throws "Type '{ answerDetails: string; }' is not assignable to
      // type 'string'.". We need to suppress this error because we need to
      // store "answerDetails" to test the relevant code. This is done to
      // avoid the lint error "This test should have at least one expectation.".
      // @ts-ignore
      learnerInput: {
        answerDetails: 'Answer Details'
      },
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true
    };

    expect(component.getShortAnswerHtml()).toBe('Answer Details');

    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true
    };

    expect(component.getShortAnswerHtml()).toBe('Short Answer');
  });

  it('should check if the current card is at the end of the transcript', () => {
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);

    expect(component.isCurrentCardAtEndOfTranscript()).toBe(true);
  });

  it('should get the css class for feedback audio highlight', () => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      .and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
    component.isLastPair = false;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');

    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe(
      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS
    );
  });

  it('should return empty css class for feedback audio highlight ' +
    'when audio player service is not playing', () => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      .and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);
    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');
  });

  it('should return empty css class for feedback audio highlight ' +
    'when auto generated audio player service is not playing', () => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      .and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(false);
    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');
  });

  it('should return empty css class for feedback audio highlight ' +
    'when current component name does not match', () => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      .and.returnValue('sample');
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');
  });

  it('should determine if a string is a number', ()=>{
    let number = '-12.4';
    expect(component.isStringifiedNumber(number)).toEqual(true);
    number = 'ab12';
    expect(component.isStringifiedNumber(number)).toEqual(false);
  });

  it('should convert answer to a local format if it is a number', ()=>{
    spyOn(numberConversionService, 'currentDecimalSeparator')
      .and.returnValues(',', '.');

    let number = '12.2';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('12,2');
    number = 'abc';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('abc');
    number = '-12.3';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('-12.3');
  });
});
