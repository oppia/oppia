// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for LearnerAnswerInfoCard
 */

import {NO_ERRORS_SCHEMA} from '@angular/core';
import {async, ComponentFixture, TestBed} from '@angular/core/testing';
import {BackgroundMaskService} from 'services/stateful/background-mask.service';
import {ExplorationHtmlFormatterService} from 'services/exploration-html-formatter.service';
import {HttpClientTestingModule} from '@angular/common/http/testing';
import {PlayerTranscriptService} from '../services/player-transcript.service';
import {InputResponsePairComponent} from './input-response-pair.component';
import {MockTranslatePipe} from 'tests/unit-test-utils';
import {NgbModule, NgbPopover} from '@ng-bootstrap/ng-bootstrap';
import {RecordedVoiceovers} from 'domain/exploration/recorded-voiceovers.model';
import {StateCard} from 'domain/state_card/state-card.model';
import {InteractionObjectFactory} from 'domain/exploration/InteractionObjectFactory';
import {AudioTranslationLanguageService} from '../services/audio-translation-language.service';
import {AudioTranslationManagerService} from '../services/audio-translation-manager.service';
import {AppConstants} from 'app.constants';
import {AudioPlayerService} from 'services/audio-player.service';
import {ExplorationPlayerConstants} from '../exploration-player-page.constants';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';
import {NumberConversionService} from 'services/number-conversion.service';
import {By} from '@angular/platform-browser';
import {PlatformFeatureService} from 'services/platform-feature.service';
import {VoiceoverPlayerService} from '../services/voiceover-player.service';

class MockPlatformFeatureService {
  get status(): object {
    return {
      EnableVoiceoverContribution: {
        isEnabled: false,
      },
      AddVoiceoverWithAccent: {
        isEnabled: false,
      },
    };
  }
}

describe('InputResponsePairComponent', () => {
  let component: InputResponsePairComponent;
  let fixture: ComponentFixture<InputResponsePairComponent>;
  let explorationHtmlFormatter: ExplorationHtmlFormatterService;
  let interactionObjectFactory: InteractionObjectFactory;
  let playerTranscriptService: PlayerTranscriptService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let audioTranslationManagerService: AudioTranslationManagerService;
  let audioPlayerService: AudioPlayerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let numberConversionService: NumberConversionService;
  let voiceoverPlayerService: VoiceoverPlayerService;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule, NgbModule],
      declarations: [InputResponsePairComponent, MockTranslatePipe],
      providers: [
        BackgroundMaskService,
        {
          provide: PlatformFeatureService,
          useClass: MockPlatformFeatureService,
        },
        NgbPopover,
      ],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    explorationHtmlFormatter = TestBed.get(ExplorationHtmlFormatterService);
    audioPlayerService = TestBed.get(AudioPlayerService);
    playerTranscriptService = TestBed.get(PlayerTranscriptService);
    interactionObjectFactory = TestBed.get(InteractionObjectFactory);
    autogeneratedAudioPlayerService = TestBed.get(
      AutogeneratedAudioPlayerService
    );
    audioTranslationManagerService = TestBed.get(
      AudioTranslationManagerService
    );
    audioTranslationLanguageService = TestBed.get(
      AudioTranslationLanguageService
    );
    i18nLanguageCodeService = TestBed.get(I18nLanguageCodeService);
    numberConversionService = TestBed.inject(NumberConversionService);
    voiceoverPlayerService = TestBed.inject(VoiceoverPlayerService);
    fixture = TestBed.createComponent(InputResponsePairComponent);
    component = fixture.componentInstance;

    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL').and.returnValue(
      true
    );

    spyOn(playerTranscriptService, 'getCard').and.returnValue(
      StateCard.createNewCard(
        'State 2',
        '<p>Content</p>',
        '<interaction></interaction>',
        interactionObjectFactory.createFromBackendDict({
          id: 'GraphInput',
          answer_groups: [
            {
              outcome: {
                dest: 'State',
                dest_if_really_stuck: null,
                feedback: {
                  html: '',
                  content_id: 'This is a new feedback text',
                },
                refresher_exploration_id: 'test',
                missing_prerequisite_skill_id: 'test_skill_id',
                labelled_as_correct: true,
                param_changes: [],
              },
              rule_specs: [],
              training_data: [],
              tagged_skill_misconception_id: '',
            },
          ],
          default_outcome: {
            dest: 'Hola',
            dest_if_really_stuck: null,
            feedback: {
              content_id: '',
              html: '',
            },
            labelled_as_correct: true,
            param_changes: [],
            refresher_exploration_id: 'test',
            missing_prerequisite_skill_id: 'test_skill_id',
          },
          confirmed_unclassified_answers: [],
          customization_args: {
            rows: {
              value: true,
            },
            placeholder: {
              value: 1,
            },
            catchMisspellings: {
              value: false,
            },
          },
          hints: [],
          solution: {
            answer_is_exclusive: true,
            correct_answer: 'test_answer',
            explanation: {
              content_id: '2',
              html: 'test_explanation1',
            },
          },
        }),
        RecordedVoiceovers.createEmpty(),
        'content',
        audioTranslationLanguageService
      )
    );
  });

  it('should check if input response contains video rte element', () => {
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.isVideoRteElementPresentInResponse()).toBe(true);
  });

  it(
    'should return false if input response does not contain ' +
      'video rte element',
    () => {
      component.data = {
        learnerInput: '',
        oppiaResponse: null,
        isHint: true,
      };

      expect(component.isVideoRteElementPresentInResponse()).toBeFalse();
    }
  );

  it('should get answer html for the displayed card', () => {
    spyOn(explorationHtmlFormatter, 'getAnswerHtml').and.returnValue(
      '<p> HTML Answer </p>'
    );
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getAnswerHtml()).toBe('<p> HTML Answer </p>');
  });

  it('should toggle popover when user clicks on it', () => {
    // This throws "Type '{ toggle: () => void; }' is missing the following
    // properties from type 'NgbPopover': _elementRef, _renderer, _ngZone,
    // _document, and 26 more.". We need to suppress this error because we have
    // to only test the toggle function.
    // @ts-expect-error
    component.popover = {
      toggle: () => {},
    };
    spyOn(component.popover, 'toggle');

    component.togglePopover();

    expect(component.popover.toggle).toHaveBeenCalled();
  });

  it('should get a short summary of the answer', () => {
    spyOn(explorationHtmlFormatter, 'getShortAnswerHtml').and.returnValue(
      'Short Answer'
    );
    component.data = {
      // This throws "Type '{ answerDetails: string; }' is not assignable to
      // type 'string'.". We need to suppress this error because we need to
      // store "answerDetails" to test the relevant code. This is done to
      // avoid the lint error "This test should have at least one expectation.".
      // @ts-ignore
      learnerInput: {
        answerDetails: 'Answer Details',
      },
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getShortAnswerHtml()).toBe('Answer Details');

    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getShortAnswerHtml()).toBe('Short Answer');
  });

  it('should check if the current card is at the end of the transcript', () => {
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);

    expect(component.isCurrentCardAtEndOfTranscript()).toBe(true);
  });

  it('should get the css class for feedback audio highlight', () => {
    spyOn(
      audioTranslationManagerService,
      'getCurrentComponentName'
    ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
    component.isLastPair = false;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');

    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe(
      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS
    );

    spyOn(
      component,
      'isVoiceoverContributionWithAccentEnabled'
    ).and.returnValue(true);
    spyOn(voiceoverPlayerService, 'getActiveComponentName').and.returnValue(
      AppConstants.COMPONENT_NAME_FEEDBACK
    );
    expect(component.getFeedbackAudioHighlightClass()).toBe(
      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS
    );
  });

  it(
    'should return empty css class for feedback audio highlight ' +
      'when audio player service is not playing',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
      spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it(
    'should return empty css class for feedback audio highlight ' +
      'when auto generated audio player service is not playing',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
      spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(
        false
      );
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it(
    'should return empty css class for feedback audio highlight ' +
      'when current component name does not match',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue('sample');
      spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it('should determine if a string is a number', () => {
    let number = '-12.4';
    expect(component.isStringifiedNumber(number)).toEqual(true);
    number = 'ab12';
    expect(component.isStringifiedNumber(number)).toEqual(false);
  });

  it('should convert answer to a local format if it is a number', () => {
    spyOn(numberConversionService, 'currentDecimalSeparator').and.returnValues(
      ',',
      '.'
    );

    let number = '12.2';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('12,2');
    number = 'abc';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('abc');
    number = '-12.3';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('-12.3');
  });

  it('should open popup when clicking on oppia-interaction-display', () => {
    spyOn(explorationHtmlFormatter, 'getAnswerHtml').and.returnValue(
      '<p> HTML Answer </p>'
    );
    spyOn(explorationHtmlFormatter, 'getShortAnswerHtml').and.returnValue(
      'Short Answer'
    );

    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: false,
    };

    fixture.detectChanges();

    let oppiaInteractionDisplay = fixture.debugElement.query(
      By.css('.oppia-popover')
    );

    spyOn(component.popover, 'toggle');

    oppiaInteractionDisplay.nativeElement.click();

    expect(component.popover.toggle).toHaveBeenCalled();
  });

  it('should verify that the popup content its not null', () => {
    spyOn(explorationHtmlFormatter, 'getAnswerHtml').and.returnValue(
      '<p> HTML Answer </p>'
    );

    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: false,
    };

    fixture.detectChanges();

    expect(document.querySelector('ngb-popover-window')).not.toBeTruthy();

    const popover = fixture.debugElement
      .query(By.directive(NgbPopover))
      .injector.get(NgbPopover);
    expect(popover).toBeTruthy();
    popover.toggle();

    fixture.detectChanges();

    expect(document.querySelector('ngb-popover-window')).toBeTruthy();

    const popoverContent = document.querySelector(
      '.oppia-answer-popup oppia-interaction-display'
    );
    expect(popoverContent).toBeTruthy();
  });
});
