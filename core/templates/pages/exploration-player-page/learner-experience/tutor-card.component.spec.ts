// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the Tutor Card Component.
 */

import { SimpleChanges } from '@angular/core';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { NO_ERRORS_SCHEMA, EventEmitter } from '@angular/core';
import { ComponentFixture, fakeAsync, TestBed, tick, waitForAsync, flush } from '@angular/core/testing';
import { TranslateService } from '@ngx-translate/core';
import { AppConstants } from 'app.constants';
import { Interaction } from 'domain/exploration/InteractionObjectFactory';
import { StateCard } from 'domain/state_card/state-card.model';
import { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';
import { AudioBarStatusService } from 'services/audio-bar-status.service';
import { AudioPlayerService } from 'services/audio-player.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { ContextService } from 'services/context.service';
import { DeviceInfoService } from 'services/contextual/device-info.service';
import { UrlService } from 'services/contextual/url.service';
import { WindowDimensionsService } from 'services/contextual/window-dimensions.service';
import { WindowRef } from 'services/contextual/window-ref.service';
import { UserService } from 'services/user.service';
import { MockTranslatePipe } from 'tests/unit-test-utils';
import { ExplorationPlayerConstants } from '../exploration-player-page.constants';
import { AudioPreloaderService } from '../services/audio-preloader.service';
import { AudioTranslationManagerService } from '../services/audio-translation-manager.service';
import { CurrentInteractionService } from '../services/current-interaction.service';
import { ExplorationPlayerStateService } from '../services/exploration-player-state.service';
import { LearnerAnswerInfoService } from '../services/learner-answer-info.service';
import { PlayerPositionService } from '../services/player-position.service';
import { TutorCardComponent } from './tutor-card.component';
import { I18nLanguageCodeService } from 'services/i18n-language-code.service';
import { EndChapterCheckMarkComponent } from './end-chapter-check-mark.component';
import { EndChapterConfettiComponent } from './end-chapter-confetti.component';
import { PlatformFeatureService } from 'services/platform-feature.service';
import { InteractionCustomizationArgs } from 'interactions/customization-args-defs';
import { UserInfo } from 'domain/user/user-info.model';
import { FeatureStatusChecker } from 'domain/feature-flag/feature-status-summary.model';

class MockWindowRef {
  nativeWindow = {
    location: {
      hash: '',
      pathname: '/path/name'
    },
    matchMedia: function(query: string) {
      return {
        matches: false
      };
    }
  };
}

class MockPlatformFeatureService {
  get status(): object {
    return {
      EndChapterCelebration: {
        isEnabled: true
      }
    };
  }
}

class MockTranslateService {
  onLangChange: EventEmitter<string> = new EventEmitter();
  instant(key: string, interpolateParams?: Object): string {
    return key;
  }
}

describe('Tutor card component', () => {
  let fixture: ComponentFixture<TutorCardComponent>;
  let componentInstance: TutorCardComponent;

  let audioBarStatusService: AudioBarStatusService;
  let audioPlayerService: AudioPlayerService;
  let audioPreloaderService: AudioPreloaderService;
  let audioTranslationManagerService: AudioTranslationManagerService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let contextService: ContextService;
  let currentInteractionService: CurrentInteractionService;
  let deviceInfoService: DeviceInfoService;
  let explorationPlayerStateService: ExplorationPlayerStateService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let playerPositionService: PlayerPositionService;
  let urlInterpolationService: UrlInterpolationService;
  let urlService: UrlService;
  let userService: UserService;
  let windowDimensionsService: WindowDimensionsService;
  let windowRef: WindowRef;
  let platformFeatureService: PlatformFeatureService;
  let translateService: TranslateService;

  let mockDisplayedCard = new StateCard(
    '', '', '', new Interaction(
      [], [], {} as InteractionCustomizationArgs, null, [], 'EndExploration',
      // This throws "Argument of type 'null' is not assignable to parameter of
      // type 'RecordedVoiceovers'." We need to suppress this error because of
      // the need to test validations. This throws an error only in the
      // frontend tests and not in the frontend.
      // @ts-ignore
      null), [], null, '', null);

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [
        HttpClientTestingModule
      ],
      declarations: [
        TutorCardComponent,
        MockTranslatePipe
      ],
      providers: [
        AudioBarStatusService,
        AudioPlayerService,
        AudioPreloaderService,
        AudioTranslationManagerService,
        AutogeneratedAudioPlayerService,
        ContextService,
        CurrentInteractionService,
        DeviceInfoService,
        ExplorationPlayerStateService,
        LearnerAnswerInfoService,
        PlayerPositionService,
        UrlInterpolationService,
        UrlService,
        UserService,
        WindowDimensionsService,
        {
          provide: WindowRef,
          useClass: MockWindowRef
        },
        {
          provide: PlatformFeatureService,
          useClass: MockPlatformFeatureService
        },
        {
          provide: TranslateService,
          useClass: MockTranslateService
        }
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(TutorCardComponent);
    componentInstance = fixture.componentInstance;
    audioBarStatusService = TestBed.inject(AudioBarStatusService);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    audioPreloaderService = TestBed.inject(AudioPreloaderService);
    audioTranslationManagerService = TestBed.inject(
      AudioTranslationManagerService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService);
    contextService = TestBed.inject(ContextService);
    currentInteractionService = TestBed.inject(CurrentInteractionService);
    deviceInfoService = TestBed.inject(DeviceInfoService);
    explorationPlayerStateService = TestBed.inject(
      ExplorationPlayerStateService);
    playerPositionService = TestBed.inject(PlayerPositionService);
    urlInterpolationService = TestBed.inject(UrlInterpolationService);
    urlService = TestBed.inject(UrlService);
    userService = TestBed.inject(UserService);
    windowDimensionsService = TestBed.inject(WindowDimensionsService);
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    windowRef = TestBed.inject(WindowRef);
    platformFeatureService = TestBed.inject(PlatformFeatureService);
    translateService = TestBed.inject(TranslateService);

    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL').and.returnValue(
      true);
    spyOn(userService, 'getProfileImageDataUrl').and.returnValue(
      ['default-image-url-png', 'default-image-url-webp']);
  });

  afterEach(() => {
    componentInstance.ngOnDestroy();
  });

  it('should initialize', fakeAsync(() => {
    const sampleUserInfoBackendObject = {
      roles: ['USER_ROLE'],
      is_moderator: false,
      is_curriculum_admin: false,
      is_super_admin: false,
      is_topic_manager: false,
      can_create_collections: true,
      preferred_site_language_code: null,
      username: 'tester',
      email: 'test@test.com',
      user_is_logged_in: true
    };
    const sampleUserInfo = UserInfo.createFromBackendDict(
      sampleUserInfoBackendObject);
    let mockOnActiveCardChangedEventEmitter = new EventEmitter<void>();
    let mockOnOppiaFeedbackAvailableEventEmitter = new EventEmitter<void>();
    let isIframed = false;

    spyOn(contextService, 'isInExplorationEditorPage').and.returnValues(
      true, false);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(deviceInfoService, 'isMobileDevice').and.returnValue(true);
    spyOn(audioBarStatusService, 'isAudioBarExpanded').and.returnValue(true);
    spyOn(urlInterpolationService, 'getStaticImageUrl')
      .and.returnValues('avatar_url', 'profile_url', 'default image path');
    spyOn(componentInstance, 'updateDisplayedCard');
    spyOnProperty(playerPositionService, 'onActiveCardChanged').and.returnValue(
      mockOnActiveCardChangedEventEmitter);
    spyOnProperty(explorationPlayerStateService, 'onOppiaFeedbackAvailable')
      .and.returnValue(mockOnOppiaFeedbackAvailableEventEmitter);
    spyOn(componentInstance, 'getInputResponsePairId').and.returnValue('hash');
    componentInstance.displayedCard = mockDisplayedCard;
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(sampleUserInfo));

    componentInstance.ngOnInit();
    componentInstance.isAudioBarExpandedOnMobileDevice();
    mockOnOppiaFeedbackAvailableEventEmitter.emit();
    mockOnActiveCardChangedEventEmitter.emit();
    tick();
    tick();

    componentInstance.ngOnInit();
    tick();
    tick();
    expect(componentInstance.profilePicturePngDataUrl).toEqual(
      'default-image-url-png');
    expect(componentInstance.profilePictureWebpDataUrl).toEqual(
      'default-image-url-webp');

    expect(componentInstance.isIframed).toEqual(isIframed);
    expect(contextService.isInExplorationEditorPage).toHaveBeenCalled();
    expect(urlService.isIframed).toHaveBeenCalled();
    expect(deviceInfoService.isMobileDevice).toHaveBeenCalled();
    expect(audioBarStatusService.isAudioBarExpanded).toHaveBeenCalled();
    expect(urlInterpolationService.getStaticImageUrl).toHaveBeenCalled();
    expect(componentInstance.getInputResponsePairId).toHaveBeenCalled();
  }));

  it('should set default profile pictures when username is null',
    fakeAsync(() => {
      spyOn(componentInstance, 'updateDisplayedCard');
      let userInfo = {
        isLoggedIn: () => true,
        getUsername: () => null
      };

      spyOn(userService, 'getUserInfoAsync')
        .and.resolveTo(userInfo as UserInfo);

      componentInstance.ngOnInit();
      tick();

      expect(componentInstance.profilePicturePngDataUrl).toBe(
        urlInterpolationService.getStaticImageUrl(
          AppConstants.DEFAULT_PROFILE_IMAGE_PNG_PATH));
      expect(componentInstance.profilePictureWebpDataUrl).toBe(
        urlInterpolationService.getStaticImageUrl(
          AppConstants.DEFAULT_PROFILE_IMAGE_WEBP_PATH));
    }));

  it('should refresh displayed card on changes', fakeAsync(() => {
    let updateDisplayedCardSpy = spyOn(
      componentInstance, 'updateDisplayedCard');
    spyOn(componentInstance, 'isOnTerminalCard');
    const changes: SimpleChanges = {
      displayedCard: {
        previousValue: false,
        currentValue: true,
        firstChange: false,
        isFirstChange: () => false,
      }
    };
    componentInstance.ngOnChanges(changes);
    expect(updateDisplayedCardSpy).toHaveBeenCalled();
    expect(componentInstance.isOnTerminalCard).toHaveBeenCalled();
  }));

  it('should trigger celebratory animation if on the last card of a chapter',
    fakeAsync(() => {
      spyOn(componentInstance, 'updateDisplayedCard');
      spyOn(componentInstance, 'isOnTerminalCard').and.returnValue(true);
      spyOn(componentInstance, 'triggerCelebratoryAnimation');
      componentInstance.animationHasPlayedOnce = false;
      componentInstance.inStoryMode = true;
      const changes: SimpleChanges = {
        displayedCard: {
          previousValue: false,
          currentValue: true,
          firstChange: false,
          isFirstChange: () => false
        }
      };

      componentInstance.ngOnChanges(changes);

      expect(componentInstance.updateDisplayedCard).toHaveBeenCalled();
      expect(componentInstance.triggerCelebratoryAnimation).toHaveBeenCalled();
    }));

  it('should not trigger celebratory animation if the feature is not enabled',
    () => {
      spyOn(componentInstance, 'updateDisplayedCard');
      spyOn(componentInstance, 'isOnTerminalCard').and.returnValue(true);
      spyOnProperty(platformFeatureService, 'status', 'get').and.returnValue(
        {
          EndChapterCelebration: {
            isEnabled: false
          }
        } as FeatureStatusChecker
      );
      spyOn(componentInstance, 'triggerCelebratoryAnimation');
      componentInstance.animationHasPlayedOnce = false;
      componentInstance.inStoryMode = true;
      const changes: SimpleChanges = {
        displayedCard: {
          previousValue: false,
          currentValue: true,
          firstChange: false,
          isFirstChange: () => false
        }
      };

      componentInstance.ngOnChanges(changes);

      expect(componentInstance.updateDisplayedCard).toHaveBeenCalled();
      expect(
        componentInstance.triggerCelebratoryAnimation).not.toHaveBeenCalled();
    });

  it('should not trigger celebratory animation if not in story mode',
    fakeAsync(() => {
      spyOn(componentInstance, 'updateDisplayedCard');
      spyOn(componentInstance, 'isOnTerminalCard').and.returnValue(true);
      spyOn(componentInstance, 'triggerCelebratoryAnimation');
      componentInstance.animationHasPlayedOnce = false;
      componentInstance.inStoryMode = false;
      const changes: SimpleChanges = {
        displayedCard: {
          previousValue: false,
          currentValue: true,
          firstChange: false,
          isFirstChange: () => false
        }
      };

      componentInstance.ngOnChanges(changes);

      expect(componentInstance.updateDisplayedCard).toHaveBeenCalled();
      expect(
        componentInstance.triggerCelebratoryAnimation).not.toHaveBeenCalled();
    }));

  it('should animate the check mark and the confetti ' +
      'if animations are enabled', fakeAsync(() => {
    expect(componentInstance.checkMarkHidden).toBe(true);
    expect(componentInstance.animationHasPlayedOnce).toBe(false);
    expect(componentInstance.checkMarkSkipped).toBe(false);

    spyOn(windowRef.nativeWindow, 'matchMedia').and.callThrough();
    componentInstance.checkMarkComponent =
      jasmine.createSpyObj<EndChapterCheckMarkComponent>(
        'EndChapterCheckMarkComponent', ['animateCheckMark']);
    componentInstance.confettiComponent =
      jasmine.createSpyObj<EndChapterConfettiComponent>(
        'EndChapterConfettiComponent', ['animateConfetti']);

    componentInstance.triggerCelebratoryAnimation();

    tick(1);
    expect(componentInstance.checkMarkComponent.animateCheckMark)
      .toHaveBeenCalled();
    expect(componentInstance.animationHasPlayedOnce).toBe(true);

    tick(2000);
    expect(componentInstance.confettiComponent.animateConfetti)
      .toHaveBeenCalled();

    tick(4000);
    expect(componentInstance.checkMarkHidden).toBe(true);
  }));

  it('should not animate the confetti if animations ' +
      'are not enabled', fakeAsync(() => {
    expect(componentInstance.checkMarkHidden).toBe(true);
    expect(componentInstance.animationHasPlayedOnce).toBe(false);
    expect(componentInstance.checkMarkSkipped).toBe(false);

    spyOn(windowRef.nativeWindow, 'matchMedia').and.returnValue({
      matches: true,
      media: 'prefers-reduced-motion',
      addListener: () => {},
      removeListener: () => {},
      addEventListener: () => {},
      removeEventListener: () => {},
      onchange: () => {},
      dispatchEvent: (ev: Event) => true
    });
    componentInstance.checkMarkComponent =
      jasmine.createSpyObj<EndChapterCheckMarkComponent>(
        'EndChapterCheckMarkComponent', ['animateCheckMark']);
    componentInstance.confettiComponent =
      jasmine.createSpyObj<EndChapterConfettiComponent>(
        'EndChapterConfettiComponent', ['animateConfetti']);

    componentInstance.triggerCelebratoryAnimation();

    tick(1);
    expect(componentInstance.checkMarkComponent.animateCheckMark)
      .toHaveBeenCalled();
    expect(componentInstance.animationHasPlayedOnce).toBe(true);

    tick(2000);
    expect(componentInstance.confettiComponent.animateConfetti)
      .not.toHaveBeenCalled();

    tick(500);
    expect(componentInstance.checkMarkHidden).toBe(true);
  }));

  it('should skip animation when a click is made onscreen', fakeAsync(() => {
    expect(componentInstance.checkMarkSkipped).toBe(false);

    spyOn(window, 'clearTimeout');
    componentInstance.checkMarkComponent =
      jasmine.createSpyObj<EndChapterCheckMarkComponent>(
        'EndChapterCheckMarkComponent', ['animateCheckMark']);
    componentInstance.confettiComponent =
      jasmine.createSpyObj<EndChapterConfettiComponent>(
        'EndChapterConfettiComponent', ['animateConfetti']);
    componentInstance.triggerCelebratoryAnimation();
    let fakeClickEvent = new MouseEvent('click');
    document.dispatchEvent(fakeClickEvent);

    tick(1);
    expect(clearTimeout).toHaveBeenCalled();
    expect(componentInstance.checkMarkSkipped).toBe(true);
    tick(500);
    expect(componentInstance.checkMarkHidden).toBe(true);

    flush();
  }));

  it('should not skip animation if it hasn\'t been triggered yet',
    fakeAsync(() => {
      let fakeClickEvent = new MouseEvent('click');
      document.dispatchEvent(fakeClickEvent);

      expect(componentInstance.checkMarkSkipped).toBe(false);
    }));

  it('should correctly generate the milestone message', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = true;
    componentInstance.completedChaptersCount = 1;
    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();
    spyOn(translateService, 'instant').and.callThrough();

    expect(componentInstance.generateMilestoneMessage()).toBe(
      'I18N_END_CHAPTER_MILESTONE_MESSAGE_1');
    expect(translateService.instant).toHaveBeenCalledWith(
      'I18N_END_CHAPTER_MILESTONE_MESSAGE_1');

    componentInstance.completedChaptersCount = 5;

    expect(componentInstance.generateMilestoneMessage()).toBe(
      'I18N_END_CHAPTER_MILESTONE_MESSAGE_2');
    expect(translateService.instant).toHaveBeenCalledWith(
      'I18N_END_CHAPTER_MILESTONE_MESSAGE_2');
  });

  it('should generate an empty message if the milestone is not to be displayed',
    () => {
      componentInstance.inStoryMode = true;
      componentInstance.completedChaptersCount = 1;
      componentInstance.milestoneMessageIsToBeDisplayed = false;
      spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();
      spyOn(translateService, 'instant').and.callThrough();

      expect(componentInstance.generateMilestoneMessage()).toBe('');
      expect(translateService.instant).not.toHaveBeenCalled();
    });

  it('should generate an empty message if not in story mode', () => {
    componentInstance.inStoryMode = false;
    componentInstance.milestoneMessageIsToBeDisplayed = true;
    componentInstance.completedChaptersCount = 1;
    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();
    spyOn(translateService, 'instant').and.callThrough();

    expect(componentInstance.generateMilestoneMessage()).toBe('');
    expect(translateService.instant).not.toHaveBeenCalled();
  });

  it('should generate an empty message if completed chapters count ' +
  'is not eligible for a milestone', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = true;
    componentInstance.completedChaptersCount = 2;
    spyOn(componentInstance, 'generateMilestoneMessage').and.callThrough();
    spyOn(translateService, 'instant').and.callThrough();

    expect(componentInstance.generateMilestoneMessage()).toBe('');
    expect(translateService.instant).not.toHaveBeenCalled();
  });

  it('should correctly show milestone progress bar', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = false;
    componentInstance.completedChaptersCount = 2;
    spyOn(componentInstance, 'setNextMilestoneAndCheckIfProgressBarIsShown')
      .and.callThrough();

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(true);
    expect(componentInstance.nextMilestoneChapterCount).toBe(5);

    componentInstance.completedChaptersCount = 4;

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(true);
    expect(componentInstance.nextMilestoneChapterCount).toBe(5);

    spyOn(componentInstance, 'isCompletedChaptersCountGreaterThanLastMilestone')
      .and.returnValue(false);
    spyOn(
      componentInstance, 'isMilestoneReachedAndMilestoneMessageToBeDisplayed')
      .and.returnValue(false);
    componentInstance.completedChaptersCount = 55;
    componentInstance.milestoneMessageIsToBeDisplayed = true;

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(false);
  });

  it('should not show milestone progress bar if completed chapters count ' +
    'is greater than 50', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = false;
    componentInstance.completedChaptersCount = 51;
    spyOn(componentInstance, 'setNextMilestoneAndCheckIfProgressBarIsShown')
      .and.callThrough();

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(false);
    expect(componentInstance.nextMilestoneChapterCount).toBeNull();
  });

  it('should not show milestone progress bar if not in story mode', () => {
    componentInstance.inStoryMode = false;
    componentInstance.milestoneMessageIsToBeDisplayed = false;
    componentInstance.completedChaptersCount = 1;
    spyOn(componentInstance, 'setNextMilestoneAndCheckIfProgressBarIsShown')
      .and.callThrough();

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(false);
    expect(componentInstance.nextMilestoneChapterCount).toBeNull();
  });

  it('should not show milestone progress bar if milestone message is to be ' +
    'displayed, and completed chapters count is a milestone', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = true;
    componentInstance.completedChaptersCount = 1;
    spyOn(componentInstance, 'setNextMilestoneAndCheckIfProgressBarIsShown')
      .and.callThrough();

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(false);
    expect(componentInstance.nextMilestoneChapterCount).toBeNull();
  });

  it('should show milestone progress bar even if the completed chapters count' +
    ' is a milestone, if the milestone message is not to be displayed', () => {
    componentInstance.inStoryMode = true;
    componentInstance.milestoneMessageIsToBeDisplayed = false;
    componentInstance.completedChaptersCount = 10;
    spyOn(componentInstance, 'setNextMilestoneAndCheckIfProgressBarIsShown')
      .and.callThrough();

    expect(componentInstance.setNextMilestoneAndCheckIfProgressBarIsShown())
      .toBe(true);
    expect(componentInstance.nextMilestoneChapterCount).toBe(25);
  });

  it('should correctly determine if new milestone is reached and message is ' +
  'to be displayed', () => {
    componentInstance.milestoneMessageIsToBeDisplayed = true;
    componentInstance.completedChaptersCount = 1;

    expect(
      componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed())
      .toBe(true);

    componentInstance.completedChaptersCount = 2;

    expect(
      componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed())
      .toBe(false);

    componentInstance.milestoneMessageIsToBeDisplayed = false;
    componentInstance.completedChaptersCount = 1;

    expect(
      componentInstance.isMilestoneReachedAndMilestoneMessageToBeDisplayed())
      .toBe(false);
  });

  it('should correctly determine if completed chapters count is greater than ' +
  'last milestone', () => {
    componentInstance.completedChaptersCount = 1;

    expect(componentInstance.isCompletedChaptersCountGreaterThanLastMilestone())
      .toBe(false);

    componentInstance.completedChaptersCount = 51;

    expect(componentInstance.isCompletedChaptersCountGreaterThanLastMilestone())
      .toBe(true);
  });

  it('should update displayed card', fakeAsync(() => {
    mockDisplayedCard.markAsCompleted();
    componentInstance.displayedCard = mockDisplayedCard;
    let mockOnNewCardAvailableEventEmitter = new EventEmitter<void>();

    spyOnProperty(playerPositionService, 'onNewCardAvailable').and.returnValue(
      mockOnNewCardAvailableEventEmitter);
    spyOn(currentInteractionService, 'registerPresubmitHook')
      .and.callFake(callb => callb());
    spyOn(audioTranslationManagerService, 'clearSecondaryAudioTranslations');
    spyOn(audioTranslationManagerService, 'setContentAudioTranslations');
    spyOn(audioPlayerService, 'clear');
    spyOn(audioPreloaderService, 'clearMostRecentlyRequestedAudioFilename');
    spyOn(autogeneratedAudioPlayerService, 'cancel');

    componentInstance.updateDisplayedCard();
    mockOnNewCardAvailableEventEmitter.emit();
    tick();

    expect(audioTranslationManagerService.clearSecondaryAudioTranslations)
      .toHaveBeenCalled();
    expect(audioTranslationManagerService.setContentAudioTranslations)
      .toHaveBeenCalled();
    expect(audioPlayerService.clear).toHaveBeenCalled();
    expect(audioPreloaderService.clearMostRecentlyRequestedAudioFilename)
      .toHaveBeenCalled();
    expect(autogeneratedAudioPlayerService.cancel).toHaveBeenCalled();
  }));

  it('should get the static image url from the image path', () => {
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      '/assets/images/general/milestone-message-star-icon.svg');

    expect(componentInstance.getStaticImageUrl(
      '/general/milestone-message-star-icon.svg')).toBe(
      '/assets/images/general/milestone-message-star-icon.svg');
    expect(urlInterpolationService.getStaticImageUrl)
      .toHaveBeenCalledWith('/general/milestone-message-star-icon.svg');
  });

  it('should tell if audio bar is expanded on mobile device', () => {
    spyOn(deviceInfoService, 'isMobileDevice').and.returnValue(true);
    spyOn(audioBarStatusService, 'isAudioBarExpanded').and.returnValue(true);
    expect(componentInstance.isAudioBarExpandedOnMobileDevice()).toBeTrue();
  });

  it('should update displayed card', fakeAsync(() => {
    componentInstance.displayedCard = mockDisplayedCard;
    let mockOnNewCardAvailableEventEmitter = new EventEmitter<void>();
    spyOnProperty(playerPositionService, 'onNewCardAvailable').and.returnValue(
      mockOnNewCardAvailableEventEmitter);
    mockOnNewCardAvailableEventEmitter.emit();
    spyOn(currentInteractionService, 'registerPresubmitHook')
      .and.callFake(callb => callb());
    spyOn(mockDisplayedCard, 'getInteraction').and.returnValue(
      // This throws "Type 'null' is not assignable to type
      // 'InteractionCustomizationArgs'." We need to suppress this error
      // because of the need to test validations. This throws an error
      // because the value of interaction is null.
      // @ts-ignore
      new Interaction([], [], null, null, [], '', null));
    spyOn(mockDisplayedCard, 'isCompleted').and.returnValue(true);
    spyOn(audioTranslationManagerService, 'setContentAudioTranslations');
    spyOn(audioPlayerService, 'clear');
    spyOn(audioPreloaderService, 'clearMostRecentlyRequestedAudioFilename');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
  }));

  it('should get RTL language status correctly', () => {
    expect(componentInstance.isLanguageRTL()).toEqual(true);
  });

  it('should check if interaction is inline', () => {
    componentInstance.conceptCardIsBeingShown = true;
    componentInstance.displayedCard = mockDisplayedCard;
    expect(componentInstance.isInteractionInline()).toBeTrue();
    componentInstance.conceptCardIsBeingShown = false;
    spyOn(mockDisplayedCard, 'isInteractionInline').and.returnValue(false);
    componentInstance.displayedCard = mockDisplayedCard;
    expect(componentInstance.isInteractionInline()).toBeFalse();
  });

  it('should get content audio highlight class', () => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      .and.returnValue(AppConstants.COMPONENT_NAME_CONTENT);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);
    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(true);
    expect(componentInstance.getContentAudioHighlightClass()).toEqual(
      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS);
  });

  it('should throw error if background image are empty', fakeAsync(() => {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName')
      // This throws "Argument of type 'null' is not assignable to parameter of
      // type 'String'." We need to suppress this error because of
      // the need to test validations. This throws an error because the
      // value of interaction is null.
      // @ts-ignore
      .and.returnValue(null);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);
    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(false);
    expect(componentInstance.getContentAudioHighlightClass()).toBeNull();
  }));

  it('should get content focus label', () => {
    expect(componentInstance.getContentFocusLabel(1)).toEqual(
      ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + 1);
  });

  it('should toggle show previous responses', () => {
    componentInstance.arePreviousResponsesShown = false;
    componentInstance.toggleShowPreviousResponses();
    expect(componentInstance.arePreviousResponsesShown).toBeTrue();
  });

  it('should tell if window is narrow', () => {
    spyOn(windowDimensionsService, 'isWindowNarrow').and.returnValue(true);
    expect(componentInstance.isWindowNarrow()).toBeTrue();
  });

  it('should show two cards', () => {
    spyOn(windowDimensionsService, 'getWidth').and.returnValue(300);
    expect(componentInstance.canWindowShowTwoCards()).toBeFalse();
  });

  it('should tell if audio bar can be shown', () => {
    componentInstance.isIframed = false;
    spyOn(explorationPlayerStateService, 'isInQuestionMode')
      .and.returnValue(false);
    expect(componentInstance.showAudioBar()).toBeTrue();
  });

  it('should tell if content audio translation is available', () => {
    componentInstance.conceptCardIsBeingShown = true;
    componentInstance.displayedCard = mockDisplayedCard;
    expect(componentInstance.isContentAudioTranslationAvailable()).toBeFalse();
    componentInstance.conceptCardIsBeingShown = false;
    spyOn(mockDisplayedCard, 'isContentAudioTranslationAvailable')
      .and.returnValue(true);
    componentInstance.displayedCard = mockDisplayedCard;
    expect(componentInstance.isContentAudioTranslationAvailable()).toBeTrue();
  });

  it('should check if current card is at end of transcript', () => {
    componentInstance.displayedCard = mockDisplayedCard;
    spyOn(mockDisplayedCard, 'isCompleted').and.returnValue(true);
    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeFalse();
  });

  it('should tell if on a terminal card', () => {
    componentInstance.displayedCard = mockDisplayedCard;
    spyOn(mockDisplayedCard, 'isTerminal').and.returnValue(true);
    expect(componentInstance.isOnTerminalCard()).toBeTrue();
  });

  it('should get input response pair id', () => {
    expect(componentInstance.getInputResponsePairId(1)).toEqual(
      'input-response-pair-1');
  });
});
