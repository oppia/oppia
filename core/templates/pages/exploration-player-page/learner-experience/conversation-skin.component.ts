// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Component for the conversation skin.
 */

import { Subscription } from 'rxjs';
import { StateCard } from 'domain/state_card/state-card.model';
import { ServicesConstants } from 'services/services.constants';
import { Component, Input } from '@angular/core';
import { downgradeComponent } from '@angular/upgrade/static';
import { WindowRef } from 'services/contextual/window-ref.service';
import { AlertsService } from 'services/alerts.service';
import { AudioPlayerService } from 'services/audio-player.service';
import { AudioTranslationLanguageService } from '../services/audio-translation-language.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { ConceptCardBackendApiService } from 'domain/skill/concept-card-backend-api.service';
import { ContentTranslationLanguageService } from '../services/content-translation-language.service';
import { ContentTranslationManagerService } from '../services/content-translation-manager.service';
import { ContextService } from 'services/context.service';
import { CurrentInteractionService } from '../services/current-interaction.service';
import { ExplorationEngineService } from '../services/exploration-engine.service';
import { ExplorationPlayerStateService } from '../services/exploration-player-state.service';
import { ExplorationRecommendationsService } from '../services/exploration-recommendations.service';
import { FatigueDetectionService } from '../services/fatigue-detection.service';
import { FocusManagerService } from 'services/stateful/focus-manager.service';
import { GuestCollectionProgressService } from 'domain/collection/guest-collection-progress.service';
import { HintsAndSolutionManagerService } from '../services/hints-and-solution-manager.service';
import { I18nLanguageCodeService } from 'services/i18n-language-code.service';
import { ImagePreloaderService } from '../services/image-preloader.service';
import { LearnerAnswerInfoService } from '../services/learner-answer-info.service';
import { LearnerParamsService } from '../services/learner-params.service';
import { LoaderService } from 'services/loader.service';
import { MessengerService } from 'services/messenger.service';
import { NumberAttemptsService } from '../services/number-attempts.service';
import { PlayerCorrectnessFeedbackEnabledService } from '../services/player-correctness-feedback-enabled.service';
import { PlayerPositionService } from '../services/player-position.service';
import { PlayerTranscriptService } from '../services/player-transcript.service';
import { QuestionPlayerEngineService } from '../services/question-player-engine.service';
import { ReadOnlyCollectionBackendApiService } from 'domain/collection/read-only-collection-backend-api.service';
import { RefresherExplorationConfirmationModalService } from '../services/refresher-exploration-confirmation-modal.service';
import { SiteAnalyticsService } from 'services/site-analytics.service';
import { StatsReportingService } from '../services/stats-reporting.service';
import { StoryViewerBackendApiService } from 'domain/story_viewer/story-viewer-backend-api.service';
import { UrlService } from 'services/contextual/url.service';
import { UserService } from 'services/user.service';
import { WindowDimensionsService } from 'services/contextual/window-dimensions.service';
import { QuestionPlayerStateService } from 'components/question-directives/question-player/services/question-player-state.service';
import { State } from 'domain/state/StateObjectFactory';
import { InteractionRulesService } from '../services/answer-classification.service';
import INTERACTION_SPECS from 'interactions/interaction_specs.json';
import { UrlInterpolationService } from 'domain/utilities/url-interpolation.service';
import { ExplorationPlayerConstants } from '../exploration-player-page.constants';
import { AppConstants } from 'app.constants';
import { TopicViewerDomainConstants } from 'domain/topic_viewer/topic-viewer-domain.constants';
import { StoryViewerDomainConstants } from 'domain/story_viewer/story-viewer-domain.constants';
import { ConceptCard } from 'domain/skill/ConceptCardObjectFactory';
import { CollectionPlayerBackendApiService } from 'pages/collection-player-page/services/collection-player-backend-api.service';
import { ExplorationSummaryBackendApiService } from 'domain/summary/exploration-summary-backend-api.service';

// Note: This file should be assumed to be in an IIFE, and the constants below
// should only be used within this file.
const TIME_FADEOUT_MSEC = 100;
const TIME_HEIGHT_CHANGE_MSEC = 500;
const TIME_FADEIN_MSEC = 100;
const TIME_NUM_CARDS_CHANGE_MSEC = 500;

@Component({
  selector: 'oppia-conversation-skin',
  templateUrl: './conversation-skin.component.html',
})
export class ConversationSkinComponent {
  @Input() questionPlayerConfig;
  directiveSubscriptions = new Subscription();
  // The minimum width, in pixels, needed to be able to show two cards
  // side-by-side.
  TIME_PADDING_MSEC = 250;
  TIME_SCROLL_MSEC = 600;
  MIN_CARD_LOADING_DELAY_MSEC = 950;

  hasInteractedAtLeastOnce: boolean = false;
  _nextFocusLabel = null;
  _editorPreviewMode;
  explorationActuallyStarted: boolean = false;

  CONTINUE_BUTTON_FOCUS_LABEL = (
    ExplorationPlayerConstants.CONTINUE_BUTTON_FOCUS_LABEL);
  isLoggedIn: boolean;
  storyNodeIdToAdd: string;
  inStoryMode: boolean = false;
  collectionId: string;
  collectionTitle: string;
  answerIsBeingProcessed: boolean = false;
  explorationId: string;
  isInPreviewMode: boolean;
  isIframed: boolean;
  hasFullyLoaded = false;
  recommendedExplorationSummaries = [];
  answerIsCorrect = false;
  nextCard;
  pendingCardWasSeenBefore: boolean = false;
  OPPIA_AVATAR_IMAGE_URL: string;
  displayedCard: StateCard;
  upcomingInlineInteractionHtml;
  DEFAULT_TWITTER_SHARE_MESSAGE_PLAYER = (
    AppConstants.DEFAULT_TWITTER_SHARE_MESSAGE_EDITOR);
  // If the exploration is iframed, send data to its parent about
  // its height so that the parent can be resized as necessary.
  lastRequestedHeight: number = 0;
  lastRequestedScroll: boolean = false;
  startCardChangeAnimation: boolean;
  collectionSummary;
  redirectToRefresherExplorationConfirmed;
  isAnimatingToTwoCards: boolean;
  isAnimatingToOneCard: boolean;
  isRefresherExploration: boolean;
  parentExplorationIds: string[];
  storyViewerUrl: string;
  conceptCard: ConceptCard;
  questionSessionCompleted: boolean;
  moveToExploration: boolean;
  upcomingInteractionInstructions;

  constructor(
    private windowRef: WindowRef,
    private alertsService: AlertsService,
    private audioPlayerService: AudioPlayerService,
    private audioTranslationLanguageService: AudioTranslationLanguageService,
    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,
    private collectionPlayerBackendApiService:
    CollectionPlayerBackendApiService,
    private conceptCardBackendApiService: ConceptCardBackendApiService,
    private contentTranslationLanguageService:
    ContentTranslationLanguageService,
    private contentTranslationManagerService: ContentTranslationManagerService,
    private contextService: ContextService,
    private currentInteractionService: CurrentInteractionService,
    private explorationEngineService: ExplorationEngineService,
    private explorationPlayerStateService: ExplorationPlayerStateService,
    private explorationRecommendationsService:
    ExplorationRecommendationsService,
    private explorationSummaryBackendApiService:
    ExplorationSummaryBackendApiService,
    private fatigueDetectionService: FatigueDetectionService,
    private focusManagerService: FocusManagerService,
    private guestCollectionProgressService: GuestCollectionProgressService,
    private hintsAndSolutionManagerService: HintsAndSolutionManagerService,
    private i18nLanguageCodeService: I18nLanguageCodeService,
    private imagePreloaderService: ImagePreloaderService,
    private learnerAnswerInfoService: LearnerAnswerInfoService,
    private learnerParamsService: LearnerParamsService,
    private loaderService: LoaderService,
    private messengerService: MessengerService,
    private numberAttemptsService: NumberAttemptsService,
    private playerCorrectnessFeedbackEnabledService:
    PlayerCorrectnessFeedbackEnabledService,
    private playerPositionService: PlayerPositionService,
    private playerTranscriptService: PlayerTranscriptService,
    private questionPlayerEngineService: QuestionPlayerEngineService,
    private questionPlayerStateService: QuestionPlayerStateService,
    private readOnlyCollectionBackendApiService:
    ReadOnlyCollectionBackendApiService,
    private refresherExplorationConfirmationModalService:
    RefresherExplorationConfirmationModalService,
    private siteAnalyticsService: SiteAnalyticsService,
    private statsReportingService: StatsReportingService,
    private storyViewerBackendApiService: StoryViewerBackendApiService,
    private urlInterpolationService: UrlInterpolationService,
    private urlService: UrlService,
    private userService: UserService,
    private windowDimensionsService: WindowDimensionsService
  ) {}

  ngOnInit(): void {
    this._editorPreviewMode = this.contextService.isInExplorationEditorPage();
    this.userService.getUserInfoAsync().then((userInfo) => {
      this.isLoggedIn = userInfo.isLoggedIn();
    });

    this.collectionId = this.urlService.getCollectionIdFromExplorationUrl();

    if (this.collectionId) {
      this.readOnlyCollectionBackendApiService.loadCollectionAsync(
        this.collectionId).then((collection) => {
        this.collectionTitle = collection.getTitle();
      });
    } else {
      this.collectionTitle = null;
    }

    this.explorationId = this.explorationEngineService.getExplorationId();
    this.isInPreviewMode = this.explorationEngineService.isInPreviewMode();
    this.isIframed = this.urlService.isIframed();
    this.loaderService.showLoadingScreen('Loading');

    this.OPPIA_AVATAR_IMAGE_URL = (
      this.urlInterpolationService.getStaticImageUrl(
        '/avatar/oppia_avatar_100px.svg'));

    if (this.explorationPlayerStateService.isInQuestionPlayerMode()) {
      this.directiveSubscriptions.add(
        this.hintsAndSolutionManagerService.onHintConsumed.subscribe(
          () => {
            this.questionPlayerStateService.hintUsed(
              this.questionPlayerEngineService.getCurrentQuestion());
          }
        )
      );

      this.directiveSubscriptions.add(
        this.hintsAndSolutionManagerService.onSolutionViewedEventEmitter
          .subscribe(() => {
            this.questionPlayerStateService.solutionViewed(
              this.questionPlayerEngineService.getCurrentQuestion()
            );
          })
      );
    }

    this.directiveSubscriptions.add(
      this.explorationPlayerStateService.onPlayerStateChange.subscribe(
        (newStateName) => {
          if (!newStateName) {
            return;
          }
          // To restart the preloader for the new state if required.
          if (!this._editorPreviewMode) {
            this.imagePreloaderService.onStateChange(newStateName);
          }
          // Ensure the transition to a terminal state properly logs
          // the end of the exploration.
          if (
            !this._editorPreviewMode && this.nextCard.isTerminal()) {
            this.statsReportingService.recordExplorationCompleted(
              newStateName, this.learnerParamsService.getAllParams());

            // If the user is a guest, has completed this exploration
            // within the context of a collection, and the collection is
            // whitelisted, record their temporary progress.

            if (this.doesCollectionAllowsGuestProgress(
              this.collectionId) && !this.isLoggedIn) {
              this.guestCollectionProgressService.
                recordExplorationCompletedInCollection(
                  this.collectionId, this.explorationId);
            }

            // For single state explorations, when the exploration
            // reachesthe terminal state and explorationActuallyStarted
            // is false, record exploration actual start event.
            if (!this.explorationActuallyStarted) {
              this.statsReportingService.recordExplorationActuallyStarted(
                newStateName);
              this.explorationActuallyStarted = true;
            }
          }
        }
      )
    );

    this.windowRef.nativeWindow.addEventListener('beforeunload', (e) => {
      if (this.redirectToRefresherExplorationConfirmed) {
        return;
      }
      if (this.hasInteractedAtLeastOnce && !this.isInPreviewMode &&
          !this.displayedCard.isTerminal() &&
          !this.explorationPlayerStateService.isInQuestionMode()) {
        this.statsReportingService.recordMaybeLeaveEvent(
          this.playerTranscriptService.getLastStateName(),
          this.learnerParamsService.getAllParams());
        let confirmationMessage = (
          'If you navigate away from this page, your progress on the ' +
          'exploration will be lost.');
        (e || this.windowRef.nativeWindow.event).returnValue = (
          confirmationMessage);
        return confirmationMessage;
      }
    });

    this.windowRef.nativeWindow.onresize = () => {
      this.adjustPageHeight(false, null);
    };

    this.windowRef.nativeWindow.addEventListener('scroll', () => {
      this.fixSupplementOnScroll();
    });

    this.currentInteractionService.setOnSubmitFn(this.submitAnswer.bind(this));
    this.startCardChangeAnimation = false;
    this.initializePage();

    this.collectionSummary = null;

    if (this.collectionId) {
      this.collectionPlayerBackendApiService
        .fetchCollectionSummariesAsync(this.collectionId)
        .then(
          (response) => {
            this.collectionSummary = response.summaries[0];
          },
          () => {
            this.alertsService.addWarning(
              'There was an error while fetching the collection ' +
              'summary.');
          }
        );
    }
  }

  doesCollectionAllowsGuestProgress(collectionId: string): boolean {
    let whiteListedCollectionIds = (
      AppConstants.
        WHITELISTED_COLLECTION_IDS_FOR_SAVING_GUEST_PROGRESS
    );
    return (
      (
        whiteListedCollectionIds as unknown as string[]
      ).
        indexOf(collectionId) !== -1);
  }

  isSubmitButtonDisabled(): boolean {
    let currentIndex = this.playerPositionService.getDisplayedCardIndex();
    // This check is added because it was observed that when returning
    // to current card after navigating through previous cards, using
    // the arrows, the Submit button was sometimes falsely disabled.
    // Also, since a learner's answers would always be in the current
    // card, this additional check doesn't interfere with its normal
    // working.
    if (!this.playerTranscriptService.isLastCard(currentIndex)) {
      return false;
    }
    return this.currentInteractionService.isSubmitButtonDisabled();
  }

  changeCard(index: number): void {
    this.playerPositionService.recordNavigationButtonClick();
    this.playerPositionService.setDisplayedCardIndex(index);
    this.explorationEngineService.onUpdateActiveStateIfInEditor.emit(
      this.playerPositionService.getCurrentStateName());
    this.playerPositionService.changeCurrentQuestion(index);
  }

  ngOnDestroy(): void {
    this.directiveSubscriptions.unsubscribe();
  }

  alwaysAskLearnerForAnswerDetails(): boolean {
    return this.explorationEngineService.getAlwaysAskLearnerForAnswerDetails();
  }

  getCanAskLearnerForAnswerInfo(): boolean {
    return this.learnerAnswerInfoService.getCanAskLearnerForAnswerInfo();
  }

  initLearnerAnswerInfoService(
      entityId: string, state: State, answer: string,
      interactionRulesService: InteractionRulesService,
      alwaysAskLearnerForAnswerInfo: boolean): void {
    this.learnerAnswerInfoService.initLearnerAnswerInfoService(
      entityId, state, answer, interactionRulesService,
      alwaysAskLearnerForAnswerInfo);
  }

  // This variable is used only when viewport is narrow.
  // Indicates whether the tutor card is displayed.
  isCorrectnessFeedbackEnabled(): boolean {
    return this.playerCorrectnessFeedbackEnabledService.isEnabled();
  }

  isCorrectnessFooterEnabled(): boolean {
    return (
      this.answerIsCorrect && this.isCorrectnessFeedbackEnabled() &&
      this.playerPositionService.hasLearnerJustSubmittedAnAnswer());
  }

  isLearnAgainButton(): boolean {
    let conceptCardIsBeingShown = (
      this.displayedCard.getStateName() === null &&
      !this.explorationPlayerStateService.isInQuestionMode());
    if (conceptCardIsBeingShown) {
      return false;
    }
    let interaction = this.displayedCard.getInteraction();

    if (!interaction.id) {
      // An editor might also try to view preview tab without adding
      // interaction to concept card.
      return false;
    }

    if (INTERACTION_SPECS[interaction.id].is_linear) {
      return false;
    }
    return (
      this.pendingCardWasSeenBefore && !this.answerIsCorrect &&
      this.isCorrectnessFeedbackEnabled());
  }

  private _getRandomSuffix(): string {
    // This is a bit of a hack. When a refresh to a $scope variable
    // happens,
    // AngularJS compares the new value of the variable to its previous
    // value. If they are the same, then the variable is not updated.
    // Appending a random suffix makes the new value different from the
    // previous one, and thus indirectly forces a refresh.
    let randomSuffix = '';
    let N = Math.round(Math.random() * 1000);
    for (let i = 0; i < N; i++) {
      randomSuffix += ' ';
    }
    return randomSuffix;
  }

  getStaticImageUrl(imagePath: string): string {
    return this.urlInterpolationService.getStaticImageUrl(imagePath);
  }

  getContentFocusLabel(index: number): string {
    return ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index;
  }

  adjustPageHeight(scroll: boolean, callback: () => void): void {
    setTimeout(() => {
      let newHeight = document.body.scrollHeight;
      if (Math.abs(this.lastRequestedHeight - newHeight) > 50.5 ||
          (scroll && !this.lastRequestedScroll)) {
        // Sometimes setting iframe height to the exact content height
        // still produces scrollbar, so adding 50 extra px.
        newHeight += 50;
        this.messengerService.sendMessage(
          ServicesConstants.MESSENGER_PAYLOAD.HEIGHT_CHANGE, {
            height: newHeight,
            scroll: scroll
          });
        this.lastRequestedHeight = newHeight;
        this.lastRequestedScroll = scroll;
      }

      if (callback) {
        callback();
      }
    }, 100);
  }

  isLanguageRTL(): boolean {
    return this.i18nLanguageCodeService.isCurrentLanguageRTL();
  }

  getExplorationLink(): string {
    if (this.recommendedExplorationSummaries &&
        this.recommendedExplorationSummaries[0]) {
      if (!this.recommendedExplorationSummaries[0].id) {
        return '#';
      } else {
        let result = '/explore/' +
            this.recommendedExplorationSummaries[0].id;
        let urlParams = this.urlService.getUrlParams();
        let parentExplorationIds = (
          this.recommendedExplorationSummaries[0]
            .parentExplorationIds);

        let collectionIdToAdd = this.collectionId;
        let storyUrlFragmentToAdd = null;
        let topicUrlFragment = null;
        let classroomUrlFragment = null;
        // Replace the collection ID with the one in the URL if it
        // exists in urlParams.
        if (parentExplorationIds &&
            urlParams.hasOwnProperty('collection_id')) {
          collectionIdToAdd = urlParams.collection_id;
        } else if (
          this.urlService.getPathname().match(/\/story\/(\w|-){12}/g) &&
            this.recommendedExplorationSummaries[0].nextNodeId) {
          storyUrlFragmentToAdd = (
            this.urlService.getStoryUrlFragmentFromLearnerUrl());
          topicUrlFragment = (
            this.urlService.getTopicUrlFragmentFromLearnerUrl());
          classroomUrlFragment = (
            this.urlService.getClassroomUrlFragmentFromLearnerUrl());
        } else if (
          urlParams.hasOwnProperty('story_url_fragment') &&
            urlParams.hasOwnProperty('node_id') &&
            urlParams.hasOwnProperty('topic_url_fragment') &&
            urlParams.hasOwnProperty('classroom_url_fragment')) {
          topicUrlFragment = urlParams.topic_url_fragment;
          classroomUrlFragment = urlParams.classroom_url_fragment;
          storyUrlFragmentToAdd = urlParams.story_url_fragment;
        }

        if (collectionIdToAdd) {
          result = this.urlService.addField(
            result, 'collection_id', collectionIdToAdd);
        }
        if (parentExplorationIds) {
          for (let i = 0; i < parentExplorationIds.length - 1; i++) {
            result = this.urlService.addField(
              result, 'parent', parentExplorationIds[i]);
          }
        }
        if (storyUrlFragmentToAdd && this.storyNodeIdToAdd) {
          result = this.urlService.addField(
            result, 'topic_url_fragment', topicUrlFragment);
          result = this.urlService.addField(
            result, 'classroom_url_fragment', classroomUrlFragment);
          result = this.urlService.addField(
            result, 'story_url_fragment', storyUrlFragmentToAdd);
          result = this.urlService.addField(
            result, 'node_id', this.storyNodeIdToAdd);
        }
        return result;
      }
    }
  }

  reloadExploration(): void {
    this.windowRef.nativeWindow.location.reload();
  }

  isOnTerminalCard(): boolean {
    return (
      this.displayedCard && this.displayedCard.isTerminal());
  }

  isSupplementalCardNonempty(card: StateCard): boolean {
    return !card.isInteractionInline();
  }

  isCurrentSupplementalCardNonempty(): boolean {
    return this.displayedCard && this.isSupplementalCardNonempty(
      this.displayedCard);
  }

  isSupplementalNavShown(): boolean {
    if (
      this.displayedCard.getStateName() === null &&
      !this.explorationPlayerStateService.isInQuestionMode()) {
      return false;
    }
    let interaction = this.displayedCard.getInteraction();
    return (
      Boolean(interaction.id) &&
      INTERACTION_SPECS[interaction.id].show_generic_submit_button &&
      this.isCurrentCardAtEndOfTranscript());
  }


  private _recordLeaveForRefresherExp(refresherExpId): void {
    if (!this._editorPreviewMode) {
      this.statsReportingService.recordLeaveForRefresherExp(
        this.playerPositionService.getCurrentStateName(),
        refresherExpId);
    }
  }

  // Navigates to the currently-active card, and resets the
  // 'show previous responses' setting.
  private _navigateToDisplayedCard(): void {
    let index = this.playerPositionService.getDisplayedCardIndex();
    this.displayedCard = this.playerTranscriptService.getCard(index);

    this.playerPositionService.onActiveCardChanged.emit();

    this.audioPlayerService.onAutoplayAudio.emit();
    /* A hash value is added to URL for scrolling to Oppia feedback
        when answer is submitted by user in mobile view. This hash value
        has to be reset each time a new card is loaded to prevent
        unwanted scrolling in the new card. */

    // $location.hash(null);

    // We must cancel the autogenerated audio player here, or else a
    // bug where the autogenerated audio player generates duplicate
    // utterances occurs.
    this.autogeneratedAudioPlayerService.cancel();
    if (this._nextFocusLabel &&
      this.playerTranscriptService.isLastCard(index)) {
      this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);
    } else {
      this.focusManagerService.setFocusIfOnDesktop(
        this.getContentFocusLabel(index));
    }
  }

  returnToExplorationAfterConceptCard(): void {
    this.playerTranscriptService.addPreviousCard();
    let numCards = this.playerTranscriptService.getNumCards();
    this.playerPositionService.setDisplayedCardIndex(numCards - 1);
  }

  animateToTwoCards(doneCallback: () => void): void {
    this.isAnimatingToTwoCards = true;
    setTimeout(() => {
      this.isAnimatingToTwoCards = false;
      if (doneCallback) {
        doneCallback();
      }
    }, TIME_NUM_CARDS_CHANGE_MSEC + TIME_FADEIN_MSEC +
      this.TIME_PADDING_MSEC);
  }

  animateToOneCard(doneCallback: () => void): void {
    this.isAnimatingToOneCard = true;
    setTimeout(() => {
      this.isAnimatingToOneCard = false;
      if (doneCallback) {
        doneCallback();
      }
    }, TIME_NUM_CARDS_CHANGE_MSEC);
  }


  isCurrentCardAtEndOfTranscript(): boolean {
    return this.playerTranscriptService.isLastCard(
      this.playerPositionService.getDisplayedCardIndex());
  }

  private _addNewCard(newCard): void {
    this.playerTranscriptService.addNewCard(newCard);
    const explorationLanguageCode = (
      this.explorationPlayerStateService.getLanguageCode());
    const selectedLanguageCode = (
      this.contentTranslationLanguageService.getCurrentContentLanguageCode()
    );
    if (explorationLanguageCode !== selectedLanguageCode) {
      this.contentTranslationManagerService.displayTranslations(
        selectedLanguageCode);
    }

    let totalNumCards = this.playerTranscriptService.getNumCards();

    let previousSupplementalCardIsNonempty = (
      totalNumCards > 1 &&
      this.isSupplementalCardNonempty(
        this.playerTranscriptService.getCard(totalNumCards - 2)));

    let nextSupplementalCardIsNonempty = this.isSupplementalCardNonempty(
      this.playerTranscriptService.getLastCard());

    if (
      totalNumCards > 1 &&
      this.canWindowShowTwoCards() &&
      !previousSupplementalCardIsNonempty &&
      nextSupplementalCardIsNonempty) {
      this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);
      this.animateToTwoCards(function() {});
    } else if (
      totalNumCards > 1 &&
      this.canWindowShowTwoCards() &&
      previousSupplementalCardIsNonempty &&
      !nextSupplementalCardIsNonempty) {
      this.animateToOneCard(() => {
        this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);
      });
    } else {
      this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);
    }
    this.playerPositionService.changeCurrentQuestion(
      this.playerPositionService.getDisplayedCardIndex());

    if (this.displayedCard && this.displayedCard.isTerminal()) {
      this.isRefresherExploration = false;
      this.parentExplorationIds =
        this.urlService.getQueryFieldValuesAsList('parent');
      let recommendedExplorationIds = [];
      let includeAutogeneratedRecommendations = false;

      if (this.parentExplorationIds.length > 0) {
        this.isRefresherExploration = true;
        let parentExplorationId = this.parentExplorationIds[
          this.parentExplorationIds.length - 1];
        recommendedExplorationIds.push(parentExplorationId);
      } else {
        recommendedExplorationIds =
          this.explorationEngineService.getAuthorRecommendedExpIds();
        includeAutogeneratedRecommendations = true;
      }

      if (this.explorationPlayerStateService.isInStoryChapterMode() &&
        AppConstants.ENABLE_NEW_STRUCTURE_VIEWER_UPDATES) {
        recommendedExplorationIds = [];
        includeAutogeneratedRecommendations = false;
        let topicUrlFragment = (
          this.urlService.getUrlParams().topic_url_fragment);
        let classroomUrlFragment = (
          this.urlService.getUrlParams().classroom_url_fragment);
        let storyUrlFragment = (
          this.urlService.getUrlParams().story_url_fragment);
        let nodeId = this.urlService.getUrlParams().node_id;
        this.inStoryMode = true;
        this.storyViewerUrl = this.urlInterpolationService.interpolateUrl(
          TopicViewerDomainConstants.STORY_VIEWER_URL_TEMPLATE, {
            topic_url_fragment: topicUrlFragment,
            classroom_url_fragment: classroomUrlFragment,
            story_url_fragment: storyUrlFragment
          });
        this.storyViewerBackendApiService.fetchStoryDataAsync(
          topicUrlFragment, classroomUrlFragment,
          storyUrlFragment).then(
          (res) => {
            let nextStoryNode = [];
            for (let i = 0; i < res.nodes.length; i++) {
              if (res.nodes[i].id === nodeId &&
                  (i + 1) < res.nodes.length) {
                this.storyNodeIdToAdd = (
                  res.nodes[i].destinationNodeIds[0]);
                nextStoryNode.push(
                  res.nodes[i + 1].explorationSummary);
                break;
              }
            }
            this.recommendedExplorationSummaries = nextStoryNode;
          });
        if (this.isLoggedIn) {
          this.storyViewerBackendApiService.recordChapterCompletionAsync(
            topicUrlFragment, classroomUrlFragment,
            storyUrlFragment, nodeId
          ).then((returnObject) => {
            if (returnObject.readyForReviewTest) {
              this.windowRef.nativeWindow.location =
                this.urlInterpolationService.interpolateUrl(
                  TopicViewerDomainConstants.REVIEW_TESTS_URL_TEMPLATE, {
                    topic_url_fragment: topicUrlFragment,
                    classroom_url_fragment: classroomUrlFragment,
                    story_url_fragment: storyUrlFragment
                  });
            }
          });
        } else {
          let loginRedirectUrl = this.urlInterpolationService.interpolateUrl(
            StoryViewerDomainConstants.STORY_PROGRESS_URL_TEMPLATE, {
              topic_url_fragment: topicUrlFragment,
              classroom_url_fragment: classroomUrlFragment,
              story_url_fragment: storyUrlFragment,
              node_id: nodeId
            });
          this.userService.setReturnUrl(loginRedirectUrl);
        }
      } else {
        this.explorationRecommendationsService.getRecommendedSummaryDicts(
          recommendedExplorationIds,
          includeAutogeneratedRecommendations,
          (summaries) => {
            this.recommendedExplorationSummaries = summaries;
          });
      }
    }
  }

  showQuestionAreNotAvailable(): void {
    this.loaderService.hideLoadingScreen();
  }

  private _initializeDirectiveComponents(initialCard, focusLabel): void {
    this._addNewCard(initialCard);
    this.nextCard = initialCard;
    this.explorationPlayerStateService.onPlayerStateChange.emit(
      this.nextCard.getStateName());
    this.focusManagerService.setFocusIfOnDesktop(focusLabel);
    this.loaderService.hideLoadingScreen();
    this.hasFullyLoaded = true;

    // If the exploration is embedded, use the exploration language
    // as site language. If the exploration language is not supported
    // as site language, English is used as default.
    let langCodes = AppConstants.SUPPORTED_SITE_LANGUAGES.map((language) => {
      return language.id;
    }) as string[];
    if (this.isIframed) {
      let explorationLanguageCode = (
        this.explorationPlayerStateService.getLanguageCode());
      if (langCodes.indexOf(explorationLanguageCode) !== -1) {
        this.i18nLanguageCodeService.setI18nLanguageCode(
          explorationLanguageCode);
      } else {
        this.i18nLanguageCodeService.setI18nLanguageCode('en');
      }
    }
    this.adjustPageHeight(false, null);
    this.windowRef.nativeWindow.scrollTo(0, 0);

    // The timeout is needed in order to give the recipient of the
    // broadcast sufficient time to load.
    setTimeout(() => {
      this.playerPositionService.onNewCardOpened.emit(initialCard);
    });
  }

  initializePage(): void {
    this.hasInteractedAtLeastOnce = false;
    this.recommendedExplorationSummaries = [];
    this.playerPositionService.init(this._navigateToDisplayedCard.bind(this));
    if (this.questionPlayerConfig) {
      this.explorationPlayerStateService.initializeQuestionPlayer(
        this.questionPlayerConfig,
        this._initializeDirectiveComponents.bind(this),
        this.showQuestionAreNotAvailable);
    } else {
      this.explorationPlayerStateService.initializePlayer(
        this._initializeDirectiveComponents.bind(this));
    }
  }

  submitAnswer(
      answer: string, interactionRulesService: InteractionRulesService): void {
    // Safety check to prevent double submissions from occurring.
    if (this.answerIsBeingProcessed ||
      !this.isCurrentCardAtEndOfTranscript() ||
      this.displayedCard.isCompleted()) {
      return;
    }

    if (!this.isInPreviewMode) {
      this.fatigueDetectionService.recordSubmissionTimestamp();
      if (this.fatigueDetectionService.isSubmittingTooFast()) {
        this.fatigueDetectionService.displayTakeBreakMessage();
        this.explorationPlayerStateService.onOppiaFeedbackAvailable.emit();
        return;
      }
    }

    if (!this.explorationPlayerStateService.isInQuestionMode() &&
      !this.isInPreviewMode &&
      AppConstants.ENABLE_SOLICIT_ANSWER_DETAILS_FEATURE) {
      this.initLearnerAnswerInfoService(
        this.explorationId, this.explorationEngineService.getState(),
        answer, interactionRulesService,
        this.alwaysAskLearnerForAnswerDetails());
    }

    this.numberAttemptsService.submitAttempt();

    this.answerIsBeingProcessed = true;
    this.hasInteractedAtLeastOnce = true;

    this.playerTranscriptService.addNewInput(answer, false);

    if (this.getCanAskLearnerForAnswerInfo()) {
      setTimeout(() => {
        this.playerTranscriptService.addNewResponse(
          this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion());
        this.answerIsBeingProcessed = false;
        this.playerPositionService.onHelpCardAvailable.emit({
          helpCardHtml: (
            this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion()),
          hasContinueButton: false
        });
      }, 100);
      return;
    }

    let timeAtServerCall = new Date().getTime();
    this.playerPositionService.recordAnswerSubmission();
    let currentEngineService =
      this.explorationPlayerStateService.getCurrentEngineService();
    this.answerIsCorrect = currentEngineService.submitAnswer(
      answer, interactionRulesService, (
          nextCard, refreshInteraction, feedbackHtml,
          feedbackAudioTranslations, refresherExplorationId,
          missingPrerequisiteSkillId, remainOnCurrentCard,
          taggedSkillMisconceptionId, wasOldStateInitial,
          isFirstHit, isFinalQuestion, focusLabel) => {
        this.nextCard = nextCard;
        if (!this._editorPreviewMode &&
            !this.explorationPlayerStateService.isInQuestionMode()) {
          let oldStateName =
            this.playerPositionService.getCurrentStateName();
          if (!remainOnCurrentCard) {
            this.statsReportingService.recordStateTransition(
              oldStateName, nextCard.getStateName(), answer,
              this.learnerParamsService.getAllParams(), isFirstHit);

            this.statsReportingService.recordStateCompleted(
              oldStateName);
          }
          if (nextCard.isTerminal()) {
            this.statsReportingService.recordStateCompleted(
              nextCard.getStateName());
          }
          if (wasOldStateInitial && !this.explorationActuallyStarted) {
            this.statsReportingService.recordExplorationActuallyStarted(
              oldStateName);
            this.explorationActuallyStarted = true;
          }
        }
        if (!this.explorationPlayerStateService.isInQuestionMode()) {
          this.explorationPlayerStateService.onPlayerStateChange.emit(
            nextCard.getStateName());
        } else {
          this.questionPlayerStateService.answerSubmitted(
            this.questionPlayerEngineService.getCurrentQuestion(),
            !remainOnCurrentCard,
            taggedSkillMisconceptionId);
        }
        // Do not wait if the interaction is supplemental -- there's
        // already a delay bringing in the help card.
        let millisecsLeftToWait = (
          !this.displayedCard.isInteractionInline() ? 1.0 :
          Math.max(this.MIN_CARD_LOADING_DELAY_MSEC - (
            new Date().getTime() - timeAtServerCall),
          1.0));

        setTimeout(() => {
          this.explorationPlayerStateService.onOppiaFeedbackAvailable.emit();

          this.audioPlayerService.onAutoplayAudio.emit({
            audioTranslations: feedbackAudioTranslations,
            html: feedbackHtml,
            componentName: AppConstants.COMPONENT_NAME_FEEDBACK
          });

          if (remainOnCurrentCard) {
            // Stay on the same card.
            this.hintsAndSolutionManagerService.recordWrongAnswer();
            this.playerTranscriptService.addNewResponse(feedbackHtml);
            let helpCardAvailable = false;
            if (feedbackHtml &&
                !this.displayedCard.isInteractionInline()) {
              helpCardAvailable = true;
            }

            if (helpCardAvailable) {
              this.playerPositionService.onHelpCardAvailable.emit({
                helpCardHtml: feedbackHtml,
                hasContinueButton: false
              });
            }
            if (missingPrerequisiteSkillId) {
              this.displayedCard.markAsCompleted();
              this.conceptCardBackendApiService.loadConceptCardsAsync(
                [missingPrerequisiteSkillId]
              ).then((conceptCardObject) => {
                this.conceptCard = conceptCardObject[0];
                if (helpCardAvailable) {
                  this.playerPositionService.onHelpCardAvailable.emit({
                    helpCardHtml: feedbackHtml,
                    hasContinueButton: true
                  });
                }
              });
            }
            if (refreshInteraction) {
              // Replace the previous interaction with another of the
              // same type.
              this._nextFocusLabel = (
                this.focusManagerService.generateFocusLabel());
              this.playerTranscriptService.updateLatestInteractionHtml(
                this.displayedCard.getInteractionHtml() +
                this._getRandomSuffix());
            }

            this.redirectToRefresherExplorationConfirmed = false;

            if (refresherExplorationId) {
              // TODO(bhenning): Add tests to verify the event is
              // properly recorded.
              let confirmRedirection = () => {
                this.redirectToRefresherExplorationConfirmed = true;
                this._recordLeaveForRefresherExp(refresherExplorationId);
              };
              this.explorationSummaryBackendApiService
                .loadPublicExplorationSummariesAsync([refresherExplorationId])
                .then((response) => {
                  if (response.summaries.length > 0) {
                    this.refresherExplorationConfirmationModalService.
                      displayRedirectConfirmationModal(
                        refresherExplorationId, confirmRedirection);
                  }
                });
            }
            this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);
            this.scrollToBottom();
          } else {
            // There is a new card. If there is no feedback, move on
            // immediately. Otherwise, give the learner a chance to read
            // the feedback, and display a 'Continue' button.
            this.pendingCardWasSeenBefore = false;
            this.displayedCard.markAsCompleted();
            if (isFinalQuestion) {
              if (this.explorationPlayerStateService.isInQuestionPlayerMode()) {
                // We will redirect to the results page here.
                this.questionSessionCompleted = true;
              }
              this.moveToExploration = true;
              if (feedbackHtml) {
                this.playerTranscriptService.addNewResponse(feedbackHtml);
                if (
                  !this.displayedCard.isInteractionInline()) {
                  this.playerPositionService.onHelpCardAvailable.emit({
                    helpCardHtml: feedbackHtml,
                    hasContinueButton: true
                  });
                }
              } else {
                this.showUpcomingCard();
              }
              this.answerIsBeingProcessed = false;
              return;
            }
            this.fatigueDetectionService.reset();
            this.numberAttemptsService.reset();

            let _isNextInteractionInline =
              this.nextCard.isInteractionInline();
            this.upcomingInlineInteractionHtml = (
              _isNextInteractionInline ?
                this.nextCard.getInteractionHtml() : '');
            this.upcomingInteractionInstructions = (
              this.nextCard.getInteractionInstructions());

            if (feedbackHtml) {
              if (
                this.playerTranscriptService.hasEncounteredStateBefore(
                  nextCard.getStateName())) {
                this.pendingCardWasSeenBefore = true;
              }
              this.playerTranscriptService.addNewResponse(feedbackHtml);
              if (!this.displayedCard.isInteractionInline()) {
                this.playerPositionService.onHelpCardAvailable.emit({
                  helpCardHtml: feedbackHtml,
                  hasContinueButton: true
                });
              }
              this.playerPositionService.onNewCardAvailable.emit();
              this._nextFocusLabel = (
                ExplorationPlayerConstants.CONTINUE_BUTTON_FOCUS_LABEL);
              this.focusManagerService.setFocusIfOnDesktop(
                this._nextFocusLabel);
              this.scrollToBottom();
            } else {
              this.playerTranscriptService.addNewResponse(feedbackHtml);
              // If there is no feedback, it immediately moves on
              // to next card. Therefore this.answerIsCorrect needs
              // to be set to false before it proceeds to next card.
              this.answerIsCorrect = false;
              this.showPendingCard();
            }
            this.currentInteractionService.clearPresubmitHooks();
          }
          this.answerIsBeingProcessed = false;
        }, millisecsLeftToWait);
      }
    );
  }

  showPendingCard(): void {
    this.startCardChangeAnimation = true;
    this.explorationPlayerStateService.recordNewCardAdded();

    setTimeout(() => {
      this._addNewCard(this.nextCard);

      this.upcomingInlineInteractionHtml = null;
      this.upcomingInteractionInstructions = null;
    }, TIME_FADEOUT_MSEC + 0.1 * TIME_HEIGHT_CHANGE_MSEC);

    setTimeout(() => {
      this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);
      this.scrollToTop();
    },
    TIME_FADEOUT_MSEC + TIME_HEIGHT_CHANGE_MSEC +
      0.5 * TIME_FADEIN_MSEC);

    setTimeout(() => {
      this.startCardChangeAnimation = false;
    },
    TIME_FADEOUT_MSEC + TIME_HEIGHT_CHANGE_MSEC + TIME_FADEIN_MSEC +
    this.TIME_PADDING_MSEC);

    this.playerPositionService.onNewCardOpened.emit(this.nextCard);
  }

  showUpcomingCard(): void {
    let currentIndex = this.playerPositionService.getDisplayedCardIndex();
    let conceptCardIsBeingShown = (
      this.displayedCard.getStateName() === null &&
      !this.explorationPlayerStateService.isInQuestionMode());
    if (conceptCardIsBeingShown &&
        this.playerTranscriptService.isLastCard(currentIndex)) {
      this.returnToExplorationAfterConceptCard();
      return;
    }
    if (this.questionSessionCompleted) {
      this.questionPlayerStateService.onQuestionSessionCompleted.emit(
        this.questionPlayerStateService.getQuestionPlayerStateData());
      return;
    }
    if (this.moveToExploration) {
      this.moveToExploration = false;
      this.explorationPlayerStateService.moveToExploration(
        this._initializeDirectiveComponents.bind(this));
      return;
    }
    if (
      this.displayedCard.isCompleted() &&
      (this.nextCard.getStateName() ===
      this.displayedCard.getStateName()) && this.conceptCard) {
      this.explorationPlayerStateService.recordNewCardAdded();
      this._addNewCard(
        StateCard.createNewCard(
          null, this.conceptCard.getExplanation().html, null, null, null,
          null, null, this.audioTranslationLanguageService));
      return;
    }
    /* This is for the following situation:
        if A->B->C is the arrangement of cards and C redirected to A,
        then after this, B and C are visited cards and hence
        pendingCardWasSeenBefore would be true during both these
        transitions and as answerIsCorrect is set to false below,
        Continue would briefly change to Learn Again (after it is
        clicked) during these transitions which is not required.
        Also, if the 'if' check is not there, Learn Again button would
        briefly switched to Continue before going to next card. */
    if (this.answerIsCorrect) {
      this.pendingCardWasSeenBefore = false;
    }
    this.answerIsCorrect = false;
    this.showPendingCard();
  }

  scrollToBottom(): void {
    setTimeout(() => {
      let tutorCard = $('.conversation-skin-main-tutor-card');

      if (tutorCard && tutorCard.length === 0) {
        return;
      }
      let tutorCardBottom = (
        tutorCard.offset().top + tutorCard.outerHeight());
      if ($(window).scrollTop() +
            $(window).height() < tutorCardBottom) {
        $('html, body').animate({
          scrollTop: tutorCardBottom - $(window).height() + 12
        }, {
          duration: this.TIME_SCROLL_MSEC,
          easing: 'easeOutQuad'
        });
      }
    }, 100);
  }

  scrollToTop(): void {
    setTimeout(() => {
      $('html, body').animate({
        scrollTop: 0
      }, 800, 'easeOutQuart');
      return false;
    });
  }

  // Returns whether the screen is wide enough to fit two
  // cards (e.g., the tutor and supplemental cards) side-by-side.
  canWindowShowTwoCards(): boolean {
    return this.windowDimensionsService.getWidth() >
    ExplorationPlayerConstants.TWO_CARD_THRESHOLD_PX;
  }

  fixSupplementOnScroll(): void {
    let supplementCard = $('div.conversation-skin-supplemental-card');
    let topMargin = $('.navbar-container').height() - 20;
    if ($(window).scrollTop() > topMargin) {
      supplementCard.addClass(
        'conversation-skin-supplemental-card-fixed');
    } else {
      supplementCard.removeClass(
        'conversation-skin-supplemental-card-fixed');
    }
  }

  onNavigateFromIframe(): void {
    this.siteAnalyticsService.registerVisitOppiaFromIframeEvent(
      this.explorationId);
  }

  submitAnswerFromProgressNav(): void {
    this.currentInteractionService.submitAnswer();
  }
}

angular.module('oppia').directive('oppiaConversationSkin',
  downgradeComponent({
    component: ConversationSkinComponent
  }) as angular.IDirectiveFactory);
