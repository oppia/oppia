// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @fileoverview Unit tests for the Supplemental card directive.
 */

// TODO(#7222): Remove the following block of unnnecessary imports once
// the code corresponding to the spec is upgraded to Angular 8.
import { importAllAngularServices } from 'tests/unit-test-utils.ajs';
import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { AudioPlayerService } from 'services/audio-player.service';
import { AudioTranslationManagerService } from '../services/audio-translation-manager.service';
import { AutogeneratedAudioPlayerService } from 'services/autogenerated-audio-player.service';
import { CurrentInteractionService } from '../services/current-interaction.service';
import { PlayerPositionService } from '../services/player-position.service';
import { WindowDimensionsService } from 'services/contextual/window-dimensions.service';
import { StateCard } from 'domain/state_card/state-card.model';
import { InteractionObjectFactory } from 'domain/exploration/InteractionObjectFactory';
import { RecordedVoiceovers } from 'domain/exploration/recorded-voiceovers.model';
import { AudioTranslationLanguageService } from '../services/audio-translation-language.service';
import { WrittenTranslationsObjectFactory } from 'domain/exploration/WrittenTranslationsObjectFactory';
import { EventEmitter } from '@angular/core';
// ^^^ This block is to be removed.

describe('Supplemental card directive', function() {
  let $scope = null;
  let ctrl = null;
  let $rootScope = null;
  let $compile = null;
  let directive = null;
  let audioPlayerService: AudioPlayerService = null;
  let audioTranslationManagerService: AudioTranslationManagerService = null;
  let audioTranslationLanguageService: AudioTranslationLanguageService = null;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService = null;
  let currentInteractionService: CurrentInteractionService = null;
  let interactionObjectFactory: InteractionObjectFactory = null;
  let playerPositionService: PlayerPositionService = null;
  let writtenTranslationsObjectFactory: WrittenTranslationsObjectFactory = null;

  let sampleCard: StateCard = null;
  let activeCardChangedEmitter = new EventEmitter();
  let helperCardAvailableEmitter = new EventEmitter();

  beforeEach(angular.mock.module('oppia'));
  importAllAngularServices();

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule]
    });
  });


  beforeEach(angular.mock.inject(function($injector, $templateCache) {
    $rootScope = $injector.get('$rootScope');
    $scope = $rootScope.$new();
    $compile = $injector.get('$compile');

    audioPlayerService = $injector.get('AudioPlayerService');
    audioTranslationManagerService = $injector.get(
      'AudioTranslationManagerService');
    autogeneratedAudioPlayerService = $injector.get(
      'AutogeneratedAudioPlayerService');
    audioTranslationLanguageService = $injector.get(
      'AudioTranslationLanguageService');
    currentInteractionService = $injector.get('CurrentInteractionService');
    currentInteractionService = $injector.get('CurrentInteractionService');
    interactionObjectFactory = $injector.get('InteractionObjectFactory');
    playerPositionService = $injector.get('PlayerPositionService');
    writtenTranslationsObjectFactory = $injector.get(
      'WrittenTranslationsObjectFactory');
    directive = $injector.get('supplementalCardDirective')[0];

    let interaction = interactionObjectFactory.createFromBackendDict({
      id: 'TextInput',
      answer_groups: [
        {
          outcome: {
            dest: 'State',
            feedback: {
              html: '',
              content_id: 'This is a new feedback text',
            },
            refresher_exploration_id: 'test',
            missing_prerequisite_skill_id: 'test_skill_id',
            labelled_as_correct: true,
            param_changes: [],
          },
          rule_specs: [],
          training_data: [],
          tagged_skill_misconception_id: '',
        },
      ],
      default_outcome: {
        dest: 'Hola',
        feedback: {
          content_id: '',
          html: '',
        },
        labelled_as_correct: true,
        param_changes: [],
        refresher_exploration_id: 'test',
        missing_prerequisite_skill_id: 'test_skill_id',
      },
      confirmed_unclassified_answers: [],
      customization_args: {
        rows: {
          value: true,
        },
        placeholder: {
          value: 1,
        },
      },
      hints: [],
      solution: {
        answer_is_exclusive: true,
        correct_answer: 'test_answer',
        explanation: {
          content_id: '2',
          html: 'test_explanation1',
        },
      },
    });

    let voiceOversDict = {
      voiceovers_mapping: {
        content: {
          en: {
            filename: 'filename1.mp3',
            file_size_bytes: 100000,
            needs_update: false,
            duration_secs: 10.0
          },
          hi: {
            filename: 'filename2.mp3',
            file_size_bytes: 11000,
            needs_update: false,
            duration_secs: 0.11
          }
        },
        default_outcome: {
          en: {
            filename: 'filename3.mp3',
            file_size_bytes: 3000,
            needs_update: false,
            duration_secs: 0.33
          },
          hi: {
            filename: 'filename4.mp3',
            file_size_bytes: 5000,
            needs_update: false,
            duration_secs: 0.5
          }
        },
        feedback_1: {
          en: {
            filename: 'filename5.mp3',
            file_size_bytes: 2000,
            needs_update: false,
            duration_secs: 0.2
          },
          hi: {
            filename: 'filename6.mp3',
            file_size_bytes: 9000,
            needs_update: false,
            duration_secs: 0.9
          }
        },
        feedback_2: {
          en: {
            filename: 'filename7.mp3',
            file_size_bytes: 1000,
            needs_update: false,
            duration_secs: 0.1
          },
          hi: {
            filename: 'filename8.mp3',
            file_size_bytes: 600,
            needs_update: false,
            duration_secs: 0.06
          }
        },
        hint_1: {
          en: {
            filename: 'filename9.mp3',
            file_size_bytes: 104000,
            needs_update: false,
            duration_secs: 10.4
          },
          hi: {
            filename: 'filename10.mp3',
            file_size_bytes: 1000,
            needs_update: true,
            duration_secs: 0.1
          }
        },
        hint_2: {},
        solution: {
          en: {
            filename: 'filename13.mp3',
            file_size_bytes: 15080,
            needs_update: false,
            duration_secs: 1.5
          },
          hi: {
            filename: 'filename14.mp3',
            file_size_bytes: 10500,
            needs_update: false,
            duration_secs: 1.05
          }
        }
      }
    };

    sampleCard = StateCard.createNewCard(
      'State 1', '<p>Content</p>', '<interaction></interaction>',
      interaction, RecordedVoiceovers.createFromBackendDict(voiceOversDict),
      writtenTranslationsObjectFactory.createEmpty(),
      'content', audioTranslationLanguageService);
    spyOn(currentInteractionService, 'registerPresubmitHook')
      .and.callFake((cb) => {
        cb();
      });
    spyOnProperty(playerPositionService, 'onActiveCardChanged').and.returnValue(
      activeCardChangedEmitter);
    spyOnProperty(playerPositionService, 'onHelpCardAvailable').and.returnValue(
      helperCardAvailableEmitter);


    ctrl = $injector.instantiate(directive.controller, {
      $rootScope: $scope,
      $scope: $scope,
      OPPIA_AVATAR_LINK_URL: 'oppiaAvaratLinkUrl',
      CONTINUE_BUTTON_FOCUS_LABEL: 'continueButtonFocusLabel'
    });

    $scope.getDisplayedCard = function() {
      return sampleCard;
    };
    $scope.displayedCard = $scope.getDisplayedCard();

    let helpCardTemplate = angular.element(
      '<div class="conversation-skin-help-card" ' +
      'style="height: 100px"></div>');

    let containerTemplate = angular.element(
      '<div class="conversation-skin-interaction-container" ' +
      'style="height: 100px"></div>');

    angular.element(document.body).append(helpCardTemplate);
    angular.element(document.body).append(containerTemplate);
    $compile(helpCardTemplate)($scope);
    $compile(containerTemplate)($scope);
    $rootScope.$digest();
  }));

  afterEach(() => {
    ctrl.$onDestroy();
  });

  it('should set properties when initialized', function() {
    expect($scope.OPPIA_AVATAR_LINK_URL).toBe(undefined);
    expect($scope.CONTINUE_BUTTON_FOCUS_LABEL).toBe(undefined);
    $scope.getDisplayedCard().markAsCompleted();

    ctrl.$onInit();
    activeCardChangedEmitter.emit();
    helperCardAvailableEmitter.emit({
      helpCardHtml: 'helpCardHtml',
      helpCardHasContinueButton: true
    });

    expect($scope.OPPIA_AVATAR_LINK_URL).toBe('oppiaAvaratLinkUrl');
    expect($scope.CONTINUE_BUTTON_FOCUS_LABEL).toBe('continueButtonFocusLabel');
  });

  it('should clear help card when initialized', function() {
    let clearHelpCardSpy = spyOn($scope, 'clearHelpCard')
      .and.returnValue(null);

    ctrl.$onInit();

    expect(clearHelpCardSpy).toHaveBeenCalled();
  });

  it('should check whether the help card is tall enough', function() {
    let result = $scope.isHelpCardTall();

    expect(result).toBe(false);
  });

  it('should get help card bottom position', function() {
    let result = $scope.getHelpCardBottomPosition();

    expect(result).toBe(50);
  });

  it('should getFeedbackAudioHighlightClass', function() {
    spyOn(audioTranslationManagerService, 'getCurrentComponentName').and
      .returnValue('feedback');
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
    spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(true);

    let result = $scope.getFeedbackAudioHighlightClass();

    expect(result).toBe('conversation-skin-audio-highlight');
  });
});
