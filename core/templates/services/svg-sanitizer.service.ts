// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview SVG related checks and sanitization service.
 */

import { Injectable } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';
import { downgradeInjectable } from '@angular/upgrade/static';

import { AppConstants } from 'app.constants';

type nodeAttr = (
  'style' |
  'about' |
  'class' |
  'content' |
  'datatype' |
  'id' |
  'lang' |
  'property' |
  'rel' |
  'resource' |
  'rev' |
  'tabindex' |
  'typeof'
);

type keyOfSvgAttrsAllowlist = keyof typeof AppConstants.SVG_ATTRS_ALLOWLIST;

@Injectable({
  providedIn: 'root'
})
export class SvgSanitizerService {
  constructor(private sanitizer: DomSanitizer) {}

  cleanMathExpressionSvgString(svgString: string): string {
    // We need to modify/remove unnecessary attributes added by mathjax
    // from the svg tag.
    let domParser = new DOMParser();
    let doc = domParser.parseFromString(svgString, 'image/svg+xml');
    doc.querySelectorAll('*').forEach((node) => {
      if (node.tagName.toLowerCase() === 'svg') {
        node.removeAttribute('xmlns:xlink');
        node.removeAttribute('role');
        // We are removing this attribute, because currently it is not in
        // the allowlist of valid attributes.
        node.removeAttribute('aria-hidden');
        node.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      }
      // Remove the custom data attributes added by MathJax.
      // These custom attributes don't affect the rendering of the SVGs,
      // and they are not present in the white list for allowed attributes.
      for (let i = 0; i < node.attributes.length; i++) {
        if (node.attributes[i].name.toLowerCase().startsWith('data-')) {
          node.removeAttribute(node.attributes[i].name.toLowerCase());
        }
      }
    });
    return doc.documentElement.outerHTML;
  }

  extractDimensionsFromMathExpressionSvgString(
      svgString: string
  ): { height: string; width: string; verticalPadding: string } {
    // The method below extracts the dimensions from the attributes of a
    // math SVG string generated by mathJax.
    let domParser = new DOMParser();
    let dimensions = {
      height: '',
      width: '',
      verticalPadding: ''
    };
    let doc = domParser.parseFromString(svgString, 'image/svg+xml');
    doc.querySelectorAll('*').forEach((node) => {
      // Mathjax SVGs have relative dimensions in the unit of 'ex' rather
      // than 'px'(pixels). Hence the dimensions have decimal points in them,
      // we need to replace these decimals with a letter so that it's easier
      // to process and validate the filenames.
      if (node.tagName.toLowerCase() === 'svg') {
        let attrHeight = node.getAttribute('height');
        if (attrHeight) {
          let heightRegexpMatchResult = attrHeight.match(/\d+\.*\d*/g);
          if (heightRegexpMatchResult) {
            dimensions.height = heightRegexpMatchResult[0].replace('.', 'd');
          }
        } else {
          throw new Error('SVG height attribute is missing.');
        }
        let attrWidth = node.getAttribute('width');
        if (attrWidth) {
          let widthRegexpMatchResult = attrWidth.match(/\d+\.*\d*/g);
          if (widthRegexpMatchResult) {
            dimensions.width = widthRegexpMatchResult[0].replace('.', 'd');
          }
        } else {
          throw new Error('SVG width attribute is missing.');
        }
        // This attribute is useful for the vertical alignment of the
        // Math SVG while displaying inline with other text.
        // Math SVGs don't necessarily have a vertical alignment, in that
        // case we assign it zero.
        let styleValue: RegExpMatchArray | null;
        let attrStyle = node.getAttribute('style');
        if (attrStyle) {
          styleValue = attrStyle.match(/\d+\.*\d*/g);
          if (styleValue) {
            dimensions.verticalPadding = styleValue[0].replace('.', 'd');
          } else {
            dimensions.verticalPadding = '0';
          }
        }
      }
    });
    return dimensions;
  }

  private _getInvalidSvgTagsAndAttrs(
      svg: Document
  ): { tags: string[]; attrs: string[] } {
    let invalidTags: string[] = [];
    let invalidAttrs: string[] = [];

    let allowedTags = Object.keys(AppConstants.SVG_ATTRS_ALLOWLIST);
    let nodeTagName: keyOfSvgAttrsAllowlist;
    svg.querySelectorAll('*').forEach((node) => {
      nodeTagName = node.tagName.toLowerCase() as keyOfSvgAttrsAllowlist;
      if (allowedTags.indexOf(nodeTagName) !== -1) {
        for (let i = 0; i < node.attributes.length; i++) {
          let nodeAttrName: string = node.attributes[i].name.toLowerCase();
          if (AppConstants.SVG_ATTRS_ALLOWLIST[nodeTagName].indexOf(
            nodeAttrName as nodeAttr) === -1
          ) {
            invalidAttrs.push(
              node.tagName + ':' + node.attributes[i].name);
          }
        }
      } else {
        invalidTags.push(node.tagName);
      }
    });
    return { tags: invalidTags, attrs: invalidAttrs };
  }

  // SVG is considered an XMLDocument and DOMParser's parseFromString method
  // returns either a HTMLDocument or XMLDocument. Visit here for more info:
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString
  // Document is the interface that both HTMLDocument and XMLDocument inherit
  // properties from.
  getSvgFromDataUri(dataURI: string): Document {
    // Convert base64/URLEncoded data component to raw binary data
    // held in a string.
    const svgString = this.convertBase64ToUnicodeString(dataURI.split(',')[1]);
    const domParser = new DOMParser();
    return domParser.parseFromString(svgString, 'image/svg+xml');
  }

  convertBase64ToUnicodeString(base64String: string): string {
    // Coverting base64 to unicode string. This technique converts bytestream
    // to percent-encoding, to original string.
    // See https://stackoverflow.com/a/30106551
    return decodeURIComponent(atob(base64String).split('').map(char => {
      return '%' + ('00' + char.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
  }

  removeAllInvalidTagsAndAttributes(svgDataURI: string): string {
    // We are removing the attributes which are currently not in
    // the allowlist of valid attributes. The allowlist is based on
    // the list of tags and attributes specified in this project:
    // https://github.com/cure53/DOMPurify
    // Complete list is present at 'assets/constants.ts'.
    let svg = this.getSvgFromDataUri(svgDataURI);
    let invalidTagsAndAttributes = this._getInvalidSvgTagsAndAttrs(svg);
    let tagsToBeRemoved = invalidTagsAndAttributes.tags;
    let attrsToBeRemoved = invalidTagsAndAttributes.attrs;
    svg.querySelectorAll('*').forEach((node) => {
      const nodeTagName: string = node.tagName;
      if (tagsToBeRemoved.indexOf(nodeTagName) !== -1) {
        node.remove();
      } else {
        for (let i = 0; i < node.attributes.length; i++) {
          const nodeAttrName: string = node.attributes[i].name;
          // Check if the tag name and attribute combination matches any value
          // in attrsToBeRemoved. If so, remove that attribute from the node.
          // Values in attrsToBeRemoved follow the format <tagName>:<attrName>
          // where the tagName and attrName is in the original letter casing
          // as in the node.
          if (
            attrsToBeRemoved.indexOf(nodeTagName + ':' + nodeAttrName) !== -1) {
            node.removeAttribute(nodeAttrName);
          }
        }
      }
    });
    return (
      'data:image/svg+xml;base64,' +
      btoa(unescape(encodeURIComponent(svg.documentElement.outerHTML))));
  }

  getInvalidSvgTagsAndAttrs(
      svg: Document
  ): { tags: string[]; attrs: string[] } {
    return this._getInvalidSvgTagsAndAttrs(svg);
  }

  getInvalidSvgTagsAndAttrsFromDataUri(
      dataURI: string): { tags: string[]; attrs: string[] } {
    let doc = this.getSvgFromDataUri(dataURI);
    return this._getInvalidSvgTagsAndAttrs(doc);
  }

  /**
   * Checks if the input is base64-encoded.
   *
   * @returns {boolean} True if all the checks pass. False Otherwise.
   */
  isBase64Svg(base64ImageData: string): boolean {
    const DATA_URL_PATTERN = /^data:image\/svg\+xml;base64,[a-z0-9+\/]+=*$/i;
    // Check if data passed is a valid bse64 SVG.
    if (!base64ImageData.match(DATA_URL_PATTERN)) {
      return false;
    }

    return true;
  }

  /**
   * Checks the input for malicious or invalid SVG code.
   * Angular by default treats svg+xml data as unsafe. In order to show the SVG
   * we need to check the SVG data for possible XSS attacks. The spec file for
   * this component showcases some scenarios where XSS attacks are possible if
   * the SVG is not checked for such attacks. The following function checks the
   * SVG data for possible XSS vulnerabilities.
   *
   * @returns {SafeResourceUrl | null} SafeResourceUrl if the SVG is valid and
   * trusted. Otherwise returns null.
   */
  getTrustedSvgResourceUrl(base64ImageData: string): SafeResourceUrl | null {
    if (this.isBase64Svg(base64ImageData)) {
      const sanitizedBase64ImageData = this.removeAllInvalidTagsAndAttributes(
        base64ImageData);

      // eslint-disable-next-line oppia/no-bypass-security-phrase
      return this.sanitizer.bypassSecurityTrustResourceUrl(
        sanitizedBase64ImageData);
    }
    return null;
  }

  getIssueURL(
      invalidTagsAndAttributes: { tags: string[]; attrs: string[] }): string {
    const invalidTags = invalidTagsAndAttributes.tags;
    const invalidAttributes = invalidTagsAndAttributes.attrs;
    const spaceBetweenValues = ', ';
    const unencodedIssueTitle = 'Uploaded SVG image looks distorted in the ' +
      'preview';
    let unencodedIssueBody = 'The image file is attached below:\n\n' +
      '{{ IMAGE_HERE }}\n\nScreenshots of the problem:\n\n' +
      '{{ SCREENSHOTS_HERE }}\n\nThe invalid tags and attributes reported:';

    if (invalidTags.length) {
      unencodedIssueBody += '\nTags: ';
      for (let i = 0; i < Math.min(invalidTags.length, 20); i++) {
        unencodedIssueBody += invalidTags[i] + spaceBetweenValues;
      }
    }
    if (invalidAttributes.length) {
      unencodedIssueBody += '\nAttributes: ';
      for (let i = 0; i < Math.min(invalidAttributes.length, 20); i++) {
        unencodedIssueBody += invalidAttributes[i] + spaceBetweenValues;
      }
    }
    unencodedIssueBody = unencodedIssueBody.substring(
      0, unencodedIssueBody.length - spaceBetweenValues.length);

    return (
      'https://github.com/oppia/oppia/issues/new?title=' +
      encodeURIComponent(unencodedIssueTitle) +
      '&body=' + encodeURIComponent(unencodedIssueBody));
  }
}

angular.module('oppia').factory(
  'SvgSanitizerService', downgradeInjectable(SvgSanitizerService));
