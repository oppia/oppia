[
  {
    "new_value": {
      "submit": [
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo ! XSS est la faille <b>la plus r\u00e9pandue dans les applications Web</b>. Si on prend en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur d\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif le plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Attention ! XSS est la faille <b>la plus r\u00e9pandue dans les application Web</b>. Si on prend\n en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur \nd\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif \nle plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo ! XSS est la faille <b>la plus r\u00e9pandue dans les application Web</b>. Si on prend en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur d\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif le plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Attention ! XSS est la faille <b>la plus r\u00e9pandue dans les application Web</b>. Si on prend\n en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur \nd\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif \nle plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "1 Importance des failles XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo ! XSS est la faille <b>la plus r\u00e9pandue dans les applications Web</b>. Si on prend en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur d\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif le plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Attention ! XSS est la faille <b>la plus r\u00e9pandue dans les applications Web</b>. Si on prend\n en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur \nd\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif \nle plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo ! XSS est la faille <b>la plus r\u00e9pandue dans les applications Web</b>. Si on prend en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur d\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif le plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Attention ! XSS est la faille <b>la plus r\u00e9pandue dans les application Web</b>. Si on prend\n en compte, en plus de leur fr\u00e9quence, leur exploitabilit\u00e9, leur \nd\u00e9tectabilit\u00e9 et leurs impacts \npotentiels, les failles XSS sont le <b>3\u00e8me risque de s\u00e9curit\u00e9 applicatif \nle plus critique</b> des applications web selon le <b>classement OWASP 2013 </b>(<oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org&amp;quot;\"></oppia-noninteractive-link>) !"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "2 Cons\u00e9quences",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "1 Importance des failles XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": [
      {
        "type": "text",
        "value": "Mais au fait, une faille XSS (en anglais: <strong>Cross-Site Scripting</strong> vulnerability), c\u2019est quoi exactement ?<br>"
      }
    ],
    "cmd": "edit_state_property",
    "old_value": [
      {
        "type": "text",
        "value": "Mais au fait, une faille XSS (en anglais: <strong>Cross-Site Scripting</strong> vulnerabilities), c\u2019est quoi exactement ?<br>"
      }
    ],
    "state_name": "3 Qu'est-ce qu'un faille XSS",
    "property_name": "content"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultat\u00a0\u00e0 l'utilisateur. Si les donn\u00e9es utilisateurs ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es\u00a0entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation\u00a0suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le\u00a0DOM</b>\u00a0(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> par des scripts c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultat\u00a0\u00e0 l'utilisateur. Si les donn\u00e9es utilisateurs ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es\u00a0entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation\u00a0suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le\u00a0DOM</b>\u00a0(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "5 D\u00e9tails types de faille XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultats \u00e0 l'utilisateur. Si les donn\u00e9es utilisateurs ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es\u00a0entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation\u00a0suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le\u00a0DOM</b>\u00a0(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultat&nbsp;\u00e0 l'utilisateur. Si les donn\u00e9es utilisateurs ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es&nbsp;entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation&nbsp;suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le&nbsp;DOM</b>&nbsp;(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "5 D\u00e9tails types de faille XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultats \u00e0 l'utilisateur. Si les donn\u00e9es utilisateur ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es\u00a0entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation\u00a0suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le\u00a0DOM</b>\u00a0(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultats \u00e0 l'utilisateur. Si les donn\u00e9es utilisateurs ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es&nbsp;entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation&nbsp;suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le&nbsp;DOM</b>&nbsp;(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "5 D\u00e9tails types de faille XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultats \u00e0 l'utilisateur. Si ces donn\u00e9es ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es\u00a0entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation\u00a0suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le\u00a0DOM</b>\u00a0(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "6 Donn\u00e9es dangereuses",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li><u>les <b>XSS non-persistants (reflected \nXSS)</b></u>: c'est le type de faille XSS<b> le plus connu et le plus courant</b>. Ces \nattaques se produisent lorsque les donn\u00e9es entr\u00e9es par l'utilisateur sont <b>\nimm\u00e9diatement exploit\u00e9es</b> c\u00f4t\u00e9 serveur pour g\u00e9n\u00e9rer une page de \nr\u00e9sultats \u00e0 l'utilisateur. Si les donn\u00e9es utilisateur ne sont pas correctement \n\u00e9chapp\u00e9es et valid\u00e9es avant leur affichage, alors le navigateur du client peut \npotentiellement les consid\u00e9rer comme un script qu'il va ex\u00e9cuter. \n</li><li><u>les <b>XSS persistants (stored \nXSS)</b></u>: ces failles conduisent aux attaques XSS <b>les plus puissantes et les plus \ndangereuses</b>. Ce type d'attaque se produit lorsque les donn\u00e9es&nbsp;entr\u00e9es par \nl'utilisateur sont <b>stock\u00e9es de mani\u00e8re permanente</b> sur le serveur, puis affich\u00e9es \nult\u00e9rieurement \u00e0 un ou des utilisateurs sans \u00e9chappement ni une \nvalidation&nbsp;suffisante pr\u00e9alable. Une seule injection de code XSS peut ainsi \nimpacter de nombreux clients. Dans le cas o\u00f9 une base de donn\u00e9es est partag\u00e9e \npar plusieurs applications, une application peut \u00eatre impact\u00e9e par des donn\u00e9es \nayant transit\u00e9 vers la base de donn\u00e9es via une autre application. \n</li><li><u>les<b> XSS bas\u00e9s sur le&nbsp;DOM</b>&nbsp;(Document Object \nModel - <b>DOM-based XSS</b>)</u>: ce type de faille est <b>moins connu</b> mais il s'agit n\u00e9anmoins d'une faille<b> dangereuse et difficile \u00e0 d\u00e9tecter</b> (pour le hacker comme pour le programmeur). Ici le code malicieux ne transite pas \npar le serveur. Il <b>s'ex\u00e9cute directement c\u00f4t\u00e9 client via une modification du DOM</b>. Pour donner un exemple simple, le code malicieux peut \u00eatre entr\u00e9e via la commande document.write();<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "5 D\u00e9tails types de faille XSS",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur sans \u00e9chappement pr\u00e9alable, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page HTML ou XHTML. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur sans \u00e9chappement pr\u00e9alable, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur sans \u00e9chappement pr\u00e9alable, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels au lieu d'\u00eatre interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page HTML ou XHTML. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur sans \u00e9chappement pr\u00e9alable, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'ils soient affich\u00e9s en tant que tels et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page HTML ou XHTML. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur sans \u00e9chappement pr\u00e9alable, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "10 Outils de d\u00e9tection",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "Non, \u00e7a n'est pas tout.<br><ul><li>Pour \u00e9viter le vol de cookie il est utile de param\u00e9trer l'objet <b>session</b> en for\u00e7ant l'attribut <b>&lt;http-only&gt;</b> \u00e0 la valeur <b>true</b>.</li><li>Il faut aussi \u00eatre<b> vigilant</b> sur les <b>biblioth\u00e8ques et les composants</b> que l'on utilise pour programmer. Par d\u00e9faut, la JSF Java \u00e9chappe tout ce qu'elle contient, m\u00eame le texte qui n'est pas inclus dans une balise. Par contre, les premi\u00e8res versions de la biblioth\u00e8que Primefaces contenaient de nombreuses failles XSS. Ces failles ont \u00e9t\u00e9 corrig\u00e9es au fur et \u00e0 mesure et la version 4 semble fiable. <br></li><li>De mani\u00e8re g\u00e9n\u00e9rale, il est important de <b>faire les mises \u00e0 jour de s\u00e9curit\u00e9</b> des programmes et d'utiliser, dans la mesure du possible,<b> les derni\u00e8res versions</b> des API et biblioth\u00e8ques java.<br></li><li>Enfin, pour ce qui est du <b>DOM-based XSS</b>, c'est <b>plus compliqu\u00e9</b>. Un d\u00e9veloppeur java qui code une application Java EE en utilisant la JSF et Primefaces n'a pas vraiment la main sur ces aspects. La fin de ce tutorial contient des liens que vous pourrez suivre pour en savoir plus.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "10 Outils de d\u00e9tection",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "Non, \u00e7a n'est pas tout.<br><ul><li>Pour \u00e9viter le vol de cookie il est utile de param\u00e9trer l'objet <b>session</b> en for\u00e7ant l'attribut <b>&lt;http-only&gt;</b> \u00e0 la valeur <b>true</b>.</li><li>Il faut aussi \u00eatre<b> vigilant</b> sur les <b>biblioth\u00e8ques et les composants</b> que l'on utilise pour programmer. Par d\u00e9faut, la JSF Java \u00e9chappe tout ce qu'elle contient, m\u00eame le texte qui n'est pas inclu dans une balise. Par contre, les premi\u00e8res versions de la biblioth\u00e8que Primefaces contenaient de nombreuses failles XSS. Ces failles ont \u00e9t\u00e9 corrig\u00e9es au fur et \u00e0 mesure et la version 4 semble fiable. <br></li><li>De mani\u00e8re g\u00e9n\u00e9rale, il est important de <b>faire les mises \u00e0 jour de s\u00e9curit\u00e9</b> des programmes et d'utiliser, dans la mesure du possible,<b> les derni\u00e8res versions</b> des API et biblioth\u00e8ques java.<br></li><li>Enfin, pour ce qui est du <b>DOM-based XSS</b>, c'est <b>plus compliqu\u00e9</b>. Un d\u00e9veloppeur java qui code une application Java EE en utilisant la JSF et Primefaces n'a pas vraiment la main sur ces aspects. La fin de ce tutorial contient des liens que vous pourrez suivre pour en savoir plus.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "9 Lutte (2)",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b>, sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne connait rein de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (penetration test en anglais)</b>, sont souvent r\u00e9alis\u00e9 en mode black-box (le testeur ne connait rein de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "10 Outils de d\u00e9tection",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b> sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne connait rein de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b>, sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne connait rein de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "10 Outils de d\u00e9tection",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b> sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne conna\u00eet rien de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b> sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne connait rein de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "10 Outils de d\u00e9tection",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b> sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne conna\u00eet rien de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "11 Quelques liens utiles",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "La d\u00e9tection des failles XSS peut se faire soit via des tests d'intrusion, soit par l'analyse du code.<br><ul><li>Les<b> tests d'intrusion (\"penetration tests\" en anglais)</b> sont souvent r\u00e9alis\u00e9s en mode black-box (le testeur ne conna\u00eet rien de l'application) ou grey-box (le testeur conna\u00eet le nom de certaines variables susceptibles de repr\u00e9senter des failles XSS). En gros le principe de ces tests est d'essayer d'injecter des scripts dans l'application. Ces tests peuvent \u00eatre fait manuellement (ce qui demande une certaine ma\u00eetrise des attaques XSS) ou automatiquement gr\u00e2ce \u00e0 des <b>outils d\u00e9di\u00e9s</b>.</li><li>l'<b>analyse directe du code</b> (white-box testing) consiste \u00e0 rechercher les failles XSS <b>directement en parcourant le code</b>. L'id\u00e9e g\u00e9n\u00e9rale est de rechercher toutes les donn\u00e9es entr\u00e9es \u00e0 un moment ou \u00e0 un autre par un utilisateur, et de v\u00e9rifier que ces donn\u00e9es soient bien valid\u00e9es et \u00e9chapp\u00e9es avant leur affichage.<br></li></ul>"
          ],
          "description": "Default"
        }
      ]
    },
    "state_name": "10 Outils de d\u00e9tection",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "END",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [""],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "END",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "11 Quelques liens utiles",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "END",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [
            "<ul><li>Pr\u00e9sentation des DOM-based XSS:</li></ul><p><oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org/index.php/DOM_Based_XSS&amp;quot;\"></oppia-noninteractive-link></p><ul><li>Pr\u00e9vention des failles XSS:</li></ul><p><oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet&amp;quot;\"></oppia-noninteractive-link></p><ul><li>Pr\u00e9vention des failles XSS DOM-based:</li></ul><p><oppia-noninteractive-link open_link_in_same_window-with-value=\"\" url-with-value=\"&amp;quot;https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet&amp;quot;\"></oppia-noninteractive-link></p>"
          ],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "END",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [""],
          "description": "Default"
        }
      ]
    },
    "state_name": "11 Quelques liens utiles",
    "property_name": "widget_handlers"
  }
]
