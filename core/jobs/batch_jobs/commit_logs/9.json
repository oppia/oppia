[
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  },
  {
    "new_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "cmd": "edit_state_property",
    "old_value": {
      "submit": [
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 0 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Oui c'est vrai,<b> la plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant correctement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles transitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi <b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que l'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro de t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML </b>car m\u00eame un lien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une faille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de l'application (\u00e0 travers un param\u00e8tre d'url par exemple).<br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 1 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Bravo, c'est la meilleure r\u00e9ponse. <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur </b>(y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien HTTP ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). "
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": {
            "rule_type": "atomic",
            "inputs": { "x": 2 },
            "name": "Equals",
            "subject": "answer"
          },
          "param_changes": [],
          "feedback": [
            "Pas de souci, voici quelques explications :<br>L'<b>\u00e9chappement</b> consiste \u00e0 <b>encoder les caract\u00e8res sp\u00e9ciaux</b> pour qu'il soient affich\u00e9s en tant que tel et non interpr\u00e9t\u00e9s par les navigateurs lors de l'affichage d'une page html ou xhtml. Par exemple, si &lt;script&gt; alert('faille!');&lt;/script&gt; est envoy\u00e9 \u00e0 un navigateur, l'interpr\u00e9teur du navigateur va interpr\u00e9ter cette suite de caract\u00e8res comme un bout de code javascript et afficher une fen\u00eatre popup d'alerte contenant le texte 'faille !' au client. <b>Gr\u00e2ce \u00e0 l'\u00e9chappement, l'interpr\u00e9teur du navigateur ne va rien interpr\u00e9ter du tout </b>et le navigateur affichera simplement &lt;script&gt; alert('faille!');&lt;/script&gt;. <br> <b>La plupart des failles XSS peuvent \u00eatre \u00e9vit\u00e9es en \u00e9chappant \ncorrectement les donn\u00e9es entr\u00e9es par l'utilisateur</b> (y compris celles \ntransitant par une base de donn\u00e9es). G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re aussi \n<b>valider</b> les donn\u00e9es avant de les \u00e9chapper, afin de s'assurer que \nl'utilisateur ne rentre pas n'importe quoi (comme par exemple un num\u00e9ro \nde t\u00e9l\u00e9phone en lettres). En fait il faut <b>tout \u00e9chapper dans les pages HTML ou XHTML</b> car m\u00eame un \nlien http ou l'attribut \"head\" d'une balise peuvent conduire \u00e0 une \nfaille XSS s'il est possible d'y acc\u00e9der depuis l'ext\u00e9rieur de \nl'application (\u00e0 travers un param\u00e8tre d'url par exemple). <br><br>"
          ],
          "description": "is equal to {{x|NonnegativeInt}}"
        },
        {
          "dest": "9 Lutte (2)",
          "definition": { "rule_type": "default" },
          "param_changes": [],
          "feedback": [],
          "description": "Default"
        }
      ]
    },
    "state_name": "8 Lutte",
    "property_name": "widget_handlers"
  }
]
