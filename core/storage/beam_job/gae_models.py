# coding: utf-8
#
# Copyright 2021 The Oppia Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Models for managing Apache Beam jobs."""

from __future__ import absolute_import  # pylint: disable=import-only-modules
from __future__ import unicode_literals  # pylint: disable=import-only-modules

from core.platform import models

(base_models,) = models.Registry.import_models([models.NAMES.base_model])

datastore_services = models.Registry.import_datastore_services()

# The job is currently running.
BEAM_JOB_STATE_RUNNING = 'RUNNING'
# The job has been created but is not yet running. Jobs that are pending may
# only transition to RUNNING, or FAILED.
BEAM_JOB_STATE_PENDING = 'PENDING'
# The job has not yet started to run.
BEAM_JOB_STATE_STOPPED = 'STOPPED'
# The job has has been explicitly cancelled and is in the process of stopping.
# Jobs that are cancelling may only transition to CANCELLED or FAILED.
BEAM_JOB_STATE_CANCELLING = 'CANCELLING'
# The job has has been explicitly cancelled. This is a terminal job state. This
# state may only be set via a Cloud Dataflow jobs.update call, and only if the
# job has not yet reached another terminal state.
BEAM_JOB_STATE_CANCELLED = 'CANCELLED'
# The job is in the process of draining. A draining job has stopped pulling from
# its input sources and is processing any data that remains in-flight. This
# state may be set via a Cloud Dataflow jobs.update call, but only as a
# transition from RUNNING. Jobs that are draining may only transition
# to DRAINED, CANCELLED, or FAILED.
BEAM_JOB_STATE_DRAINING = 'DRAINING'
# The job has been drained. A drained job terminated by stopping pulling from
# its input sources and processing any data that remained in-flight when
# draining was requested. This state is a terminal state, may only be set by the
# Cloud Dataflow service, and only as a transition from DRAINING.
BEAM_JOB_STATE_DRAINED = 'DRAINED'
# The job was successfully updated, meaning that this job was stopped and
# another job was started, inheriting state from this one. This is a terminal
# job state. This state may only be set by the Cloud Dataflow service, and only
# as a transition from RUNNING.
BEAM_JOB_STATE_UPDATED = 'UPDATED'
# The job has successfully completed. This is a terminal job state. This state
# may be set by the Cloud Dataflow service, as a transition from
# RUNNING. It may also be set via a Cloud Dataflow jobs.update call,
# if the job has not yet reached a terminal state.
BEAM_JOB_STATE_DONE = 'DONE'
# The job has has failed. This is a terminal job state. This state may only be
# set by the Cloud Dataflow service, and only as a transition from RUNNING.
BEAM_JOB_STATE_FAILED = 'FAILED'
# The job's run state isn't specified.
BEAM_JOB_STATE_UNKNOWN = 'UNKNOWN'


class BeamJobRunModel(base_models.BaseModel):
    """Represents an individual execution of an Apache Beam job.

    IDs are generated by Google Cloud Dataflow, not Oppia.
    """

    # The name of the job class that implements the job's logic.
    job_name = datastore_services.StringProperty(required=True)
    # The arguments provided to the job run.
    job_arguments = datastore_services.StringProperty(repeated=True)
    # The state of the job at the time the model was last updated.
    latest_job_state = datastore_services.StringProperty(choices=[
        BEAM_JOB_STATE_DONE, BEAM_JOB_STATE_FAILED,
        BEAM_JOB_STATE_RUNNING, BEAM_JOB_STATE_PENDING,
        BEAM_JOB_STATE_UPDATED, BEAM_JOB_STATE_STOPPED,
        BEAM_JOB_STATE_CANCELLING, BEAM_JOB_STATE_CANCELLED,
        BEAM_JOB_STATE_DRAINING, BEAM_JOB_STATE_DRAINED,
        BEAM_JOB_STATE_UNKNOWN
    ], required=True)

    @property
    def in_terminal_state(self):
        """Returns whether the job run has reached a terminal state and will no
        longer run.

        Returns:
            bool. Whether the job has reached a terminal state.
        """
        return self.latest_job_state in [
            BEAM_JOB_STATE_CANCELLED, BEAM_JOB_STATE_DRAINED,
            BEAM_JOB_STATE_UPDATED, BEAM_JOB_STATE_DONE, BEAM_JOB_STATE_FAILED
        ]

    @staticmethod
    def get_deletion_policy():
        """Model doesn't contain any data directly corresponding to a user."""
        return base_models.DELETION_POLICY.NOT_APPLICABLE

    @staticmethod
    def get_model_association_to_user():
        """Model does not contain user data."""
        return base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER

    @classmethod
    def get_export_policy(cls):
        """Model doesn't contain any data directly corresponding to a user."""
        return dict(super(BeamJobRunModel, cls).get_export_policy(), **{
            'job_name': base_models.EXPORT_POLICY.NOT_APPLICABLE,
            'job_arguments': base_models.EXPORT_POLICY.NOT_APPLICABLE,
            'latest_job_state': base_models.EXPORT_POLICY.NOT_APPLICABLE,
        })


class BeamJobRunResultModel(base_models.BaseModel):
    """Represents the result of an Apache Beam job.

    IDs are generated by Google Cloud Dataflow, not Oppia.
    """

    # The unordered text output generated by the corresponding Apache Beam job.
    stdout = datastore_services.TextProperty(repeated=True)
    # The unordered error output generated by the corresponding Apache Beam job.
    stderr = datastore_services.TextProperty(repeated=True)

    @staticmethod
    def get_deletion_policy():
        """Model doesn't contain any data directly corresponding to a user."""
        return base_models.DELETION_POLICY.NOT_APPLICABLE

    @staticmethod
    def get_model_association_to_user():
        """Model does not contain user data."""
        return base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER

    @classmethod
    def get_export_policy(cls):
        """Model doesn't contain any data directly corresponding to a user."""
        return dict(super(BeamJobRunResultModel, cls).get_export_policy(), **{
            'stdout': base_models.EXPORT_POLICY.NOT_APPLICABLE,
            'stderr': base_models.EXPORT_POLICY.NOT_APPLICABLE,
        })
