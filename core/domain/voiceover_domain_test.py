# coding: utf-8
#
# Copyright 2024 The Oppia Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for domain objects related to voiceovers."""

from __future__ import annotations

from core import feconf
from core import utils
from core.domain import state_domain
from core.domain import voiceover_domain
from core.tests import test_utils


class EntityVoiceoversUnitTests(test_utils.GenericTestBase):
    """Test for EntityVoiceovers domain class."""

    def setUp(self) -> None:
        super().setUp()

        self.dummy_manual_voiceover_dict: state_domain.VoiceoverDict = {
            'filename': 'filename1.mp3',
            'file_size_bytes': 3000,
            'needs_update': False,
            'duration_secs': 6.1
        }
        self.dummy_autogenerated_voiceover_dict: state_domain.VoiceoverDict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 3500,
            'needs_update': False,
            'duration_secs': 5.9
        }

        self.entity_voiceovers_instance = voiceover_domain.EntityVoiceovers(
            entity_id='exp_id',
            entity_type=feconf.ENTITY_TYPE_EXPLORATION,
            entity_version=1,
            language_accent_code='en-US',
            voiceovers_mapping={
                'content_id_0': {
                    feconf.VoiceoverType.MANUAL: (
                        state_domain.Voiceover.from_dict(
                            self.dummy_manual_voiceover_dict)),
                    feconf.VoiceoverType.AUTO: (
                        state_domain.Voiceover.from_dict(
                            self.dummy_autogenerated_voiceover_dict))
                }
            }
        )
        self.entity_voiceovers_instance.validate()

    def test_to_dict_method_of_entity_voiceovers_class(self) -> None:
        expected_entity_voiceovers_dict = {
            'entity_id': 'exp_id',
            'entity_type': 'exploration',
            'entity_version': 1,
            'language_accent_code': 'en-US',
            'voiceovers_mapping': {
                'content_id_0': {
                    'manual': self.dummy_manual_voiceover_dict,
                    'auto': self.dummy_autogenerated_voiceover_dict
                }
            }
        }
        self.assertDictEqual(
            self.entity_voiceovers_instance.to_dict(),
            expected_entity_voiceovers_dict)

    def test_from_dict_method_of_entity_voiceovers_class(self) -> None:
        entity_voiceovers_dict: voiceover_domain.EntityVoiceoversDict = {
            'entity_id': 'exp_id',
            'entity_type': 'exploration',
            'entity_version': 1,
            'language_accent_code': 'en-US',
            'voiceovers_mapping': {
                'content_id_0': {
                    'manual': self.dummy_manual_voiceover_dict,
                    'auto': self.dummy_autogenerated_voiceover_dict
                }
            }
        }
        expected_entity_voiceovers_instance = (
            voiceover_domain.EntityVoiceovers.from_dict(entity_voiceovers_dict))

        self.assertDictEqual(
            entity_voiceovers_dict,
            expected_entity_voiceovers_instance.to_dict())

    def test_validate_entity_id(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_id must be a string'
        ):
            self.entity_voiceovers_instance.entity_id = 123  # type: ignore[assignment]
            self.entity_voiceovers_instance.validate()

    def test_validate_entity_version(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_version must be an int'
        ):
            self.entity_voiceovers_instance.entity_version = 'version'  # type: ignore[assignment]
            self.entity_voiceovers_instance.validate()

    def test_validate_entity_type(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_type must be a string'
        ):
            self.entity_voiceovers_instance.entity_type = 1  # type: ignore[assignment]
            self.entity_voiceovers_instance.validate()

    def test_validate_datatype_of_voiceover_type(self) -> None:
        self.entity_voiceovers_instance.voiceovers_mapping[
            'content_id_0'][feconf.VoiceoverType.MANUAL] = None
        self.entity_voiceovers_instance.validate()

        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'voiceover type must be VoiceoverType'
        ):
            self.entity_voiceovers_instance.voiceovers_mapping[
                'content_id_0'][1] = ( # type: ignore[index]
                    self.entity_voiceovers_instance.voiceovers_mapping[
                        'content_id_0'][feconf.VoiceoverType.MANUAL])
            self.entity_voiceovers_instance.validate()

    def test_validate_language_accent_code(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'language_accent_code must be a string'
        ):
            self.entity_voiceovers_instance.language_accent_code = 1  # type: ignore[assignment]
            self.entity_voiceovers_instance.validate()

    def test_validate_language_accent_code_pattern(self) -> None:
        expected_error_msg = (
            'language_accent_code must be formatted as '
            '{{language}}-{{accent}}')

        with self.assertRaisesRegex(utils.ValidationError, expected_error_msg):
            self.entity_voiceovers_instance.language_accent_code = 'en'
            self.entity_voiceovers_instance.validate()

        with self.assertRaisesRegex(utils.ValidationError, expected_error_msg):
            self.entity_voiceovers_instance.language_accent_code = 'en-'
            self.entity_voiceovers_instance.validate()

        with self.assertRaisesRegex(utils.ValidationError, expected_error_msg):
            self.entity_voiceovers_instance.language_accent_code = 'enUS'
            self.entity_voiceovers_instance.validate()

    def test_validate_content_id(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'content_id must be a string'
        ):
            self.entity_voiceovers_instance.voiceovers_mapping[1] = None # type: ignore[index, assignment]
            self.entity_voiceovers_instance.validate()

    def test_add_voiceovers_correctly(self) -> None:
        dummy_new_voiceover_dict: state_domain.VoiceoverDict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 4000,
            'needs_update': False,
            'duration_secs': 6.0
        }
        new_voiceover_object = state_domain.Voiceover.from_dict(
            dummy_new_voiceover_dict)
        manual_voiceover = self.entity_voiceovers_instance.voiceovers_mapping[
            'content_id_0'][feconf.VoiceoverType.MANUAL]
        assert isinstance(manual_voiceover, state_domain.Voiceover)
        self.assertDictEqual(
            manual_voiceover.to_dict(),
            self.dummy_manual_voiceover_dict
        )

        self.entity_voiceovers_instance.add_voiceover(
            content_id='content_id_0',
            voiceover_type=feconf.VoiceoverType.MANUAL,
            voiceovers_mapping=new_voiceover_object)

        manual_voiceover = self.entity_voiceovers_instance.voiceovers_mapping[
            'content_id_0'][feconf.VoiceoverType.MANUAL]
        assert isinstance(manual_voiceover, state_domain.Voiceover)
        self.assertDictEqual(
            manual_voiceover.to_dict(),
            dummy_new_voiceover_dict
        )

    def test_removes_voiceover_correctly(self) -> None:
        self.assertIsNotNone(
            self.entity_voiceovers_instance.voiceovers_mapping[
                'content_id_0'][feconf.VoiceoverType.MANUAL])
        self.assertIsNotNone(
            self.entity_voiceovers_instance.voiceovers_mapping[
                'content_id_0'][feconf.VoiceoverType.AUTO])

        self.entity_voiceovers_instance.remove_voiceover(
            content_id='content_id_0',
            voiceover_type=feconf.VoiceoverType.MANUAL
        )

        self.assertIsNone(
            self.entity_voiceovers_instance.voiceovers_mapping[
                'content_id_0'][feconf.VoiceoverType.MANUAL])

        self.entity_voiceovers_instance.remove_voiceover(
            content_id='content_id_0',
            voiceover_type=feconf.VoiceoverType.AUTO
        )

        self.assertFalse(
            'content_id_0' in
            self.entity_voiceovers_instance.voiceovers_mapping)

    def test_create_empty_entity_voiceovers(self) -> None:
        empty_entity_voiceovers = (
            voiceover_domain.EntityVoiceovers.create_empty(
                'exp_id', 'exploration', 1, 'en-US'))

        self.assertEqual(empty_entity_voiceovers.entity_id, 'exp_id')
        self.assertEqual(empty_entity_voiceovers.entity_version, 1)
        self.assertEqual(
            empty_entity_voiceovers.entity_type, 'exploration')
        self.assertEqual(
            empty_entity_voiceovers.language_accent_code, 'en-US')
        self.assertEqual(empty_entity_voiceovers.voiceovers_mapping, {})

    def test_should_be_able_to_add_new_content_id(self) -> None:
        entity_voiceovers_object = (
            voiceover_domain.EntityVoiceovers.create_empty(
                'exp_id', 'exploration', 1, 'en-US'))

        self.assertEqual(entity_voiceovers_object.entity_id, 'exp_id')
        self.assertEqual(entity_voiceovers_object.entity_version, 1)
        self.assertEqual(
            entity_voiceovers_object.entity_type, 'exploration')
        self.assertEqual(
            entity_voiceovers_object.language_accent_code, 'en-US')
        self.assertEqual(entity_voiceovers_object.voiceovers_mapping, {})

        entity_voiceovers_object.add_new_content_id_without_voiceovers(
            'content_1')
        entity_voiceovers_object.add_voiceover(
            'content_1',
            feconf.VoiceoverType.MANUAL,
            state_domain.Voiceover.from_dict(self.dummy_manual_voiceover_dict))

        manual_voiceover = entity_voiceovers_object.voiceovers_mapping[
            'content_1'][feconf.VoiceoverType.MANUAL]
        assert isinstance(manual_voiceover, state_domain.Voiceover)

        self.assertDictEqual(
            manual_voiceover.to_dict(),
            self.dummy_manual_voiceover_dict)

    def test_is_both_voiceovers_empty_should_return_successfully(self) -> None:
        entity_voiceovers_object = (
            voiceover_domain.EntityVoiceovers.create_empty(
                'exp_id', 'exploration', 1, 'en-US'))
        dummy_new_voiceover_dict: state_domain.VoiceoverDict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 4000,
            'needs_update': False,
            'duration_secs': 6.0
        }
        new_voiceover_object = state_domain.Voiceover.from_dict(
            dummy_new_voiceover_dict)
        entity_voiceovers_object.add_new_content_id_without_voiceovers(
            'content_0')

        self.assertTrue(
            entity_voiceovers_object.is_both_voiceovers_empty('content_0'))

        entity_voiceovers_object.add_voiceover(
            content_id='content_0',
            voiceover_type=feconf.VoiceoverType.MANUAL,
            voiceovers_mapping=new_voiceover_object)

        self.assertFalse(
            entity_voiceovers_object.is_both_voiceovers_empty('content_0'))
