
  <!DOCTYPE html>
  <html>
    <head>
      <title>data.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">extensions/interactions/LogicProof/static/js/data.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">949</td><td class="">949</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Contains logic proof data.
 */

var logicProofData = (function() {
  var BASE_VOCABULARY = {
    from: [&#x27;from&#x27;],
    and: [&#x27;and&#x27;],
    have: [&#x27;we have&#x27;, &#x27;we know&#x27;, &#x27;have&#x27;],
    hence: [&#x27;hence&#x27;, &#x27;so&#x27;, &#x27;thus&#x27;, &#x27;thence&#x27;, &#x27;whence&#x27;],
    whichever: [
      &#x27;and whichever is true&#x27;, &#x27;and either way&#x27;, &#x27;and in either case&#x27;
    ],
    arbitrary: [&#x27;was arbitrary&#x27;, &#x27;is arbitrary&#x27;],
    take: [&#x27;take&#x27;],
    satisfying: [&#x27;satisfying&#x27;, &#x27;such that&#x27;],
    // eslint-disable-next-line quote-props
    &#x27;if&#x27;: [&#x27;if&#x27;],
    given: [&#x27;given&#x27;],
    contradiction: [&#x27;contradiction&#x27;],
    at: [&#x27;at&#x27;]
  };

  var SINGLE_BOOLEAN = {
    type: &#x27;boolean&#x27;,
    arbitrarily_many: false
  };
  var SINGLE_ELEMENT = {
    type: &#x27;element&#x27;,
    arbitrarily_many: false
  };

  // NOTE: By default, &#x27;and&#x27; &amp; &#x27;or&#x27; must be binary.
  // NOTE: We are not yet using the display keys from the kinds (we are using
  // symbol keys from the list of operators).
  var BASE_STUDENT_LANGUAGE = {
    types: {
      // eslint-disable-next-line quote-props
      &#x27;boolean&#x27;: {
        quantifiable: false
      },
      element: {
        quantifiable: true
      }
    },
    kinds: {
      binary_connective: {
        display: [{
          format: &#x27;argument_index&#x27;,
          content: 0
        }, {
          format: &#x27;name&#x27;
        }, {
          format: &#x27;argument_index&#x27;,
          content: 1
        }]
      },
      unary_connective: {
        matchable: false,
        display: [{
          format: &#x27;name&#x27;
        }, {
          format: &#x27;argument_index&#x27;,
          content: 0
        }]
      },
      quantifier: {
        matchable: false,
        display: [{
          format: &#x27;name&#x27;
        }, {
          format: &#x27;dummy_index&#x27;,
          content: 0
        }, {
          format: &#x27;string&#x27;,
          content: &#x27;.&#x27;
        }, {
          format: &#x27;argument_index&#x27;,
          conent: 0
        }]
      },
      binary_function: {
        matchable: false,
        display: [{
          format: &#x27;argument_index&#x27;,
          content: 0
        }, {
          format: &#x27;name&#x27;
        }, {
          format: &#x27;argument_index&#x27;,
          content: 1
        }],
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }]
      },
      prefix_function: {
        matchable: false,
        typing: [{
          arguments: [{
            type: &#x27;element&#x27;,
            arbitrarily_many: true
          }],
          dummies: [],
          output: &#x27;element&#x27;
        }, {
          arguments: [{
            type: &#x27;element&#x27;,
            arbitrarily_many: true
          }],
          dummies: [],
          output: &#x27;boolean&#x27;
        }]
      },
      constant: {
        matchable: false,
        display: [{
          format: &#x27;name&#x27;
        }],
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;element&#x27;
        }]
      },
      variable: {
        matchable: true,
        display: [{
          format: &#x27;name&#x27;
        }],
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;element&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;boolean&#x27;
        }]
      }
    },
    operators: {
      and: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2227&#x27;]
      },
      or: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2228&#x27;]
      },
      implies: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;=&gt;&#x27;]
      },
      iff: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;=&gt;&#x27;]
      },
      not: {
        kind: &#x27;unary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;~&#x27;]
      },
      for_all: {
        kind: &#x27;quantifier&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN],
          dummies: [SINGLE_ELEMENT],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2200&#x27;, &#x27;.&#x27;]
      },
      exists: {
        kind: &#x27;quantifier&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN],
          dummies: [SINGLE_ELEMENT],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2203&#x27;, &#x27;.&#x27;]
      },
      equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;=&#x27;]
      },
      not_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;!=&#x27;]
      },
      less_than: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;&#x27;]
      },
      greater_than: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&gt;&#x27;]
      },
      less_than_or_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;=&#x27;]
      },
      greater_than_or_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&gt;=&#x27;]
      },
      addition: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }],
        symbols: [&#x27;+&#x27;]
      },
      subtraction: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }],
        symbols: [&#x27;-&#x27;]
      },
      multiplication: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }],
        symbols: [&#x27;*&#x27;]
      },
      division: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }],
        symbols: [&#x27;/&#x27;]
      },
      exponentiation: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_ELEMENT, SINGLE_ELEMENT],
          dummies: [],
          output: &#x27;element&#x27;
        }],
        symbols: [&#x27;^&#x27;]
      }
    }
  };

  var SINGLE_INTEGER = {
    type: &#x27;integer&#x27;,
    arbitrarily_many: false
  };
  var SINGLE_STRING = {
    type: &#x27;string&#x27;,
    arbitrarily_many: false
  };
  var SINGLE_FORMULA = {
    type: &#x27;formula&#x27;,
    arbitrarily_many: false
  };
  var SINGLE_SET_OF_FORMULAS = {
    type: &#x27;set_of_formulas&#x27;,
    arbitrarily_many: false
  };

  var BASE_CONTROL_LANGUAGE = {
    types: {
      // eslint-disable-next-line quote-props
      &#x27;boolean&#x27;: {
        quantifiable: false
      },
      // Used for line numbers &amp; indentation.
      integer: {
        quantifiable: true
      },
      // Used for line.template.
      string: {
        quantifiable: false
      },
      // Used for matchings, target.
      formula: {
        quantifiable: true
      },
      // Used for antecedents, results &amp; assumptions.
      set_of_formulas: {
        quantifiable: false
      }
    },

    kinds: {
      binary_connective: {},
      unary_connective: {},
      quantifier: {},
      bounded_quantifier: {},
      binary_relation: {},
      binary_function: {},
      // NOTE: new prefix_functions will be explicitely added by making
      // definitions, and from these definitions their types will be known.
      // Thus it is not necessary for their kinds to have typing rules (and
      // such typing rules would in any case have to be inconveniently long).
      prefix_function: {},
      ranged_function: {},
      constant: {
        matchable: false,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;integer&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;string&#x27;
        }]
      },
      variable: {
        matchable: true,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;integer&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;string&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;formula&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }, {
          arguments: [],
          dummies: [],
          output: &#x27;boolean&#x27;
        }]
      }
    },
    operators: {
      and: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [{
            type: &#x27;boolean&#x27;,
            arbitrarily_many: true
          }],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2227&#x27;]
      },
      or: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [{
            type: &#x27;boolean&#x27;,
            arbitrarily_many: true
          }],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2228&#x27;]
      },
      implies: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;=&gt;&#x27;]
      },
      iff: {
        kind: &#x27;binary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;=&gt;&#x27;]
      },
      not: {
        kind: &#x27;unary_connective&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;~&#x27;]
      },
      equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_STRING, SINGLE_STRING],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_FORMULA, SINGLE_FORMULA],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;=&#x27;]
      },
      not_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_STRING, SINGLE_STRING],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_FORMULA, SINGLE_FORMULA],
          dummies: [],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;!=&#x27;]
      },
      less_than: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;&#x27;]
      },
      greater_than: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&gt;&#x27;]
      },
      less_than_or_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&lt;=&#x27;]
      },
      greater_than_or_equals: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;&gt;=&#x27;]
      },
      is_in: {
        kind: &#x27;binary_relation&#x27;,
        typing: [{
          arguments: [SINGLE_FORMULA, SINGLE_SET_OF_FORMULAS],
          dummies: [],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2208&#x27;]
      },
      addition: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;integer&#x27;
        }],
        symbols: [&#x27;+&#x27;]
      },
      subtraction: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;integer&#x27;
        }],
        symbols: [&#x27;-&#x27;]
      },
      multiplication: {
        kind: &#x27;binary_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;integer&#x27;
        }],
        symbols: [&#x27;*&#x27;]
      },
      bounded_for_all: {
        kind: &#x27;bounded_quantifier&#x27;,
        typing: [{
          // The first argument is the bounding.
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_INTEGER],
          output: &#x27;boolean&#x27;
        }, {
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_INTEGER],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2200&#x27;, &#x27;.&#x27;]
      },
      bounded_exists: {
        kind: &#x27;bounded_quantifier&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_INTEGER],
          output: &#x27;boolean&#x27;
        }, {
          // The first argument is the bounding.
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_FORMULA],
          output: &#x27;boolean&#x27;
        }],
        symbols: [&#x27;\u2203&#x27;, &#x27;.&#x27;]
      },
      // This has form min{n&lt;m|A(n)}, A(n) is the argument and n the dummy, or
      // alteratively min{p∈antecedents(n)|B(p)} which will return the first
      // element of set_of_formulas antecedents(n) satisfying B.
      min: {
        kind: &#x27;ranged_function&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_INTEGER],
          output: &#x27;integer&#x27;
        }, {
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_FORMULA],
          output: &#x27;formula&#x27;
        }],
        symbols: [&#x27;min&#x27;, &#x27;{&#x27;, &#x27;|&#x27;, &#x27;}&#x27;]
      },
      max: {
        kind: &#x27;ranged_function&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_INTEGER],
          output: &#x27;integer&#x27;
        }, {
          arguments: [SINGLE_BOOLEAN, SINGLE_BOOLEAN],
          dummies: [SINGLE_FORMULA],
          output: &#x27;formula&#x27;
        }],
        symbols: [&#x27;max&#x27;, &#x27;{&#x27;, &#x27;|&#x27;, &#x27;}&#x27;]
      },
      indentation: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;integer&#x27;
        }]
      },
      template: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;string&#x27;
        }]
      },
      antecedents: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      results: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      variables: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      text: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER],
          dummies: [],
          output: &#x27;string&#x27;
        }]
      },
      element: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_STRING, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;formula&#x27;
        }]
      },
      num_lines: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;integer&#x27;
        }]
      },
      assumptions: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      target: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;formula&#x27;
        }]
      },
      question_variables: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      // eslint-disable-next-line quote-props
      &#x27;if&#x27;: {
        // NOTE: this prefix function is unusual in having a boolean input.
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_BOOLEAN, SINGLE_INTEGER, SINGLE_INTEGER],
          dummies: [],
          output: &#x27;integer&#x27;
        }, {
          arguments: [SINGLE_BOOLEAN, SINGLE_STRING, SINGLE_STRING],
          dummies: [],
          output: &#x27;string&#x27;
        }, {
          arguments: [SINGLE_BOOLEAN, SINGLE_FORMULA, SINGLE_FORMULA],
          dummies: [],
          output: &#x27;formula&#x27;
        }, {
          arguments: [
            SINGLE_BOOLEAN, SINGLE_SET_OF_FORMULAS, SINGLE_SET_OF_FORMULAS],
          dummies: [],
          output: &#x27;set_of_formulas&#x27;
        }]
      },
      entry: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_INTEGER, SINGLE_SET_OF_FORMULAS],
          dummies: [],
          output: &#x27;formula&#x27;
        }]
      },
      substitute: {
        kind: &#x27;prefix_function&#x27;,
        typing: [{
          arguments: [SINGLE_FORMULA, SINGLE_FORMULA, SINGLE_FORMULA],
          dummies: [],
          output: &#x27;formula&#x27;
        }]
      }
    }
  };

  var BASE_GENERAL_MESSAGES = {
    odd_number_spaces: {
      templates: [[{
        isFixed: true,
        content: (
          &#x27;An indentation is indicated by a double space at the start of &#x27; +
          &#x27;the line, but this line starts with an odd number of spaces.&#x27;)
      }]],
      parameters: {},
      category: &#x27;parsing&#x27;
    },
    unmatched_line: {
      templates: [[{
        isFixed: true,
        content: (
          &#x27;This line could not be identified as valid - please check the &#x27; +
          &#x27;list of possible lines.&#x27;)
      }]],
      parameters: {},
      category: &#x27;parsing&#x27;
    },
    wrong_kind_in_line: {
      templates: [[{
        isFixed: true,
        content: &#x27;In a line of this form, your &#x27;
      }, {
        isFixed: false,
        content: &#x27;expression&#x27;
      }, {
        isFixed: true,
        content: &#x27; should be a &#x27;
      }, {
        isFixed: false,
        content: &#x27;expected_kind&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        expression: {
          format: &#x27;expression&#x27;
        },
        expected_kind: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    unspecified_mistake: {
      templates: [[{
        isFixed: true,
        content: &#x27;This line contains a mistake in its &#x27;
      }, {
        isFixed: false,
        content: &#x27;section&#x27;
      }, {
        isFixed: true,
        content: &#x27; (with code &#x27;
      }, {
        isFixed: false,
        content: &#x27;entry&#x27;
      }, {
        isFixed: true,
        content: &#x27;).&#x27;
      }]],
      parameters: {
        section: {
          format: &#x27;string&#x27;
        },
        entry: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;mistake&#x27;
    },
    illegal_symbol: {
      templates: [[{
        isFixed: true,
        content: &#x27;The symbol &#x27;
      }, {
        isFixed: false,
        content: &#x27;symbol&#x27;
      }, {
        isFixed: true,
        content: &#x27; was not recognised.&#x27;
      }]],
      parameters: {
        symbol: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;parsing&#x27;
    },
    blank_line: {
      templates: [[{
        isFixed: true,
        content: &#x27;This line is blank.&#x27;
      }]],
      parameters: {},
      category: &#x27;parsing&#x27;
    },
    unidentified_word: {
      templates: [[{
        isFixed: true,
        content: &#x27;We could not identify \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;word&#x27;
      }, {
        isFixed: true,
        content: (
          &#x27;\&#x27;; please make sure you are using vocabulary from the &#x27; +
          &#x27;given list, and don\&#x27;t have two consecutive expressions.&#x27;)
      }]],
      parameters: {
        word: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;parsing&#x27;
    },
    unidentified_words: {
      templates: [[{
        isFixed: true,
        content: &#x27;We could not identify either of \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;word1&#x27;
      }, {
        isFixed: true,
        content: &#x27;\&#x27; or \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;word2&#x27;
      }, {
        isFixed: true,
        content: (
          &#x27;\&#x27; as words; please make sure you are using vocabulary from the &#x27; +
          &#x27;given list, and don\&#x27;t have two consecutive expressions.&#x27;)
      }]],
      parameters: {
        word1: {
          format: &#x27;string&#x27;
        },
        word2: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;parsing&#x27;
    },
    consecutive_expressions: {
      templates: [[{
        isFixed: true,
        content: &#x27;This line has two expressions in a row (&#x27;
      }, {
        isFixed: false,
        content: &#x27;word1&#x27;
      }, {
        isFixed: true,
        content: &#x27; and &#x27;
      }, {
        isFixed: false,
        content: &#x27;word2&#x27;
      }, {
        isFixed: true,
        content: &#x27;) which is not allowed.&#x27;
      }]],
      parameters: {
        word1: {
          format: &#x27;string&#x27;
        },
        word2: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;parsing&#x27;
    },
    unidentified_phrase_starting_at: {
      templates: [[{
        isFixed: true,
        content: &#x27;The phrase starting \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;word&#x27;
      }, {
        isFixed: true,
        content: (
          &#x27;\&#x27; could not be identified; please make sure you are only &#x27; +
          &#x27;using phrases from the given list of vocabulary.&#x27;)
      }]],
      parameters: {
        word: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;formattting&#x27;
    },
    forbidden_word: {
      templates: [[{
        isFixed: true,
        content: &#x27;The name \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;word&#x27;
      }, {
        isFixed: true,
        content: &#x27;\&#x27; is reserved for vocabulary and so cannot be used here.&#x27;
      }]],
      parameters: {
        word: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;parsing&#x27;
    },
    not_enough_inputs: {
      templates: [[{
        isFixed: false,
        content: &#x27;operator&#x27;
      }, {
        isFixed: true,
        content: &#x27; must have at least &#x27;
      }, {
        isFixed: false,
        content: &#x27;num_needed&#x27;
      }, {
        isFixed: true,
        content: &#x27; &#x27;
      }, {
        isFixed: false,
        content: &#x27;input_category&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        num_needed: {
          format: &#x27;string&#x27;
        },
        input_category: {
          format: &#x27;string&#x27;
        },
        operator: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    wrong_num_inputs: {
      templates: [[{
        isFixed: false,
        content: &#x27;operator&#x27;
      }, {
        isFixed: true,
        content: &#x27; must have &#x27;
      }, {
        isFixed: false,
        content: &#x27;num_needed&#x27;
      }, {
        isFixed: true,
        content: &#x27; &#x27;
      }, {
        isFixed: false,
        content: &#x27;input_category&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        num_needed: {
          format: &#x27;string&#x27;
        },
        input_category: {
          format: &#x27;string&#x27;
        },
        operator: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    wrong_kind: {
      templates: [[{
        isFixed: false,
        content: &#x27;operator&#x27;
      }, {
        isFixed: true,
        content: &#x27; is supposed to be a &#x27;
      }, {
        isFixed: false,
        content: &#x27;expected_kind&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        operator: {
          format: &#x27;string&#x27;
        },
        expected_kind: {
          format: &#x27;string&#x27;
        },
        actual_kind: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    wrong_type: {
      templates: [[{
        isFixed: false,
        content: &#x27;operator&#x27;
      }, {
        isFixed: true,
        content: &#x27; yields a &#x27;
      }, {
        isFixed: false,
        content: &#x27;actual_type&#x27;
      }, {
        isFixed: true,
        content: &#x27; but you are trying to use it to give a &#x27;
      }, {
        isFixed: false,
        content: &#x27;expected_type&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        operator: {
          format: &#x27;string&#x27;
        },
        expected_type: {
          format: &#x27;string&#x27;
        },
        actual_type: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    duplicate_dummy_name: {
      templates: [[{
        isFixed: true,
        content: &#x27;The name \&#x27;&#x27;
      }, {
        isFixed: false,
        content: &#x27;dummy&#x27;
      }, {
        isFixed: true,
        content: &#x27;\&#x27; is already in use and so cannot be quantified over in &#x27;
      }, {
        isFixed: false,
        content: &#x27;expression&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        dummy: {
          format: &#x27;expression&#x27;
        },
        expression: {
          format: &#x27;expression&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    dummy_not_variable: {
      templates: [[{
        isFixed: true,
        content: &#x27;You can only quantify over variables, not  &#x27;
      }, {
        isFixed: false,
        content: &#x27;dummy&#x27;
      }, {
        isFixed: true,
        content: &#x27;.&#x27;
      }]],
      parameters: {
        dummy: {
          format: &#x27;expression&#x27;
        },
        expression: {
          format: &#x27;expression&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    unknown_operator: {
      templates: [[{
        isFixed: true,
        content: &#x27;The operator &#x27;
      }, {
        isFixed: false,
        content: &#x27;operator&#x27;
      }, {
        isFixed: true,
        content: &#x27; could not be identified.&#x27;
      }]],
      parameters: {
        operator: {
          format: &#x27;string&#x27;
        }
      },
      category: &#x27;typing&#x27;
    },
    too_many_parsings: {
      templates: [[{
        isFixed: true,
        content: (
          &#x27;This can be parsed in too many different ways - try using fewer &#x27; +
          &#x27;words, especially single-character words.&#x27;)
      }]],
      parameters: {},
      category: &#x27;parsing&#x27;
    },
    too_many_typings: {
      templates: [[{
        isFixed: true,
        content: (
          &#x27;This has too many possible typings - try using fewer variables.&#x27;)
      }]],
      parameters: {}
    },
    category: &#x27;typing&#x27;
  };

  return {
    BASE_VOCABULARY: BASE_VOCABULARY,
    BASE_STUDENT_LANGUAGE: BASE_STUDENT_LANGUAGE,
    BASE_CONTROL_LANGUAGE: BASE_CONTROL_LANGUAGE,
    BASE_GENERAL_MESSAGES: BASE_GENERAL_MESSAGES
  };
})();

export default logicProofData;
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  