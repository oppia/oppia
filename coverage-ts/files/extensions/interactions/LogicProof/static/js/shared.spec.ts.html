
  <!DOCTYPE html>
  <html>
    <head>
      <title>shared.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">extensions/interactions/LogicProof/static/js/shared.spec.ts</td><td class="">92.59%</td><td class="">100%</td><td class="">405</td><td class="">375</td><td class="">30</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the shared components of the LogicProof
 * interaction.
 */

import logicProofShared from &#x27;interactions/LogicProof/static/js/shared&#x27;;
import logicProofData from &#x27;interactions/LogicProof/static/js/data&#x27;;
import logicProofParser from
  &#x27;interactions/LogicProof/static/js/generatedParser&#x27;;

describe(&#x27;Parse then display expressions&#x27;, function() {
  var parseThenDisplay = function(expressionString) {
    return logicProofShared.displayExpression(
      logicProofParser.parse(expressionString, &#x27;expression&#x27;),
      logicProofData.BASE_STUDENT_LANGUAGE.operators);
  };
  var parseThenDisplayControl = function(expressionString) {
    return logicProofShared.displayExpression(
      logicProofParser.parse(expressionString, &#x27;expression&#x27;),
      logicProofData.BASE_CONTROL_LANGUAGE.operators);
  };

  it(&#x27;should parse examples correctly&#x27;, function() {
    expect(parseThenDisplay(&#x27;p\u2227q&#x27;)).toEqual(&#x27;p\u2227q&#x27;);
    expect(parseThenDisplay(&#x27;(p+q)=r&#x27;)).toEqual(&#x27;(p+q)=r&#x27;);
    expect(parseThenDisplay(&#x27;p&lt;(\u2200x.(2+2))&#x27;)).toEqual(&#x27;p&lt;(\u2200x.(2+2))&#x27;);
    expect(
      parseThenDisplay(&#x27;((x=2)\u2227(\u2203y.(y=6)))=&gt;valid&#x27;)
    ).toEqual(&#x27;((x=2)\u2227(\u2203y.(y=6)))=&gt;valid&#x27;);
    expect(
      parseThenDisplayControl(&#x27;p\u2228(\u2200m\u2208S.A(m,S))&#x27;)
    ).toEqual(&#x27;p\u2228(\u2200m\u2208S.A(m,S))&#x27;);
    expect(
      parseThenDisplayControl(&#x27;min{a&lt;b|p\u2228(q\u2227r)}&#x27;)
    ).toEqual(&#x27;min{a&lt;b | p\u2228(q\u2227r)}&#x27;);
  });
});

describe(&#x27;Pre-parse lines&#x27;, function() {
  var preParse = function(lineString, isTemplate) {
    return logicProofShared.preParseLineString(
      lineString, logicProofData.BASE_STUDENT_LANGUAGE.operators, isTemplate);
  };
  var errorWrapper = function(
      dubiousFunction, input, parameter = null) {
    return function() {
      try {
        if (parameter === null) {
          dubiousFunction(input);
        } else {
          dubiousFunction(input, parameter);
        }
      } catch (err) {
        throw new Error(logicProofShared.renderError(
          err, logicProofData.BASE_GENERAL_MESSAGES,
          logicProofData.BASE_STUDENT_LANGUAGE));
      }
    };
  };

  it(&#x27;should pre-parse examples correctly&#x27;, function() {
    expect(
      preParse(&#x27;from p and q we have p\u2227q&#x27;, false)
    ).toEqual([&#x27;from&#x27;, &#x27;p&#x27;, &#x27;and&#x27;, &#x27;q&#x27;, &#x27;we&#x27;, &#x27;have&#x27;, &#x27;p\u2227q&#x27;]);
    expect(
      preParse(&#x27;    from p \u2228 (q\u2227 r ) s we see \u2200 x. r&#x27;, false)
    ).toEqual([&#x27;from&#x27;, &#x27;p\u2228(q\u2227r)&#x27;, &#x27;s&#x27;, &#x27;we&#x27;, &#x27;see&#x27;, &#x27;\u2200x.r&#x27;]);
    expect(
      preParse(&#x27;from p [ x -&gt; a ] at {{ a | variable }} have q&#x27;, true)
    ).toEqual([&#x27;from&#x27;, &#x27;p[x-&gt;a]&#x27;, &#x27;at&#x27;, &#x27;{{a|variable}}&#x27;, &#x27;have&#x27;, &#x27;q&#x27;]);
    expect(
      preParse(&#x27;from  ~R =&gt;~S and  ~S =&gt;~R we have ~R &lt;=&gt; ~S&#x27;, true)
    ).toEqual([&#x27;from&#x27;, &#x27;~R=&gt;~S&#x27;, &#x27;and&#x27;, &#x27;~S=&gt;~R&#x27;, &#x27;we&#x27;, &#x27;have&#x27;, &#x27;~R&lt;=&gt;~S&#x27;]);
  });

  it(&#x27;should reject lines that are entirely whitespace&#x27;, function() {
    expect(
      errorWrapper(preParse, &#x27;   &#x27;, false)
    ).toThrowError(&#x27;This line is blank.&#x27;);
  });

  it(&#x27;should reject unknown symbols&#x27;, function() {
    expect(
      errorWrapper(preParse, &#x27;from p and p{q we see q&#x27;, false)
    ).toThrowError(&#x27;The symbol { was not recognised.&#x27;);
  });
  describe(&#x27;Parse lines&#x27;, function() {
    var parse = function(lineString, isTemplate) {
      return logicProofShared.parseLineString(
        lineString, logicProofData.BASE_STUDENT_LANGUAGE.operators,
        logicProofData.BASE_VOCABULARY, isTemplate);
    };

    it(&#x27;should parse examples correctly&#x27;, function() {
      expect(parse(&#x27;from p and q we have p\u2227q&#x27;, false)).toEqual([[{
        format: &#x27;phrase&#x27;,
        content: &#x27;from&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          top_kind_name: &#x27;variable&#x27;,
          top_operator_name: &#x27;p&#x27;,
          arguments: [],
          dummies: []
        }
      }, {
        format: &#x27;phrase&#x27;,
        content: &#x27;and&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          top_kind_name: &#x27;variable&#x27;,
          top_operator_name: &#x27;q&#x27;,
          arguments: [],
          dummies: []
        }
      }, {
        format: &#x27;phrase&#x27;,
        content: &#x27;have&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          top_kind_name: &#x27;binary_connective&#x27;,
          top_operator_name: &#x27;and&#x27;,
          arguments: [{
            top_kind_name: &#x27;variable&#x27;,
            top_operator_name: &#x27;p&#x27;,
            arguments: [],
            dummies: []
          }, {
            top_kind_name: &#x27;variable&#x27;,
            top_operator_name: &#x27;q&#x27;,
            arguments: [],
            dummies: []
          }],
          dummies: []
        }
      }]]);

      expect(
        parse(
          &#x27;from p[x-&gt;a] we know hence a contradiction {{ a | element }}&#x27;, true)
      ).toEqual([[{
        format: &#x27;phrase&#x27;,
        content: &#x27;from&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          expression: {
            top_kind_name: &#x27;variable&#x27;,
            top_operator_name: &#x27;p&#x27;,
            arguments: [],
            dummies: []
          },
          substitutions: [{
            x: {
              top_kind_name: &#x27;variable&#x27;,
              top_operator_name: &#x27;a&#x27;,
              arguments: [],
              dummies: []
            }
          }],
          type: &#x27;boolean&#x27;
        }
      }, {
        format: &#x27;phrase&#x27;,
        content: &#x27;have&#x27;
      }, {
        format: &#x27;phrase&#x27;,
        content: &#x27;hence&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          expression: {
            top_kind_name: &#x27;variable&#x27;,
            top_operator_name: &#x27;a&#x27;,
            arguments: [],
            dummies: []
          },
          substitutions: [],
          type: &#x27;boolean&#x27;
        }
      }, {
        format: &#x27;phrase&#x27;,
        content: &#x27;contradiction&#x27;
      }, {
        format: &#x27;expression&#x27;,
        content: {
          expression: {
            top_kind_name: &#x27;variable&#x27;,
            top_operator_name: &#x27;a&#x27;,
            arguments: [],
            dummies: []
          },
          substitutions: [],
          type: &#x27;element&#x27;
        }
      }]]);
    });

    it(&#x27;should reject unknown phrases&#x27;, function() {
      expect(
        errorWrapper(parse, &#x27;from p we havw p\u2227q&#x27;)
      ).toThrowError(
        &#x27;The phrase starting \&#x27;we\&#x27; could not be identified; &#x27; +
        &#x27;please make sure you are only using phrases from the given list of &#x27; +
        &#x27;vocabulary.&#x27;
      );
    });

    it(&#x27;should reject consecutive expressions&#x27;, function() {
      expect(
        errorWrapper(parse, &#x27;from A=&gt;B B have B&#x27;)
      ).toThrowError(
        &#x27;We could not identify \&#x27;B\&#x27;; please make sure you are using &#x27; +
        &#x27;vocabulary from the given list, and don\&#x27;t have two consecutive &#x27; +
        &#x27;expressions.&#x27;);
    });
  });
  describe(&#x27;Assign types to expressions&#x27;, function() {
    var assignTypes = function(expressionString, newKindsPermitted) {
      return logicProofShared.assignTypesToExpression(
        logicProofParser.parse(expressionString, &#x27;expression&#x27;), [&#x27;boolean&#x27;],
        logicProofData.BASE_STUDENT_LANGUAGE, newKindsPermitted
      )[0].typedExpression;
    };

    var assignTypesControl = function(expressionString, newKindsPermitted) {
      return logicProofShared.assignTypesToExpression(
        logicProofParser.parse(expressionString, &#x27;expression&#x27;), [&#x27;boolean&#x27;],
        logicProofData.BASE_CONTROL_LANGUAGE, newKindsPermitted
      )[0].typedExpression;
    };

    it(&#x27;should assign types to examples correctly&#x27;, function() {
      expect(assignTypes(&#x27;p&#x27;, [&#x27;variable&#x27;])).toEqual({
        top_operator_name: &#x27;p&#x27;,
        top_kind_name: &#x27;variable&#x27;,
        arguments: [],
        dummies: [],
        type: &#x27;boolean&#x27;
      });

      expect(assignTypes(&#x27;p\u2227x=y&#x27;, [&#x27;variable&#x27;])).toEqual({
        top_operator_name: &#x27;and&#x27;,
        top_kind_name: &#x27;binary_connective&#x27;,
        arguments: [{
          top_operator_name: &#x27;p&#x27;,
          top_kind_name: &#x27;variable&#x27;,
          arguments: [],
          dummies: [],
          type: &#x27;boolean&#x27;
        }, {
          top_operator_name: &#x27;equals&#x27;,
          top_kind_name: &#x27;binary_relation&#x27;,
          arguments: [{
            top_operator_name: &#x27;x&#x27;,
            top_kind_name: &#x27;variable&#x27;,
            arguments: [],
            dummies: [],
            type: &#x27;element&#x27;
          }, {
            top_operator_name: &#x27;y&#x27;,
            top_kind_name: &#x27;variable&#x27;,
            arguments: [],
            dummies: [],
            type: &#x27;element&#x27;
          }],
          dummies: [],
          type: &#x27;boolean&#x27;
        }],
        dummies: [],
        type: &#x27;boolean&#x27;
      });

      expect(assignTypes(&#x27;\u2203x.x=x&#x27;, [])).toEqual({
        top_operator_name: &#x27;exists&#x27;,
        top_kind_name: &#x27;quantifier&#x27;,
        arguments: [{
          top_operator_name: &#x27;equals&#x27;,
          top_kind_name: &#x27;binary_relation&#x27;,
          arguments: [{
            top_operator_name: &#x27;x&#x27;,
            top_kind_name: &#x27;variable&#x27;,
            arguments: [],
            dummies: [],
            type: &#x27;element&#x27;
          }, {
            top_operator_name: &#x27;x&#x27;,
            top_kind_name: &#x27;variable&#x27;,
            arguments: [],
            dummies: [],
            type: &#x27;element&#x27;
          }],
          dummies: [],
          type: &#x27;boolean&#x27;
        }],
        dummies: [{
          top_operator_name: &#x27;x&#x27;,
          top_kind_name: &#x27;variable&#x27;,
          arguments: [],
          dummies: [],
          type: &#x27;element&#x27;
        }],
        type: &#x27;boolean&#x27;
      });
    });

    it(&#x27;should reject type mismatches&#x27;, function() {
      expect(
        errorWrapper(assignTypes, &#x27;p&lt;=&gt;2+x&#x27;, [&#x27;variable&#x27;])
      ).toThrowError(
        &#x27;addition yields a element but you are trying to use it to give a &#x27; +
        &#x27;boolean.&#x27;);

      expect(
        errorWrapper(
          assignTypes, &#x27;x\u2227f(x)&#x27;,
          [&#x27;variable&#x27;, &#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(
        &#x27;x yields a boolean but you are trying to use it to give a element.&#x27;);

      expect(
        errorWrapper(
          assignTypesControl, &#x27;\&#x27;a\&#x27;=2&#x27;, [&#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(
        &#x27;2 yields a integer but you are trying to use it to give a string.&#x27;);
    });

    it(&#x27;should forbid quantification over pre-existing variables&#x27;, function() {
      expect(
        errorWrapper(
          assignTypes, &#x27;a\u2227\u2203a.f(2)&#x27;,
          [&#x27;variable&#x27;, &#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(
        &#x27;The name \&#x27;a\&#x27; is already in use and so cannot be quantified &#x27; +
        &#x27;over in \u2203a.f(2).&#x27;);
    });

    it(&#x27;should reject kind mismatches&#x27;, function() {
      expect(
        errorWrapper(
          assignTypes, &#x27;f(f)&#x27;, [&#x27;variable&#x27;, &#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(&#x27;f is supposed to be a prefix_function.&#x27;);
    });

    it(&#x27;should reject unknown operators of an un-addable kind&#x27;, function() {
      expect(
        errorWrapper(
          assignTypes, &#x27;\u2200m&lt;n.A(n)&#x27;,
          [&#x27;variable&#x27;, &#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(&#x27;The operator bounded_for_all could not be identified.&#x27;);
      expect(
        errorWrapper(
          assignTypes, &#x27;\u2203x.A(x)&lt;=&gt;x=2&#x27;, [&#x27;prefix_function&#x27;, &#x27;constant&#x27;])
      ).toThrowError(&#x27;The operator x could not be identified.&#x27;);
    });
  });
});

describe(&#x27;Instantiate types&#x27;, function() {
  it(&#x27;should instantiate examples correctly&#x27;, function() {
    expect(logicProofShared.instantiateTypingElementArray([{
      type: &#x27;boolean&#x27;,
      arbitrarily_many: false
    }, {
      type: &#x27;element&#x27;,
      arbitrarily_many: true
    }], 3)).toEqual([&#x27;boolean&#x27;, &#x27;element&#x27;, &#x27;element&#x27;]);
    expect(logicProofShared.instantiateTypingElementArray([], 0)).toEqual([]);
  });
});

describe(&#x27;Check equality between expression constructs&#x27;, function() {
  it(&#x27;should recognise when expressions are equal&#x27;, function() {
    expect(
      logicProofShared.checkExpressionsAreEqual(
        logicProofParser.parse(&#x27;p\u2227r\u2228\u2200x.s&#x27;, &#x27;expression&#x27;),
        logicProofParser.parse(&#x27;(p\u2227r)\u2228(\u2200x.s)&#x27;, &#x27;expression&#x27;))
    ).toBe(true);
  });

  it(&#x27;should recognise when expressions are not equal&#x27;, function() {
    expect(
      logicProofShared.checkExpressionsAreEqual(
        logicProofParser.parse(&#x27;p\u2227r\u2228\u2200x.s&#x27;, &#x27;expression&#x27;),
        logicProofParser.parse(&#x27;(p\u2227r)\u2228(\u2200y.s)&#x27;, &#x27;expression&#x27;))
    ).toBe(false);
  });

  it(&#x27;should recognise when an expression is not in a set&#x27;, function() {
    expect(
      logicProofShared.checkExpressionIsInSet(
        logicProofParser.parse(&#x27;p\u2227q&#x27;, &#x27;expression&#x27;),
        [
          logicProofParser.parse(&#x27;A(x)&#x27;, &#x27;expression&#x27;),
          logicProofParser.parse(&#x27;q\u2227p&#x27;, &#x27;expression&#x27;)
        ])
    ).toBe(false);
  });

  it(&#x27;should recognise when sets of expressions are equal&#x27;, function() {
    expect(
      logicProofShared.checkSetsOfExpressionsAreEqual([
        logicProofParser.parse(&#x27;A(x)\u2228x=2&#x27;, &#x27;expression&#x27;),
        logicProofParser.parse(&#x27;p&#x27;, &#x27;expression&#x27;)
      ], [
        logicProofParser.parse(&#x27;p&#x27;, &#x27;expression&#x27;),
        logicProofParser.parse(&#x27;A(x)\u2228(x=2)&#x27;, &#x27;expression&#x27;),
        logicProofParser.parse(&#x27;p&#x27;, &#x27;expression&#x27;)
      ])
    ).toBe(true);
  });
});

describe(&#x27;Get operators from expression&#x27;, function() {
  it(&#x27;should identify all operators&#x27;, function() {
    expect(
      logicProofShared.getOperatorsFromExpression(
        logicProofParser.parse(&#x27;f(x+2)=y+x\u2227p&#x27;, &#x27;expression&#x27;))
    ).toEqual([&#x27;x&#x27;, 2, &#x27;addition&#x27;, &#x27;f&#x27;, &#x27;y&#x27;, &#x27;equals&#x27;, &#x27;p&#x27;, &#x27;and&#x27;]);
  });

  it(&#x27;should identify all operators of a given kind&#x27;, function() {
    expect(
      logicProofShared.getOperatorsFromExpression(
        logicProofParser.parse(&#x27;x+2=y+x&#x27;, &#x27;expression&#x27;),
        [&#x27;variable&#x27;])).toEqual([&#x27;x&#x27;, &#x27;y&#x27;]);
  });
});

describe(&#x27;Check ordering in lex&#x27;, function() {
  it(&#x27;should identify when one array exceeds another&#x27;, function() {
    expect(logicProofShared.greaterThanInLex(
      [1, 2, 4, 4], [1, 2, 3, 5])).toBe(true);
  });

  it(&#x27;should identify when one array does not exceed another&#x27;, function() {
    expect(logicProofShared.greaterThanInLex(
      [1, 2], [1, 2])).toBe(false);
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:25,&quot;character&quot;:34,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:27,&quot;character&quot;:29,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:30,&quot;character&quot;:41,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:32,&quot;character&quot;:29,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:53,&quot;character&quot;:26,&quot;text&quot;:&quot;lineString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:53,&quot;character&quot;:38,&quot;text&quot;:&quot;isTemplate&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:55,&quot;character&quot;:6,&quot;text&quot;:&quot;lineString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:55,&quot;character&quot;:66,&quot;text&quot;:&quot;isTemplate&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:58,&quot;character&quot;:6,&quot;text&quot;:&quot;dubiousFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:58,&quot;character&quot;:23,&quot;text&quot;:&quot;input&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:58,&quot;character&quot;:30,&quot;text&quot;:&quot;parameter&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:61,&quot;character&quot;:12,&quot;text&quot;:&quot;parameter&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:62,&quot;character&quot;:10,&quot;text&quot;:&quot;dubiousFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:62,&quot;character&quot;:26,&quot;text&quot;:&quot;input&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:64,&quot;character&quot;:10,&quot;text&quot;:&quot;dubiousFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:64,&quot;character&quot;:26,&quot;text&quot;:&quot;input&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:64,&quot;character&quot;:33,&quot;text&quot;:&quot;parameter&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:68,&quot;character&quot;:10,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:66,&quot;character&quot;:15,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:101,&quot;character&quot;:25,&quot;text&quot;:&quot;lineString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:101,&quot;character&quot;:37,&quot;text&quot;:&quot;isTemplate&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:103,&quot;character&quot;:8,&quot;text&quot;:&quot;lineString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:234,&quot;character&quot;:31,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:234,&quot;character&quot;:49,&quot;text&quot;:&quot;newKindsPermitted&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:236,&quot;character&quot;:31,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:238,&quot;character&quot;:11,&quot;text&quot;:&quot;typedExpression&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:241,&quot;character&quot;:38,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:241,&quot;character&quot;:56,&quot;text&quot;:&quot;newKindsPermitted&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:243,&quot;character&quot;:31,&quot;text&quot;:&quot;expressionString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/LogicProof/static/js/shared.spec.ts&quot;,&quot;line&quot;:245,&quot;character&quot;:11,&quot;text&quot;:&quot;typedExpression&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:44:00 GMT</p>
    </body>
  </html>
  