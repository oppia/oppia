
  <!DOCTYPE html>
  <html>
    <head>
      <title>graph-input-rules.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">extensions/interactions/GraphInput/directives/graph-input-rules.service.spec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">1031</td><td class="">1031</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for Graph Input rules.
 */

import { GraphInputRulesService } from
  &#x27;interactions/GraphInput/directives/graph-input-rules.service&#x27;;
import { TestBed } from &#x27;@angular/core/testing&#x27;;
import { GraphAnswer } from &#x27;interactions/answer-defs&#x27;;

describe(&#x27;Graph Input service&#x27;, () =&gt; {
  let girs: GraphInputRulesService = null;
  beforeEach(() =&gt; {
    girs = TestBed.get(GraphInputRulesService);
  });

  let undirectedEmptyGraph = (): GraphAnswer =&gt; {
    return {
      vertices: [],
      edges: [],
      isDirected: false,
      isWeighted: false,
      isLabeled: false
    };
  };

  let undirectedNullGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = undirectedEmptyGraph();
    for (var i = 0; i &lt; numVertices; i++) {
      graph.vertices.push({
        label: &#x27;&#x27;,
        x: 0.0,
        y: 0.0
      });
    }
    return graph;
  };

  let undirectedCycleGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = undirectedNullGraph(numVertices);
    if (numVertices === 1) {
      return graph;
    }
    for (var i = 0; i &lt; numVertices; i++) {
      graph.edges.push({
        src: i,
        dst: (i + 1) % numVertices,
        weight: 1
      });
    }
    return graph;
  };

  let undirectedCompleteGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = undirectedNullGraph(numVertices);
    for (var i = 0; i &lt; numVertices; i++) {
      for (var j = i + 1; j &lt; numVertices; j++) {
        graph.edges.push({
          src: i,
          dst: j,
          weight: 1
        });
      }
    }
    return graph;
  };

  let undirectedStarGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = undirectedNullGraph(numVertices);
    for (var i = 1; i &lt; numVertices; i++) {
      graph.edges.push({
        src: 0,
        dst: i,
        weight: 1
      });
    }
    return graph;
  };

  let directedEmptyGraph = (): GraphAnswer =&gt; {
    return {
      vertices: [],
      edges: [],
      isDirected: true,
      isWeighted: false,
      isLabeled: false
    };
  };

  let directedNullGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = directedEmptyGraph();
    for (var i = 0; i &lt; numVertices; i++) {
      graph.vertices.push({
        label: &#x27;&#x27;,
        x: 0.0,
        y: 0.0
      });
    }
    return graph;
  };

  let directedCycleGraph = (numVertices: number): GraphAnswer =&gt; {
    var graph = directedNullGraph(numVertices);
    if (numVertices === 1) {
      return graph;
    }
    for (var i = 0; i &lt; numVertices; i++) {
      graph.edges.push({
        src: i,
        dst: (i + 1) % numVertices,
        weight: 1
      });
    }
    return graph;
  };

  describe(&#x27;\&#x27;is isomorphic to\&#x27; rule&#x27;, () =&gt; {
    it(&#x27;should match graphs which are the same&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo(undirectedEmptyGraph(), {
        g: undirectedEmptyGraph()
      })).toBe(true);

      expect(girs.IsIsomorphicTo(undirectedCycleGraph(5), {
        g: undirectedCycleGraph(5)
      })).toBe(true);

      expect(girs.IsIsomorphicTo(directedCycleGraph(6), {
        g: directedCycleGraph(6)
      })).toBe(true);
    });

    it(&#x27;should match isomorphic graphs&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo(undirectedCycleGraph(5), {
        g: {
          vertices: [{
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }],
          edges: [{
            src: 0,
            dst: 2,
            weight: 1
          }, {
            src: 2,
            dst: 4,
            weight: 1
          }, {
            src: 4,
            dst: 1,
            weight: 1
          }, {
            src: 1,
            dst: 3,
            weight: 1
          }, {
            src: 3,
            dst: 0,
            weight: 1
          }],
          isDirected: false,
          isWeighted: false,
          isLabeled: false
        }
      })).toBe(true);
    });

    it(&#x27;should match isomorphic graphs with labels&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 3.0,
          y: 3.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: false,
        isLabeled: true
      }, {
        g: {
          vertices: [{
            label: &#x27;c&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;a&#x27;,
            x: 2.0,
            y: 2.0
          }, {
            label: &#x27;b&#x27;,
            x: 3.0,
            y: 3.0
          }],
          edges: [{
            src: 2,
            dst: 1,
            weight: 1
          }],
          isDirected: false,
          isWeighted: false,
          isLabeled: true
        }
      })).toBe(true);
    });

    it(&#x27;should match isomorphic graphs with labels and weights&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 3.0,
          y: 3.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }, {
          src: 1,
          dst: 2,
          weight: 1
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        g: {
          vertices: [{
            label: &#x27;b&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;a&#x27;,
            x: 2.0,
            y: 2.0
          }, {
            label: &#x27;c&#x27;,
            x: 3.0,
            y: 3.0
          }],
          edges: [{
            src: 2,
            dst: 0,
            weight: 1
          }, {
            src: 1,
            dst: 0,
            weight: 2
          }],
          isDirected: false,
          isWeighted: true,
          isLabeled: true
        }
      })).toBe(true);
    });

    it(&#x27;should match directed and undirected graphs&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;&#x27;,
          x: 2.0,
          y: 2.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: false,
        isLabeled: false
      }, {
        g: {
          vertices: [{
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 2.0,
            y: 2.0
          }],
          edges: [{
            src: 0,
            dst: 1,
            weight: 1
          }, {
            src: 1,
            dst: 0,
            weight: 1
          }],
          isDirected: true,
          isWeighted: false,
          isLabeled: false
        }
      })).toBe(true);
    });

    it(&#x27;should not match simple graphs with different edges&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo(undirectedCycleGraph(3), {
        g: undirectedNullGraph(3)
      })).toBe(false);

      expect(girs.IsIsomorphicTo(undirectedNullGraph(3), {
        g: undirectedCycleGraph(3)
      })).toBe(false);

      expect(girs.IsIsomorphicTo(undirectedCompleteGraph(4), {
        g: undirectedCycleGraph(4)
      })).toBe(false);

      expect(girs.IsIsomorphicTo(undirectedCycleGraph(4), {
        g: undirectedCompleteGraph(4)
      })).toBe(false);

      expect(girs.IsIsomorphicTo(directedCycleGraph(4), {
        g: undirectedCompleteGraph(4)
      })).toBe(false);
    });

    it(&#x27;should not match graphs with different numbers of nodes&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo(undirectedNullGraph(3), {
        g: undirectedNullGraph(6)
      })).toBe(false);
    });

    it(&#x27;should not match graphs with different edges&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 3.0,
          y: 3.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }, {
          src: 1,
          dst: 2,
          weight: 2
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        g: {
          vertices: [{
            label: &#x27;b&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;a&#x27;,
            x: 2.0,
            y: 2.0
          }, {
            label: &#x27;c&#x27;,
            x: 3.0,
            y: 3.0
          }],
          edges: [{
            src: 0,
            dst: 1,
            weight: 1
          }, {
            src: 0,
            dst: 2,
            weight: 2
          }],
          isDirected: false,
          isWeighted: true,
          isLabeled: true
        }
      })).toBe(false);
    });

    it(&#x27;should not match graphs with different edge weights&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;&#x27;,
          x: 2.0,
          y: 2.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: false
      }, {
        g: {
          vertices: [{
            label: &#x27;&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;&#x27;,
            x: 2.0,
            y: 2.0
          }],
          edges: [{
            src: 0,
            dst: 1,
            weight: 2
          }],
          isDirected: false,
          isWeighted: true,
          isLabeled: false
        }
      })).toBe(false);
    });

    it(&#x27;should not match graphs with different labels&#x27;, () =&gt; {
      expect(girs.IsIsomorphicTo({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        g: {
          vertices: [{
            label: &#x27;a&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;c&#x27;,
            x: 2.0,
            y: 2.0
          }],
          edges: [{
            src: 0,
            dst: 1,
            weight: 2
          }],
          isDirected: false,
          isWeighted: true,
          isLabeled: true
        }
      })).toBe(false);
    });
  });

  describe(&#x27;\&#x27;is weakly connected\&#x27; rule&#x27;, () =&gt; {
    it(&#x27;should return true on undirected connected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedEmptyGraph(), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCycleGraph(5), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedStarGraph(4), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCompleteGraph(6), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }, {
          src: 2,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);
    });

    it(&#x27;should return true on directed weakly connected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(directedCycleGraph(4), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }, {
          src: 2,
          dst: 1,
          weight: 1
        }],
        isDirected: true,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;weakly_connected&#x27;
      })).toBe(true);
    });

    it(&#x27;should return false for disconnected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedNullGraph(2), {
        p: &#x27;weakly_connected&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;weakly_connected&#x27;
      })).toBe(false);
    });
  });

  describe(&#x27;\&#x27;is strongly connected\&#x27; rule&#x27;, () =&gt; {
    it(&#x27;should return true for undirected connected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedEmptyGraph(), {
        p: &#x27;strongly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCycleGraph(5), {
        p: &#x27;strongly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCompleteGraph(6), {
        p: &#x27;strongly_connected&#x27;
      })).toBe(true);
    });

    it(&#x27;should return true for directed strongly connected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(directedCycleGraph(6), {
        p: &#x27;strongly_connected&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 3.0,
          y: 3.0
        }, {
          label: &#x27;d&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 1,
          dst: 2,
          weight: 2
        }, {
          src: 2,
          dst: 0,
          weight: 3
        }, {
          src: 0,
          dst: 3,
          weight: 3
        }, {
          src: 3,
          dst: 2,
          weight: 3
        }],
        isDirected: true,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;strongly_connected&#x27;
      })).toBe(true);
    });

    it(&#x27;should return false for disconnected graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedNullGraph(2), {
        p: &#x27;strongly_connected&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 1.0,
          y: 1.0
        }, {
          label: &#x27;b&#x27;,
          x: 2.0,
          y: 2.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }],
        isDirected: true,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;strongly_connected&#x27;
      })).toBe(false);
    });

    it(&#x27;should return false for graphs that are only weakly connected&#x27;,
      () =&gt; {
        expect(girs.HasGraphProperty({
          vertices: [{
            label: &#x27;a&#x27;,
            x: 1.0,
            y: 1.0
          }, {
            label: &#x27;b&#x27;,
            x: 2.0,
            y: 2.0
          }, {
            label: &#x27;c&#x27;,
            x: 0.0,
            y: 0.0
          }],
          edges: [{
            src: 0,
            dst: 1,
            weight: 2
          }, {
            src: 2,
            dst: 1,
            weight: 1
          }],
          isDirected: true,
          isWeighted: true,
          isLabeled: true
        }, {
          p: &#x27;strongly_connected&#x27;
        })).toBe(false);
      }
    );
  });

  describe(&#x27;\&#x27;is acyclic\&#x27; rule&#x27;, () =&gt; {
    it(&#x27;should return true on acyclic graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedEmptyGraph(), {
        p: &#x27;acyclic&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCompleteGraph(2), {
        p: &#x27;acyclic&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedStarGraph(4), {
        p: &#x27;acyclic&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;b&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;d&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 2,
          weight: 2
        }, {
          src: 2,
          dst: 3,
          weight: 4
        }, {
          src: 1,
          dst: 3,
          weight: 123
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;acyclic&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;a&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;b&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;c&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;d&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 2
        }, {
          src: 2,
          dst: 1,
          weight: 4
        }, {
          src: 3,
          dst: 1,
          weight: 123
        }],
        isDirected: false,
        isWeighted: true,
        isLabeled: true
      }, {
        p: &#x27;acyclic&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 0,
          dst: 2,
          weight: 1
        }, {
          src: 1,
          dst: 2,
          weight: 1
        }],
        isDirected: true,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;acyclic&#x27;
      })).toBe(true);
    });

    it(&#x27;should return false on graphs with cycles&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedCycleGraph(5), {
        p: &#x27;acyclic&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty(directedCycleGraph(6), {
        p: &#x27;acyclic&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty(undirectedCompleteGraph(4), {
        p: &#x27;acyclic&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 2,
          dst: 0,
          weight: 1
        }, {
          src: 1,
          dst: 2,
          weight: 1
        }],
        isDirected: true,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;acyclic&#x27;
      })).toBe(false);
    });
  });

  describe(&#x27;\&#x27;is regular\&#x27; rule&#x27;, () =&gt; {
    it(&#x27;should detect undirected regular graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(undirectedEmptyGraph(), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedNullGraph(9), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCompleteGraph(8), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCycleGraph(3), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedCycleGraph(4), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty(undirectedStarGraph(4), {
        p: &#x27;regular&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;regular&#x27;
      })).toBe(false);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 2,
          dst: 1,
          weight: 1
        }, {
          src: 3,
          dst: 1,
          weight: 1
        }],
        isDirected: false,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;regular&#x27;
      })).toBe(false);
    });

    it(&#x27;should detect directed regular graphs&#x27;, () =&gt; {
      expect(girs.HasGraphProperty(directedCycleGraph(4), {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 2,
          dst: 0,
          weight: 1
        }, {
          src: 1,
          dst: 2,
          weight: 1
        }],
        isDirected: true,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;regular&#x27;
      })).toBe(true);

      expect(girs.HasGraphProperty({
        vertices: [{
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }, {
          label: &#x27;&#x27;,
          x: 0.0,
          y: 0.0
        }],
        edges: [{
          src: 0,
          dst: 1,
          weight: 1
        }, {
          src: 0,
          dst: 2,
          weight: 1
        }, {
          src: 1,
          dst: 2,
          weight: 1
        }],
        isDirected: true,
        isWeighted: false,
        isLabeled: false
      }, {
        p: &#x27;regular&#x27;
      })).toBe(false);
    });
  });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:44:00 GMT</p>
    </body>
  </html>
  