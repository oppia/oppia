
  <!DOCTYPE html>
  <html>
    <head>
      <title>algebraic-expression-input-rules.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts</td><td class="">97.45%</td><td class="">100%</td><td class="">745</td><td class="">726</td><td class="">19</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for algebraic expression input interaction rules.
 */

import { AlgebraicExpressionInputRulesService } from
// eslint-disable-next-line max-len
  &#x27;interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service&#x27;;

describe(&#x27;Algebraic expression input rules service&#x27;, () =&gt; {
  let algebraicRulesService: AlgebraicExpressionInputRulesService;
  let inputString;

  beforeEach(() =&gt; {
    algebraicRulesService = new AlgebraicExpressionInputRulesService();
  });

  it(&#x27;should have a correct MatchesExactlyWith rule&#x27;, () =&gt; {
    inputString = &#x27;((x)^(2)-x)/(z)-4*y&#x27;;

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2)-x)/(z)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2)-x)/(z)-(8*y)/(2)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;-4*y+((x)^(2)-x)/(z)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2)-x)*(z)^(-1)-4*y&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x*(x-1))/(z)-4*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2))/(z)-(x)/(z)-4*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2))/(z)-((x)/(z)+4*y)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;;

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;2*a*b+2*b*c+2*a*c+(a)^(2)+(b)^(2)+(c)^(2)&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;a*a+b*b+((c)^(3))/(c)+2*a*b+2*b*c+2*c*a&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*(a*b+b*c+a*c)&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(a+b)^(2)+(c)^(2)+2*b*c+2*a*c&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(a+b+c)^(2)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(x)^(2*t+3)+(x)^(4)&#x27;;

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x)^(2*t+3)+(x)^(4)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x)^(2*t)*(x)^(3)+((x)^(2))^(2)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2*t))/((x)^(-3))+((x)^(8))/((x)^(4))&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2*t+5))/((x)^(2))-(-(x)^(4))&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x)^(3*t+3)+(x)^(4)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x)^(3)*((x)^(2*t)+x)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(x)^(4)*((x)^(2*t-1)+1)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((x)^(2*t+4)+(x)^(5))/(x)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;9*(x)^(2)-6*x+1&#x27;;

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;9*(x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;3*(3*(x)^(2)-2*x)+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(3*x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((3*x-1))^(2)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;3*x(3*x-2)+1&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;9*(x)^(2)-6*x+1&#x27;;

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;9*(x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;3*(3*(x)^(2)-2*x)+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;(3*x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;((3*x-1))^(2)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.MatchesExactlyWith(
      &#x27;3*x(3*x-2)+1&#x27;, {x: inputString})).toBeFalse();
  });

  it(&#x27;should have a correct IsEquivalentTo rule&#x27;, () =&gt; {
    inputString = &#x27;((x)^(2)-x)/(z)-4*y&#x27;;

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2)-x)/(z)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;-4*y+((x)^(2)-x)/(z)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2)-x)*(z)^(-1)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x*(x-1))/(z)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2))/(z)-(x)/(z)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2))/(z)-((x)/(z)+4*y)&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2)-x)/(z)-40*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2)+x)/(z)-4*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2.00000000000001)+x)/(z)+4*y&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;;

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;2*a*b+2*b*c+2*a*c+(a)^(2)+(b)^(2)+(c)^(2)&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;a*a+b*b+((c)^(3))/(c)+2*a*b+2*b*c+2*c*a&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*(a*b+b*c+a*c)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a+b)^(2)+(c)^(2)+2*b*c+2*a*c&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a+b+c)^(2)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(((a+b+c))^(3))/(a+b+c)&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(a+b-c)^(2)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(x)^(2*t+3)+(x)^(4)&#x27;;

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(2*t+3)+(x)^(4)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(2*t)*(x)^(3)+((x)^(2))^(2)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2*t))/((x)^(-3))+((x)^(8))/((x)^(4))&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2*t+5))/((x)^(2))-(-(x)^(4))&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(3)*((x)^(2*t)+x)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(4)*((x)^(2*t-1)+1)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((x)^(2*t+4)+(x)^(5))/(x)&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(2*t+3)+(x)^(3)+x&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(x)^(2*t+3)-(x)^(4)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;9*(x)^(2)-6*x+1&#x27;;

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;9*(x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;3*(3*(x)^(2)-2*x)+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(3*x)^(2)-6*x+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((3*x-1))^(2)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;3*x(3*x-2)+1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;(1-3x)^(2)&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;sqrt((3x-1)^(2))&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;9*(x)^(2)-6*x-1&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.IsEquivalentTo(
      &#x27;((3*x-1))^(4)&#x27;, {x: inputString})).toBeFalse();
  });

  it(&#x27;should have a correct ContainsSomeOf rule&#x27;, () =&gt; {
    inputString = &#x27;((x)^(2)-x)/(z)-4*y&#x27;;

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;((x)^(2)-x)/(z)-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;((x)^(2)-x)/(z)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;((x)^(2)-x)*(z^(-1))&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;-8y/2&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(x-(x)^(2))/(z)+4*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;x(x-1)/z&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(x^2)/z - x/z&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;;

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;,
      {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;a^2 + b^2 + 2ab&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(a + b)^2 + c^2 + 2ac + 2bc&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(a + b + c)^2&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(a + b)^2&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;a + b + c&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;x^(2t+3) + x^4&#x27;;

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;x^(2t+3) + x^4&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;x^(2t+3)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;x^4&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(x^2)^2&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(x^3)(x^(2t) + x)&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;(x^(2t+4) + x^5)/x&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;9x^2 - 6x + 1&#x27;;

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;9x^2 - 6x + 1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;9x^2 - 6x&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;9x^2 + 1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;- 6x + 1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;9x^2 - 6x - 1&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;sqrt((3x-1)^(2))&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;3*(3x^2 - 2x) - 1&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.ContainsSomeOf(
      &#x27;((3*x-1))^(4)&#x27;, {x: inputString})).toBeFalse();
  });

  it(&#x27;should have a correct OmitsSomeOf rule&#x27;, () =&gt; {
    inputString = &#x27;((x)^(2)-x)/(z)-4*y&#x27;;

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;((x)^(2)-x)/(z)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;-4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;4*y&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x^2)/z - x/z - 4y&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;((x)^(2)-x)/(z)-4*y&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;((x)^(2)-x)*(z^(-1))-4*y&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;;

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;a^2 + c^2 + 2ab + 2bc + 2ac&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;a^2 + b^2 + c^2&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(a + b)^2 + c^2 + 2ac + 2bc&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(a)^(2)+(b)^(2)+(c)^(2)+2*a*b+2*b*c+2*a*c&#x27;,
      {x: inputString})).toBeFalse();


    inputString = &#x27;x^(2t+3) + x^4&#x27;;

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x)^(2*t+3)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x)^(4)&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x^2)^2&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x^(2t))*x^3&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;(x^(2t))*x*x*x&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;x^(2t+3) + x^4&#x27;, {x: inputString})).toBeFalse();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;x^(2t+4-1) + x^(8-4)&#x27;, {x: inputString})).toBeFalse();


    inputString = &#x27;9x^2 - 6x + 1&#x27;;

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;9x^2 - 6x&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;9x^2 + 1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;- 6x + 1&#x27;, {x: inputString})).toBeTrue();
    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;9x^2 - 6x - 1&#x27;, {x: inputString})).toBeTrue();

    expect(algebraicRulesService.OmitsSomeOf(
      &#x27;9x^2 - 6x + 1&#x27;, {x: inputString})).toBeFalse();
  });

  it(&#x27;should have a correct MatchesWithGeneralForm rule&#x27;, () =&gt; {
    inputString = &#x27;x/a + y/b&#x27;;

    expect(algebraicRulesService.MatchesWithGeneralForm(
      &#x27;x/2 + y/3&#x27;, {x: &#x27;x/a + y/b&#x27;, y: [&#x27;a&#x27;, &#x27;b&#x27;]})).toBeTrue();
    expect(algebraicRulesService.MatchesWithGeneralForm(
      &#x27;x/2 + z/4&#x27;, {x: &#x27;x/a + y/b&#x27;, y: [&#x27;a&#x27;, &#x27;b&#x27;]})).toBeFalse();
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:24,&quot;character&quot;:6,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:31,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:50,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:69,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:91,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:106,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:122,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:145,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:170,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:194,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:218,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:239,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:274,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:296,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:313,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:327,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:346,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;extensions/interactions/AlgebraicExpressionInput/directives/algebraic-expression-input-rules.service.spec.ts&quot;,&quot;line&quot;:362,&quot;character&quot;:4,&quot;text&quot;:&quot;inputString&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:44:00 GMT</p>
    </body>
  </html>
  