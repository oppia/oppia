
  <!DOCTYPE html>
  <html>
    <head>
      <title>expression-syntax-tree.service.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/expressions/expression-syntax-tree.service.ts</td><td class="">99.74%</td><td class="">100%</td><td class="">387</td><td class="">386</td><td class="">1</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Expression syntax tree service.
 */

import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;

import { ExpressionParserService } from &#x27;expressions/expression-parser.service&#x27;;

export type Expr = string | number | boolean;

export interface SystemEnv {
  eval: (args: Expr[]) =&gt; Expr;
}

export type Env = SystemEnv | Expr;

export interface EnvDict {
  [param: string]: Env;
}

export class ExpressionError extends Error {
  // &#x27;message&#x27; is optional beacuse it is optional in the actual &#x27;Error&#x27;
  // constructor object. Also, we may not want a custom error message
  // while throwing &#x27;ExpressionError&#x27;.
  constructor(message?: string) {
    super(message);
    // NOTE TO DEVELOPERS: In order to properly extend Error, we must manually
    // rebuild the prototype chain because it is broken by the call to `super`.
    // For details, please see: https://stackoverflow.com/a/58417721/4859885.
    Object.setPrototypeOf(this, new.target.prototype);
    this.name = new.target.name;
  }
}

export class ExprUndefinedVarError extends ExpressionError {
  constructor(public varname: string, public envs: EnvDict[]) {
    super(varname + &#x27; not found in &#x27; + angular.toJson(envs));
  }
}

export class ExprWrongNumArgsError extends ExpressionError {
  constructor(
      public args: (number|string)[],
      public expectedMin: number, public expectedMax: number) {
    super(
      &#x27;{&#x27; + args + &#x27;} not in range [&#x27; + expectedMin + &#x27;, &#x27; + expectedMax + &#x27;]&#x27;);
  }
}

export class ExprWrongArgTypeError extends ExpressionError {
  constructor(
      public arg: number|string,
      public actualType: string, public expectedType: string) {
    super(
      (
        arg !== null ?
        (arg + &#x27; has type &#x27; + actualType + &#x27; which&#x27;) : (&#x27;Type &#x27; + actualType)) +
      &#x27; does not match expected type &#x27; + expectedType);
  }
}

@Injectable({ providedIn: &#x27;root&#x27; })
export class ExpressionSyntaxTreeService {
  constructor(private expressionParserService: ExpressionParserService) {}

  public ExpressionError = ExpressionError;
  public ExprUndefinedVarError = ExprUndefinedVarError;
  public ExprWrongNumArgsError = ExprWrongNumArgsError;
  public ExprWrongArgTypeError = ExprWrongArgTypeError;

  public getParamsUsedInExpression(expression: string): string[] {
    const parsedExpression = this.expressionParserService.parse(expression);
    return [...this.findParams(parsedExpression)].sort();
  }

  public applyFunctionToParseTree(
      parsed: Expr | Expr[], envs: EnvDict[],
      func: (parsed: Expr | Expr[], envs: EnvDict[]) =&gt; Expr): Expr {
    return func(parsed, envs.concat(this.system));
  }

  // Looks up a variable of the given name in the env. Here the variable can be
  // system or user-defined functions or parameters, including system operators.
  public lookupEnvs(name: string, envs: EnvDict[]): Env {
    for (const env of envs) {
      if (env.hasOwnProperty(name)) {
        return env[name];
      }
    }
    throw new ExprUndefinedVarError(name, envs);
  }

  private findParams(parseTree: string | string[]): Set&lt;string&gt; {
    const paramsFound = new Set&lt;string&gt;();
    if (parseTree instanceof Array) {
      if (parseTree[0] === &#x27;#&#x27;) {
        paramsFound.add(parseTree[1]);
      } else {
        for (let i = 1; i &lt; parseTree.length; ++i) {
          this.findParams(parseTree[i]).forEach(p =&gt; paramsFound.add(p));
        }
      }
    }
    return paramsFound;
  }

  // Checks if the args array has the expectedMin number of elements and throws
  // an error if not. If optional expectedMax is specified, it verifies the
  // number of args is in the inclusive range: [expectedMin, expectedMax].
  private verifyNumArgs(
      args: string[],
      expectedMin: number, expectedMax: number = expectedMin): void {
    if (args.length &lt; expectedMin || args.length &gt; expectedMax) {
      throw new ExprWrongNumArgsError(args, expectedMin, expectedMax);
    }
  }

  // Coerces the argument to a Number, and throws an error if the result is NaN.
  private coerceToNumber(originalValue: string|number): number {
    const coercedValue = +originalValue;
    if (isNaN(coercedValue)) {
      throw new ExprWrongArgTypeError(
        originalValue, typeof originalValue, &#x27;Number&#x27;);
    }
    return coercedValue;
  }

  private coerceAllArgsToNumber(args: (number|string)[]): number[] {
    return args.map(this.coerceToNumber);
  }

  // NOTE TO DEVELOPERS: When adding a new reserved word to this object, please
  // first ensure that existing explorations do not use this parameter name.
  // Also, to prevent future explorations using it, modify
  // constants.INVALID_PARAMETER_NAMES accordingly.
  //
  // TODO(kashida): Document each operator&#x27;s input and output contracts.
  //
  // Arguments:
  //    for eval(): list of values of the evaluated sub-expression.
  private system: {[name: string]: SystemEnv} = {
    &#x27;+&#x27;: {
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 1, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs.length === 1 ?
          numericArgs[0] :
          numericArgs[0] + numericArgs[1];
      }
    },

    &#x27;-&#x27;: {
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 1, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs.length === 1 ?
          -numericArgs[0] :
          numericArgs[0] - numericArgs[1];
      }
    },

    &#x27;*&#x27;: {
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] * numericArgs[1];
      }
    },

    &#x27;/&#x27;: {
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] / numericArgs[1];
      }
    },

    &#x27;%&#x27;: {
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] % numericArgs[1];
      }
    },

    &#x27;&lt;=&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] &lt;= numericArgs[1];
      }
    },

    &#x27;&gt;=&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] &gt;= numericArgs[1];
      }
    },

    &#x27;&lt;&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] &lt; numericArgs[1];
      }
    },

    &#x27;&gt;&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return numericArgs[0] &gt; numericArgs[1];
      }
    },

    &#x27;!&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 1);
        return !args[0];
      }
    },

    &#x27;==&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        return args[0] === args[1];
      }
    },

    &#x27;!=&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        return args[0] !== args[1];
      }
    },

    &#x27;&amp;&amp;&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        return Boolean(args[0] &amp;&amp; args[1]);
      }
    },

    &#x27;||&#x27;: {
      eval: (args: string[]): boolean =&gt; {
        this.verifyNumArgs(args, 2);
        return Boolean(args[0] || args[1]);
      }
    },

    // NOTE TO DEVELOPERS: Removing the quotation marks from the following keys
    // causes issues with minification when running the deployment scripts.
    &#x27;if&#x27;: { // eslint-disable-line quote-props
      eval: (args: string[]): string =&gt; {
        this.verifyNumArgs(args, 3);
        return args[0] ? args[1] : args[2];
      }
    },

    &#x27;floor&#x27;: { // eslint-disable-line quote-props
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 1);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return Math.floor(numericArgs[0]);
      }
    },

    &#x27;pow&#x27;: { // eslint-disable-line quote-props
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return Math.pow(numericArgs[0], numericArgs[1]);
      }
    },

    &#x27;log&#x27;: { // eslint-disable-line quote-props
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 2);
        const numericArgs = this.coerceAllArgsToNumber(args);
        const preciseAns = Math.log(numericArgs[0]) / Math.log(numericArgs[1]);
        // We round answers to 9 decimal places, so that we don&#x27;t run into
        // issues like log(9, 3) = 2.0000000000004.
        return Math.round(preciseAns * Math.pow(10, 9)) / Math.pow(10, 9);
      }
    },

    &#x27;abs&#x27;: { // eslint-disable-line quote-props
      eval: (args: string[]): number =&gt; {
        this.verifyNumArgs(args, 1);
        const numericArgs = this.coerceAllArgsToNumber(args);
        return Math.abs(numericArgs[0]);
      }
    }
  };
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;ExpressionSyntaxTreeService&#x27;,
  downgradeInjectable(ExpressionSyntaxTreeService));
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/expressions/expression-syntax-tree.service.ts&quot;,&quot;line&quot;:86,&quot;character&quot;:10,&quot;text&quot;:&quot;parsedExpression&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:55 GMT</p>
    </body>
  </html>
  