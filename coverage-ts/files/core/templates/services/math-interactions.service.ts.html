
  <!DOCTYPE html>
  <html>
    <head>
      <title>math-interactions.service.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/services/math-interactions.service.ts</td><td class="">93.96%</td><td class="">100%</td><td class="">613</td><td class="">576</td><td class="">37</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service for providing helper functions for math interactions.
 */

import { Injectable } from &#x27;@angular/core&#x27;;
import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;

import nerdamer from &#x27;nerdamer&#x27;;

import { AppConstants } from &#x27;app.constants&#x27;;

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class MathInteractionsService {
  private warningText = &#x27;&#x27;;
  private mathFunctionNames = AppConstants.MATH_FUNCTION_NAMES;

  private cleanErrorMessage(
      errorMessage: string, expressionString: string): string {
    // The error thrown by nerdamer includes the index of the violation which
    // starts with a colon. That part needs to be removed before displaying
    // the error to the end user. Same rationale applies for stripping the
    // error message from &#x27;at&#x27;, since some errors from nerdamer use &#x27;at&#x27; to
    // show the location.
    if (errorMessage.indexOf(&#x27;bracket&#x27;) !== -1) {
      // The error is about invalid bracket pairings.
      return &#x27;It looks like your answer has an invalid bracket pairing.&#x27;;
    }
    let colonIndex = errorMessage.indexOf(&#x27;:&#x27;);
    if (colonIndex !== -1) {
      errorMessage = errorMessage.slice(0, colonIndex);
    }
    let atColonIndex = errorMessage.indexOf(&#x27; at &#x27;);
    if (atColonIndex !== -1) {
      errorMessage = errorMessage.slice(0, atColonIndex);
    }
    if (errorMessage[errorMessage.length - 1] === &#x27;!&#x27;) {
      errorMessage = errorMessage.slice(0, errorMessage.length - 1);
    }
    if (errorMessage[errorMessage.length - 1] !== &#x27;.&#x27;) {
      errorMessage += &#x27;.&#x27;;
    }
    if (errorMessage === &#x27;Division by zero not allowed.&#x27;) {
      errorMessage = &#x27;Your answer includes a division by zero, which is &#x27; +
        &#x27;not valid.&#x27;;
    }
    if (errorMessage.indexOf(&#x27;is not a valid postfix operator.&#x27;) !== -1) {
      errorMessage = (
        &#x27;Your answer seems to be missing a variable/number after the &quot;&#x27; +
        errorMessage[0] + &#x27;&quot;.&#x27;);
    }
    if (errorMessage === &#x27;A prefix operator was expected.&#x27;) {
      let symbol1, symbol2;
      for (let s1 of &#x27;/*^&#x27;) {
        for (let s2 of &#x27;+-/*^&#x27;) {
          if (expressionString.indexOf(s1 + s2) !== -1) {
            symbol1 = s1;
            symbol2 = s2;
          }
        }
      }
      errorMessage = (
        &#x27;Your answer has two symbols next to each other: &quot;&#x27; + symbol1 +
        &#x27;&quot; and &quot;&#x27; + symbol2 + &#x27;&quot;.&#x27;);
    }
    if (
      errorMessage === &#x27;Cannot read property \&#x27;column\&#x27; of undefined.&#x27;) {
      let emptyFunctionNames = [];
      for (let functionName of this.mathFunctionNames) {
        if (expressionString.includes(functionName + &#x27;()&#x27;)) {
          emptyFunctionNames.push(functionName);
        }
      }
      errorMessage = (
        &#x27;The &#x27; + emptyFunctionNames.join(&#x27;, &#x27;) +
        &#x27; function(s) cannot be empty. Please enter a variable/number in it.&#x27;);
    }
    return errorMessage;
  }

  _validateExpression(expressionString: string): boolean {
    expressionString = expressionString.replace(/\s/g, &#x27;&#x27;);
    if (expressionString.length === 0) {
      this.warningText = &#x27;Please enter an answer before submitting.&#x27;;
      return false;
    } else if (expressionString.indexOf(&#x27;=&#x27;) !== -1 || expressionString.indexOf(
      &#x27;&lt;&#x27;) !== -1 || expressionString.indexOf(&#x27;&gt;&#x27;) !== -1) {
      this.warningText = &#x27;It looks like you have entered an &#x27; +
        &#x27;equation/inequality. Please enter an expression instead.&#x27;;
      return false;
    } else if (expressionString.indexOf(&#x27;_&#x27;) !== -1) {
      this.warningText = &#x27;Your answer contains an invalid character: &quot;_&quot;.&#x27;;
      return false;
    }
    if (expressionString.match(/(\+$)|(\+\))/g)) {
      this.warningText = (
        &#x27;Your answer seems to be missing a variable/number after the &quot;+&quot;.&#x27;);
      return false;
    }
    let invalidIntegers = expressionString.match(
      /(\d*\.\d*\.\d*)|(\d+\.\D)|(\D\.\d+)|(\d+\.$)/g);
    if (invalidIntegers !== null) {
      this.warningText = (
        &#x27;Your answer contains an invalid term: &#x27; + invalidIntegers[0]);
      return false;
    }
    try {
      expressionString = this.insertMultiplicationSigns(expressionString);
      nerdamer(expressionString);
    } catch (err) {
      this.warningText = this.cleanErrorMessage(err.message, expressionString);
      return false;
    }
    this.warningText = &#x27;&#x27;;
    return true;
  }

  validateAlgebraicExpression(
      expressionString: string, validVariablesList: string[]): boolean {
    if (!this._validateExpression(expressionString)) {
      return false;
    }

    expressionString = this.insertMultiplicationSigns(expressionString);
    let variablesList = nerdamer(expressionString).variables();
    // Explicitly checking for presence of constants (pi and e).
    if (expressionString.match(/(^|[^a-zA-Z])e($|[^a-zA-Z])/g)) {
      variablesList.push(&#x27;e&#x27;);
    }
    if (expressionString.match(/(^|[^a-zA-Z])pi($|[^a-zA-Z])/g)) {
      variablesList.push(&#x27;pi&#x27;);
    }
    const greekNameToSymbolMap: { [greekName: string]: string } = (
      AppConstants.GREEK_LETTER_NAMES_TO_SYMBOLS);

    // Replacing greek names with symbols.
    for (let i = 0; i &lt; variablesList.length; i++) {
      if (variablesList[i].length &gt; 1) {
        variablesList[i] = greekNameToSymbolMap[variablesList[i]];
      }
    }
    if (variablesList.length === 0) {
      this.warningText = &#x27;It looks like you have entered only &#x27; +
      &#x27;numbers. Make sure to include the necessary variables&#x27; +
      &#x27; mentioned in the question.&#x27;;
      return false;
    } else if (validVariablesList.length !== 0) {
      for (let variable of variablesList) {
        if (validVariablesList.indexOf(variable) === -1) {
          this.warningText = (
            &#x27;You have entered an invalid variable: &#x27; + variable +
            &#x27;. Please use only the variables &#x27; + validVariablesList.join() +
            &#x27; in your answer.&#x27;);
          return false;
        }
      }
    }
    return true;
  }

  validateNumericExpression(expressionString: string): boolean {
    if (!this._validateExpression(expressionString)) {
      return false;
    }
    for (let functionName of this.mathFunctionNames) {
      expressionString = expressionString.replace(
        new RegExp(functionName, &#x27;g&#x27;), &#x27;&#x27;);
    }
    if (/[a-zA-Z]/.test(expressionString)) {
      this.warningText = &#x27;It looks like you have entered some variables. &#x27; +
        &#x27;Please enter numbers only.&#x27;;
      return false;
    }
    return true;
  }

  validateEquation(
      equationString: string, validVariablesList: string[]): boolean {
    equationString = equationString.replace(/\s/g, &#x27;&#x27;);
    if (equationString.length === 0) {
      this.warningText = &#x27;Please enter an answer before submitting.&#x27;;
      return false;
    } else if (equationString.indexOf(
      &#x27;&lt;&#x27;) !== -1 || equationString.indexOf(&#x27;&gt;&#x27;) !== -1) {
      this.warningText = &#x27;It looks like you have entered an &#x27; +
        &#x27;inequality. Please enter an equation instead.&#x27;;
      return false;
    } else if (equationString.indexOf(&#x27;=&#x27;) === -1) {
      this.warningText = &#x27;It looks like you have entered an &#x27; +
        &#x27;expression. Please enter an equation instead.&#x27;;
      return false;
    } else if (equationString.indexOf(&#x27;=&#x27;) === 0) {
      this.warningText = &#x27;The LHS of your equation is empty.&#x27;;
      return false;
    } else if (equationString.indexOf(&#x27;=&#x27;) === equationString.length - 1) {
      this.warningText = &#x27;The RHS of your equation is empty.&#x27;;
      return false;
    }
    let splitString = equationString.split(&#x27;=&#x27;);
    if (splitString.length !== 2) {
      this.warningText = &#x27;Your equation contains multiple = signs.&#x27;;
      return false;
    }
    let lhsString = splitString[0], rhsString = splitString[1];
    let lhsIsAlgebraicallyValid = this.validateAlgebraicExpression(
      lhsString, validVariablesList);
    let rhsIsAlgebraicallyValid = this.validateAlgebraicExpression(
      rhsString, validVariablesList);
    let lhsIsNumericallyValid = this.validateNumericExpression(lhsString);
    let rhsIsNumericallyValid = this.validateNumericExpression(rhsString);

    // At least one side must be algebraic. Purely numeric equations are
    // considered as invalid.
    if (lhsIsNumericallyValid &amp;&amp; rhsIsNumericallyValid) {
      this.warningText = &#x27;The equation must contain at least one variable.&#x27;;
      return false;
    }
    if (lhsIsAlgebraicallyValid &amp;&amp; rhsIsAlgebraicallyValid ||
      lhsIsAlgebraicallyValid &amp;&amp; rhsIsNumericallyValid ||
      lhsIsNumericallyValid &amp;&amp; rhsIsAlgebraicallyValid) {
      this.warningText = &#x27;&#x27;;
      return true;
    }
    // Neither side is algebraically valid. Calling validation functions again
    // to appropriately update the warningText.
    this.validateAlgebraicExpression(lhsString, validVariablesList);
    if (this.getWarningText().length === 0) {
      this.validateAlgebraicExpression(rhsString, validVariablesList);
    }
    return false;
  }

  getWarningText(): string {
    return this.warningText;
  }

  insertMultiplicationSigns(expressionString: string): string {
    let greekLetters = Object.keys(
      AppConstants.GREEK_LETTER_NAMES_TO_SYMBOLS);
    let greekSymbols = Object.values(
      AppConstants.GREEK_LETTER_NAMES_TO_SYMBOLS);
    let greekLettersAndSymbols = [];
    for (let i = 0; i &lt; greekLetters.length; i++) {
      greekLettersAndSymbols.push([greekLetters[i], greekSymbols[i]]);
    }
    // Sorting by length in descending order so that longer letters get replaced
    // before shorted ones. For eg. &#x27;alphabeta&#x27; should have variables list as
    // [&#x27;alpha&#x27;, &#x27;beta&#x27;] and not [&#x27;alpha&#x27;, &#x27;b&#x27;, &#x27;eta&#x27;].
    greekLettersAndSymbols.sort((a, b) =&gt; b[0].length - a[0].length);

    let greekLetterToSymbol: { [letter: string]: string } = {};
    let greekSymbolToLetter: { [symbol: string]: string } = {};
    for (let letterAndSymbol of greekLettersAndSymbols) {
      greekLetterToSymbol[letterAndSymbol[0]] = letterAndSymbol[1];
      greekSymbolToLetter[letterAndSymbol[1]] = letterAndSymbol[0];
    }

    // Temporarily replacing letters with symbols.
    for (let letter in greekLetterToSymbol) {
      expressionString = expressionString.replace(
        new RegExp(letter, &#x27;g&#x27;), greekLetterToSymbol[letter]);
    }

    expressionString = expressionString.replace(/\s/g, &#x27;&#x27;);
    // Assumes that given expressionString is valid.
    // Nerdamer allows multi-character variables so, &#x27;ax+b&#x27; will be considered
    // to have variables: [ax, b], but we want a and x to be considered as
    // separate variables which is why we would assume that any such instance of
    // consecutive characters means they are single characters multiplied with
    // each other. So, &#x27;ax+b&#x27; would be transformed to &#x27;a*x+b&#x27; via this function.
    let variables = nerdamer(expressionString).variables();
    for (let variable of variables) {
      let separatedVariables = variable.split(&#x27;&#x27;).join(&#x27;*&#x27;);
      expressionString = expressionString.replace(
        new RegExp(variable, &#x27;g&#x27;), separatedVariables);
    }
    // Reverting the temporary replacement of letters.
    for (let symbol in greekSymbolToLetter) {
      expressionString = expressionString.replace(
        new RegExp(symbol, &#x27;g&#x27;), greekSymbolToLetter[symbol]);
    }

    // Inserting multiplication signs before functions. For eg. 5sqrt(x) should
    // be treated as 5*sqrt(x).
    for (let functionName of this.mathFunctionNames) {
      expressionString = expressionString.replace(new RegExp(
        &#x27;([a-zA-Z0-9\)])&#x27; + functionName, &#x27;g&#x27;), &#x27;$1*&#x27; + functionName);
    }
    // Inserting multiplication signs after closing parens.
    expressionString = expressionString.replace(/\)([^\*\+\/\-\^\)])/g, &#x27;)*$1&#x27;);
    // Inserting multiplication signs before opening parens.
    // Note: We don&#x27;t wanna insert signs before opening parens that are part of
    // functions, for eg., we want to convert a(b) to a*(b) but not sqrt(4) to
    // sqrt*(4).
    let removeExtraMultiSymbol = expressionString[0] === &#x27;(&#x27;;
    expressionString = expressionString.replace(new RegExp(
      &#x27;(?&lt;!\\*|\\+|\\/|\\-|\\^|\\(|&#x27; + this.mathFunctionNames.join(
        &#x27;|&#x27;) + &#x27;)\\(&#x27;, &#x27;g&#x27;), &#x27;*(&#x27;);
    if (removeExtraMultiSymbol) {
      expressionString = expressionString.slice(1);
    }
    return expressionString;
  }

  replaceAbsSymbolWithText(expressionString: string): string {
    // The guppy editor outputs abs as a symbol &#x27;|x|&#x27; but that is incompatible
    // with nerdamer and the backend validations. Both of them need &#x27;abs(x)&#x27;,
    // hence the replacement.
    let opening = true;
    let modifiedExpressionList = [];
    for (let i = 0; i &lt; expressionString.length; i++) {
      if (expressionString[i] === &#x27;|&#x27;) {
        if (opening) {
          modifiedExpressionList.push(&#x27;abs(&#x27;);
          opening = false;
        } else {
          modifiedExpressionList.push(&#x27;)&#x27;);
          opening = true;
        }
      } else {
        modifiedExpressionList.push(expressionString[i]);
      }
    }
    return modifiedExpressionList.join(&#x27;&#x27;);
  }

  getTerms(expressionString: string, splitByAddition = true): string[] {
    let listOfTerms: string[] = [];
    let currentTerm: string = &#x27;&#x27;;
    let bracketBalance: number = 0;
    let shouldModifyNextTerm: boolean = false;
    let modifyTerm = function(termString: string): string {
      // If the shouldModifyNextTerm flag is set to true, we add the &#x27;-&#x27; sign,
      // or raise the term to a power of -1. This ensures that when the final
      // list is joined by the &#x27;+&#x27;/&#x27;*&#x27; sign, it matches with the original
      // expression. For eg.
      // &#x27;3/10&#x27; would be split as [3, 10^(-1)] and
      // &#x27;3-10&#x27; would be split as [3, -(10)].
      if (splitByAddition) {
        return &#x27;-(&#x27; + termString + &#x27;)&#x27;;
      } else {
        return &#x27;(&#x27; + termString + &#x27;)^(-1)&#x27;;
      }
    };
    const primaryDelimiter = splitByAddition ? &#x27;+&#x27; : &#x27;*&#x27;;
    const secondaryDelimiter = splitByAddition ? &#x27;-&#x27; : &#x27;/&#x27;;

    expressionString = expressionString.replace(/\s/g, &#x27;&#x27;);

    // Temporarily replacing all unary negation signs with &#x27;~&#x27; so as to avoid
    // splitting terms by them. We only need to split terms by binary
    // subtraction signs and not unary negation signs. A &#x27;-&#x27; sign is considered
    // to be binary subtraction iff it is preceded by an alphanumeric or a
    // closing bracket, otherwise it is considered as unary negation operation.
    // NOTE: The replace function is called twice to deal with cases where there
    // might be overlapping matches.
    // For eg. 4----5 would be converted to 4-~-~5 after the first call. So we
    // need a second call to convert it to the desired result, which is 4-~~~5.
    expressionString = expressionString.replace(/([^a-zA-Z0-9\)])-/g, &#x27;$1~&#x27;);
    expressionString = expressionString.replace(/([^a-zA-Z0-9\)])-/g, &#x27;$1~&#x27;);

    for (let i = 0; i &lt; expressionString.length; i++) {
      let currentVal = expressionString[i];
      if (currentVal === &#x27;(&#x27; || currentVal === &#x27;)&#x27;) {
        bracketBalance += (currentVal === &#x27;(&#x27;) ? 1 : -1;
      }

      // Split term only if we are not inside a set of parens and the current
      // value is a delimiter.
      if (bracketBalance === 0 &amp;&amp; (
        currentVal === primaryDelimiter || currentVal === secondaryDelimiter)) {
        if (currentTerm.length !== 0) {
          if (shouldModifyNextTerm) {
            currentTerm = modifyTerm(currentTerm);
            shouldModifyNextTerm = false;
          }
          listOfTerms.push(currentTerm);
          currentTerm = &#x27;&#x27;;
        }
        if (currentVal === secondaryDelimiter) {
          shouldModifyNextTerm = true;
        }
      } else {
        currentTerm += currentVal;
      }
    }
    if (shouldModifyNextTerm) {
      currentTerm = modifyTerm(currentTerm);
      shouldModifyNextTerm = false;
    }
    listOfTerms.push(currentTerm);

    // Reverting the temporary &#x27;~&#x27; replace in the final list of terms.
    for (let i = 0; i &lt; listOfTerms.length; i++) {
      listOfTerms[i] = listOfTerms[i].replace(/~/g, &#x27;-&#x27;);
    }
    return listOfTerms;
  }

  // The input terms to this function should be the terms split by &#x27;+&#x27;/&#x27;-&#x27;
  // from an expression.
  termsMatch(term1: string, term2: string): boolean {
    // We split both terms by multiplication and division into separate parts
    // and try to match these parts from both inputs by checking equivalency.
    let partsList1 = this.getTerms(term1, false);
    let partsList2 = this.getTerms(term2, false);

    // NOTE: We only need to iterate from the top in the partsList1 list since
    // in the partsList2 list, we will break the loop each time an element is
    // removed from it, thus, indexing errors would only arise in the outer
    // loop.
    for (let i = partsList1.length - 1; i &gt;= 0; i--) {
      for (let j = 0; j &lt; partsList2.length; j++) {
        if (nerdamer(partsList1[i]).eq(nerdamer(partsList2[j]).toString())) {
          partsList1.splice(i, 1);
          partsList2.splice(j, 1);
          break;
        }
      }
    }

    return partsList1.length === 0 &amp;&amp; partsList2.length === 0;
  }

  expressionMatchWithPlaceholders(
      expressionWithPlaceholders: string, inputExpression: string,
      placeholders: string[]): boolean {
    // Check if inputExpression contains any placeholders.
    for (let variable of nerdamer(inputExpression).variables()) {
      if (placeholders.includes(variable)) {
        return false;
      }
    }

    // The expressions are first split into terms by addition and subtraction.
    let termsWithPlaceholders = this.getTerms(expressionWithPlaceholders);
    let inputTerms = this.getTerms(inputExpression);

    // Each term in the expression containing placeholders is compared with
    // terms in the input expression. Two terms are said to be matched iff
    // upon subtracting or dividing them, the resultant contains only
    // placeholders. This would imply that the input term matches with the
    // general form(the term with placeholders).
    for (let i = termsWithPlaceholders.length - 1; i &gt;= 0; i--) {
      for (let j = 0; j &lt; inputTerms.length; j++) {
        let termWithPlaceholders = termsWithPlaceholders[i];
        let termWithoutPlaceholders = inputTerms[j];

        let divisionCondition;
        // Try catch block is meant to catch division by zero errors.
        try {
          let variablesAfterDivision = nerdamer(termWithPlaceholders).divide(
            termWithoutPlaceholders).variables();
          divisionCondition = variablesAfterDivision.every(
            variable =&gt; placeholders.includes(variable));
        } catch (e) {
          divisionCondition = true;
        }

        let variablesAfterSubtraction = nerdamer(termWithPlaceholders).subtract(
          termWithoutPlaceholders).variables();
        let subtractionCondition = variablesAfterSubtraction.every(
          variable =&gt; placeholders.includes(variable));

        // If only placeholders are left in the term after dividing/subtracting
        // them, then the terms are said to match.
        if (divisionCondition || subtractionCondition) {
          termsWithPlaceholders.splice(i, 1);
          inputTerms.splice(j, 1);
          break;
        }
      }
    }

    // Checks if all terms have matched.
    return termsWithPlaceholders.length + inputTerms.length === 0;
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;MathInteractionsService&#x27;,
  downgradeInjectable(MathInteractionsService));
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:67,&quot;character&quot;:10,&quot;text&quot;:&quot;symbol1&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:67,&quot;character&quot;:19,&quot;text&quot;:&quot;symbol2&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:71,&quot;character&quot;:12,&quot;text&quot;:&quot;symbol1&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:72,&quot;character&quot;:12,&quot;text&quot;:&quot;symbol2&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:77,&quot;character&quot;:62,&quot;text&quot;:&quot;symbol1&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:78,&quot;character&quot;:20,&quot;text&quot;:&quot;symbol2&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:82,&quot;character&quot;:10,&quot;text&quot;:&quot;emptyFunctionNames&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:85,&quot;character&quot;:10,&quot;text&quot;:&quot;emptyFunctionNames&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:89,&quot;character&quot;:17,&quot;text&quot;:&quot;emptyFunctionNames&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:125,&quot;character&quot;:48,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:125,&quot;character&quot;:52,&quot;text&quot;:&quot;message&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:124,&quot;character&quot;:13,&quot;text&quot;:&quot;err&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:256,&quot;character&quot;:8,&quot;text&quot;:&quot;greekLettersAndSymbols&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:258,&quot;character&quot;:6,&quot;text&quot;:&quot;greekLettersAndSymbols&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:4,&quot;text&quot;:&quot;greekLettersAndSymbols&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:33,&quot;text&quot;:&quot;a&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:36,&quot;text&quot;:&quot;b&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:42,&quot;text&quot;:&quot;b&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:47,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:56,&quot;text&quot;:&quot;a&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:61,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:267,&quot;character&quot;:13,&quot;text&quot;:&quot;letterAndSymbol&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:268,&quot;character&quot;:26,&quot;text&quot;:&quot;letterAndSymbol&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:268,&quot;character&quot;:48,&quot;text&quot;:&quot;letterAndSymbol&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:269,&quot;character&quot;:26,&quot;text&quot;:&quot;letterAndSymbol&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:269,&quot;character&quot;:48,&quot;text&quot;:&quot;letterAndSymbol&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:267,&quot;character&quot;:32,&quot;text&quot;:&quot;greekLettersAndSymbols&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:324,&quot;character&quot;:8,&quot;text&quot;:&quot;modifiedExpressionList&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:328,&quot;character&quot;:10,&quot;text&quot;:&quot;modifiedExpressionList&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:331,&quot;character&quot;:10,&quot;text&quot;:&quot;modifiedExpressionList&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:335,&quot;character&quot;:8,&quot;text&quot;:&quot;modifiedExpressionList&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:338,&quot;character&quot;:11,&quot;text&quot;:&quot;modifiedExpressionList&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:463,&quot;character&quot;:12,&quot;text&quot;:&quot;divisionCondition&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:468,&quot;character&quot;:10,&quot;text&quot;:&quot;divisionCondition&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:471,&quot;character&quot;:10,&quot;text&quot;:&quot;divisionCondition&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:470,&quot;character&quot;:17,&quot;text&quot;:&quot;e&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/math-interactions.service.ts&quot;,&quot;line&quot;:481,&quot;character&quot;:12,&quot;text&quot;:&quot;divisionCondition&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:54 GMT</p>
    </body>
  </html>
  