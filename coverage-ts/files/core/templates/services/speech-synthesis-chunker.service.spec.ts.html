
  <!DOCTYPE html>
  <html>
    <head>
      <title>speech-synthesis-chunker.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/services/speech-synthesis-chunker.service.spec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">274</td><td class="">274</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for SpeechSynthesisChunkerService.
 */

import { TestBed, fakeAsync, flush } from &#x27;@angular/core/testing&#x27;;

import { SpeechSynthesisChunkerService } from
  &#x27;services/speech-synthesis-chunker.service&#x27;;

describe(&#x27;Speech Synthesis Chunker Service&#x27;, () =&gt; {
  let speechSynthesisChunkerService: SpeechSynthesisChunkerService = null;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [SpeechSynthesisChunkerService]
    });

    speechSynthesisChunkerService = TestBed.get(SpeechSynthesisChunkerService);
  });

  describe(&#x27;formatLatexToSpeakableText&#x27;, () =&gt; {
    it(&#x27;should properly convert subtraction in LaTeX to speakable text&#x27;,
      () =&gt; {
        var latex1 = &#x27;5 - 3&#x27;;
        var latex2 = &#x27;i - j&#x27;;
        var speakableLatex1 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex1);
        var speakableLatex2 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex2);
        expect(speakableLatex1).toEqual(&#x27;5 minus 3&#x27;);
        expect(speakableLatex2).toEqual(&#x27;i minus j&#x27;);
      }
    );

    it(&#x27;should properly convert fractions in LaTeX to speakable text&#x27;,
      () =&gt; {
        var latex1 = &#x27;\\\\frac{2}{3}&#x27;;
        var latex2 = &#x27;\\\\frac{abc}{xyz}&#x27;;
        var latex3 = &#x27;\\\\frac{3n}{5}&#x27;;
        var latex4 = &#x27;\\\\frac{ijk}{5xy}&#x27;;
        var speakableLatex1 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex1);
        var speakableLatex2 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex2);
        var speakableLatex3 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex3);
        var speakableLatex4 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex4);
        expect(speakableLatex1).toEqual(&#x27;2/3&#x27;);
        expect(speakableLatex2).toEqual(&#x27;a b c over x y z&#x27;);
        expect(speakableLatex3).toEqual(&#x27;3n over 5&#x27;);
        expect(speakableLatex4).toEqual(&#x27;i j k over 5x y&#x27;);
      }
    );

    it(&#x27;should properly convert square roots in LaTeX to speakable text&#x27;,
      () =&gt; {
        var latex1 = &#x27;\\\\sqrt{3}&#x27;;
        var latex2 = &#x27;\\\\sqrt{xy}&#x27;;
        var speakableLatex1 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex1);
        var speakableLatex2 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex2);
        expect(speakableLatex1).toEqual(&#x27;the square root of 3&#x27;);
        expect(speakableLatex2).toEqual(&#x27;the square root of x y&#x27;);
      }
    );

    it(&#x27;should properly convert exponents in LaTeX to speakable text&#x27;,
      () =&gt; {
        var latex1 = &#x27;x ^ 2&#x27;;
        var latex2 = &#x27;42 ^ 4&#x27;;
        var latex3 = &#x27;x ^ 62&#x27;;
        var latex4 = &#x27;3n ^ 4x&#x27;;
        var speakableLatex1 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex1);
        var speakableLatex2 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex2);
        var speakableLatex3 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex3);
        var speakableLatex4 =
          speechSynthesisChunkerService.formatLatexToSpeakableText(latex4);
        expect(speakableLatex1).toEqual(&#x27;x^2&#x27;);
        expect(speakableLatex2).toEqual(&#x27;42 to the power of 4&#x27;);
        expect(speakableLatex3).toEqual(&#x27;x to the power of 62&#x27;);
        expect(speakableLatex4).toEqual(&#x27;3n to the power of 4x&#x27;);
      }
    );

    it(&#x27;should properly convert trigonometric functions in LaTeX to &#x27; +
        &#x27;speakable text&#x27;, () =&gt; {
      var latex1 = &#x27;\\\\sin{90}&#x27;;
      var latex2 = &#x27;\\\\cos{0}&#x27;;
      var latex3 = &#x27;\\\\tan{uv}&#x27;;
      var speakableLatex1 =
        speechSynthesisChunkerService.formatLatexToSpeakableText(latex1);
      var speakableLatex2 =
        speechSynthesisChunkerService.formatLatexToSpeakableText(latex2);
      var speakableLatex3 =
        speechSynthesisChunkerService.formatLatexToSpeakableText(latex3);
      expect(speakableLatex1).toEqual(&#x27;the sine of 90&#x27;);
      expect(speakableLatex2).toEqual(&#x27;the cosine of 0&#x27;);
      expect(speakableLatex3).toEqual(&#x27;the tangent of u v&#x27;);
    });
  });

  describe(&#x27;convertToSpeakableText&#x27;, () =&gt; {
    it(&#x27;should properly convert the raw_latex-with-value attribute to&#x27; +
      &#x27; speakable text&#x27;, () =&gt; {
      const html = (
        &#x27;&lt;oppia-noninteractive-math math_content-with-value=&quot;{&amp;amp;quot;&#x27; +
        &#x27;raw_latex&amp;amp;quot;:&amp;amp;quot;5-1&amp;amp;quot;,&amp;amp;quot;svg_filename&amp;&#x27; +
        &#x27;amp;quot;:&amp;amp;quot;&amp;amp;quot;}&quot;&gt;&lt;/oppia-noninteractive-math&gt;&#x27; +
        &#x27;&lt;li&gt;Speech&lt;/li&gt;&#x27; +
        &#x27;&lt;li&gt;Text&lt;/li&gt;&#x27;
      );

      expect(speechSynthesisChunkerService.convertToSpeakableText(html))
        .toBe(&#x27;5 minus 1 Speech. Text. &#x27;);
    });

    it(&#x27;should properly convert the text-with-value attribute to&#x27; +
      &#x27; speakable text&#x27;, () =&gt; {
      const html = (
        &#x27;&lt;oppia-noninteractive-link text-with-value=&quot;Testing&amp;quot;&quot;&gt;&#x27; +
        &#x27;&lt;/oppia-noninteractive-link&gt;&#x27; +
        &#x27;&lt;li&gt;&quot;Speech&quot;&lt;/li&gt;&#x27; +
        &#x27;&lt;li&gt;Text&lt;/li&gt;&#x27;
      );

      expect(speechSynthesisChunkerService.convertToSpeakableText(html))
        .toBe(&#x27;Testing Speech. Text. &#x27;);
    });
  });

  describe(&#x27;speak&#x27;, function() {
    const MockSpeechSynthesisUtteranceConstructor = (
      SpeechSynthesisUtterance);
    const mockSpeechSynthesisUtteran = {
      speak: () =&gt; {},
      onend: () =&gt; {}
    };

    beforeEach(() =&gt; {
      spyOn(window, &#x27;SpeechSynthesisUtterance&#x27;).and.returnValue(
        // This throws &quot;Argument of type &#x27;{ speak: () =&gt; void; onend:
        // () =&gt; void; }&#x27; is not assignable to parameter of type
        // &#x27;SpeechSynthesisUtterance&#x27;.&quot;. We need to suppress this error because
        // &#x27;SpeechSynthesisUtterance&#x27; has around 10 more properties. We have
        // only defined the properties we need in &#x27;mockSpeechSynthesisUtteran&#x27;.
        // @ts-expect-error
        mockSpeechSynthesisUtteran);
    });

    it(&#x27;should not speak when chunk is too short&#x27;, () =&gt; {
      const speakSpy = spyOn(window.speechSynthesis, &#x27;speak&#x27;).and
        .callFake(function() {
          mockSpeechSynthesisUtteran.onend();
        });
      const speechSynthesisUtterance = (
        new MockSpeechSynthesisUtteranceConstructor(&#x27;a&#x27;));
      const callbackSpy = jasmine.createSpy(&#x27;callback&#x27;);
      speechSynthesisChunkerService.speak(
        speechSynthesisUtterance, callbackSpy);

      expect(callbackSpy).toHaveBeenCalled();
      expect(speakSpy).not.toHaveBeenCalled();
    });

    it(&#x27;should not speak when chunk is a falsy value&#x27;, () =&gt; {
      const speakSpy = spyOn(window.speechSynthesis, &#x27;speak&#x27;).and
        .callFake(function() {
          mockSpeechSynthesisUtteran.onend();
        });
      const speechSynthesisUtterance = (
        new MockSpeechSynthesisUtteranceConstructor(&#x27;&#x27;));
      const callbackSpy = jasmine.createSpy(&#x27;callback&#x27;);
      speechSynthesisChunkerService.speak(
        speechSynthesisUtterance, callbackSpy);

      expect(callbackSpy).toHaveBeenCalled();
      expect(speakSpy).not.toHaveBeenCalled();
    });

    it(&#x27;should speak two phrases at a time&#x27;, fakeAsync(() =&gt; {
      const speakSpy = spyOn(window.speechSynthesis, &#x27;speak&#x27;).and
        .callFake(function() {
          mockSpeechSynthesisUtteran.onend();
        });
      const speechSynthesisUtterance = (
        new MockSpeechSynthesisUtteranceConstructor(
          &#x27;Value inside utterance for testing purposes.&#x27; +
          &#x27; This is the next chunk&#x27;));
      const callbackSpy = jasmine.createSpy(&#x27;callback&#x27;);
      speechSynthesisChunkerService.speak(
        speechSynthesisUtterance, callbackSpy);

      // Wait for 2 setTimeout calls to finished because there are
      // two chuncks in speechSynthesisUtterance.
      flush(2);

      expect(callbackSpy).toHaveBeenCalled();
      expect(speakSpy).toHaveBeenCalledTimes(2);
    }));

    it(&#x27;should speak only one phrase when cancel is requested&#x27;,
      fakeAsync(() =&gt; {
        const speakSpy = spyOn(window.speechSynthesis, &#x27;speak&#x27;).and
          .callFake(() =&gt; mockSpeechSynthesisUtteran.onend());
        const speechSynthesisUtterance = (
          new MockSpeechSynthesisUtteranceConstructor(

            &#x27;Value inside utterance for testing purposes.&#x27; +
            &#x27; This is the next chunk&#x27;));
        const callbackSpy = jasmine.createSpy(&#x27;callback&#x27;);
        speechSynthesisChunkerService.speak(
          speechSynthesisUtterance, callbackSpy);
        speechSynthesisChunkerService.cancel();

        // Wait for 1 setTimeout call to finished.
        flush(1);

        expect(callbackSpy).not.toHaveBeenCalled();
        expect(speakSpy).toHaveBeenCalledTimes(1);
      }));
  });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  