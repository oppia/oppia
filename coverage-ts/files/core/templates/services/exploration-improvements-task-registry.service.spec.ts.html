
  <!DOCTYPE html>
  <html>
    <head>
      <title>exploration-improvements-task-registry.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/services/exploration-improvements-task-registry.service.spec.ts</td><td class="">99.64%</td><td class="">100%</td><td class="">1102</td><td class="">1098</td><td class="">4</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the ExplorationImprovementsTaskRegistryService.
 */

import { TestBed } from &#x27;@angular/core/testing&#x27;;

import { AnswerStats, AnswerStatsBackendDict } from
  &#x27;domain/exploration/answer-stats.model&#x27;;
import {
  ExplorationTask,
  ExplorationTaskType,
  ExplorationTaskBackendDict,
  ExplorationTaskModel
} from &#x27;domain/improvements/exploration-task.model&#x27;;
import { HighBounceRateTask } from
  &#x27;domain/improvements/high-bounce-rate-task.model&#x27;;
import { StateStatsBackendDict } from
  &#x27;domain/statistics/state-stats-model&#x27;;
import { IneffectiveFeedbackLoopTask } from
  &#x27;domain/improvements/ineffective-feedback-loop-task.model&#x27;;
import { NeedsGuidingResponsesTask } from
  &#x27;domain/improvements/needs-guiding-response-task.model&#x27;;
import { SuccessiveIncorrectAnswersTask } from
  &#x27;domain/improvements/successive-incorrect-answers-task.model&#x27;;
import { ExplorationImprovementsConfig } from
  &#x27;domain/improvements/exploration-improvements-config.model&#x27;;
import { StateBackendDict } from &#x27;domain/state/StateObjectFactory&#x27;;
import { ExplorationStats, ExplorationStatsBackendDict } from
  &#x27;domain/statistics/exploration-stats.model&#x27;;
import {
  CyclicStateTransitionsPlaythroughIssue,
  EarlyQuitPlaythroughIssue,
  CyclicStateTransitionsPlaythroughIssueBackendDict,
  EarlyQuitPlaythroughIssueBackendDict,
  MultipleIncorrectSubmissionsPlaythroughIssueBackendDict,
  MultipleIncorrectSubmissionsPlaythroughIssue,
  PlaythroughIssueObjectFactory,
} from &#x27;domain/statistics/PlaythroughIssueObjectFactory&#x27;;
import { StatesObjectFactory } from &#x27;domain/exploration/StatesObjectFactory&#x27;;
import { ExplorationImprovementsTaskRegistryService } from
  &#x27;services/exploration-improvements-task-registry.service&#x27;;


describe(&#x27;Exploration improvements task registrar service&#x27;, () =&gt; {
  let taskRegistryService: ExplorationImprovementsTaskRegistryService;

  let playthroughIssueObjectFactory: PlaythroughIssueObjectFactory;
  let statesObjectFactory: StatesObjectFactory;

  let answerStatsBackendDict: AnswerStatsBackendDict;
  let cstPlaythroughIssueBackendDict:
    CyclicStateTransitionsPlaythroughIssueBackendDict;
  let eqPlaythroughIssueBackendDict:
    EarlyQuitPlaythroughIssueBackendDict;
  let expStatsBackendDict: ExplorationStatsBackendDict;
  let misPlaythroughIssueBackendDict:
    MultipleIncorrectSubmissionsPlaythroughIssueBackendDict;
  let stateBackendDict: StateBackendDict;
  let stateStatsBackendDict: StateStatsBackendDict;
  let statesBackendDict: {[stateName: string]: StateBackendDict};
  let taskBackendDict: ExplorationTaskBackendDict;
  let config: ExplorationImprovementsConfig;

  const expId = &#x27;eid&#x27;;
  const expVersion = 1;

  beforeEach(() =&gt; {
    taskRegistryService = (
      TestBed.get(ExplorationImprovementsTaskRegistryService));

    playthroughIssueObjectFactory = TestBed.get(PlaythroughIssueObjectFactory);
    statesObjectFactory = TestBed.get(StatesObjectFactory);

    config = new ExplorationImprovementsConfig(
      expId, expVersion, true, 0.25, 0.20, 100);

    stateBackendDict = {
      classifier_model_id: null,
      content: {
        content_id: &#x27;content&#x27;,
        html: &#x27;&#x27;
      },
      recorded_voiceovers: {
        voiceovers_mapping: {
          content: {},
          default_outcome: {}
        }
      },
      interaction: {
        answer_groups: [],
        confirmed_unclassified_answers: [],
        customization_args: {
          placeholder: {
            value: {
              content_id: &#x27;ca_placeholder_0&#x27;,
              unicode_str: &#x27;&#x27;
            }
          },
          rows: { value: 1 }
        },
        default_outcome: {
          dest: &#x27;new state&#x27;,
          feedback: {
            content_id: &#x27;default_outcome&#x27;,
            html: &#x27;&#x27;
          },
          labelled_as_correct: false,
          param_changes: [],
          refresher_exploration_id: null,
          missing_prerequisite_skill_id: null,
        },
        hints: [],
        solution: {
          answer_is_exclusive: false,
          correct_answer: &#x27;answer&#x27;,
          explanation: {
            content_id: &#x27;solution&#x27;,
            html: &#x27;&lt;p&gt;This is an explanation.&lt;/p&gt;&#x27;
          }
        },
        id: &#x27;TextInput&#x27;
      },
      linked_skill_id: null,
      next_content_id_index: 0,
      param_changes: [],
      solicit_answer_details: false,
      card_is_checkpoint: false,
      written_translations: {
        translations_mapping: {
          content: {},
          default_outcome: {}
        }
      },
    };

    stateStatsBackendDict = {
      total_hit_count: 100,
      total_answers_count: 100,
      num_completions: 100,
      num_times_solution_viewed: 5,
      first_hit_count: 100,
      useful_feedback_count: 8,
    };

    expStatsBackendDict = {
      exp_id: expId,
      exp_version: expVersion,
      num_starts: 1,
      num_actual_starts: 10,
      num_completions: 100,
      state_stats_mapping: {
        Introduction: stateStatsBackendDict,
        Middle: stateStatsBackendDict,
        End: stateStatsBackendDict,
      },
    };

    answerStatsBackendDict = {
      answer: &#x27;foo&#x27;,
      frequency: 5,
    };

    cstPlaythroughIssueBackendDict = {
      issue_type: &#x27;CyclicStateTransitions&#x27;,
      issue_customization_args: {
        state_names: {
          value: [&#x27;Middle&#x27;, &#x27;Introduction&#x27;]
        }
      },
      playthrough_ids: [&#x27;pid&#x27;],
      schema_version: 1,
      is_valid: true,
    };

    eqPlaythroughIssueBackendDict = {
      issue_type: &#x27;EarlyQuit&#x27;,
      issue_customization_args: {
        state_name: {
          value: &#x27;Introduction&#x27;
        },
        time_spent_in_exp_in_msecs: {
          value: 1200
        }
      },
      playthrough_ids: [&#x27;pid&#x27;],
      schema_version: 1,
      is_valid: true,
    };

    misPlaythroughIssueBackendDict = {
      issue_type: &#x27;MultipleIncorrectSubmissions&#x27;,
      issue_customization_args: {
        state_name: { value: &#x27;Introduction&#x27; },
        num_times_answered_incorrectly: { value: 3 },
      },
      playthrough_ids: [&#x27;pid&#x27;],
      schema_version: 1,
      is_valid: true,
    };

    taskBackendDict = {
      entity_type: &#x27;exploration&#x27;,
      entity_id: expId,
      entity_version: expVersion,
      task_type: &#x27;high_bounce_rate&#x27;,
      target_type: &#x27;state&#x27;,
      target_id: &#x27;Introduction&#x27;,
      issue_description: &#x27;20% of learners dropped at this state&#x27;,
      status: &#x27;open&#x27;,
      resolver_username: null,
      resolver_profile_picture_data_url: null,
      resolved_on_msecs: null,
    };

    statesBackendDict = {
      Introduction: stateBackendDict,
      Middle: stateBackendDict,
      End: stateBackendDict,
    };
  });

  const makeTask = (
    &lt;T extends ExplorationTask = ExplorationTask&gt;(dict = taskBackendDict) =&gt; {
      return &lt;T&gt; ExplorationTaskModel.createFromBackendDict(dict);
    });
  const makeStates = (map = statesBackendDict) =&gt; {
    return statesObjectFactory.createFromBackendDict(map);
  };
  const makeExpStats = (dict = expStatsBackendDict) =&gt; {
    return ExplorationStats.createFromBackendDict(dict);
  };
  const makeAnswerStats = (dict = answerStatsBackendDict) =&gt; {
    return AnswerStats.createFromBackendDict(dict);
  };
  const makeCstPlaythroughIssue = (dict = cstPlaythroughIssueBackendDict) =&gt; {
    return &lt;CyclicStateTransitionsPlaythroughIssue&gt; (
      playthroughIssueObjectFactory.createFromBackendDict(dict));
  };
  const makeEqPlaythroughIssue = (dict = eqPlaythroughIssueBackendDict) =&gt; {
    return &lt;EarlyQuitPlaythroughIssue&gt; (
      playthroughIssueObjectFactory.createFromBackendDict(dict));
  };
  const makeMisPlaythroughIssue = (dict = misPlaythroughIssueBackendDict) =&gt; {
    return &lt;MultipleIncorrectSubmissionsPlaythroughIssue&gt; (
      playthroughIssueObjectFactory.createFromBackendDict(dict));
  };

  it(&#x27;should initialize successfully using default test values&#x27;, () =&gt; {
    expect(
      () =&gt; taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []))
      .not.toThrowError();
  });

  it(&#x27;should return exp stats passed to initialization&#x27;, () =&gt; {
    const expStats = makeExpStats();

    taskRegistryService.initialize(
      config, makeStates(), expStats, [], new Map(), new Map(), []);

    expect(taskRegistryService.getExplorationStats()).toBe(expStats);
  });

  describe(&#x27;Validating initialize arguments&#x27;, () =&gt; {
    it(&#x27;should throw if stats is for wrong exploration&#x27;, () =&gt; {
      expStatsBackendDict.exp_id = &#x27;wrong_exp_id&#x27;;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), new Map(), []))
        .toThrowError(
          &#x27;Expected stats for exploration &quot;eid&quot;, but got stats for &#x27; +
          &#x27;exploration &quot;wrong_exp_id&quot;&#x27;);
    });

    it(&#x27;should throw if stats is for wrong exploration version&#x27;, () =&gt; {
      expStatsBackendDict.exp_version = 2;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), new Map(), []))
        .toThrowError(
          &#x27;Expected stats for exploration version 1, but got stats for &#x27; +
          &#x27;exploration version 2&#x27;);
    });

    it(&#x27;should throw if a task targets an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      taskBackendDict.target_id = &#x27;End&#x27;;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [makeTask()], new Map(),
          new Map(), []))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if a resolved task type targets an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      const resolvedTaskTypesByStateName = new Map([
        [&#x27;End&#x27;, &lt;ExplorationTaskType[]&gt; [&#x27;high_bounce_rate&#x27;]]
      ]);
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [],
          resolvedTaskTypesByStateName, new Map(), []))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if answer stats maps to an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      const answerStats = new Map([[&#x27;End&#x27;, [makeAnswerStats()]]]);
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), answerStats, []))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if CST playthrough issue maps to an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      cstPlaythroughIssueBackendDict.issue_customization_args
        .state_names.value = [&#x27;Introduction&#x27;, &#x27;End&#x27;];
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), new Map(),
          [makeCstPlaythroughIssue()]))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if EQ playthrough issue maps to an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      eqPlaythroughIssueBackendDict.issue_customization_args
        .state_name.value = &#x27;End&#x27;;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), new Map(),
          [makeEqPlaythroughIssue()]))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if MIS playthrough issue maps to an unknown state&#x27;, () =&gt; {
      delete statesBackendDict.End;
      misPlaythroughIssueBackendDict.issue_customization_args
        .state_name.value = &#x27;End&#x27;;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [], new Map(), new Map(),
          [makeMisPlaythroughIssue()]))
        .toThrowError(
          &#x27;Unexpected reference to state &quot;End&quot;, which does not exist&#x27;);
    });

    it(&#x27;should throw if task targets wrong exploration&#x27;, () =&gt; {
      taskBackendDict.entity_id = &#x27;wrong_exp_id&#x27;;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [makeTask()], new Map(),
          new Map(), []))
        .toThrowError(
          &#x27;Expected task for exploration &quot;eid&quot;, but got task for exploration &#x27; +
          &#x27;&quot;wrong_exp_id&quot;&#x27;);
    });

    it(&#x27;should throw if task targets wrong exploration version&#x27;, () =&gt; {
      taskBackendDict.entity_version = 2;
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [makeTask()], new Map(),
          new Map(), []))
        .toThrowError(
          &#x27;Expected task for exploration version 1, but got task for &#x27; +
          &#x27;exploration version 2&#x27;);
    });

    it(&#x27;should throw if open tasks with the same type are targeting the same &#x27; +
      &#x27;state&#x27;, () =&gt; {
      taskBackendDict.target_id = &#x27;Introduction&#x27;;
      taskBackendDict.task_type = &#x27;high_bounce_rate&#x27;;
      const tasks = [makeTask(), makeTask()];
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), tasks, new Map(), new Map(),
          []))
        .toThrowError(
          &#x27;Found duplicate task of type &quot;high_bounce_rate&quot; targeting state &#x27; +
          &#x27;&quot;Introduction&quot;&#x27;);
    });

    it(&#x27;should throw if open and resolved tasks with the same type are &#x27; +
      &#x27;targeting the same state&#x27;, () =&gt; {
      taskBackendDict.target_id = &#x27;Introduction&#x27;;
      taskBackendDict.task_type = &#x27;high_bounce_rate&#x27;;
      const resolvedTaskTypesByStateName = new Map([
        [&#x27;Introduction&#x27;, &lt;ExplorationTaskType[]&gt; [&#x27;high_bounce_rate&#x27;]]
      ]);
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [makeTask()],
          resolvedTaskTypesByStateName, new Map(), []))
        .toThrowError(
          &#x27;Found duplicate task of type &quot;high_bounce_rate&quot; targeting state &#x27; +
          &#x27;&quot;Introduction&quot;&#x27;);
    });

    it(&#x27;should throw if resolved tasks with the same type are targeting the &#x27; +
      &#x27;same state&#x27;, () =&gt; {
      const resolvedTaskTypesByStateName = new Map([
        [&#x27;Introduction&#x27;,
          &lt;ExplorationTaskType[]&gt; [&#x27;high_bounce_rate&#x27;, &#x27;high_bounce_rate&#x27;]],
      ]);
      expect(
        () =&gt; taskRegistryService.initialize(
          config, makeStates(), makeExpStats(), [],
          resolvedTaskTypesByStateName, new Map(), []))
        .toThrowError(
          &#x27;Found duplicate task of type &quot;high_bounce_rate&quot; targeting state &#x27; +
          &#x27;&quot;Introduction&quot;&#x27;);
    });
  });

  describe(&#x27;Post-initialization&#x27;, () =&gt; {
    it(&#x27;should not return a resolved task from the open tasks API&#x27;, () =&gt; {
      statesBackendDict = {Introduction: stateBackendDict};
      const resolvedTaskTypesByStateName = (
        new Map&lt;string, ExplorationTaskType[]&gt;([
          [&#x27;Introduction&#x27;, [
            &#x27;high_bounce_rate&#x27;, &#x27;ineffective_feedback_loop&#x27;,
            &#x27;needs_guiding_responses&#x27;, &#x27;successive_incorrect_answers&#x27;,
          ]],
        ]));

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], resolvedTaskTypesByStateName,
        new Map(), []);

      expect(taskRegistryService.getOpenHighBounceRateTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenIneffectiveFeedbackLoopTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(0);
      expect(
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks().length
      ).toEqual(0);
    });

    it(&#x27;should return tasks for each state as an array&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
        Middle: stateBackendDict,
        End: stateBackendDict,
      };

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []);

      expect(taskRegistryService.getAllStateTasks().map(st =&gt; st.stateName))
        .toEqual(jasmine.arrayContaining([&#x27;Introduction&#x27;, &#x27;Middle&#x27;, &#x27;End&#x27;]));
    });

    it(&#x27;should throw an error when state does not exist&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
        Middle: stateBackendDict,
        End: stateBackendDict,
      };

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []);

      expect(() =&gt; taskRegistryService.getStateTasks(&#x27;Epilogue&#x27;))
        .toThrowError(&#x27;Unknown state with name: Epilogue&#x27;);
    });

    it(&#x27;should return tasks for a specific state&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
        Middle: stateBackendDict,
        End: stateBackendDict,
      };

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []);

      expect(taskRegistryService.getStateTasks(&#x27;Introduction&#x27;).stateName)
        .toEqual(&#x27;Introduction&#x27;);
    });
  });

  describe(&#x27;Generating new tasks&#x27;, () =&gt; {
    it(&#x27;should not generate open tasks when they do not exist&#x27;, () =&gt; {
      statesBackendDict = {Introduction: stateBackendDict};
      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []);

      expect(taskRegistryService.getOpenHighBounceRateTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenIneffectiveFeedbackLoopTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(0);
      expect(
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks().length
      ).toEqual(0);
    });

    it(&#x27;should generate a new high bounce rate task&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
      };
      expStatsBackendDict.num_starts = 500;
      expStatsBackendDict.state_stats_mapping = {
        Introduction: {
          ...stateStatsBackendDict,
          ...{total_hit_count: 500, num_completions: 350},
        },
      };

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(),
        [makeEqPlaythroughIssue()]);

      const [hbrTask] = taskRegistryService.getOpenHighBounceRateTasks();
      expect(hbrTask.isOpen()).toBeTrue();
    });

    it(&#x27;should generate a new ineffective feedback loop task&#x27;, () =&gt; {
      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(),
        [makeCstPlaythroughIssue()]);

      const [iflTask] = (
        taskRegistryService.getOpenIneffectiveFeedbackLoopTasks());
      expect(iflTask.isOpen()).toBeTrue();
    });

    it(&#x27;should generate a new needs guiding responses task&#x27;, () =&gt; {
      const answerStats = makeAnswerStats();
      answerStats.isAddressed = false;
      const stateAnswerStats = new Map([[&#x27;Introduction&#x27;, [answerStats]]]);

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), stateAnswerStats,
        []);

      const [ngrTask] = taskRegistryService.getOpenNeedsGuidingResponsesTasks();
      expect(ngrTask.isOpen()).toBeTrue();
    });

    it(&#x27;should generate a new successive incorrect answers task&#x27;, () =&gt; {
      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(),
        [makeMisPlaythroughIssue()]);

      const [siaTask] = (
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks());
      expect(siaTask.isOpen()).toBeTrue();
    });
  });

  describe(&#x27;Discarding open tasks&#x27;, () =&gt; {
    it(&#x27;should discard an HBR task when bounce rate is too low&#x27;, () =&gt; {
      const task = makeTask&lt;HighBounceRateTask&gt;(
        {...taskBackendDict, ...{status: &#x27;open&#x27;}});
      statesBackendDict = {
        Introduction: stateBackendDict,
      };
      expStatsBackendDict.num_starts = 500;
      expStatsBackendDict.state_stats_mapping = {
        Introduction: {
          ...stateStatsBackendDict,
          ...{total_hit_count: 500, num_completions: 450},
        },
      };

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [task], new Map(), new Map(), []);

      expect(taskRegistryService.getOpenHighBounceRateTasks().length)
        .toEqual(0);
    });

    it(&#x27;should discard an NGR task when all answers are addressed&#x27;, () =&gt; {
      const states = makeStates();
      const answerStats = makeAnswerStats();
      answerStats.isAddressed = false;
      const stateAnswerStats = new Map([[&#x27;Introduction&#x27;, [answerStats]]]);

      taskRegistryService.initialize(
        config, states, makeExpStats(), [], new Map(), stateAnswerStats, []);

      const [ngrTask] = taskRegistryService.getOpenNeedsGuidingResponsesTasks();
      expect(ngrTask.isOpen()).toBeTrue();

      answerStats.isAddressed = true;

      taskRegistryService.onStateInteractionSaved(
        states.getState(&#x27;Introduction&#x27;));
      expect(ngrTask.isOpen()).toBeFalse();
    });
  });

  describe(&#x27;Handling state changes&#x27;, () =&gt; {
    it(&#x27;should create new obsolete tasks for newly created state&#x27;, () =&gt; {
      statesBackendDict = {Introduction: stateBackendDict};
      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(), [], new Map(), new Map(), []);

      expect(taskRegistryService.getOpenHighBounceRateTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenIneffectiveFeedbackLoopTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(0);
      expect(
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks().length
      ).toEqual(0);

      taskRegistryService.onStateAdded(&#x27;Middle&#x27;);

      expect(taskRegistryService.getOpenHighBounceRateTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenIneffectiveFeedbackLoopTasks().length)
        .toEqual(0);
      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(0);
      expect(
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks().length
      ).toEqual(0);
    });

    it(&#x27;should have an obsolete and re-targeted task for states that are &#x27; +
      &#x27;renamed&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
      };
      expStatsBackendDict.num_starts = 500;
      expStatsBackendDict.state_stats_mapping = {
        Introduction: {
          ...stateStatsBackendDict,
          ...{total_hit_count: 500, num_completions: 350},
        },
      };
      const answerStats = makeAnswerStats();
      answerStats.isAddressed = false;
      const stateAnswerStats = new Map([[&#x27;Introduction&#x27;, [answerStats]]]);

      taskBackendDict.status = &#x27;open&#x27;;
      let [hbrTask, iflTask, ngrTask, siaTask] = [
        makeTask&lt;HighBounceRateTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;high_bounce_rate&#x27;}}),
        makeTask&lt;IneffectiveFeedbackLoopTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;ineffective_feedback_loop&#x27;}}),
        makeTask&lt;NeedsGuidingResponsesTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;needs_guiding_responses&#x27;}}),
        makeTask&lt;SuccessiveIncorrectAnswersTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;successive_incorrect_answers&#x27;}}),
      ];
      statesBackendDict = {Introduction: stateBackendDict};

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(),
        [hbrTask, iflTask, ngrTask, siaTask], new Map(), stateAnswerStats,
        [makeEqPlaythroughIssue()]);

      expect(hbrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(hbrTask.isOpen()).toBeTrue();
      expect(iflTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(iflTask.isOpen()).toBeTrue();
      expect(ngrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(ngrTask.isOpen()).toBeTrue();
      expect(siaTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(siaTask.isOpen()).toBeTrue();

      taskRegistryService.onStateRenamed(&#x27;Introduction&#x27;, &#x27;Prologue&#x27;);

      let [[newHbrTask], [newIflTask], [newNgrTask], [newSiaTask]] = [
        taskRegistryService.getOpenHighBounceRateTasks(),
        taskRegistryService.getOpenIneffectiveFeedbackLoopTasks(),
        taskRegistryService.getOpenNeedsGuidingResponsesTasks(),
        taskRegistryService.getOpenSuccessiveIncorrectAnswersTasks(),
      ];

      expect(hbrTask.isObsolete()).toBeTrue();
      expect(hbrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(iflTask.isObsolete()).toBeTrue();
      expect(iflTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(ngrTask.isObsolete()).toBeTrue();
      expect(ngrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(siaTask.isObsolete()).toBeTrue();
      expect(siaTask.targetId).toEqual(&#x27;Introduction&#x27;);

      expect(newHbrTask.isOpen()).toBeTrue();
      expect(newHbrTask.targetId).toEqual(&#x27;Prologue&#x27;);
      expect(newIflTask.isOpen()).toBeTrue();
      expect(newIflTask.targetId).toEqual(&#x27;Prologue&#x27;);
      expect(newNgrTask.isOpen()).toBeTrue();
      expect(newNgrTask.targetId).toEqual(&#x27;Prologue&#x27;);
      expect(newSiaTask.isOpen()).toBeTrue();
      expect(newSiaTask.targetId).toEqual(&#x27;Prologue&#x27;);
    });

    it(&#x27;should discard tasks targeting a state that is newly deleted&#x27;, () =&gt; {
      statesBackendDict = {
        Introduction: stateBackendDict,
      };
      expStatsBackendDict.num_starts = 500;
      expStatsBackendDict.state_stats_mapping = {
        Introduction: {
          ...stateStatsBackendDict,
          ...{total_hit_count: 500, num_completions: 350},
        },
      };
      const answerStats = makeAnswerStats();
      answerStats.isAddressed = false;
      const stateAnswerStats = new Map([[&#x27;Introduction&#x27;, [answerStats]]]);

      taskBackendDict.status = &#x27;open&#x27;;
      let [hbrTask, iflTask, ngrTask, siaTask] = [
        makeTask&lt;HighBounceRateTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;high_bounce_rate&#x27;}}),
        makeTask&lt;IneffectiveFeedbackLoopTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;ineffective_feedback_loop&#x27;}}),
        makeTask&lt;NeedsGuidingResponsesTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;needs_guiding_responses&#x27;}}),
        makeTask&lt;SuccessiveIncorrectAnswersTask&gt;(
          {...taskBackendDict, ...{task_type: &#x27;successive_incorrect_answers&#x27;}}),
      ];
      statesBackendDict = {Introduction: stateBackendDict};

      taskRegistryService.initialize(
        config, makeStates(), makeExpStats(),
        [hbrTask, iflTask, ngrTask, siaTask], new Map(), stateAnswerStats,
        [makeEqPlaythroughIssue()]);

      expect(hbrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(hbrTask.isOpen()).toBeTrue();
      expect(iflTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(iflTask.isOpen()).toBeTrue();
      expect(ngrTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(ngrTask.isOpen()).toBeTrue();
      expect(siaTask.targetId).toEqual(&#x27;Introduction&#x27;);
      expect(siaTask.isOpen()).toBeTrue();

      taskRegistryService.onStateDeleted(&#x27;Introduction&#x27;);

      expect(hbrTask.isOpen()).toBeFalse();
      expect(iflTask.isOpen()).toBeFalse();
      expect(ngrTask.isOpen()).toBeFalse();
      expect(siaTask.isOpen()).toBeFalse();
    });

    it(&#x27;should open a new NGR task after initialization if an answer becomes &#x27; +
      &#x27;unaddressed&#x27;, () =&gt; {
      const states = makeStates();
      const answerStats = makeAnswerStats();
      answerStats.isAddressed = true;
      const stateAnswerStats = new Map([[&#x27;Introduction&#x27;, [answerStats]]]);

      taskRegistryService.initialize(
        config, states, makeExpStats(), [], new Map(), stateAnswerStats, []);

      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(0);

      answerStats.isAddressed = false;

      taskRegistryService.onStateInteractionSaved(
        states.getState(&#x27;Introduction&#x27;));
      expect(taskRegistryService.getOpenNeedsGuidingResponsesTasks().length)
        .toEqual(1);
    });
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/services/exploration-improvements-task-registry.service.spec.ts&quot;,&quot;line&quot;:237,&quot;character&quot;:13,&quot;text&quot;:&quot;&lt;T&gt; ExplorationTaskModel.createFromBackendDict(dict)&quot;,&quot;kind&quot;:4},{&quot;file&quot;:&quot;core/templates/services/exploration-improvements-task-registry.service.spec.ts&quot;,&quot;line&quot;:249,&quot;character&quot;:11,&quot;text&quot;:&quot;&lt;CyclicStateTransitionsPlaythroughIssue&gt; (\n      playthroughIssueObjectFactory.createFromBackendDict(dict))&quot;,&quot;kind&quot;:4},{&quot;file&quot;:&quot;core/templates/services/exploration-improvements-task-registry.service.spec.ts&quot;,&quot;line&quot;:253,&quot;character&quot;:11,&quot;text&quot;:&quot;&lt;EarlyQuitPlaythroughIssue&gt; (\n      playthroughIssueObjectFactory.createFromBackendDict(dict))&quot;,&quot;kind&quot;:4},{&quot;file&quot;:&quot;core/templates/services/exploration-improvements-task-registry.service.spec.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:11,&quot;text&quot;:&quot;&lt;MultipleIncorrectSubmissionsPlaythroughIssue&gt; (\n      playthroughIssueObjectFactory.createFromBackendDict(dict))&quot;,&quot;kind&quot;:4}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  