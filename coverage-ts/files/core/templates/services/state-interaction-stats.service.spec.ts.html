
  <!DOCTYPE html>
  <html>
    <head>
      <title>state-interaction-stats.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/services/state-interaction-stats.service.spec.ts</td><td class="">98.64%</td><td class="">100%</td><td class="">513</td><td class="">506</td><td class="">7</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for state interaction stats service.
 */

import { TestBed, flushMicrotasks, fakeAsync } from &#x27;@angular/core/testing&#x27;;
import { HttpClientTestingModule, HttpTestingController } from
  &#x27;@angular/common/http/testing&#x27;;

import { NormalizeWhitespacePipe } from
  &#x27;filters/string-utility-filters/normalize-whitespace.pipe&#x27;;
import { NormalizeWhitespacePunctuationAndCasePipe } from
  // eslint-disable-next-line max-len
  &#x27;filters/string-utility-filters/normalize-whitespace-punctuation-and-case.pipe&#x27;;
import { StateInteractionStats, StateInteractionStatsService } from
  &#x27;services/state-interaction-stats.service&#x27;;
import { SubtitledHtml } from &#x27;domain/exploration/subtitled-html.model&#x27;;
import { State, StateBackendDict, StateObjectFactory } from
  &#x27;domain/state/StateObjectFactory&#x27;;

const joC = jasmine.objectContaining;

describe(&#x27;State Interaction Stats Service&#x27;, () =&gt; {
  let httpTestingController: HttpTestingController;
  let stateObjectFactory: StateObjectFactory;
  let stateInteractionStatsService: StateInteractionStatsService;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [
        HttpClientTestingModule,
      ],
      providers: [
        NormalizeWhitespacePipe,
        NormalizeWhitespacePunctuationAndCasePipe
      ],
    });

    stateObjectFactory = TestBed.get(StateObjectFactory);
    httpTestingController = TestBed.get(HttpTestingController);
    stateInteractionStatsService = (
      TestBed.get(StateInteractionStatsService));
  });

  afterEach(() =&gt; httpTestingController.verify());

  const expId = &#x27;expid&#x27;;
  let mockState: State;

  beforeEach(() =&gt; {
    const stateDict: StateBackendDict = {
      classifier_model_id: &#x27;model_id&#x27;,
      content: {
        content_id: &#x27;content&#x27;,
        html: &#x27;content&#x27;
      },
      recorded_voiceovers: {
        voiceovers_mapping: {}
      },
      interaction: {
        answer_groups: [
          {
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {x: {
                contentId: &#x27;rule_input&#x27;,
                normalizedStrSet: [&#x27;hola!&#x27;]
              }}
            }],
            outcome: {
              dest: &#x27;Me Llamo&#x27;,
              feedback: {content_id: &#x27;feedback_1&#x27;, html: &#x27;¡Buen trabajo!&#x27;},
              labelled_as_correct: true,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null,
            },
            training_data: null,
            tagged_skill_misconception_id: null,
          },
          {
            rule_specs: [{
              rule_type: &#x27;Contains&#x27;,
              inputs: {x: {
                contentId: &#x27;rule_input&#x27;,
                normalizedStrSet: [&#x27;hola&#x27;]
              }}
            }],
            outcome: {
              dest: &#x27;Me Llamo&#x27;,
              feedback: {content_id: &#x27;feedback_1&#x27;, html: &#x27;¡Buen trabajo!&#x27;},
              labelled_as_correct: true,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null,
            },
            training_data: null,
            tagged_skill_misconception_id: null,
          },
          {
            rule_specs: [{
              rule_type: &#x27;FuzzyEquals&#x27;,
              inputs: {x: {
                contentId: &#x27;rule_input&#x27;,
                normalizedStrSet: [&#x27;hola&#x27;]
              }}
            }],
            outcome: {
              dest: &#x27;Me Llamo&#x27;,
              feedback: {content_id: &#x27;feedback_1&#x27;, html: &#x27;¡Buen trabajo!&#x27;},
              labelled_as_correct: true,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null,
            },
            training_data: null,
            tagged_skill_misconception_id: null,
          }
        ],
        confirmed_unclassified_answers: [],
        customization_args: {
          placeholder: {
            value: {
              content_id: &#x27;ca_placeholder_0&#x27;,
              unicode_str: &#x27;&#x27;
            }
          },
          rows: { value: 1 }
        },
        default_outcome: {
          dest: &#x27;Hola&#x27;,
          feedback: {content_id: &#x27;default_outcome&#x27;, html: &#x27;&#x27;},
          labelled_as_correct: true,
          param_changes: [],
          refresher_exploration_id: null,
          missing_prerequisite_skill_id: null,
        },
        hints: [],
        id: &#x27;TextInput&#x27;,
        solution: {
          answer_is_exclusive: true,
          correct_answer: &#x27;&#x27;,
          explanation: {
            content_id: &#x27;&#x27;,
            html: &#x27;&#x27;
          }
        }
      },
      param_changes: [],
      solicit_answer_details: false,
      card_is_checkpoint: false,
      written_translations: {
        translations_mapping: {}
      },
      linked_skill_id: null,
      next_content_id_index: 0
    };

    mockState = stateObjectFactory.createFromBackendDict(&#x27;Hola&#x27;, stateDict);
  });

  it(&#x27;should support improvements overview for states with text-input&#x27;, () =&gt; {
    expect(
      stateInteractionStatsService.stateSupportsImprovementsOverview(mockState)
    ).toBeTrue();
  });

  describe(&#x27;when gathering stats from the backend&#x27;, () =&gt; {
    it(&#x27;should provide cached results after first call&#x27;, fakeAsync(() =&gt; {
      let statsCaptured: StateInteractionStats[] = [];
      const captureStats = (stats: StateInteractionStats) =&gt; {
        expect(stats).toBeDefined();
        statsCaptured.push(stats);
      };

      stateInteractionStatsService.computeStatsAsync(expId, mockState)
        .then(captureStats);
      const req = httpTestingController.expectOne(
        &#x27;/createhandler/state_interaction_stats/expid/Hola&#x27;);
      expect(req.request.method).toEqual(&#x27;GET&#x27;);
      req.flush({
        visualizations_info: [{
          data: [
            {answer: &#x27;Ni Hao&#x27;, frequency: 5},
            {answer: &#x27;Aloha&#x27;, frequency: 3},
            {answer: &#x27;Hola&#x27;, frequency: 1}
          ]
        }]
      });
      flushMicrotasks();

      stateInteractionStatsService.computeStatsAsync(expId, mockState)
        .then(captureStats);
      httpTestingController.expectNone(
        &#x27;/createhandler/state_interaction_stats/expid/Hola&#x27;);
      flushMicrotasks();

      expect(statsCaptured.length).toEqual(2);
      const [statsFromFirstFetch, statsFromSecondFetch] = statsCaptured;
      expect(statsFromSecondFetch).toBe(statsFromFirstFetch);
    }));

    it(&#x27;should have separate caches for different states&#x27;, fakeAsync(() =&gt; {
      let statsCaptured: StateInteractionStats[] = [];
      const captureStats = (stats: StateInteractionStats) =&gt; {
        expect(stats).toBeDefined();
        statsCaptured.push(stats);
      };

      stateInteractionStatsService.computeStatsAsync(expId, mockState)
        .then(captureStats);
      const holaReq = httpTestingController.expectOne(
        &#x27;/createhandler/state_interaction_stats/expid/Hola&#x27;);
      expect(holaReq.request.method).toEqual(&#x27;GET&#x27;);
      holaReq.flush({
        visualizations_info: [{
          data: [
            {answer: &#x27;Ni Hao&#x27;, frequency: 5},
            {answer: &#x27;Aloha&#x27;, frequency: 3},
            {answer: &#x27;Hola&#x27;, frequency: 1}
          ]
        }]
      });
      flushMicrotasks();

      mockState.name = &#x27;Adios&#x27;;
      stateInteractionStatsService.computeStatsAsync(expId, mockState)
        .then(captureStats);
      const adiosReq = httpTestingController.expectOne(
        &#x27;/createhandler/state_interaction_stats/expid/Adios&#x27;);
      expect(adiosReq.request.method).toEqual(&#x27;GET&#x27;);
      adiosReq.flush({
        visualizations_info: [{
          data: [
            {answer: &#x27;Zai Jian&#x27;, frequency: 5},
            {answer: &#x27;Aloha&#x27;, frequency: 3},
            {answer: &#x27;Adios&#x27;, frequency: 1}
          ]
        }]
      });
      flushMicrotasks();

      expect(statsCaptured.length).toEqual(2);
      const [statsFromFirstFetch, statsFromSecondFetch] = statsCaptured;
      expect(statsFromSecondFetch).not.toBe(statsFromFirstFetch);
    }));

    it(&#x27;should include answer frequencies in the response&#x27;, fakeAsync(() =&gt; {
      const onSuccess = jasmine.createSpy(&#x27;success&#x27;);
      const onFailure = jasmine.createSpy(&#x27;failure&#x27;);

      stateInteractionStatsService.computeStatsAsync(expId, mockState)
        .then(onSuccess, onFailure);

      const req = httpTestingController.expectOne(
        &#x27;/createhandler/state_interaction_stats/expid/Hola&#x27;);
      expect(req.request.method).toEqual(&#x27;GET&#x27;);
      req.flush({
        visualizations_info: [{
          data: [
            {answer: &#x27;Ni Hao&#x27;, frequency: 5},
            {answer: &#x27;Aloha&#x27;, frequency: 3},
            {answer: &#x27;Hola&#x27;, frequency: 1}
          ]
        }]
      });
      flushMicrotasks();

      expect(onSuccess).toHaveBeenCalledWith(joC({
        visualizationsInfo: [joC({
          data: [
            joC({answer: &#x27;Ni Hao&#x27;, frequency: 5}),
            joC({answer: &#x27;Aloha&#x27;, frequency: 3}),
            joC({answer: &#x27;Hola&#x27;, frequency: 1})
          ]
        })]
      }));
      expect(onFailure).not.toHaveBeenCalled();
    }));

    it(
      &#x27;should determine whether TextInput answers are addressed explicitly&#x27;,
      fakeAsync(() =&gt; {
        const onSuccess = jasmine.createSpy(&#x27;success&#x27;);
        const onFailure = jasmine.createSpy(&#x27;failure&#x27;);

        stateInteractionStatsService.computeStatsAsync(expId, mockState).then(
          onSuccess, onFailure);

        const req = httpTestingController.expectOne(
          &#x27;/createhandler/state_interaction_stats/expid/Hola&#x27;);
        expect(req.request.method).toEqual(&#x27;GET&#x27;);
        req.flush({
          visualizations_info: [{
            data: [{answer: &#x27;Ni Hao&#x27;}, {answer: &#x27;Aloha&#x27;}, {answer: &#x27;Hola&#x27;}],
            addressed_info_is_supported: true
          }]
        });
        flushMicrotasks();

        expect(onSuccess).toHaveBeenCalledWith(joC({
          visualizationsInfo: [joC({
            data: [
              joC({answer: &#x27;Ni Hao&#x27;, isAddressed: false}),
              joC({answer: &#x27;Aloha&#x27;, isAddressed: false}),
              joC({answer: &#x27;Hola&#x27;, isAddressed: true})
            ]
          })]
        }));
        expect(onFailure).not.toHaveBeenCalled();
      }));

    it(&#x27;should return content of MultipleChoiceInput answers&#x27;, fakeAsync(() =&gt; {
      const onSuccess = jasmine.createSpy(&#x27;success&#x27;);
      const onFailure = jasmine.createSpy(&#x27;failure&#x27;);

      mockState.name = &#x27;Fraction&#x27;;
      mockState.interaction.id = &#x27;MultipleChoiceInput&#x27;;
      mockState.interaction.customizationArgs = {
        choices: {
          value: [
            new SubtitledHtml(&#x27;&lt;p&gt;foo&lt;/p&gt;&#x27;, &#x27;&#x27;),
            new SubtitledHtml(&#x27;&lt;p&gt;bar&lt;/p&gt;&#x27;, &#x27;&#x27;)
          ]
        }
      };
      stateInteractionStatsService.computeStatsAsync(expId, mockState).then(
        onSuccess, onFailure);

      const req = httpTestingController.expectOne(
        &#x27;/createhandler/state_interaction_stats/expid/Fraction&#x27;);
      expect(req.request.method).toEqual(&#x27;GET&#x27;);
      req.flush({
        visualizations_info: [{
          data: [{answer: 0, frequency: 3}, {answer: 1, frequency: 5}],
        }]
      });
      flushMicrotasks();

      expect(onSuccess).toHaveBeenCalledWith(joC({
        visualizationsInfo: [joC({
          data: [
            joC({answer: &#x27;&lt;p&gt;foo&lt;/p&gt;&#x27;}),
            joC({answer: &#x27;&lt;p&gt;bar&lt;/p&gt;&#x27;}),
          ]
        })]
      }));
    }));

    it(
      &#x27;should return FractionInput answers as readable strings&#x27;,
      fakeAsync(() =&gt; {
        const onSuccess = jasmine.createSpy(&#x27;success&#x27;);
        const onFailure = jasmine.createSpy(&#x27;failure&#x27;);

        mockState.name = &#x27;Fraction&#x27;;
        mockState.interaction.id = &#x27;FractionInput&#x27;;
        mockState.interaction.customizationArgs = {
          choices: {
            value: [
              new SubtitledHtml(&#x27;&lt;p&gt;foo&lt;/p&gt;&#x27;, &#x27;&#x27;),
              new SubtitledHtml(&#x27;&lt;p&gt;bar&lt;/p&gt;&#x27;, &#x27;&#x27;)
            ]
          }
        };

        stateInteractionStatsService.computeStatsAsync(expId, mockState).then(
          onSuccess, onFailure);

        const req = httpTestingController.expectOne(
          &#x27;/createhandler/state_interaction_stats/expid/Fraction&#x27;);
        expect(req.request.method).toEqual(&#x27;GET&#x27;);
        req.flush({
          visualizations_info: [
            {
              data: [
                {
                  answer: {
                    isNegative: false,
                    wholeNumber: 0,
                    numerator: 1,
                    denominator: 2
                  },
                  frequency: 3
                },
                {
                  answer: {
                    isNegative: false,
                    wholeNumber: 0,
                    numerator: 0,
                    denominator: 1
                  },
                  frequency: 5
                }
              ]
            }
          ]
        });
        flushMicrotasks();

        expect(onSuccess).toHaveBeenCalledWith(joC({
          visualizationsInfo: [joC({
            data: [
              joC({ answer: &#x27;1/2&#x27; }),
              joC({ answer: &#x27;0&#x27; })
            ]
          })]
        }));
      }));
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:192,&quot;character&quot;:17,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:226,&quot;character&quot;:21,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:243,&quot;character&quot;:22,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:269,&quot;character&quot;:17,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:304,&quot;character&quot;:19,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:344,&quot;character&quot;:17,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/services/state-interaction-stats.service.spec.ts&quot;,&quot;line&quot;:384,&quot;character&quot;:19,&quot;text&quot;:&quot;request&quot;,&quot;kind&quot;:2}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  