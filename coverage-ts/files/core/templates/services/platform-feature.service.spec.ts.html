
  <!DOCTYPE html>
  <html>
    <head>
      <title>platform-feature.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/services/platform-feature.service.spec.ts</td><td class="">99.17%</td><td class="">100%</td><td class="">480</td><td class="">476</td><td class="">4</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2020 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for PlatformFeatureService.
 */

import { TestBed, fakeAsync, flushMicrotasks, tick } from
  &#x27;@angular/core/testing&#x27;;
import { HttpClientTestingModule } from &#x27;@angular/common/http/testing&#x27;;

import { WindowRef } from &#x27;services/contextual/window-ref.service&#x27;;
import { PlatformFeatureService, platformFeatureInitFactory } from
  &#x27;services/platform-feature.service&#x27;;
import { PlatformFeatureBackendApiService } from
  &#x27;domain/platform_feature/platform-feature-backend-api.service&#x27;;
import { FeatureNames, FeatureStatusSummary } from
  &#x27;domain/platform_feature/feature-status-summary.model&#x27;;
import { UrlService } from &#x27;services/contextual/url.service&#x27;;


describe(&#x27;PlatformFeatureService&#x27;, () =&gt; {
  let windowRef: WindowRef;
  let apiService: PlatformFeatureBackendApiService;
  let platformFeatureService: PlatformFeatureService;
  let urlService: UrlService;

  let mockSessionStore: (obj: object) =&gt; void;
  let mockCookie: (cookieStr: string) =&gt; void;
  let mockPathName: (pathName: string) =&gt; void;

  let apiSpy: jasmine.Spy;

  // These properties are static, which are not automatically cleared after
  // each test, so we need to manually clear the state of
  // PlatformFeatureService.
  const clearStaticProperties = () =&gt; {
    PlatformFeatureService.featureStatusSummary = null;
    PlatformFeatureService._isInitializedWithError = false;
    PlatformFeatureService.initializationPromise = null;
  };

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
    });

    windowRef = TestBed.get(WindowRef);
    apiService = TestBed.get(PlatformFeatureBackendApiService);
    urlService = TestBed.get(UrlService);

    clearStaticProperties();

    const store = {};
    let cookie = &#x27;&#x27;;
    let userAgent = &#x27;&#x27;;
    spyOnProperty(windowRef, &#x27;nativeWindow&#x27;).and.returnValue({
      sessionStorage: {
        getItem: (key: string) =&gt; store[key] || null,
        setItem: (key: string, value: string) =&gt; store[key] = value,
        removeItem: (key: string) =&gt; delete store[key]
      },
      document: {
        get cookie() {
          return cookie;
        }
      },
      navigator: {
        get userAgent() {
          return userAgent;
        }
      }
    });
    mockSessionStore = (obj: object) =&gt; {
      Object.assign(store, obj);
    };
    mockCookie = (cookieStr: string) =&gt; cookie = cookieStr;

    let pathName = &#x27;/&#x27;;
    spyOn(urlService, &#x27;getPathname&#x27;).and.callFake(() =&gt; pathName);
    mockPathName = path =&gt; pathName = path;

    apiSpy = spyOn(apiService, &#x27;fetchFeatureFlags&#x27;).and.resolveTo(
      FeatureStatusSummary.createFromBackendDict({
        [FeatureNames.DummyFeature]: true,
      })
    );
  });

  describe(&#x27;.initialize&#x27;, () =&gt; {
    it(&#x27;should load from server when storage is clean.&#x27;, fakeAsync(() =&gt; {
      const successHandler = jasmine.createSpy(&#x27;success&#x27;);
      const failHandler = jasmine.createSpy(&#x27;fail&#x27;);
      platformFeatureService = TestBed.get(PlatformFeatureService);
      platformFeatureService.initialize()
        .then(successHandler, failHandler);

      flushMicrotasks();

      expect(apiService.fetchFeatureFlags).toHaveBeenCalled();
      expect(successHandler).toHaveBeenCalled();
      expect(failHandler).not.toHaveBeenCalled();
      expect(platformFeatureService.isInitialzedWithError).toBeFalse();
    }));

    it(&#x27;should save results in sessionStorage after loading.&#x27;, fakeAsync(() =&gt; {
      const sessionId = &#x27;session_id&#x27;;
      mockCookie(`SACSID=${sessionId}`);
      platformFeatureService = TestBed.get(PlatformFeatureService);

      const timestamp = Date.now();

      flushMicrotasks();

      expect(apiService.fetchFeatureFlags).toHaveBeenCalled();
      expect(
        windowRef.nativeWindow.sessionStorage.getItem(&#x27;SAVED_FEATURE_FLAGS&#x27;)
      ).not.toBeNull();
      expect(
        JSON.parse(windowRef.nativeWindow.sessionStorage.getItem(
          &#x27;SAVED_FEATURE_FLAGS&#x27;))
      ).toEqual({
        timestamp: timestamp,
        sessionId: sessionId,
        featureStatusSummary: {
          [FeatureNames.DummyFeature]: true,
        }
      });
      expect(platformFeatureService.isInitialzedWithError).toBeFalse();
    }));

    it(
      &#x27;should use SACSID instead of dev_appserver_login as sessionId when&#x27; +
      &#x27; saving results.&#x27;, fakeAsync(() =&gt; {
        const sessionId = &#x27;session_id&#x27;;
        mockCookie(`SACSID=${sessionId}; dev_appserver_login=should_not_use`);

        platformFeatureService = TestBed.get(PlatformFeatureService);

        flushMicrotasks();

        expect(
          JSON.parse(windowRef.nativeWindow.sessionStorage.getItem(
            &#x27;SAVED_FEATURE_FLAGS&#x27;))
            .sessionId
        ).toEqual(sessionId);
      })
    );

    it(
      &#x27;should use dev_app_server_login as sessionId when no SACSID is set&#x27;,
      fakeAsync(() =&gt; {
        const sessionId = &#x27;session_id&#x27;;
        mockCookie(`dev_appserver_login=${sessionId}`);

        platformFeatureService = TestBed.get(PlatformFeatureService);

        flushMicrotasks();

        expect(
          JSON.parse(windowRef.nativeWindow.sessionStorage.getItem(
            &#x27;SAVED_FEATURE_FLAGS&#x27;))
            .sessionId
        ).toEqual(sessionId);
      })
    );

    it(&#x27;should load from sessionStorage if there are valid results.&#x27;, fakeAsync(
      () =&gt; {
        const sessionId = &#x27;session_id&#x27;;
        mockCookie(`SACSID=${sessionId}`);
        mockSessionStore({
          SAVED_FEATURE_FLAGS: JSON.stringify({
            sessionId: sessionId,
            timestamp: Date.now(),
            featureStatusSummary: {
              [FeatureNames.DummyFeature]: true,
            }
          })
        });

        // Ticks 60 secs, as stored results are valid for 12 hrs, the results
        // should still be valid.
        tick(60 * 1000);
        platformFeatureService = TestBed.get(PlatformFeatureService);

        flushMicrotasks();

        expect(apiService.fetchFeatureFlags).not.toHaveBeenCalled();
        expect(platformFeatureService.isInitialzedWithError).toBeFalse();
      })
    );

    it(&#x27;should load from server if saved results have expired.&#x27;,
      fakeAsync(() =&gt; {
        const sessionId = &#x27;session_id&#x27;;
        mockCookie(`SACSID=${sessionId}`);
        mockSessionStore({
          SAVED_FEATURE_FLAGS: JSON.stringify({
            sessionId: sessionId,
            timestamp: Date.now(),
            featureStatusSummary: {
              [FeatureNames.DummyFeature]: true,
            }
          })
        });

        // Ticks 13 hrs, as stored results are valid for 12 hrs, ths results
        // should have expired.
        tick(13 * 3600 * 1000);
        platformFeatureService = TestBed.get(PlatformFeatureService);

        flushMicrotasks();

        expect(apiService.fetchFeatureFlags).toHaveBeenCalled();
        expect(platformFeatureService.isInitialzedWithError).toBeFalse();
      })
    );

    it(
      &#x27;should load from server if sessionId of saved result does not match.&#x27;,
      fakeAsync(() =&gt; {
        const sessionId = &#x27;session_id&#x27;;
        mockCookie(`SACSID=${sessionId}`);
        mockSessionStore({
          SAVED_FEATURE_FLAGS: JSON.stringify({
            sessionId: &#x27;different session id&#x27;,
            timestamp: Date.now(),
            featureStatusSummary: {
              [FeatureNames.DummyFeature]: true,
            }
          })
        });

        platformFeatureService = TestBed.get(PlatformFeatureService);

        flushMicrotasks();

        expect(apiService.fetchFeatureFlags).toHaveBeenCalled();
        expect(
          JSON.parse(windowRef.nativeWindow.sessionStorage.getItem(
            &#x27;SAVED_FEATURE_FLAGS&#x27;))
            .sessionId
        ).toEqual(sessionId);
        expect(platformFeatureService.isInitialzedWithError).toBeFalse();
      })
    );

    it(&#x27;should load from server if the stored features don\&#x27;t match with&#x27; +
      &#x27; feature list&#x27;, fakeAsync(() =&gt; {
      const sessionId = &#x27;session_id&#x27;;
      mockCookie(`SACSID=${sessionId}`);
      mockSessionStore({
        SAVED_FEATURE_FLAGS: JSON.stringify({
          sessionId: sessionId,
          timestamp: Date.now(),
          featureStatusSummary: {}
        })
      });

      platformFeatureService = TestBed.get(PlatformFeatureService);

      flushMicrotasks();

      expect(apiService.fetchFeatureFlags).toHaveBeenCalled();
      expect(platformFeatureService.isInitialzedWithError).toBeFalse();
    }));

    it(&#x27;should request only once if there are more than one call to &#x27; +
      &#x27;.initialize.&#x27;, fakeAsync(() =&gt; {
      platformFeatureService = TestBed.get(PlatformFeatureService);

      platformFeatureService.initialize();
      platformFeatureService.initialize();

      flushMicrotasks();

      expect(apiService.fetchFeatureFlags).toHaveBeenCalledTimes(1);
      expect(platformFeatureService.isInitialzedWithError).toBeFalse();
    }));

    it(&#x27;should disable all features when loading fails.&#x27;, fakeAsync(() =&gt; {
      apiSpy.and.throwError(&#x27;mock error&#x27;);

      platformFeatureService = TestBed.get(PlatformFeatureService);

      flushMicrotasks();

      expect(
        platformFeatureService.status.DummyFeature.isEnabled
      ).toBeFalse();
      expect(platformFeatureService.isInitialzedWithError).toBeTrue();
    }));

    it(&#x27;should skip on the signup page&#x27;, fakeAsync(() =&gt; {
      mockPathName(&#x27;/signup&#x27;);

      platformFeatureService = TestBed.get(PlatformFeatureService);

      flushMicrotasks();

      expect(apiService.fetchFeatureFlags).not.toHaveBeenCalled();
      expect(platformFeatureService.isSkipped).toBeTrue();
    }));
  });

  describe(&#x27;.featureSummary&#x27;, () =&gt; {
    it(&#x27;should return correct values of feature flags&#x27;, fakeAsync(() =&gt; {
      platformFeatureService = TestBed.get(PlatformFeatureService);

      flushMicrotasks();

      expect(
        platformFeatureService.status.DummyFeature.isEnabled
      ).toBeTrue();
      expect(platformFeatureService.isInitialzedWithError).toBeFalse();
    }));

    it(&#x27;should throw error when accessed before initialization.&#x27;, fakeAsync(
      () =&gt; {
        platformFeatureService = TestBed.get(PlatformFeatureService);
        expect(
          () =&gt; platformFeatureService.status.DummyFeature.isEnabled
        ).toThrowError(
          &#x27;The platform feature service has not been initialized.&#x27;);
      })
    );
  });

  describe(&#x27;platformFeatureInitFactory&#x27;, () =&gt; {
    let factoryFn = (service: PlatformFeatureService) =&gt; {
      return async(): Promise&lt;void&gt; =&gt; service.initialize();
    };

    beforeEach(() =&gt; {
      factoryFn = platformFeatureInitFactory;
      platformFeatureService = TestBed.get(PlatformFeatureService);
    });

    it(&#x27;should return a function that calls initialize&#x27;, async() =&gt; {
      const mockPromise = Promise.resolve(null);
      const spy = spyOn(platformFeatureService, &#x27;initialize&#x27;)
        .and.returnValue(mockPromise);

      const returnedFn = factoryFn(platformFeatureService);
      const returnedPromise = returnedFn();

      expect(spy).toHaveBeenCalled();
      await expectAsync(returnedPromise).toBeResolvedTo(null);
    });
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/services/platform-feature.service.spec.ts&quot;,&quot;line&quot;:155,&quot;character&quot;:13,&quot;text&quot;:&quot;sessionId&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/platform-feature.service.spec.ts&quot;,&quot;line&quot;:173,&quot;character&quot;:13,&quot;text&quot;:&quot;sessionId&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/platform-feature.service.spec.ts&quot;,&quot;line&quot;:253,&quot;character&quot;:13,&quot;text&quot;:&quot;sessionId&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/services/platform-feature.service.spec.ts&quot;,&quot;line&quot;:351,&quot;character&quot;:12,&quot;text&quot;:&quot;mockPromise&quot;,&quot;kind&quot;:2}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  