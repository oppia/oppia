
  <!DOCTYPE html>
  <html>
    <head>
      <title>state-top-answers-stats.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/services/state-top-answers-stats.service.spec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">457</td><td class="">457</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Factory for domain object which holds the list of top answer
 * statistics for a particular state.
 */

import { HttpClientTestingModule } from &#x27;@angular/common/http/testing&#x27;;
import { TestBed, fakeAsync, flushMicrotasks } from &#x27;@angular/core/testing&#x27;;

import { AnswerStats } from
  &#x27;domain/exploration/answer-stats.model&#x27;;
import { AnswerStatsBackendDict } from
  &#x27;domain/exploration/visualization-info.model&#x27;;
import { StateBackendDict } from &#x27;domain/state/StateObjectFactory&#x27;;
import { RuleObjectFactory } from &#x27;domain/exploration/RuleObjectFactory&#x27;;
import { StateTopAnswersStats } from
  &#x27;domain/statistics/state-top-answers-stats-object.factory&#x27;;
import { StateTopAnswersStatsService } from
  &#x27;services/state-top-answers-stats.service&#x27;;
import { StateTopAnswersStatsBackendApiService } from
  &#x27;services/state-top-answers-stats-backend-api.service&#x27;;
import { States, StatesObjectFactory } from
  &#x27;domain/exploration/StatesObjectFactory&#x27;;

const joC = jasmine.objectContaining;

describe(&#x27;StateTopAnswersStatsService&#x27;, () =&gt; {
  let ruleObjectFactory: RuleObjectFactory;
  let stateTopAnswersStatsBackendApiService:
    StateTopAnswersStatsBackendApiService;
  let stateTopAnswersStatsService: StateTopAnswersStatsService;
  let statesObjectFactory: StatesObjectFactory;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({imports: [HttpClientTestingModule]});

    ruleObjectFactory = TestBed.get(RuleObjectFactory);
    stateTopAnswersStatsBackendApiService = (
      TestBed.get(StateTopAnswersStatsBackendApiService));
    stateTopAnswersStatsService = TestBed.get(StateTopAnswersStatsService);
    statesObjectFactory = TestBed.get(StatesObjectFactory);
  });

  const expId = &#x27;7&#x27;;

  const stateBackendDict: StateBackendDict = {
    content: {content_id: &#x27;content&#x27;, html: &#x27;Say &quot;hello&quot; in Spanish!&#x27;},
    linked_skill_id: null,
    next_content_id_index: 0,
    param_changes: [],
    interaction: {
      answer_groups: [{
        rule_specs: [{
          rule_type: &#x27;Contains&#x27;,
          inputs: {x: {
            contentId: &#x27;rule_input&#x27;,
            normalizedStrSet: [&#x27;hola&#x27;]
          }}
        }],
        outcome: {
          dest: &#x27;Me Llamo&#x27;,
          feedback: {content_id: &#x27;feedback_1&#x27;, html: &#x27;Â¡Buen trabajo!&#x27;},
          labelled_as_correct: true,
          param_changes: [],
          refresher_exploration_id: null,
          missing_prerequisite_skill_id: null,
        },
        training_data: null,
        tagged_skill_misconception_id: null,
      }],
      default_outcome: {
        dest: &#x27;Hola&#x27;,
        feedback: {content_id: &#x27;default_outcome&#x27;, html: &#x27;Try again!&#x27;},
        labelled_as_correct: false,
        param_changes: [],
        refresher_exploration_id: null,
        missing_prerequisite_skill_id: null,
      },
      hints: [],
      id: &#x27;TextInput&#x27;,
      confirmed_unclassified_answers: [],
      customization_args: {
        placeholder: {
          value: {
            content_id: &#x27;ca_placeholder_0&#x27;,
            unicode_str: &#x27;&#x27;
          }
        },
        rows: { value: 1 }
      },
      solution: null,
    },
    classifier_model_id: null,
    recorded_voiceovers: {
      voiceovers_mapping: {
        content: {},
        default_outcome: {},
        feedback_1: {},
      },
    },
    solicit_answer_details: false,
    card_is_checkpoint: false,
    written_translations: {
      translations_mapping: {
        content: {},
        default_outcome: {},
        feedback_1: {},
      },
    },
  };

  const makeStates = (statesBackendDict = {Hola: stateBackendDict}): States =&gt; {
    return statesObjectFactory.createFromBackendDict(statesBackendDict);
  };

  const spyOnBackendApiFetchStatsAsync = (
      stateName: string,
      answersStatsBackendDicts: AnswerStatsBackendDict[]): jasmine.Spy =&gt; {
    const answersStats = answersStatsBackendDicts.map(
      a =&gt; AnswerStats.createFromBackendDict(a));
    return spyOn(stateTopAnswersStatsBackendApiService, &#x27;fetchStatsAsync&#x27;)
      .and.returnValue(Promise.resolve(new StateTopAnswersStats(
        {[stateName]: answersStats}, {[stateName]: &#x27;TextInput&#x27;})));
  };

  it(&#x27;should not contain any stats before init&#x27;, () =&gt; {
    expect(stateTopAnswersStatsService.hasStateStats(&#x27;Hola&#x27;)).toBeFalse();
  });

  it(&#x27;should identify unaddressed issues&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, [
      {answer: &#x27;hola&#x27;, frequency: 5},
      {answer: &#x27;adios&#x27;, frequency: 3},
      {answer: &#x27;ciao&#x27;, frequency: 1},
    ]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    const stateStats = stateTopAnswersStatsService.getStateStats(&#x27;Hola&#x27;);
    expect(stateStats).toContain(joC({answer: &#x27;hola&#x27;, isAddressed: true}));
    expect(stateStats).toContain(joC({answer: &#x27;adios&#x27;, isAddressed: false}));
    expect(stateStats).toContain(joC({answer: &#x27;ciao&#x27;, isAddressed: false}));
  }));

  it(&#x27;should order results by frequency&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, [
      {answer: &#x27;hola&#x27;, frequency: 7},
      {answer: &#x27;adios&#x27;, frequency: 4},
      {answer: &#x27;ciao&#x27;, frequency: 2},
    ]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.getStateStats(&#x27;Hola&#x27;)).toEqual([
      joC({answer: &#x27;hola&#x27;, frequency: 7}),
      joC({answer: &#x27;adios&#x27;, frequency: 4}),
      joC({answer: &#x27;ciao&#x27;, frequency: 2}),
    ]);
  }));

  it(&#x27;should throw when stats for state do not exist&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, [
      {answer: &#x27;hola&#x27;, frequency: 7},
      {answer: &#x27;adios&#x27;, frequency: 4},
      {answer: &#x27;ciao&#x27;, frequency: 2},
    ]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(() =&gt; stateTopAnswersStatsService.getStateStats(&#x27;Me Llamo&#x27;))
      .toThrowError(&#x27;Me Llamo does not exist.&#x27;);
  }));

  it(&#x27;should have stats for state provided by backend&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(
      &#x27;Hola&#x27;, [{answer: &#x27;hola&#x27;, frequency: 3}]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.hasStateStats(&#x27;Hola&#x27;)).toBeTrue();
  }));

  it(&#x27;should have stats for state without any answers&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.hasStateStats(&#x27;Hola&#x27;)).toBeTrue();
  }));

  it(&#x27;should not have stats for state not provided by backend&#x27;,
    fakeAsync(async() =&gt; {
      const states = makeStates();
      spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
      stateTopAnswersStatsService.initAsync(expId, states);
      flushMicrotasks();
      await stateTopAnswersStatsService.getInitPromiseAsync();

      expect(stateTopAnswersStatsService.hasStateStats(&#x27;Me Llamo&#x27;)).toBeFalse();
    }));

  it(&#x27;should only returns state names with stats&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.getStateNamesWithStats())
      .toEqual([&#x27;Hola&#x27;]);
  }));

  it(&#x27;should return empty stats for a newly added state&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(() =&gt; stateTopAnswersStatsService.getStateStats(&#x27;Me Llamo&#x27;))
      .toThrowError(&#x27;Me Llamo does not exist.&#x27;);

    stateTopAnswersStatsService.onStateAdded(&#x27;Me Llamo&#x27;);

    expect(stateTopAnswersStatsService.getStateStats(&#x27;Me Llamo&#x27;))
      .toEqual([]);
  }));

  it(&#x27;should throw when accessing a deleted state&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    stateTopAnswersStatsService.onStateDeleted(&#x27;Hola&#x27;);
    flushMicrotasks();

    expect(() =&gt; stateTopAnswersStatsService.getStateStats(&#x27;Hola&#x27;))
      .toThrowError(&#x27;Hola does not exist.&#x27;);
  }));

  it(&#x27;should respond to changes in state names&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();
    spyOnBackendApiFetchStatsAsync(&#x27;Hola&#x27;, []);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    const oldStats = stateTopAnswersStatsService.getStateStats(&#x27;Hola&#x27;);

    stateTopAnswersStatsService.onStateRenamed(&#x27;Hola&#x27;, &#x27;Bonjour&#x27;);

    expect(stateTopAnswersStatsService.getStateStats(&#x27;Bonjour&#x27;))
      .toEqual(oldStats);

    expect(() =&gt; stateTopAnswersStatsService.getStateStats(&#x27;Hola&#x27;))
      .toThrowError(&#x27;Hola does not exist.&#x27;);
  }));

  it(&#x27;should recognize newly resolved answers&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();

    spyOnBackendApiFetchStatsAsync(
      &#x27;Hola&#x27;, [{answer: &#x27;adios&#x27;, frequency: 3}]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.getUnresolvedStateStats(&#x27;Hola&#x27;))
      .toContain(joC({answer: &#x27;adios&#x27;}));

    const updatedState = states.getState(&#x27;Hola&#x27;);
    updatedState.interaction.answerGroups[0].rules.push(
      ruleObjectFactory.createFromBackendDict(
        {
          rule_type: &#x27;Contains&#x27;,
          inputs: {
            x: {
              contentId: &#x27;rule_input&#x27;,
              normalizedStrSet: [&#x27;adios&#x27;]
            }
          }
        },
        &#x27;TextInput&#x27;
      ));
    stateTopAnswersStatsService.onStateInteractionSaved(updatedState);

    expect(stateTopAnswersStatsService.getUnresolvedStateStats(&#x27;Hola&#x27;))
      .not.toContain(joC({answer: &#x27;adios&#x27;}));
  }));

  it(&#x27;should recognize newly unresolved answers&#x27;, fakeAsync(async() =&gt; {
    const states = makeStates();

    spyOnBackendApiFetchStatsAsync(
      &#x27;Hola&#x27;, [{answer: &#x27;hola&#x27;, frequency: 3}]);
    stateTopAnswersStatsService.initAsync(expId, states);
    flushMicrotasks();
    await stateTopAnswersStatsService.getInitPromiseAsync();

    expect(stateTopAnswersStatsService.getUnresolvedStateStats(&#x27;Hola&#x27;))
      .not.toContain(joC({answer: &#x27;hola&#x27;}));

    const updatedState = states.getState(&#x27;Hola&#x27;);
    updatedState.interaction.answerGroups[0].rules = [
      ruleObjectFactory.createFromBackendDict(
        {
          rule_type: &#x27;Contains&#x27;,
          inputs: {
            x: {
              contentId: &#x27;rule_input&#x27;,
              normalizedStrSet: [&#x27;bonjour&#x27;]
            }
          }
        },
        &#x27;TextInput&#x27;
      )
    ];
    stateTopAnswersStatsService.onStateInteractionSaved(updatedState);

    expect(stateTopAnswersStatsService.getUnresolvedStateStats(&#x27;Hola&#x27;))
      .toContain(joC({answer: &#x27;hola&#x27;}));
  }));
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  