
  <!DOCTYPE html>
  <html>
    <head>
      <title>collection-linearizer.service.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/pages/collection-editor-page/services/collection-linearizer.service.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">212</td><td class="">212</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2016 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service to maintain the state of a single collection shared
 * throughout the collection editor. This service provides functionality for
 * retrieving the collection, saving it, and listening for changes.
 */

import { Injectable } from &#x27;@angular/core&#x27;;
import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { CollectionNode } from &#x27;domain/collection/collection-node.model&#x27;;
import { CollectionUpdateService } from &#x27;domain/collection/collection-update.service&#x27;;
import { Collection } from &#x27;domain/collection/collection.model&#x27;;
import { LearnerExplorationSummaryBackendDict } from &#x27;domain/summary/learner-exploration-summary.model&#x27;;

interface SwapFunction {
  (
    collection: Collection,
    linearNodeList: CollectionNode[], nodeIndex: number): void;
  (
    collection: Collection,
    linearNodeList: CollectionNode[], nodeIndex: number): void;
  (arg0: Collection, arg1: CollectionNode[], arg2: number): void;
 }

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class CollectionLinearizerService {
  explorationIds: string[];
  explorationId: number;
  constructor(
      private collectionUpdateService: CollectionUpdateService
  ) {}

  _getNextExplorationId(
      collection: Collection,
      completedExpIds: string[]): string | null {
    this.explorationIds = collection.getExplorationIds();

    for (let i = 0; i &lt; this.explorationIds.length; i++) {
      if (completedExpIds.indexOf(this.explorationIds[i]) === -1) {
        return this.explorationIds[i];
      }
    }
    return null;
  }

  // Given a non linear collection input, the function will linearize it by
  // picking the first node it encounters on the branch and ignore the others.
  _getCollectionNodesInPlayableOrder(collection: Collection): CollectionNode[] {
    return collection.getCollectionNodes();
  }

  addAfter(collection: Collection, curExplorationId: string): void {
    collection.getCollectionNodeByExplorationId(curExplorationId);
  }

  findNodeIndex(
      linearNodeList: CollectionNode[],
      explorationId: string): number {
    let index = -1;
    for (let i = 0; i &lt; linearNodeList.length; i++) {
      if (linearNodeList[i].getExplorationId() === explorationId) {
        index = i;
        break;
      }
    }
    return index;
  }

  // Swap the node at the specified index with the node immediately to the
  // left of it.
  swapLeft = (
      collection: Collection,
      linearNodeList: CollectionNode[],
      nodeIndex: number): void =&gt; {
    let leftNodeIndex = nodeIndex &gt; 0 ? nodeIndex - 1 : null;

    if (leftNodeIndex === null) {
      return;
    }

    this.collectionUpdateService.swapNodes(
      collection, leftNodeIndex, nodeIndex);
  };

  swapRight = (
      collection: Collection,
      linearNodeList: CollectionNode[], nodeIndex: number): void =&gt; {
    let rightNodeIndex = nodeIndex + 1;
    this.collectionUpdateService.swapNodes(
      collection, rightNodeIndex, nodeIndex
    );
  };

  shiftNode(
      collection: Collection, explorationId: string,
      swapFunction: SwapFunction): boolean {
    // There is nothing to shift if the collection has only 1 node.
    if (collection.getCollectionNodeCount() &gt; 1) {
      let linearNodeList = this._getCollectionNodesInPlayableOrder(collection);
      let nodeIndex = this.findNodeIndex(linearNodeList, explorationId);
      if (nodeIndex === -1) {
        return false;
      }
      swapFunction(collection, linearNodeList, nodeIndex);
    }
    return true;
  }

  /**
     * Given a collection and a list of completed exploration IDs within the
     * context of that collection, returns a list of which explorations in the
     * collection is immediately playable by the user. NOTE: This function
     * does not assume that the collection is linear.
     */
  getNextExplorationId(
      collection: Collection, completedExpIds: string[]): string {
    return this._getNextExplorationId(collection, completedExpIds);
  }

  /**
     * Given a collection, returns a linear list of collection nodes which
     * represents a valid path for playing through this collection.
     */
  getCollectionNodesInPlayableOrder(collection: Collection): CollectionNode[] {
    return this._getCollectionNodesInPlayableOrder(collection);
  }

  /**
     * Inserts a new collection node at the end of the collection&#x27;s playable
     * list of explorations, based on the specified exploration ID and
     * exploration summary backend object.
     */
  appendCollectionNode(
      collection: Collection, explorationId: string,
      summaryBackendObject: LearnerExplorationSummaryBackendDict): void {
    let linearNodeList = this._getCollectionNodesInPlayableOrder(collection);
    this.collectionUpdateService.addCollectionNode(
      collection, explorationId, summaryBackendObject);
    if (linearNodeList.length &gt; 0) {
      let lastNode = linearNodeList[linearNodeList.length - 1];
      this.addAfter(collection, lastNode.getExplorationId());
    }
  }

  /**
     * Remove a collection node from a given collection which maps to the
     * specified exploration ID. This function ensures the linear structure of
     * the collection is maintained. Returns whether the provided exploration
     * ID is contained within the linearly playable path of the specified
     * collection.
     */
  removeCollectionNode(collection: Collection, explorationId: string): boolean {
    if (!collection.containsCollectionNode(explorationId)) {
      return false;
    }

    // Delete the node.
    this.collectionUpdateService.deleteCollectionNode(
      collection, explorationId);
    return true;
  }

  /**
     * Looks up a collection node given an exploration ID in the specified
     * collection and attempts to shift it left in the linear ordering of the
     * collection. If the node is the first exploration played by the player,
     * then this function is a no-op. Returns false if the specified
     * exploration ID does not associate to any nodes in the collection.
     */
  shiftNodeLeft(collection: Collection, explorationId: string): boolean {
    return this.shiftNode(collection, explorationId, this.swapLeft);
  }

  /**
     * Looks up a collection node given an exploration ID in the specified
     * collection and attempts to shift it right in the linear ordering of the
     * collection. If the node is the last exploration played by the player,
     * then this function is a no-op. Returns false if the specified
     * exploration ID does not associate to any nodes in the collection.
     */
  shiftNodeRight(collection: Collection, explorationId: string): boolean {
    return this.shiftNode(collection, explorationId, this.swapRight);
  }
}

angular.module(&#x27;oppia&#x27;).factory(&#x27;CollectionLinearizerService&#x27;,
  downgradeInjectable(CollectionLinearizerService));
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  