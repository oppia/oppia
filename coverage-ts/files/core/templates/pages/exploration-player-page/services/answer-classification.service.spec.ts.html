
  <!DOCTYPE html>
  <html>
    <head>
      <title>answer-classification.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts</td><td class="">98.17%</td><td class="">100%</td><td class="">602</td><td class="">591</td><td class="">11</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the answer classification service
 */

import { HttpClientTestingModule } from &#x27;@angular/common/http/testing&#x27;;
import { TestBed } from &#x27;@angular/core/testing&#x27;;

import { AnswerClassificationResult } from
  &#x27;domain/classifier/answer-classification-result.model&#x27;;
import { AnswerClassificationService, InteractionRulesService } from
  &#x27;pages/exploration-player-page/services/answer-classification.service&#x27;;
import { AppService } from &#x27;services/app.service&#x27;;
import { CamelCaseToHyphensPipe } from
  &#x27;filters/string-utility-filters/camel-case-to-hyphens.pipe&#x27;;
import { Classifier } from &#x27;domain/classifier/classifier.model&#x27;;
import { ExplorationPlayerConstants } from
  &#x27;pages/exploration-player-page/exploration-player-page.constants&#x27;;
import { InteractionSpecsService } from &#x27;services/interaction-specs.service&#x27;;
import { OutcomeObjectFactory } from &#x27;domain/exploration/OutcomeObjectFactory&#x27;;
import { PredictionAlgorithmRegistryService } from
  // eslint-disable-next-line max-len
  &#x27;pages/exploration-player-page/services/prediction-algorithm-registry.service&#x27;;
import { StateClassifierMappingService } from
  &#x27;pages/exploration-player-page/services/state-classifier-mapping.service&#x27;;
import { StateObjectFactory } from &#x27;domain/state/StateObjectFactory&#x27;;
import { TextClassifierFrozenModel } from &#x27;classifiers/proto/text_classifier&#x27;;
import { TextInputRulesService } from
  &#x27;interactions/TextInput/directives/text-input-rules.service&#x27;;

describe(&#x27;Answer Classification Service&#x27;, () =&gt; {
  const stateName = &#x27;Test State&#x27;;

  let answerClassificationService: AnswerClassificationService;
  let appService: AppService;
  let interactionSpecsService: InteractionSpecsService;
  let outcomeObjectFactory: OutcomeObjectFactory;
  let predictionAlgorithmRegistryService: PredictionAlgorithmRegistryService;
  let stateClassifierMappingService: StateClassifierMappingService;
  let stateObjectFactory: StateObjectFactory;
  let textInputRulesService: InteractionRulesService;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [CamelCaseToHyphensPipe],
    });

    answerClassificationService = TestBed.get(AnswerClassificationService);
    appService = TestBed.get(AppService);
    interactionSpecsService = TestBed.get(InteractionSpecsService);
    outcomeObjectFactory = TestBed.get(OutcomeObjectFactory);
    predictionAlgorithmRegistryService = TestBed.get(
      PredictionAlgorithmRegistryService);
    stateClassifierMappingService = TestBed.get(StateClassifierMappingService);
    stateObjectFactory = TestBed.get(StateObjectFactory);
    textInputRulesService = TestBed.get(TextInputRulesService);
  });

  describe(&#x27;with string classifier disabled&#x27;, () =&gt; {
    let stateDict;
    let expId = &#x27;0&#x27;;

    beforeEach(() =&gt; {
      spyOn(
        interactionSpecsService, &#x27;isInteractionTrainable&#x27;
      ).and.returnValue(false);
      spyOn(appService, &#x27;isMachineLearningClassificationEnabled&#x27;)
        .and.returnValue(false);
      stateClassifierMappingService.init(expId, 0);

      stateDict = {
        content: {
          content_id: &#x27;content&#x27;,
          html: &#x27;content&#x27;
        },
        recorded_voiceovers: {
          voiceovers_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        },
        interaction: {
          id: &#x27;TextInput&#x27;,
          customization_args: {
            placeholder: {
              value: {
                content_id: &#x27;ca_placeholder_0&#x27;,
                unicode_str: &#x27;&#x27;
              }
            },
            rows: { value: 1 }
          },
          answer_groups: [{
            outcome: {
              dest: &#x27;outcome 1&#x27;,
              feedback: {
                content_id: &#x27;feedback_1&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_0&#x27;,
                  normalizedStrSet: [&#x27;10&#x27;]
                }
              }
            }],
          }, {
            outcome: {
              dest: &#x27;outcome 2&#x27;,
              feedback: {
                content_id: &#x27;feedback_2&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_1&#x27;,
                  normalizedStrSet: [&#x27;5&#x27;]
                }
              }
            }, {
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_2&#x27;,
                  normalizedStrSet: [&#x27;6&#x27;]
                }
              }
            }, {
              rule_type: &#x27;FuzzyEquals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_3&#x27;,
                  normalizedStrSet: [&#x27;7&#x27;]
                }
              }
            }],
          }],
          default_outcome: {
            dest: &#x27;default&#x27;,
            feedback: {
              content_id: &#x27;default_outcome&#x27;,
              html: &#x27;&#x27;
            },
            labelled_as_correct: false,
            param_changes: [],
            refresher_exploration_id: null,
            missing_prerequisite_skill_id: null
          },
          hints: []
        },
        param_changes: [],
        solicit_answer_details: false,
        written_translations: {
          translations_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        }
      };
    });

    it(&#x27;should fail if no frontend rules are provided&#x27;, () =&gt; {
      const state = (
        stateObjectFactory.createFromBackendDict(stateName, stateDict));

      expect(
        () =&gt; answerClassificationService.getMatchingClassificationResult(
          state.name, state.interaction, &#x27;0&#x27;, null)
      ).toThrowError(
        &#x27;No interactionRulesService was available to classify the answer.&#x27;);
    });

    it(&#x27;should return the first matching answer group and first matching &#x27; +
        &#x27;rule spec&#x27;, () =&gt; {
      const state = (
        stateObjectFactory.createFromBackendDict(stateName, stateDict));

      expect(
        answerClassificationService.getMatchingClassificationResult(
          state.name, state.interaction, &#x27;10&#x27;, textInputRulesService)
      ).toEqual(
        new AnswerClassificationResult(
          outcomeObjectFactory.createNew(&#x27;outcome 1&#x27;, &#x27;feedback_1&#x27;, &#x27;&#x27;, []),
          0, 0,
          ExplorationPlayerConstants.EXPLICIT_CLASSIFICATION));

      expect(
        answerClassificationService.getMatchingClassificationResult(
          state.name, state.interaction, &#x27;5&#x27;, textInputRulesService)
      ).toEqual(
        new AnswerClassificationResult(
          outcomeObjectFactory.createNew(&#x27;outcome 2&#x27;, &#x27;feedback_2&#x27;, &#x27;&#x27;, []),
          1, 0,
          ExplorationPlayerConstants.EXPLICIT_CLASSIFICATION));

      expect(
        answerClassificationService.getMatchingClassificationResult(
          state.name, state.interaction, &#x27;6&#x27;, textInputRulesService)
      ).toEqual(
        new AnswerClassificationResult(
          outcomeObjectFactory.createNew(&#x27;outcome 2&#x27;, &#x27;feedback_2&#x27;, &#x27;&#x27;, []),
          1, 1,
          ExplorationPlayerConstants.EXPLICIT_CLASSIFICATION));
    });

    it(&#x27;should return the default rule if no answer group matches&#x27;, () =&gt; {
      const state = (
        stateObjectFactory.createFromBackendDict(stateName, stateDict));

      expect(
        answerClassificationService.getMatchingClassificationResult(
          state.name, state.interaction, &#x27;777&#x27;, textInputRulesService)
      ).toEqual(
        new AnswerClassificationResult(
          outcomeObjectFactory.createNew(&#x27;default&#x27;, &#x27;default_outcome&#x27;, &#x27;&#x27;, []),
          2, 0,
          ExplorationPlayerConstants.DEFAULT_OUTCOME_CLASSIFICATION
        )
      );
    });

    it(
      &#x27;should fail if no answer group matches and no default rule is &#x27; +
        &#x27;provided&#x27;,
      () =&gt; {
        stateDict.interaction.answer_groups = [{
          outcome: {
            dest: &#x27;outcome 1&#x27;,
            feedback: {
              content_id: &#x27;feedback_1&#x27;,
              html: &#x27;&#x27;
            },
            labelled_as_correct: false,
            param_changes: [],
            refresher_exploration_id: null,
            missing_prerequisite_skill_id: null
          },
          rule_specs: [{
            rule_type: &#x27;Equals&#x27;,
            inputs: {
              x: {
                contentId: &#x27;rule_input_0&#x27;,
                normalizedStrSet: [&#x27;10&#x27;]
              }
            }
          }],
        }];

        const state = (
          stateObjectFactory.createFromBackendDict(stateName, stateDict));

        expect(
          () =&gt; answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;0&#x27;, null)
        ).toThrowError(
          &#x27;No interactionRulesService was available to classify the answer.&#x27;);
      });
  });

  describe(&#x27;with string classifier enabled&#x27;, () =&gt; {
    let stateDict;
    let expId = &#x27;0&#x27;;

    beforeEach(() =&gt; {
      spyOn(appService, &#x27;isMachineLearningClassificationEnabled&#x27;)
        .and.returnValue(true);

      let modelJson = {
        KNN: {
          occurrence: 40,
          K: 30,
          T: 20,
          top: 10,
          fingerprint_data: {},
          token_to_id: {}
        },
        SVM: {
          classes: [],
          kernel_params: {
            kernel: &#x27;kernel&#x27;,
            coef0: 1,
            degree: 2,
            gamma: 3,
          },
          intercept: [],
          n_support: [],
          probA: [],
          support_vectors: [[]],
          probB: [],
          dual_coef: [[]]
        },
        cv_vocabulary: {}
      };
      let textClassifierModel = new TextClassifierFrozenModel();
      // The model_json attribute in TextClassifierFrozenModel class can&#x27;t be
      // changed to camelcase since the class definition is automatically
      // compiled with the help of protoc.
      textClassifierModel.model_json = JSON.stringify(modelJson);
      let testClassifier = new Classifier(
        &#x27;TestClassifier&#x27;, textClassifierModel.serialize(), 1);

      stateClassifierMappingService.init(expId, 0);
      stateClassifierMappingService.testOnlySetClassifierData(
        stateName, testClassifier);
      predictionAlgorithmRegistryService.testOnlySetPredictionService(
        &#x27;TestClassifier&#x27;, 1, { predict: (classifierData, answer) =&gt; 1 });

      stateDict = {
        content: {
          content_id: &#x27;content&#x27;,
          html: &#x27;content&#x27;
        },
        recorded_voiceovers: {
          voiceovers_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        },
        interaction: {
          id: &#x27;TextInput&#x27;,
          customization_args: {
            placeholder: {
              value: {
                content_id: &#x27;ca_placeholder_0&#x27;,
                unicode_str: &#x27;&#x27;
              }
            },
            rows: { value: 1 }
          },
          answer_groups: [{
            outcome: {
              dest: &#x27;outcome 1&#x27;,
              feedback: {
                content_id: &#x27;feedback_1&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_0&#x27;,
                  normalizedStrSet: [&#x27;10&#x27;]
                }
              }
            }],
          }, {
            outcome: {
              dest: &#x27;outcome 2&#x27;,
              feedback: {
                content_id: &#x27;feedback_2&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            rule_input_translations: {},
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_1&#x27;,
                  normalizedStrSet: [&#x27;5&#x27;]
                }
              }
            }, {
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_2&#x27;,
                  normalizedStrSet: [&#x27;7&#x27;]
                }
              }
            }],
          }],
          default_outcome: {
            dest: &#x27;default&#x27;,
            feedback: {
              content_id: &#x27;default_outcome&#x27;,
              html: &#x27;&#x27;
            },
            labelled_as_correct: false,
            param_changes: [],
            refresher_exploration_id: null,
            missing_prerequisite_skill_id: null
          },
          hints: []
        },
        param_changes: [],
        solicit_answer_details: false,
        written_translations: {
          translations_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        }
      };
    });

    it(
      &#x27;should query the prediction service if no answer group matches and &#x27; +
        &#x27;interaction is trainable&#x27;,
      () =&gt; {
        spyOn(
          interactionSpecsService, &#x27;isInteractionTrainable&#x27;
        ).and.returnValue(true);

        const state = (
          stateObjectFactory.createFromBackendDict(stateName, stateDict));

        expect(
          answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;0&#x27;, textInputRulesService)
        ).toEqual(
          new AnswerClassificationResult(
            state.interaction.answerGroups[1].outcome, 1, null,
            ExplorationPlayerConstants.STATISTICAL_CLASSIFICATION));
      });

    it(
      &#x27;should return the default rule if no answer group matches and &#x27; +
        &#x27;interaction is not trainable&#x27;,
      () =&gt; {
        spyOn(
          interactionSpecsService, &#x27;isInteractionTrainable&#x27;
        ).and.returnValue(false);

        const state = (
          stateObjectFactory.createFromBackendDict(stateName, stateDict));

        expect(
          answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;0&#x27;, textInputRulesService)
        ).toEqual(
          new AnswerClassificationResult(
            outcomeObjectFactory.createNew(
              &#x27;default&#x27;, &#x27;default_outcome&#x27;, &#x27;&#x27;, []),
            2, 0,
            ExplorationPlayerConstants.DEFAULT_OUTCOME_CLASSIFICATION
          )
        );
      });
  });

  describe(&#x27;with training data classification&#x27;, () =&gt; {
    let stateDict;
    let expId = &#x27;0&#x27;;

    beforeEach(() =&gt; {
      spyOn(
        interactionSpecsService, &#x27;isInteractionTrainable&#x27;
      ).and.returnValue(true);
      spyOn(appService, &#x27;isMachineLearningClassificationEnabled&#x27;)
        .and.returnValue(true);
      stateClassifierMappingService.init(expId, 0);

      stateDict = {
        content: {
          content_id: &#x27;content&#x27;,
          html: &#x27;content&#x27;
        },
        recorded_voiceovers: {
          voiceovers_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        },
        interaction: {
          id: &#x27;TextInput&#x27;,
          customization_args: {
            placeholder: {
              value: {
                content_id: &#x27;ca_placeholder_0&#x27;,
                unicode_str: &#x27;&#x27;
              }
            },
            rows: { value: 1 }
          },
          answer_groups: [{
            outcome: {
              dest: &#x27;outcome 1&#x27;,
              feedback: {
                content_id: &#x27;feedback_1&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            training_data: [&#x27;abc&#x27;, &#x27;input&#x27;],
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_0&#x27;,
                  normalizedStrSet: [&#x27;equal&#x27;]
                }
              }
            }],
          }, {
            outcome: {
              dest: &#x27;outcome 2&#x27;,
              feedback: {
                content_id: &#x27;feedback_2&#x27;,
                html: &#x27;&#x27;
              },
              labelled_as_correct: false,
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null
            },
            training_data: [&#x27;xyz&#x27;],
            rule_specs: [{
              rule_type: &#x27;Contains&#x27;,
              inputs: {
                x: {
                  contentId: &#x27;rule_input_5&#x27;,
                  normalizedStrSet: [&#x27;npu&#x27;]
                }
              }
            }],
          }],
          default_outcome: {
            dest: &#x27;default&#x27;,
            feedback: {
              content_id: &#x27;default_outcome&#x27;,
              html: &#x27;&#x27;
            },
            labelled_as_correct: false,
            param_changes: [],
            refresher_exploration_id: null,
            missing_prerequisite_skill_id: null
          },
          hints: []
        },
        param_changes: [],
        solicit_answer_details: false,
        written_translations: {
          translations_mapping: {
            content: {},
            default_outcome: {},
            feedback_1: {},
            feedback_2: {}
          }
        }
      };
    });

    it(
      &#x27;should use training data classification if no answer group matches &#x27; +
        &#x27;and interaction is trainable&#x27;,
      () =&gt; {
        const state = (
          stateObjectFactory.createFromBackendDict(stateName, stateDict));

        expect(
          answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;abc&#x27;, textInputRulesService)
        ).toEqual(
          new AnswerClassificationResult(
            state.interaction.answerGroups[0].outcome, 0, null,
            ExplorationPlayerConstants.TRAINING_DATA_CLASSIFICATION));

        expect(
          answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;xyz&#x27;, textInputRulesService)
        ).toEqual(
          new AnswerClassificationResult(
            state.interaction.answerGroups[1].outcome, 1, null,
            ExplorationPlayerConstants.TRAINING_DATA_CLASSIFICATION));
      });

    it(
      &#x27;should perform explicit classification before doing training data &#x27; +
        &#x27;classification&#x27;,
      () =&gt; {
        const state = (
          stateObjectFactory.createFromBackendDict(stateName, stateDict));

        expect(
          answerClassificationService.getMatchingClassificationResult(
            state.name, state.interaction, &#x27;input&#x27;, textInputRulesService)
        ).toEqual(
          new AnswerClassificationResult(
            state.interaction.answerGroups[1].outcome, 1, 0,
            ExplorationPlayerConstants.EXPLICIT_CLASSIFICATION));
      });
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:73,&quot;character&quot;:8,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:84,&quot;character&quot;:6,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:8,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:18,&quot;text&quot;:&quot;interaction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:30,&quot;text&quot;:&quot;answer_groups&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:292,&quot;character&quot;:8,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:337,&quot;character&quot;:41,&quot;text&quot;:&quot;classifierData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:337,&quot;character&quot;:57,&quot;text&quot;:&quot;answer&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:339,&quot;character&quot;:6,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:487,&quot;character&quot;:8,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;core/templates/pages/exploration-player-page/services/answer-classification.service.spec.ts&quot;,&quot;line&quot;:498,&quot;character&quot;:6,&quot;text&quot;:&quot;stateDict&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:59 GMT</p>
    </body>
  </html>
  