
  <!DOCTYPE html>
  <html>
    <head>
      <title>question-player-engine.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/pages/exploration-player-page/services/question-player-engine.service.spec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">1018</td><td class="">1018</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &#x27;License&#x27;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &#x27;AS-IS&#x27; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the question player engine service.
 */

import { HttpClientTestingModule } from &#x27;@angular/common/http/testing&#x27;;
import { TestBed} from &#x27;@angular/core/testing&#x27;;
import { AnswerClassificationResult } from &#x27;domain/classifier/answer-classification-result.model&#x27;;
import { OutcomeObjectFactory } from &#x27;domain/exploration/OutcomeObjectFactory&#x27;;
import { QuestionBackendDict, QuestionObjectFactory } from &#x27;domain/question/QuestionObjectFactory&#x27;;
import { StateCardObjectFactory } from &#x27;domain/state_card/StateCardObjectFactory&#x27;;
import { ExpressionInterpolationService } from &#x27;expressions/expression-interpolation.service&#x27;;
import { TextInputRulesService } from &#x27;interactions/TextInput/directives/text-input-rules.service&#x27;;
import { AlertsService } from &#x27;services/alerts.service&#x27;;
import { ContextService } from &#x27;services/context.service&#x27;;
import { FocusManagerService } from &#x27;services/stateful/focus-manager.service&#x27;;
import { AnswerClassificationService, InteractionRulesService } from &#x27;./answer-classification.service&#x27;;
import { QuestionPlayerEngineService } from &#x27;./question-player-engine.service&#x27;;

describe(&#x27;Question player engine service &#x27;, () =&gt; {
  let alertsService: AlertsService;
  let answerClassificationService: AnswerClassificationService;
  let contextService: ContextService;
  let expressionInterpolationService: ExpressionInterpolationService;
  let focusManagerService: FocusManagerService;
  let multipleQuestionsBackendDict: QuestionBackendDict[];
  let outcomeObjectFactory: OutcomeObjectFactory;
  let questionObjectFactory: QuestionObjectFactory;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let singleQuestionBackendDict: QuestionBackendDict;
  let stateCardObjectFactory: StateCardObjectFactory;
  let textInputService: InteractionRulesService;

  beforeEach(() =&gt; {
    singleQuestionBackendDict = {
      id: &#x27;questionId1&#x27;,
      question_state_data: {
        classifier_model_id: null,
        param_changes: [],
        next_content_id_index: 1,
        solicit_answer_details: false,
        content: {
          content_id: &#x27;1&#x27;,
          html: &#x27;Question 1&#x27;
        },
        written_translations: {
          translations_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        },
        interaction: {
          answer_groups: [{
            outcome: {
              dest: &#x27;State 1&#x27;,
              feedback: {
                content_id: &#x27;feedback_1&#x27;,
                html: &#x27;&lt;p&gt;Try Again.&lt;/p&gt;&#x27;
              },
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null,
              labelled_as_correct: true,
            },
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {x: 0}
            }],
            training_data: null,
            tagged_skill_misconception_id: null,
          },
          {
            outcome: {
              dest: &#x27;State 2&#x27;,
              feedback: {
                content_id: &#x27;feedback_2&#x27;,
                html: &#x27;&lt;p&gt;Try Again.&lt;/p&gt;&#x27;
              },
              param_changes: [],
              refresher_exploration_id: null,
              missing_prerequisite_skill_id: null,
              labelled_as_correct: true,
            },
            rule_specs: [{
              rule_type: &#x27;Equals&#x27;,
              inputs: {x: 0}
            }],
            training_data: null,
            tagged_skill_misconception_id: &#x27;misconceptionId&#x27;,
          }],
          default_outcome: {
            dest: null,
            labelled_as_correct: true,
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            param_changes: [],
            feedback: {
              content_id: &#x27;feedback_id&#x27;,
              html: &#x27;&lt;p&gt;Dummy Feedback&lt;/p&gt;&#x27;
            }
          },
          id: &#x27;TextInput&#x27;,
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: &#x27;&#x27;,
                content_id: &#x27;ca_placeholder_0&#x27;
              }
            }
          },
          confirmed_unclassified_answers: [],
          hints: [
            {
              hint_content: {
                content_id: &#x27;hint_1&#x27;,
                html: &#x27;&lt;p&gt;This is a hint.&lt;/p&gt;&#x27;
              }
            }
          ],
          solution: {
            correct_answer: &#x27;Solution&#x27;,
            explanation: {
              content_id: &#x27;solution&#x27;,
              html: &#x27;&lt;p&gt;This is a solution.&lt;/p&gt;&#x27;
            },
            answer_is_exclusive: false
          }
        },
        linked_skill_id: null,
        card_is_checkpoint: true,
        recorded_voiceovers: {
          voiceovers_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        }
      },
      question_state_data_schema_version: 45,
      language_code: &#x27;en&#x27;,
      version: 1,
      linked_skill_ids: [],
      inapplicable_skill_misconception_ids: [],
    };

    multipleQuestionsBackendDict = [{
      id: &#x27;questionId1&#x27;,
      question_state_data: {
        classifier_model_id: null,
        param_changes: [],
        next_content_id_index: 1,
        solicit_answer_details: false,
        content: {
          content_id: &#x27;1&#x27;,
          html: &#x27;Question 1&#x27;
        },
        written_translations: {
          translations_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        },
        interaction: {
          answer_groups: [],
          default_outcome: {
            dest: null,
            labelled_as_correct: true,
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            param_changes: [],
            feedback: {
              content_id: &#x27;feedback_id&#x27;,
              html: &#x27;&lt;p&gt;Dummy Feedback&lt;/p&gt;&#x27;
            }
          },
          id: &#x27;TextInput&#x27;,
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: &#x27;&#x27;,
                content_id: &#x27;ca_placeholder_0&#x27;
              }
            }
          },
          confirmed_unclassified_answers: [],
          hints: [
            {
              hint_content: {
                content_id: &#x27;hint_1&#x27;,
                html: &#x27;&lt;p&gt;This is a hint.&lt;/p&gt;&#x27;
              }
            }
          ],
          solution: {
            correct_answer: &#x27;Solution&#x27;,
            explanation: {
              content_id: &#x27;solution&#x27;,
              html: &#x27;&lt;p&gt;This is a solution.&lt;/p&gt;&#x27;
            },
            answer_is_exclusive: false
          }
        },
        linked_skill_id: null,
        card_is_checkpoint: true,
        recorded_voiceovers: {
          voiceovers_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        }
      },
      question_state_data_schema_version: 45,
      language_code: &#x27;en&#x27;,
      version: 1,
      linked_skill_ids: [],
      inapplicable_skill_misconception_ids: [],
    },
    {
      id: &#x27;questionId2&#x27;,
      question_state_data: {
        classifier_model_id: null,
        param_changes: [],
        next_content_id_index: 2,
        solicit_answer_details: false,
        content: {
          content_id: &#x27;2&#x27;,
          html: &#x27;Question 2&#x27;
        },
        written_translations: {
          translations_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        },
        interaction: {
          answer_groups: [],
          default_outcome: {
            dest: null,
            labelled_as_correct: true,
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            param_changes: [],
            feedback: {
              content_id: &#x27;feedback_id&#x27;,
              html: &#x27;&lt;p&gt;Dummy Feedback&lt;/p&gt;&#x27;
            }
          },
          id: &#x27;TextInput&#x27;,
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: &#x27;&#x27;,
                content_id: &#x27;ca_placeholder_0&#x27;
              }
            }
          },
          confirmed_unclassified_answers: [],
          hints: [
            {
              hint_content: {
                content_id: &#x27;hint_1&#x27;,
                html: &#x27;&lt;p&gt;This is a hint.&lt;/p&gt;&#x27;
              }
            }
          ],
          solution: {
            correct_answer: &#x27;Solution&#x27;,
            explanation: {
              content_id: &#x27;solution&#x27;,
              html: &#x27;&lt;p&gt;This is a solution.&lt;/p&gt;&#x27;
            },
            answer_is_exclusive: false
          }
        },
        linked_skill_id: null,
        card_is_checkpoint: true,
        recorded_voiceovers: {
          voiceovers_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        }
      },
      question_state_data_schema_version: 45,
      language_code: &#x27;br&#x27;,
      version: 1,
      linked_skill_ids: [],
      inapplicable_skill_misconception_ids: [],
    },
    {
      id: &#x27;questionId3&#x27;,
      question_state_data: {
        classifier_model_id: null,
        param_changes: [],
        next_content_id_index: 1,
        solicit_answer_details: false,
        content: {
          content_id: &#x27;3&#x27;,
          html: &#x27;Question 3&#x27;
        },
        written_translations: {
          translations_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        },
        interaction: {
          answer_groups: [],
          default_outcome: {
            dest: null,
            labelled_as_correct: true,
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            param_changes: [],
            feedback: {
              content_id: &#x27;feedback_id&#x27;,
              html: &#x27;&lt;p&gt;Dummy Feedback&lt;/p&gt;&#x27;
            }
          },
          id: &#x27;TextInput&#x27;,
          customization_args: {
            rows: {
              value: 1
            },
            placeholder: {
              value: {
                unicode_str: &#x27;&#x27;,
                content_id: &#x27;ca_placeholder_0&#x27;
              }
            }
          },
          confirmed_unclassified_answers: [],
          hints: [
            {
              hint_content: {
                content_id: &#x27;hint_1&#x27;,
                html: &#x27;&lt;p&gt;This is a hint.&lt;/p&gt;&#x27;
              }
            }
          ],
          solution: {
            correct_answer: &#x27;Solution&#x27;,
            explanation: {
              content_id: &#x27;solution&#x27;,
              html: &#x27;&lt;p&gt;This is a solution.&lt;/p&gt;&#x27;
            },
            answer_is_exclusive: false
          }
        },
        linked_skill_id: null,
        card_is_checkpoint: true,
        recorded_voiceovers: {
          voiceovers_mapping: {
            1: {},
            ca_placeholder_0: {},
            feedback_id: {},
            solution: {},
            hint_1: {}
          }
        }
      },
      question_state_data_schema_version: 45,
      language_code: &#x27;ab&#x27;,
      version: 1,
      linked_skill_ids: [],
      inapplicable_skill_misconception_ids: [],
    }];
  });

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule]
    });

    alertsService = TestBed.inject(AlertsService);
    answerClassificationService = TestBed.inject(AnswerClassificationService);
    contextService = TestBed.inject(ContextService);
    expressionInterpolationService =
      TestBed.inject(ExpressionInterpolationService);
    questionObjectFactory = TestBed.inject(QuestionObjectFactory);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    outcomeObjectFactory = TestBed.inject(OutcomeObjectFactory);
    focusManagerService = TestBed.inject(FocusManagerService);
    stateCardObjectFactory = TestBed.inject(StateCardObjectFactory);
    textInputService = TestBed.get(TextInputRulesService);
  });

  it(&#x27;should load questions when initialized&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);

    expect(questionPlayerEngineService.getQuestionCount()).toBe(0);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);

    expect(questionPlayerEngineService.getQuestionCount()).toBe(3);
  });

  it(&#x27;should set question player mode to true when initialized&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    expect(contextService.isInQuestionPlayerMode()).toBe(false);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);

    expect(contextService.isInQuestionPlayerMode()).toBe(true);
  });

  it(&#x27;should update the current question ID when an answer is &#x27; +
    &#x27;submitted and a new card is recorded&#x27;, () =&gt; {
    let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
    let answer = &#x27;answer&#x27;;
    let answerClassificationResult = new AnswerClassificationResult(
      outcomeObjectFactory.createNew(
        &#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;);

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);
    spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
      .and.returnValue(answerClassificationResult);
    spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
      .and.callFake((html, envs) =&gt; html);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);
    let currentQuestion1 = questionPlayerEngineService.getCurrentQuestion();
    expect(currentQuestion1.getId()).toBe(&#x27;questionId1&#x27;);

    questionPlayerEngineService.submitAnswer(
      answer, textInputService, submitAnswerSuccessCb);
    questionPlayerEngineService.recordNewCardAdded();
    let currentQuestion2 = questionPlayerEngineService.getCurrentQuestion();

    expect(currentQuestion2.getId()).toBe(&#x27;questionId2&#x27;);
  });

  it(&#x27;should return the current question Id&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);

    expect(() =&gt; {
      questionPlayerEngineService.getCurrentQuestionId();
    }).toThrowError(&#x27;Cannot read property \&#x27;getId\&#x27; of undefined&#x27;);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);

    expect(questionPlayerEngineService.getCurrentQuestionId())
      .toBe(&#x27;questionId1&#x27;);
  });

  it(&#x27;should return number of questions&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);
    let totalQuestions = questionPlayerEngineService.getQuestionCount();
    expect(totalQuestions).toBe(3);

    questionPlayerEngineService.clearQuestions();
    totalQuestions = questionPlayerEngineService.getQuestionCount();
    expect(totalQuestions).toBe(0);

    questionPlayerEngineService.init(
      [singleQuestionBackendDict], initSuccessCb, initErrorCb);
    totalQuestions = questionPlayerEngineService.getQuestionCount();
    expect(totalQuestions).toBe(1);
  });

  it(&#x27;should clear all questions&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);

    expect(questionPlayerEngineService.getQuestionCount()).toBe(3);

    questionPlayerEngineService.clearQuestions();

    expect(questionPlayerEngineService.getQuestionCount()).toBe(0);
  });

  it(&#x27;should return the language code correctly when an answer is &#x27; +
    &#x27;submitted and a new card is recorded&#x27;, () =&gt; {
    let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
    let answer = &#x27;answer&#x27;;
    let answerClassificationResult = new AnswerClassificationResult(
      outcomeObjectFactory
        .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
    );

    spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
    spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);
    spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
      .and.returnValue(answerClassificationResult);
    spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
      .and.callFake((html, envs) =&gt; html);

    questionPlayerEngineService.init(
      multipleQuestionsBackendDict, initSuccessCb, initErrorCb);
    let languageCode = questionPlayerEngineService.getLanguageCode();

    expect(languageCode).toBe(&#x27;en&#x27;);

    questionPlayerEngineService.submitAnswer(
      answer, textInputService, submitAnswerSuccessCb);
    questionPlayerEngineService.recordNewCardAdded();

    languageCode = questionPlayerEngineService.getLanguageCode();
    expect(languageCode).toBe(&#x27;br&#x27;);

    questionPlayerEngineService.submitAnswer(
      answer, textInputService, submitAnswerSuccessCb);
    questionPlayerEngineService.recordNewCardAdded();

    languageCode = questionPlayerEngineService.getLanguageCode();
    expect(languageCode).toBe(&#x27;ab&#x27;);
  });

  it(&#x27;should always return false when calling \&#x27;isInPreviewMode()\&#x27;&#x27;, () =&gt; {
    let previewMode = questionPlayerEngineService.isInPreviewMode();

    expect(previewMode).toBe(false);
  });

  it(&#x27;should show warning message while loading a question &#x27; +
    &#x27;if the question name is empty&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    singleQuestionBackendDict.question_state_data
      .content.html = null;
    let alertsServiceSpy = spyOn(
      alertsService, &#x27;addWarning&#x27;).and.returnValue();
    spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
      .and.callFake((html, envs) =&gt; html);

    questionPlayerEngineService.init(
      [singleQuestionBackendDict], initSuccessCb, initErrorCb);

    expect(alertsServiceSpy).toHaveBeenCalledWith(
      &#x27;Question name should not be empty.&#x27;);
  });

  it(&#x27;should not load questions if there are no questions&#x27;, () =&gt; {
    let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
    let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);

    let alertsServiceSpy = spyOn(
      alertsService, &#x27;addWarning&#x27;).and.returnValue();

    questionPlayerEngineService.init(
      [], initSuccessCb, initErrorCb);

    expect(alertsServiceSpy).toHaveBeenCalledWith(
      &#x27;There are no questions to display.&#x27;);
    expect(initSuccessCb).not.toHaveBeenCalled();
    expect(initErrorCb).toHaveBeenCalled();
  });

  describe(&#x27;on submitting answer &#x27;, () =&gt; {
    it(&#x27;should call success callback if the submitted &#x27; +
      &#x27;answer is correct&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
      );
      answerClassificationResult.outcome.labelledAsCorrect = true;

      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);

      questionPlayerEngineService.init(
        multipleQuestionsBackendDict, initSuccessCb, initErrorCb);
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(questionPlayerEngineService.isAnswerBeingProcessed()).toBe(false);
      expect(submitAnswerSuccessCb).toHaveBeenCalled();
    });

    it(&#x27;should not submit answer again if the answer &#x27; +
      &#x27;is already being processed&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
      );

      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);

      questionPlayerEngineService.setAnswerIsBeingProcessed(true);
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(submitAnswerSuccessCb).not.toHaveBeenCalled();
    });

    it(&#x27;should show warning message if the feedback &#x27; +
      &#x27;content is empty&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, null, null, []), 1, 0, &#x27;default_outcome&#x27;
      );
      answerClassificationResult.outcome.labelledAsCorrect = true;

      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);
      let alertsServiceSpy = spyOn(
        alertsService, &#x27;addWarning&#x27;).and.returnValue();
      spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
        .and.callFake((html, envs) =&gt; html);

      singleQuestionBackendDict.question_state_data
        .interaction.default_outcome.feedback.html = null;
      questionPlayerEngineService.init(
        [singleQuestionBackendDict], initSuccessCb, initErrorCb);

      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(alertsServiceSpy)
        .toHaveBeenCalledWith(&#x27;Feedback content should not be empty.&#x27;);
    });

    it(&#x27;should show warning message if the question &#x27; +
      &#x27;name is empty&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
      );
      answerClassificationResult.outcome.labelledAsCorrect = true;

      singleQuestionBackendDict.question_state_data
        .content.html = null;
      let sampleQuestion = questionObjectFactory.createFromBackendDict(
        singleQuestionBackendDict);

      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);
      let alertsServiceSpy = spyOn(
        alertsService, &#x27;addWarning&#x27;).and.returnValue();
      spyOn(questionPlayerEngineService, &#x27;init&#x27;).and.callFake(() =&gt; {
        questionPlayerEngineService.addQuestion(sampleQuestion);
      });

      spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
        .and.callFake((html, envs) =&gt; html);

      questionPlayerEngineService.init(
        [singleQuestionBackendDict], initSuccessCb, initErrorCb);
      questionPlayerEngineService.setCurrentIndex(0);
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(alertsServiceSpy)
        .toHaveBeenCalledWith(&#x27;Question name should not be empty.&#x27;);
    });

    it(&#x27;should update the current index when a card is added&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
      );
      answerClassificationResult.outcome.labelledAsCorrect = true;

      spyOn(contextService, &#x27;setQuestionPlayerIsOpen&#x27;);
      spyOn(contextService, &#x27;isInQuestionPlayerMode&#x27;).and.returnValue(true);
      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);
      spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
        .and.callFake((html, envs) =&gt; html);

      questionPlayerEngineService.init(
        multipleQuestionsBackendDict, initSuccessCb, initErrorCb);
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(questionPlayerEngineService.getCurrentIndex()).toBe(0);

      questionPlayerEngineService.recordNewCardAdded();

      expect(questionPlayerEngineService.getCurrentIndex()).toBe(1);
    });

    it(&#x27;should not create next card if the existing &#x27; +
      &#x27;card is the last one&#x27;, () =&gt; {
      let submitAnswerSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initSuccessCb = jasmine.createSpy(&#x27;success&#x27;);
      let initErrorCb = jasmine.createSpy(&#x27;fail&#x27;);
      let answer = &#x27;answer&#x27;;
      let answerClassificationResult = new AnswerClassificationResult(
        outcomeObjectFactory
          .createNew(&#x27;default&#x27;, &#x27;&#x27;, &#x27;&#x27;, []), 1, 0, &#x27;default_outcome&#x27;
      );
      let sampleCard = stateCardObjectFactory.createNewCard(
        &#x27;Card 1&#x27;, &#x27;Content html&#x27;, &#x27;Interaction text&#x27;, null,
        null, null, &#x27;content_id&#x27;);

      answerClassificationResult.outcome.labelledAsCorrect = true;

      spyOn(answerClassificationService, &#x27;getMatchingClassificationResult&#x27;)
        .and.returnValue(answerClassificationResult);
      spyOn(expressionInterpolationService, &#x27;processHtml&#x27;)
        .and.callFake((html, envs) =&gt; html);
      spyOn(focusManagerService, &#x27;generateFocusLabel&#x27;)
        .and.returnValue(&#x27;focusLabel&#x27;);

      // We are using a stub backend dict which consists of three questions.
      questionPlayerEngineService.init(
        multipleQuestionsBackendDict, initSuccessCb, initErrorCb);

      let createNewCardSpy = spyOn(
        stateCardObjectFactory, &#x27;createNewCard&#x27;).and.returnValue(sampleCard);

      expect(createNewCardSpy).toHaveBeenCalledTimes(0);

      // Submitting answer to the first question.
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(
        questionPlayerEngineService.getCurrentQuestionId()).toBe(&#x27;questionId1&#x27;);
      expect(createNewCardSpy).toHaveBeenCalledTimes(1);

      questionPlayerEngineService.recordNewCardAdded();
      // Submitting answer to the second question.
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(
        questionPlayerEngineService.getCurrentQuestionId()).toBe(&#x27;questionId2&#x27;);
      expect(createNewCardSpy).toHaveBeenCalledTimes(2);

      questionPlayerEngineService.recordNewCardAdded();
      // Submitting answer to the last question.
      questionPlayerEngineService.submitAnswer(
        answer, textInputService, submitAnswerSuccessCb);

      expect(
        questionPlayerEngineService.getCurrentQuestionId()).toBe(&#x27;questionId3&#x27;);
      // Please note that after submitting answer to the final question,
      // a new card was not created, hence createNewCardSpy was not called.
      expect(createNewCardSpy).toHaveBeenCalledTimes(2);
    });
  });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:59 GMT</p>
    </body>
  </html>
  