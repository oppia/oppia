
  <!DOCTYPE html>
  <html>
    <head>
      <title>state-classifier-mapping.service.spec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/pages/exploration-player-page/services/state-classifier-mapping.service.spec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">239</td><td class="">239</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for the State classifier mapping service.
 */
import { HttpClientTestingModule } from &#x27;@angular/common/http/testing&#x27;;
import { TestBed, waitForAsync } from &#x27;@angular/core/testing&#x27;;

import { AppService } from &#x27;services/app.service&#x27;;
import { Classifier } from &#x27;domain/classifier/classifier.model&#x27;;
import { ClassifierDataBackendApiService } from &#x27;services/classifier-data-backend-api.service&#x27;;
import { StateClassifierMappingService } from
  &#x27;pages/exploration-player-page/services/state-classifier-mapping.service&#x27;;
import { TextClassifierFrozenModel } from &#x27;classifiers/proto/text_classifier&#x27;;

describe(&#x27;State classifier mapping service&#x27;, () =&gt; {
  describe(&#x27;Test that classifier data is fetched properly when ML is enabled&#x27;,
    () =&gt; {
      let mappingService: StateClassifierMappingService;
      let appService: AppService;
      let classifierFrozenModel = new TextClassifierFrozenModel();
      let classifierDataBackendApiService: ClassifierDataBackendApiService;
      const expId = &#x27;0&#x27;;
      const expVersion = 0;
      const stateName = &#x27;stateName1&#x27;;

      // The model_json attribute in TextClassifierFrozenModel class can&#x27;t be
      // changed to camelcase since the class definition is automatically
      // compiled with the help of protoc.
      classifierFrozenModel.model_json = JSON.stringify({
        KNN: {
          occurrence: 0,
          K: 0,
          T: 0,
          top: 0,
          fingerprint_data: {
            0: {
              &#x27;class&#x27;: 0,
              fingerprint: [[0]]
            }
          },
          token_to_id: {
            a: 0
          }
        },
        SVM: {
          classes: [0],
          kernel_params: {
            kernel: &#x27;string&#x27;,
            coef0: 0,
            degree: 0,
            gamma: 0
          },
          intercept: [0],
          n_support: [0],
          probA: [0],
          support_vectors: [[0]],
          probB: [0],
          dual_coef: [[0]]
        },
        cv_vocabulary: {
          a: 0
        }
      });

      let classifierData = new Classifier(
        &#x27;TestClassifier&#x27;, classifierFrozenModel.serialize(), 1);

      beforeEach(() =&gt; {
        TestBed.configureTestingModule({
          imports: [HttpClientTestingModule],
          providers: [StateClassifierMappingService]
        });

        mappingService = TestBed.get(StateClassifierMappingService);
        appService = TestBed.get(AppService);
        classifierDataBackendApiService = TestBed.inject(
          ClassifierDataBackendApiService);
        spyOn(appService, &#x27;isMachineLearningClassificationEnabled&#x27;)
          .and.returnValue(true);
      });

      it(&#x27;should fetch classifier data correctly&#x27;, waitForAsync(async() =&gt; {
        spyOn(
          classifierDataBackendApiService,
          &#x27;getClassifierDataAsync&#x27;).and.callFake(() =&gt; {
          return new Promise((resolve, reject) =&gt; {
            resolve(classifierData);
          });
        });
        mappingService.init(expId, expVersion);
        await mappingService.initializeClassifierDataForState(stateName);
        expect(mappingService.hasClassifierData(stateName)).toBe(true);
      }));

      it(&#x27;should handle failure of fetching classifier data&#x27;, waitForAsync(
        async() =&gt; {
          spyOn(
            classifierDataBackendApiService,
            &#x27;getClassifierDataAsync&#x27;).and.callFake(() =&gt; {
            return new Promise((resolve, reject) =&gt; {
              reject(&#x27;No classifier data found for exploration&#x27;);
            });
          });
          mappingService.init(expId, expVersion);
          await mappingService.initializeClassifierDataForState(stateName);
          expect(mappingService.hasClassifierData(stateName)).toBe(false);
        }));

      it(&#x27;should return classifier data when it exists.&#x27;, () =&gt; {
        mappingService.init(expId, expVersion);

        mappingService.testOnlySetClassifierData(stateName, classifierData);
        var retrievedClassifier = mappingService.getClassifier(stateName);

        expect(retrievedClassifier.algorithmId).toEqual(&#x27;TestClassifier&#x27;);
        expect(retrievedClassifier.classifierData).toEqual(
          classifierFrozenModel.serialize());
        expect(retrievedClassifier.algorithmVersion).toEqual(1);
      });

      it(&#x27;should return undefined when classifier data does not exist.&#x27;, () =&gt; {
        mappingService.init(expId, expVersion);
        var stateNameNonexistent = &#x27;stateName2&#x27;;
        var nonExistentClassifier = mappingService.getClassifier(
          stateNameNonexistent);
        expect(nonExistentClassifier).toBe(undefined);
      });

      it(&#x27;should return true when it has classifier data.&#x27;, () =&gt; {
        mappingService.init(expId, expVersion);
        mappingService.testOnlySetClassifierData(stateName, classifierData);
        expect(mappingService.hasClassifierData(stateName)).toBe(true);
      });

      it(&#x27;should return false when it does not have classifier data .&#x27;, () =&gt; {
        mappingService.init(expId, expVersion);
        var stateNameNonexistent = &#x27;stateName2&#x27;;
        expect(mappingService.hasClassifierData(
          stateNameNonexistent)).toBe(false);
      });

      it(&#x27;should not return correct classifier details when init is not &#x27; +
        &#x27;called&#x27;, () =&gt; {
        var retrievedClassifier = mappingService.getClassifier(stateName);
        expect(retrievedClassifier).toBe(undefined);
      });
    });

  describe(&#x27;Test that classifier data is not fetched when ML is disabled&#x27;,
    () =&gt; {
      let mappingService: StateClassifierMappingService;
      let appService: AppService;
      const expId = &#x27;0&#x27;;
      const stateName = &#x27;stateName1&#x27;;
      const expVersion = 0;

      beforeEach(() =&gt; {
        TestBed.configureTestingModule({
          imports: [HttpClientTestingModule],
          providers: [StateClassifierMappingService]
        });

        mappingService = TestBed.get(StateClassifierMappingService);
        appService = TestBed.get(AppService);
        spyOn(appService, &#x27;isMachineLearningClassificationEnabled&#x27;)
          .and.returnValue(false);
      });

      it(&#x27;should not return classifier data.&#x27;, () =&gt; {
        mappingService.init(expId, expVersion);
        expect(mappingService.hasClassifierData(stateName)).toBe(false);
        expect(mappingService.getClassifier(stateName)).toBe(undefined);
      });
    });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:59 GMT</p>
    </body>
  </html>
  