
  <!DOCTYPE html>
  <html>
    <head>
      <title>audio-bar.component.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/pages/exploration-player-page/layout-directives/audio-bar.component.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">376</td><td class="">376</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Component for a set of audio controls for a specific
 * audio translation in the learner view.
 */

import { Component } from &#x27;@angular/core&#x27;;
import { downgradeComponent } from &#x27;@angular/upgrade/static&#x27;;
import { Voiceover } from &#x27;domain/exploration/voiceover.model&#x27;;
import { Subscription } from &#x27;rxjs&#x27;;
import { AssetsBackendApiService } from &#x27;services/assets-backend-api.service&#x27;;
import { AudioBarStatusService } from &#x27;services/audio-bar-status.service&#x27;;
import { AudioPlayerService, AutoPlayAudioEvent } from &#x27;services/audio-player.service&#x27;;
import { AutogeneratedAudioPlayerService } from &#x27;services/autogenerated-audio-player.service&#x27;;
import { ContextService } from &#x27;services/context.service&#x27;;
import { AudioPreloaderService } from &#x27;../services/audio-preloader.service&#x27;;
import { AudioTranslationLanguageService, ExplorationLanguageInfo } from &#x27;../services/audio-translation-language.service&#x27;;
import { AudioTranslationManagerService } from &#x27;../services/audio-translation-manager.service&#x27;;
import { PlayerPositionService } from &#x27;../services/player-position.service&#x27;;

interface Track {
  progress: (progressPercentage: number) =&gt; number;
}

@Component({
  selector: &#x27;oppia-audio-bar&#x27;,
  templateUrl: &#x27;./audio-bar.component.html&#x27;
})
export class AudioBarComponent {
  lastScrollTop: number = 0;
  isPaused: boolean = true;
  directiveSubscriptions: Subscription = new Subscription();
  languagesInExploration: ExplorationLanguageInfo[];
  audioBarIsExpanded: boolean;
  progressBarIsShown: boolean;
  audioLoadingIndicatorIsShown: boolean = false;
  explorationPlayerModeIsActive: boolean;
  selectedLanguage: { value: string };
  track: Track;

  constructor(
    private assetsBackendApiService: AssetsBackendApiService,
    private audioBarStatusService: AudioBarStatusService,
    private audioPlayerService: AudioPlayerService,
    private audioPreloaderService: AudioPreloaderService,
    private audioTranslationLanguageService: AudioTranslationLanguageService,
    private audioTranslationManagerService: AudioTranslationManagerService,
    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,
    private contextService: ContextService,
    private playerPositionService: PlayerPositionService
  ) {
    this.explorationPlayerModeIsActive =
      this.contextService.isInExplorationPlayerPage();
    this.languagesInExploration = this.audioTranslationLanguageService
      .getLanguageOptionsForDropdown();
    this.selectedLanguage = {
      value: this.audioTranslationLanguageService.getCurrentAudioLanguageCode()
    };

    this.track = {
      progress: (progressPercentage: number) =&gt; {
        if (progressPercentage) {
          this.audioPlayerService.setProgress(progressPercentage / 100);
        }
        return this.audioPlayerService.getProgress() * 100;
      }
    };
  }

  ngOnInit(): void {
    this.directiveSubscriptions.add(
      this.audioPlayerService.onAutoplayAudio.subscribe(
        (params: AutoPlayAudioEvent) =&gt; {
          if (this.audioBarIsExpanded) {
            this.audioPlayerService.stop();
            this.autogeneratedAudioPlayerService.cancel();

            // We use a timeout to allow for any previous audio to have
            // their &#x27;onend&#x27; callback called. This is primarily used to
            // address delays with autogenerated audio callbacks.
            setTimeout(() =&gt; {
              if (params) {
                this.audioTranslationManagerService
                  .setSecondaryAudioTranslations(
                    params.audioTranslations,
                    params.html,
                    params.componentName
                  );
                if (!this.isPaused) {
                  this.onPlayButtonClicked();
                }
              }
            }, 100);
          }
        }
      ));
    this.audioBarIsExpanded = false;
    this.progressBarIsShown = false;
    this.audioLoadingIndicatorIsShown = false;
    this.audioPreloaderService.setAudioLoadedCallback(
      this.onFinishedLoadingAudio.bind(this));
  }

  ngOnDestroy(): void {
    this.directiveSubscriptions.unsubscribe();
  }

  setProgress(val: {value: number}): void {
    this.audioPlayerService.setCurrentTime(val.value);
  }

  isAudioBarAvailable(): boolean {
    return this.languagesInExploration.length &gt; 0;
  }

  onNewLanguageSelected(): void {
    this.audioTranslationLanguageService.setCurrentAudioLanguageCode(
      this.selectedLanguage.value);
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
    this.autogeneratedAudioPlayerService.cancel();
    if (this.isAudioBarAvailable() &amp;&amp;
        !this.isAutogeneratedLanguageCodeSelected()) {
      let audioTranslation: Voiceover = this.getVoiceoverInCurrentLanguage();
      this.audioPreloaderService
        .setMostRecentlyRequestedAudioFilename(audioTranslation.filename);
      this.audioPreloaderService.restartAudioPreloader(
        this.playerPositionService.getCurrentStateName());
    }
  }

  expandAudioBar(): void {
    this.audioBarIsExpanded = true;
    this.audioBarStatusService.markAudioBarExpanded();
  }

  collapseAudioBar(): void {
    this.audioBarStatusService.markAudioBarCollapsed();
    this.audioBarIsExpanded = false;
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
    this.autogeneratedAudioPlayerService.cancel();
  }

  getCurrentAudioLanguageCode(): string {
    return this.audioTranslationLanguageService
      .getCurrentAudioLanguageCode();
  }

  getCurrentAudioLanguageDescription(): string {
    return this.audioTranslationLanguageService
      .getCurrentAudioLanguageDescription();
  }

  getVoiceoverInCurrentLanguage(): Voiceover {
    return this.audioTranslationManagerService.getCurrentAudioTranslations()[
      this.audioTranslationLanguageService.getCurrentAudioLanguageCode()];
  }

  isAudioPlaying(): boolean {
    return this.audioPlayerService.isPlaying() ||
      this.autogeneratedAudioPlayerService.isPlaying();
  }

  isAudioAvailableInCurrentLanguage(): boolean {
    return Boolean(this.getVoiceoverInCurrentLanguage()) ||
      this.isAutogeneratedLanguageCodeSelected();
  }

  doesCurrentAudioTranslationNeedUpdate(): boolean {
    if (!this.isAutogeneratedLanguageCodeSelected()) {
      let audioTranslation: Voiceover = this.getVoiceoverInCurrentLanguage();
      return (audioTranslation &amp;&amp; audioTranslation.needsUpdate);
    } else {
      return false;
    }
  }

  isAutogeneratedLanguageCodeSelected(): boolean {
    return this.audioTranslationLanguageService
      .isAutogeneratedLanguageCodeSelected();
  }

  onBackwardButtonClicked(): void {
    this.audioPlayerService.rewind(5);
  }

  onForwardButtonClicked(): void {
    this.audioPlayerService.forward(5);
  }

  onPlayButtonClicked(): void {
    this.isPaused = !this.isPaused;
    this.progressBarIsShown = !this.isAutogeneratedLanguageCodeSelected();
    if (this.isAutogeneratedLanguageCodeSelected()) {
      this.playPauseAutogeneratedAudioTranslation();
    } else {
      let audioTranslation = this.getVoiceoverInCurrentLanguage();
      if (audioTranslation) {
        this.playPauseUploadedAudioTranslation();
      }
    }
  }

  isCached(audioTranslation: Voiceover): boolean {
    return this.assetsBackendApiService.isCached(audioTranslation.filename);
  }

  playPauseAutogeneratedAudioTranslation(): void {
    // SpeechSynthesis in Chrome seems to have a bug
    // where if you pause the utterance, wait for around
    // 15 or more seconds, then try resuming, nothing
    // will sound. As a temporary fix, just restart the
    // utterance from the beginning instead of resuming.
    if (this.autogeneratedAudioPlayerService.isPlaying()) {
      this.autogeneratedAudioPlayerService.cancel();
    } else {
      this.autogeneratedAudioPlayerService.play(
        this.audioTranslationManagerService
          .getCurrentHtmlForAutogeneratedAudio(),
        this.audioTranslationLanguageService
          .getSpeechSynthesisLanguageCode(),
        () =&gt; {
          // Used to update bindings to show a silent speaker after
          // autogenerated audio has finished playing.
          this.audioTranslationManagerService
            .clearSecondaryAudioTranslations();
        });
    }
  }

  playPauseUploadedAudioTranslation(): void {
    if (!this.audioPlayerService.isPlaying()) {
      if (this.audioPlayerService.isTrackLoaded()) {
        this.audioPlayerService.play();
      } else {
        this.loadAndPlayAudioTranslation();
      }
    } else {
      this.audioPlayerService.pause();
    }
  }

  playCachedAudioTranslation(audioFilename: string): void {
    this.audioPlayerService.loadAsync(audioFilename)
      .then(() =&gt; {
        this.audioLoadingIndicatorIsShown = false;
        this.audioPlayerService.play();
      });
  }

  /**
   * Called when an audio file finishes loading.
   * @param {string} audioFilename - Filename of the audio file that
   *                                 finished loading.
   */
  onFinishedLoadingAudio(audioFilename: string): void {
    let mostRecentlyRequestedAudioFilename =
      this.audioPreloaderService.getMostRecentlyRequestedAudioFilename();
    if (this.audioLoadingIndicatorIsShown &amp;&amp;
        audioFilename === mostRecentlyRequestedAudioFilename) {
      this.playCachedAudioTranslation(audioFilename);
    }
  }

  loadAndPlayAudioTranslation(): void {
    this.audioLoadingIndicatorIsShown = true;
    let audioTranslation = this.getVoiceoverInCurrentLanguage();
    this.audioPreloaderService.setMostRecentlyRequestedAudioFilename(
      audioTranslation.filename);
    if (audioTranslation) {
      if (this.isCached(audioTranslation)) {
        this.playCachedAudioTranslation(
          audioTranslation.filename);
      } else if (!this.audioPreloaderService.isLoadingAudioFile(
        audioTranslation.filename)) {
        this.audioPreloaderService.restartAudioPreloader(
          this.playerPositionService.getCurrentStateName());
      }
    }
  }
}

angular.module(&#x27;oppia&#x27;).directive(&#x27;oppiaAudioBar&#x27;,
  downgradeComponent({
    component: AudioBarComponent
  }) as angular.IDirectiveFactory);
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:56 GMT</p>
    </body>
  </html>
  