
  <!DOCTYPE html>
  <html>
    <head>
      <title>FractionObjectFactorySpec.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/domain/objects/FractionObjectFactorySpec.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">451</td><td class="">451</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2017 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview unit tests for the fraction object type factory service.
 */

import { ObjectsDomainConstants } from
  &#x27;domain/objects/objects-domain.constants&#x27;;
import { Fraction, FractionObjectFactory } from
  &#x27;domain/objects/FractionObjectFactory&#x27;;

describe(&#x27;Fraction Object Factory&#x27;, () =&gt; {
  let errors: typeof ObjectsDomainConstants.FRACTION_PARSING_ERRORS;
  let fraction: FractionObjectFactory;

  beforeEach(() =&gt; {
    errors = ObjectsDomainConstants.FRACTION_PARSING_ERRORS;
    fraction = new FractionObjectFactory();
  });

  it(&#x27;should create a new object from dict&#x27;, () =&gt; {
    const fractionObject = {
      isNegative: false,
      wholeNumber: 0,
      numerator: 0,
      denominator: 1
    };
    const createdFraction = fraction.fromDict(fractionObject);

    expect(createdFraction.toDict()).toEqual(fractionObject);
  });

  it(&#x27;should equate two fractions&#x27;, () =&gt; {
    const fractionObject = {
      isNegative: false,
      wholeNumber: 0,
      numerator: 0,
      denominator: 1
    };
    let createdFraction = fraction.fromDict(fractionObject);
    let createdFraction2 = fraction.fromDict(fractionObject);
    expect(createdFraction.isEqualTo(createdFraction2)).toBe(true);
    createdFraction = fraction.fromDict({
      isNegative: false,
      wholeNumber: 0,
      numerator: 1,
      denominator: 2
    });
    createdFraction2 = fraction.fromDict({
      isNegative: false,
      wholeNumber: 0,
      numerator: 2,
      denominator: 4
    });
    expect(createdFraction.isEqualTo(createdFraction2)).toBe(true);
    createdFraction = fraction.fromDict({
      isNegative: false,
      wholeNumber: 0,
      numerator: 1,
      denominator: 3
    });
    createdFraction2 = fraction.fromDict({
      isNegative: false,
      wholeNumber: 0,
      numerator: 2,
      denominator: 4
    });
    expect(createdFraction.isEqualTo(createdFraction2)).toBe(false);
  });

  it(&#x27;should convert itself to a string in fraction format&#x27;, () =&gt; {
    expect(new Fraction(true, 1, 2, 3).toString()).toBe(&#x27;-1 2/3&#x27;);
    expect(new Fraction(false, 1, 2, 3).toString()).toBe(&#x27;1 2/3&#x27;);
    expect(new Fraction(true, 0, 2, 3).toString()).toBe(&#x27;-2/3&#x27;);
    expect(new Fraction(false, 0, 2, 3).toString()).toBe(&#x27;2/3&#x27;);
    expect(new Fraction(true, 1, 0, 3).toString()).toBe(&#x27;-1&#x27;);
    expect(new Fraction(false, 1, 0, 3).toString()).toBe(&#x27;1&#x27;);
    expect(new Fraction(true, 0, 0, 3).toString()).toBe(&#x27;0&#x27;);
    expect(new Fraction(false, 0, 0, 3).toString()).toBe(&#x27;0&#x27;);
  });

  it(&#x27;should return the correct integer part&#x27;, () =&gt; {
    expect(new Fraction(true, 1, 2, 3).getIntegerPart()).toBe(-1);
    expect(new Fraction(false, 1, 2, 3).getIntegerPart()).toBe(1);
    expect(new Fraction(true, 0, 2, 3).getIntegerPart()).toBe(0);
    expect(new Fraction(false, 0, 2, 3).getIntegerPart()).toBe(0);
    expect(new Fraction(true, 1, 0, 3).getIntegerPart()).toBe(-1);
    expect(new Fraction(false, 1, 0, 3).getIntegerPart()).toBe(1);
    expect(new Fraction(true, 0, 0, 3).getIntegerPart()).toBe(0);
    expect(new Fraction(false, 0, 0, 3).getIntegerPart()).toBe(0);
  });

  it(&#x27;should parse valid strings&#x27;, () =&gt; {
    expect(fraction.fromRawInputString(&#x27;10/ 2&#x27;).toDict()).toEqual(
      new Fraction(false, 0, 10, 2).toDict());
    expect(fraction.fromRawInputString(&#x27;10/20&#x27;).toDict()).toEqual(
      new Fraction(false, 0, 10, 20).toDict());
    expect(fraction.fromRawInputString(&#x27;1   1/ 2&#x27;).toDict()).toEqual(
      new Fraction(false, 1, 1, 2).toDict());
    expect(fraction.fromRawInputString(&#x27;- 1 1 /2&#x27;).toDict()).toEqual(
      new Fraction(true, 1, 1, 2).toDict());
    expect(fraction.fromRawInputString(&#x27;1      &#x27;).toDict()).toEqual(
      new Fraction(false, 1, 0, 1).toDict());
    expect(fraction.fromRawInputString(&#x27;  - 1&#x27;).toDict()).toEqual(
      new Fraction(true, 1, 0, 1).toDict());
    expect(fraction.fromRawInputString(&#x27;1  /  22&#x27;).toDict()).toEqual(
      new Fraction(false, 0, 1, 22).toDict());
    expect(fraction.fromRawInputString(&#x27; -1 /2&#x27;).toDict()).toEqual(
      new Fraction(true, 0, 1, 2).toDict());
    expect(fraction.fromRawInputString(&#x27;0  1/2&#x27;).toDict()).toEqual(
      new Fraction(false, 0, 1, 2).toDict());
    expect(fraction.fromRawInputString(&#x27;1 0 /2&#x27;).toDict()).toEqual(
      new Fraction(false, 1, 0, 2).toDict());
  });

  it(&#x27;should throw errors for invalid fractions&#x27;, () =&gt; {
    // Invalid characters.
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;3 \ b&#x27;);
    }).toThrowError(errors.INVALID_CHARS);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;a 3/5&#x27;);
    }).toThrowError(errors.INVALID_CHARS);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;5 b/c&#x27;);
    }).toThrowError(errors.INVALID_CHARS);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;a b/c&#x27;);
    }).toThrowError(errors.INVALID_CHARS);
    // Invalid format.
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1 / -3&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;-1 -3/2&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;3 -&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1  1&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1/3 1/2&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1 2 3 / 4&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1 / 2 3&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;- / 3&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;/ 3&#x27;);
    }).toThrowError(errors.INVALID_FORMAT);
    // Division by zero.
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27; 1/0&#x27;);
    }).toThrowError(errors.DIVISION_BY_ZERO);
    expect(() =&gt; {
      fraction.fromRawInputString(&#x27;1 2 /0&#x27;);
    }).toThrowError(errors.DIVISION_BY_ZERO);
  });

  it(&#x27;should convert to the correct float value&#x27;, () =&gt; {
    expect(fraction.fromRawInputString(&#x27;1&#x27;).toFloat()).toEqual(1);
    expect(fraction.fromRawInputString(&#x27;1 0/5&#x27;).toFloat()).toEqual(1);
    expect(fraction.fromRawInputString(&#x27;1 4/5&#x27;).toFloat()).toEqual(1.8);
    expect(fraction.fromRawInputString(&#x27;0 4/5&#x27;).toFloat()).toEqual(0.8);
    expect(fraction.fromRawInputString(&#x27;-10/10&#x27;).toFloat()).toEqual(-1);
    expect(fraction.fromRawInputString(&#x27;0 40/50&#x27;).toFloat()).toEqual(0.8);
    expect(fraction.fromRawInputString(&#x27;0 2/3&#x27;).toFloat()).toEqual(2 / 3);
    expect(fraction.fromRawInputString(&#x27;0 25/5&#x27;).toFloat()).toEqual(5);
    expect(fraction.fromRawInputString(&#x27;4 1/3&#x27;).toFloat()).toEqual(13 / 3);
  });

  it(&#x27;should correctly detect nonzero integer part&#x27;, () =&gt; {
    expect(
      fraction.fromRawInputString(&#x27;0&#x27;).hasNonzeroIntegerPart()).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;1&#x27;).hasNonzeroIntegerPart()).toBe(true);
    expect(
      fraction.fromRawInputString(&#x27;1 0/5&#x27;).hasNonzeroIntegerPart()
    ).toBe(true);
    expect(
      fraction.fromRawInputString(&#x27;1 3/5&#x27;).hasNonzeroIntegerPart()
    ).toBe(true);
    expect(
      fraction.fromRawInputString(&#x27;7/5&#x27;).hasNonzeroIntegerPart()).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;2/5&#x27;).hasNonzeroIntegerPart()).toBe(false);
  });

  it(&#x27;should correctly detect improper fractions&#x27;, () =&gt; {
    expect(fraction.fromRawInputString(&#x27;0&#x27;).isImproperFraction()).toBe(false);
    expect(fraction.fromRawInputString(&#x27;1&#x27;).isImproperFraction()).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;1 0/5&#x27;).isImproperFraction()
    ).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;1 3/5&#x27;).isImproperFraction()
    ).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;2/5&#x27;).isImproperFraction()).toBe(false);
    expect(
      fraction.fromRawInputString(&#x27;7/5&#x27;).isImproperFraction()).toBe(true);
    expect(
      fraction.fromRawInputString(&#x27;5/5&#x27;).isImproperFraction()).toBe(true);
  });

  it(&#x27;should convert to simplest form&#x27;, () =&gt; {
    expect(fraction.fromRawInputString(&#x27;1&#x27;).convertToSimplestForm())
      .toEqual(new Fraction(false, 1, 0, 1));
    expect(fraction.fromRawInputString(&#x27;0&#x27;).convertToSimplestForm())
      .toEqual(new Fraction(false, 0, 0, 1));
    expect(fraction.fromRawInputString(&#x27;2/5&#x27;).convertToSimplestForm())
      .toEqual(new Fraction(false, 0, 2, 5));
    expect(fraction.fromRawInputString(&#x27;5/5&#x27;).convertToSimplestForm())
      .toEqual(new Fraction(false, 0, 1, 1));
    expect(fraction.fromRawInputString(&#x27;1 0/5&#x27;).convertToSimplestForm())
      .toEqual(new Fraction(false, 1, 0, 1));
  });
});
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:57 GMT</p>
    </body>
  </html>
  