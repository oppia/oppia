
  <!DOCTYPE html>
  <html>
    <head>
      <title>StatesObjectFactory.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/domain/exploration/StatesObjectFactory.ts</td><td class="">99.38%</td><td class="">100%</td><td class="">323</td><td class="">321</td><td class="">2</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Factory for creating new frontend instances of State
 * domain objects given a list of backend state dictionaries.
 */
import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;

import {
  StateBackendDict,
  StateObjectFactory,
  State
} from &#x27;domain/state/StateObjectFactory&#x27;;
import { AppConstants } from &#x27;app.constants&#x27;;
import { Voiceover } from &#x27;domain/exploration/voiceover.model&#x27;;
import { WrittenTranslation } from
  &#x27;domain/exploration/WrittenTranslationObjectFactory&#x27;;

import INTERACTION_SPECS from &#x27;interactions/interaction_specs.json&#x27;;

export interface StateObjectsDict {
  [state: string]: State;
}

export interface StateObjectsBackendDict {
  [state: string]: StateBackendDict;
}

export interface VoiceoverObjectsDict {
  [state: string]: Voiceover[];
}

export interface WrittenTranslationObjectsDict {
  [stateName: string]: WrittenTranslation[];
}

const MIN_ALLOWED_MISSING_OR_UPDATE_NEEDED_WRITTEN_TRANSLATIONS = 5;

const WRITTEN_TRANSLATIONS_KEY = &#x27;writtenTranslations&#x27;;
const RECORDED_VOICEOVERS_KEY = &#x27;recordedVoiceovers&#x27;;
type TranslationType = (
  typeof WRITTEN_TRANSLATIONS_KEY | typeof RECORDED_VOICEOVERS_KEY);

export class States {
  constructor(
    private _stateObject: StateObjectFactory,
    private _states: StateObjectsDict) { }

  getState(stateName: string): State {
    return this._states[stateName];
  }

  // TODO(tjiang11): Remove getStateObjects() and replace calls
  // with an object to represent data to be manipulated inside
  // ExplorationDiffService.

  getStateObjects(): StateObjectsDict {
    return this._states;
  }
  addState(newStateName: string): void {
    this._states[newStateName] = this._stateObject.createDefaultState(
      newStateName);
  }
  setState(stateName: string, stateData: State): void {
    // We use the copy method defined in the StateObjectFactory to make
    // sure that this._states[stateName] remains a State object as opposed to
    // Object.assign(..) which returns an object with the content of stateData.
    this._states[stateName].copy(stateData);
  }
  hasState(stateName: string): boolean {
    return this._states.hasOwnProperty(stateName);
  }
  deleteState(deleteStateName: string): void {
    delete this._states[deleteStateName];
    for (var otherStateName in this._states) {
      var interaction = this._states[otherStateName].interaction;
      var groups = interaction.answerGroups;
      for (var i = 0; i &lt; groups.length; i++) {
        if (groups[i].outcome.dest === deleteStateName) {
          groups[i].outcome.dest = otherStateName;
        }
      }
      if (interaction.defaultOutcome) {
        if (interaction.defaultOutcome.dest === deleteStateName) {
          interaction.defaultOutcome.dest = otherStateName;
        }
      }
    }
  }
  renameState(oldStateName: string, newStateName: string): void {
    this._states[newStateName] = this._states[oldStateName];
    this._states[newStateName].setName(newStateName);
    delete this._states[oldStateName];

    for (var otherStateName in this._states) {
      var interaction = this._states[otherStateName].interaction;
      var groups = interaction.answerGroups;
      for (var i = 0; i &lt; groups.length; i++) {
        if (groups[i].outcome.dest === oldStateName) {
          groups[i].outcome.dest = newStateName;
        }
      }
      if (interaction.defaultOutcome) {
        if (interaction.defaultOutcome.dest === oldStateName) {
          interaction.defaultOutcome.dest = newStateName;
        }
      }
    }
  }
  getStateNames(): string[] {
    return Object.keys(this._states);
  }
  getFinalStateNames(): string[] {
    var finalStateNames = [];
    for (var stateName in this._states) {
      var interaction = this._states[stateName].interaction;
      if (interaction.id &amp;&amp; INTERACTION_SPECS[interaction.id].is_terminal) {
        finalStateNames.push(stateName);
      }
    }
    return finalStateNames;
  }

  _getAllLanguageCodesFor(translationType: TranslationType): string[] {
    const allLanguageCodes = new Set&lt;string&gt;();
    Object.values(this._states).forEach(state =&gt; {
      state[translationType].getAllContentIds().forEach(contentId =&gt; {
        const contentLanguageCodes = (
          state[translationType].getLanguageCodes(contentId));
        contentLanguageCodes.forEach(
          allLanguageCodes.add,
          allLanguageCodes);
      });
    });
    return [...allLanguageCodes];
  }

  getAllVoiceoverLanguageCodes(): string[] {
    return this._getAllLanguageCodesFor(RECORDED_VOICEOVERS_KEY);
  }

  getAllWrittenTranslationLanguageCodes(): string[] {
    return this._getAllLanguageCodesFor(WRITTEN_TRANSLATIONS_KEY);
  }

  getAllVoiceovers(languageCode: string): VoiceoverObjectsDict {
    var allAudioTranslations = {};
    for (var stateName in this._states) {
      var state = this._states[stateName];
      allAudioTranslations[stateName] = [];
      var contentIdsList = state.recordedVoiceovers.getAllContentIds();
      contentIdsList.forEach(function(contentId) {
        var audioTranslations = (
          state.recordedVoiceovers.getBindableVoiceovers(contentId));
        if (audioTranslations.hasOwnProperty(languageCode)) {
          allAudioTranslations[stateName].push(
            audioTranslations[languageCode]);
        }
      });
    }
    return allAudioTranslations;
  }

  areWrittenTranslationsDisplayable(languageCode: string): boolean {
    // A language&#x27;s translations are ready to be displayed if there are less
    // than five missing or update-needed translations. In addition, all
    // rule-related translations must be present.
    let translationsNeedingUpdate = 0;
    let translationsMissing = 0;

    for (const stateName in this._states) {
      const state = this._states[stateName];

      const requiredContentIds = (
        state.getRequiredWrittenTranslationContentIds());

      const contentIds = state.writtenTranslations.getAllContentIds();
      for (const contentId of contentIds) {
        if (!requiredContentIds.has(contentId)) {
          continue;
        }

        const writtenTranslation = (
          state.writtenTranslations.getWrittenTranslation(
            contentId, languageCode));
        if (writtenTranslation === undefined) {
          translationsMissing += 1;
          if (contentId.startsWith(AppConstants.COMPONENT_NAME_RULE_INPUT)) {
            // Rule-related translations cannot be missing.
            return false;
          }
        } else if (writtenTranslation.needsUpdate) {
          translationsNeedingUpdate += 1;
        }

        if (
          translationsMissing + translationsNeedingUpdate &gt;
          MIN_ALLOWED_MISSING_OR_UPDATE_NEEDED_WRITTEN_TRANSLATIONS
        ) {
          return false;
        }
      }
    }

    return true;
  }
}

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class StatesObjectFactory {
  constructor(private stateObject: StateObjectFactory) {}
  createFromBackendDict(statesBackendDict: StateObjectsBackendDict): States {
    var stateObjectsDict = {};
    for (var stateName in statesBackendDict) {
      stateObjectsDict[stateName] = this.stateObject.createFromBackendDict(
        stateName, statesBackendDict[stateName]);
    }
    return new States(this.stateObject, stateObjectsDict);
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;StatesObjectFactory&#x27;,
  downgradeInjectable(StatesObjectFactory));
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/domain/exploration/StatesObjectFactory.ts&quot;,&quot;line&quot;:126,&quot;character&quot;:8,&quot;text&quot;:&quot;finalStateNames&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/domain/exploration/StatesObjectFactory.ts&quot;,&quot;line&quot;:130,&quot;character&quot;:8,&quot;text&quot;:&quot;finalStateNames&quot;,&quot;kind&quot;:2}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:54 GMT</p>
    </body>
  </html>
  