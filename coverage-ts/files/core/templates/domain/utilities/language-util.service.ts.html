
  <!DOCTYPE html>
  <html>
    <head>
      <title>language-util.service.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/domain/utilities/language-util.service.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">224</td><td class="">224</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2014 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility service for language operations.
 */

import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;

import { AudioLanguage } from &#x27;domain/utilities/audio-language.model&#x27;;
import { AutogeneratedAudioLanguage, AutogeneratedAudioLanguageDict } from &#x27;domain/utilities/autogenerated-audio-language.model&#x27;;
import { BrowserCheckerService } from &#x27;domain/utilities/browser-checker.service&#x27;;

import CONSTANTS from &#x27;assets/constants&#x27;;

interface SupportedAudioLanguagesDict {
  [language: string]: AudioLanguage;
}

interface SupportedContentLanguagesDict {
  [language: string]: ContentLanguage;
}

interface AutogeneratedAudioLanguagesByType {
  [language: string]: AutogeneratedAudioLanguage;
}

interface SupportedAudioLanguageBackendDict {
  &#x27;id&#x27;: string;
  &#x27;description&#x27;: string;
  &#x27;relatedLanguages&#x27;: readonly string[];
  &#x27;direction&#x27;: string;
}

interface SupportedContentLanguageBackendDict {
  &#x27;code&#x27;: string;
  &#x27;description&#x27;: string;
  &#x27;direction&#x27;: string;
}

interface LanguageIdAndText {
  id: string;
  text: string;
}

interface ContentLanguage {
  code: string;
  description: string;
  direction: string;
}

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class LanguageUtilService {
  get SUPPORTED_AUDIO_LANGUAGES():
      readonly SupportedAudioLanguageBackendDict[] {
    return CONSTANTS.SUPPORTED_AUDIO_LANGUAGES;
  }
  get AUTOGENERATED_AUDIO_LANGUAGES():
      readonly AutogeneratedAudioLanguageDict[] {
    return CONSTANTS.AUTOGENERATED_AUDIO_LANGUAGES;
  }
  get SUPPORTED_CONTENT_LANGUAGES():
      readonly SupportedContentLanguageBackendDict[] {
    return CONSTANTS.SUPPORTED_CONTENT_LANGUAGES;
  }

  constructor(
    private browserChecker: BrowserCheckerService) {}

  getSupportedAudioLanguages(): SupportedAudioLanguagesDict {
    var supportedAudioLanguages: SupportedAudioLanguagesDict = {};
    this.SUPPORTED_AUDIO_LANGUAGES.forEach(audioLanguageDict =&gt; {
      supportedAudioLanguages[audioLanguageDict.id] =
        AudioLanguage.createFromDict(audioLanguageDict);
    });
    return supportedAudioLanguages;
  }

  getSupportedContentLanguages(): SupportedContentLanguagesDict {
    const supportedContentLanguages: SupportedContentLanguagesDict = {};
    this.SUPPORTED_CONTENT_LANGUAGES.forEach(contentLanguageDict =&gt; {
      supportedContentLanguages[contentLanguageDict.code] = contentLanguageDict;
    });
    return supportedContentLanguages;
  }

  getAllAudioLanguageCodes(): string[] {
    var allAudioLanguageCodes = (
      this.SUPPORTED_AUDIO_LANGUAGES.map(audioLanguage =&gt; {
        return audioLanguage.id;
      }));
    return allAudioLanguageCodes;
  }

  getAutogeneratedAudioLanguages(
      type: string): AutogeneratedAudioLanguagesByType {
    var autogeneratedAudioLanguagesByType:
      AutogeneratedAudioLanguagesByType = {};
    this.AUTOGENERATED_AUDIO_LANGUAGES.forEach(
      autogeneratedAudioLanguageDict =&gt; {
        var autogeneratedAudioLanguage =
          AutogeneratedAudioLanguage.createFromDict(
            autogeneratedAudioLanguageDict);

        if (type === &#x27;exp-lang-code&#x27;) {
          autogeneratedAudioLanguagesByType[
            autogeneratedAudioLanguage.explorationLanguage] =
              autogeneratedAudioLanguage;
        } else if (type === &#x27;autogen-lang-code&#x27;) {
          autogeneratedAudioLanguagesByType[
            autogeneratedAudioLanguage.id] =
              autogeneratedAudioLanguage;
        } else {
          throw new Error(&#x27;Invalid type: &#x27; + type);
        }
      }
    );
    return autogeneratedAudioLanguagesByType;
  }

  getShortLanguageDescription(fullLanguageDescription: string): string {
    var ind = fullLanguageDescription.indexOf(&#x27; (&#x27;);
    if (ind === -1) {
      return fullLanguageDescription;
    } else {
      return fullLanguageDescription.substring(0, ind);
    }
  }

  getLanguageIdsAndTexts(): LanguageIdAndText[] {
    var languageIdsAndTexts = this.SUPPORTED_CONTENT_LANGUAGES.map(
      (languageItem: ContentLanguage) =&gt; {
        return {
          id: languageItem.code,
          text: this.getShortLanguageDescription(languageItem.description)
        };
      });
    return languageIdsAndTexts;
  }
  getAudioLanguagesCount(): number {
    return this.getAllAudioLanguageCodes().length;
  }
  getAllVoiceoverLanguageCodes(): string[] {
    return this.getAllAudioLanguageCodes();
  }

  getAudioLanguageDescription(audioLanguageCode: string): string | null {
    const language = this.getSupportedAudioLanguages()[audioLanguageCode];
    return language ? language.description : null;
  }

  getLanguageDirection(languageCode: string): string {
    // The backend constants tests guarantee that SUPPORTED_CONTENT_LANGUAGES
    // and SUPPORTED_AUDIO_LANGUAGES do not conflict and contain at most one
    // entry per language code.
    const matchingContentLanguage = this.SUPPORTED_CONTENT_LANGUAGES.find(
      (language) =&gt; language.code === languageCode);
    if (matchingContentLanguage !== undefined) {
      return matchingContentLanguage.direction;
    }

    const matchingAudioLanguage = this.SUPPORTED_AUDIO_LANGUAGES.find(
      (language) =&gt; language.id === languageCode);
    if (matchingAudioLanguage !== undefined) {
      return matchingAudioLanguage.direction;
    }
    throw new Error(
      &#x27;Could not find language direction for the supplied language code: &#x27; +
        languageCode);
  }

  getContentLanguageDescription(contentLanguageCode: string): string | null {
    const language = this.getSupportedContentLanguages()[contentLanguageCode];
    return language ? language.description : null;
  }

  // Given a list of audio language codes, returns the complement list, i.e.
  // the list of audio language codes not in the input list.
  getComplementAudioLanguageCodes(
      audioLanguageCodes: string[]): string[] {
    return this.getAllAudioLanguageCodes().filter(languageCode =&gt; {
      return audioLanguageCodes.indexOf(languageCode) === -1;
    });
  }
  getLanguageCodesRelatedToAudioLanguageCode(
      audioLanguageCode: string): readonly string[] {
    return (
      this.getSupportedAudioLanguages()[audioLanguageCode].relatedLanguages);
  }
  supportsAutogeneratedAudio(explorationLanguageCode: string): boolean {
    return (
      this.browserChecker.supportsSpeechSynthesis() &amp;&amp;
      this.getAutogeneratedAudioLanguages(&#x27;exp-lang-code&#x27;)
        .hasOwnProperty(explorationLanguageCode));
  }
  isAutogeneratedAudioLanguage(audioLanguageCode: string): boolean {
    return this.getAutogeneratedAudioLanguages(&#x27;autogen-lang-code&#x27;)
      .hasOwnProperty(audioLanguageCode);
  }

  getAutogeneratedAudioLanguage(
      explorationLanguageCode: string): AutogeneratedAudioLanguage {
    return this.getAutogeneratedAudioLanguages(&#x27;exp-lang-code&#x27;)[
      explorationLanguageCode];
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;LanguageUtilService&#x27;, downgradeInjectable(LanguageUtilService));
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:54 GMT</p>
    </body>
  </html>
  