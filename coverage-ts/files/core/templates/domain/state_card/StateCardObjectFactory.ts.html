
  <!DOCTYPE html>
  <html>
    <head>
      <title>StateCardObjectFactory.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/domain/state_card/StateCardObjectFactory.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">296</td><td class="">296</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Factory for creating new frontend instances of State
 * card domain objects used in the exploration player.
 */

import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;
import cloneDeep from &#x27;lodash/cloneDeep&#x27;;

import { AppConstants } from &#x27;app.constants&#x27;;
import { AudioTranslationLanguageService } from
  &#x27;pages/exploration-player-page/services/audio-translation-language.service&#x27;;
import { Interaction } from &#x27;domain/exploration/InteractionObjectFactory&#x27;;
import { BindableVoiceovers, RecordedVoiceovers } from
  &#x27;domain/exploration/recorded-voiceovers.model&#x27;;
import { InteractionCustomizationArgs } from
  &#x27;interactions/customization-args-defs&#x27;;
import { Hint } from &#x27;domain/exploration/HintObjectFactory&#x27;;
import { Solution } from &#x27;domain/exploration/SolutionObjectFactory&#x27;;

import INTERACTION_SPECS from &#x27;interactions/interaction_specs.json&#x27;;
import { WrittenTranslations } from
  &#x27;domain/exploration/WrittenTranslationsObjectFactory&#x27;;

export interface InputResponsePair {
  learnerInput: string,
  oppiaResponse: string,
  isHint: boolean
}

export class StateCard {
  _stateName: string;
  _contentHtml: string;
  _interactionHtml: string;
  _interaction: Interaction;
  _inputResponsePairs: InputResponsePair[];
  _recordedVoiceovers: RecordedVoiceovers;
  _writtenTranslations: WrittenTranslations;
  _contentId: string;
  _completed: boolean;
  audioTranslationLanguageService: AudioTranslationLanguageService;
  constructor(
      stateName: string, contentHtml: string,
      interactionHtml: string, interaction: Interaction,
      inputResponsePairs: InputResponsePair[],
      recordedVoiceovers: RecordedVoiceovers,
      writtenTranslations: WrittenTranslations,
      contentId: string,
      audioTranslationLanguageService: AudioTranslationLanguageService) {
    this._stateName = stateName;
    this._contentHtml = contentHtml;
    this._interactionHtml = interactionHtml;
    this._inputResponsePairs = inputResponsePairs;
    this._interaction = interaction;
    this._recordedVoiceovers = recordedVoiceovers;
    this._writtenTranslations = writtenTranslations;
    this._contentId = contentId;
    this._completed = false;
    this.audioTranslationLanguageService = audioTranslationLanguageService;
  }

  // Restore everything immutably so that Angular can detect changes.
  restoreImmutable(stateCard: StateCard): void {
    Object.assign(this, stateCard);
  }

  getStateName(): string {
    return this._stateName;
  }

  getInteraction(): Interaction {
    return this._interaction;
  }

  getVoiceovers(): BindableVoiceovers {
    let recordedVoiceovers = this._recordedVoiceovers;
    let contentId = this._contentId;
    if (recordedVoiceovers) {
      return recordedVoiceovers.getBindableVoiceovers(contentId);
    }
    return {};
  }

  getRecordedVoiceovers(): RecordedVoiceovers {
    return this._recordedVoiceovers;
  }

  isContentAudioTranslationAvailable(): boolean {
    return Object.keys(
      this.getVoiceovers()).length &gt; 0 ||
        this.audioTranslationLanguageService.isAutogeneratedAudioAllowed();
  }

  getInteractionId(): string | null {
    if (this.getInteraction()) {
      return this.getInteraction().id;
    }
    return null;
  }

  isTerminal(): boolean {
    let interactionId = this.getInteractionId();
    return (
      interactionId &amp;&amp; INTERACTION_SPECS[interactionId].is_terminal);
  }

  getHints(): Hint[] {
    return this.getInteraction().hints;
  }

  getSolution(): Solution {
    return this.getInteraction().solution;
  }

  doesInteractionSupportHints(): boolean {
    let interactionId = this.getInteractionId();
    return (
      !INTERACTION_SPECS[interactionId].is_terminal &amp;&amp;
        !INTERACTION_SPECS[interactionId].is_linear);
  }

  isCompleted(): boolean {
    return this._completed;
  }

  markAsCompleted(): void {
    this._completed = true;
  }

  markAsNotCompleted(): void {
    this._completed = false;
  }

  getInteractionInstructions(): string {
    let interactionId = this.getInteractionId();
    return (
        interactionId ? INTERACTION_SPECS[interactionId].instructions : &#x27;&#x27;);
  }

  getInteractionCustomizationArgs(): InteractionCustomizationArgs {
    let interaction = this.getInteraction();
    if (!interaction) {
      return null;
    }
    return interaction.customizationArgs;
  }

  isInteractionInline(): boolean {
    let interactionId = this.getInteractionId();
    return (
      !interactionId ||
        INTERACTION_SPECS[interactionId].display_mode ===
        AppConstants.INTERACTION_DISPLAY_MODE_INLINE);
  }

  getContentHtml(): string {
    return this._contentHtml;
  }

  getInteractionHtml(): string {
    return this._interactionHtml;
  }

  getOppiaResponse(index: number): string {
    return this._inputResponsePairs[index].oppiaResponse;
  }

  getInputResponsePairs(): InputResponsePair[] {
    return this._inputResponsePairs;
  }

  getLastInputResponsePair(): InputResponsePair {
    if (this._inputResponsePairs.length === 0) {
      return null;
    }
    return this._inputResponsePairs[this._inputResponsePairs.length - 1];
  }

  getLastAnswer(): string {
    if (this.getLastInputResponsePair() === null) {
      return null;
    }
    return this.getLastInputResponsePair().learnerInput;
  }

  getLastOppiaResponse(): string {
    if (this.getLastInputResponsePair() === null) {
      return null;
    }
    return this.getLastInputResponsePair().oppiaResponse;
  }

  addInputResponsePair(inputResponsePair: InputResponsePair): void {
    this._inputResponsePairs.push(cloneDeep(inputResponsePair));
  }

  setLastOppiaResponse(response: string): void {
    // This check is added here to ensure that this._inputReponsePairs is
    // accessed only if there is atleast one input response pair present.
    // In the editor preview tab if a user clicks on restart from beginning
    // option just after submitting an answer for a card while the response
    // is still loading, this function is called after
    // this._inputResponsePairs is set to null as we are starting from the
    // first card again. Adding a check here makes sure that element at index
    // -1 is not accessed even in the above case.
    if (this._inputResponsePairs.length &gt;= 1) {
      this._inputResponsePairs[
        this._inputResponsePairs.length - 1].oppiaResponse = response;
    }
  }

  setInteractionHtml(interactionHtml: string): void {
    this._interactionHtml = interactionHtml;
  }

  get writtenTranslations(): WrittenTranslations {
    return cloneDeep(this._writtenTranslations);
  }

  get contentHtml(): string {
    return this._contentHtml;
  }

  set contentHtml(html: string) {
    this._contentHtml = html;
  }

  get contentId(): string {
    return this._contentId;
  }
}

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class StateCardObjectFactory {
  constructor(
    private audioTranslationLanguageService: AudioTranslationLanguageService) {}

  /**
   * @param {string} stateName - The state name for the current card.
   * @param {string} contentHtml - The HTML string for the content displayed
   *        on the content card.
   * @param {string} interactionHtml - The HTML that calls the interaction
   *        directive for the current card.
   * @param {Interaction} interaction - An interaction object that stores all
   *        the properties of the card&#x27;s interaction.
   * @param {RecordedVoiceovers} recordedVoiceovers
   * @param {string} contentId
   */
  createNewCard(
      stateName: string, contentHtml: string, interactionHtml: string,
      interaction: Interaction, recordedVoiceovers: RecordedVoiceovers,
      writtenTranslations: WrittenTranslations, contentId: string): StateCard {
    return new StateCard(
      stateName, contentHtml, interactionHtml,
      cloneDeep(interaction), [],
      recordedVoiceovers, writtenTranslations, contentId,
      this.audioTranslationLanguageService);
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;StateCardObjectFactory&#x27;,
  downgradeInjectable(StateCardObjectFactory));
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:54 GMT</p>
    </body>
  </html>
  