
  <!DOCTYPE html>
  <html>
    <head>
      <title>StateObjectFactory.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">core/templates/domain/state/StateObjectFactory.ts</td><td class="">100.00%</td><td class="">100%</td><td class="">314</td><td class="">314</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2015 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Factory for creating new frontend instances of State
 * domain objects.
 */
import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;

import { InteractionBackendDict, Interaction, InteractionObjectFactory } from
  &#x27;domain/exploration/InteractionObjectFactory&#x27;;
import { ParamChangeBackendDict, ParamChange } from
  &#x27;domain/exploration/ParamChangeObjectFactory&#x27;;
import { ParamChangesObjectFactory } from
  &#x27;domain/exploration/ParamChangesObjectFactory&#x27;;
import {
  RecordedVoiceOverBackendDict,
  RecordedVoiceovers
} from &#x27;domain/exploration/recorded-voiceovers.model&#x27;;
import {
  SubtitledHtmlBackendDict,
  SubtitledHtml
} from &#x27;domain/exploration/subtitled-html.model&#x27;;
import {
  WrittenTranslationsBackendDict,
  WrittenTranslations,
  WrittenTranslationsObjectFactory
} from &#x27;domain/exploration/WrittenTranslationsObjectFactory&#x27;;

import INTERACTION_SPECS from &#x27;interactions/interaction_specs.json&#x27;;
import constants from &#x27;assets/constants&#x27;;
import { AppConstants } from &#x27;app.constants&#x27;;

export interface StateBackendDict {
  &#x27;classifier_model_id&#x27;: string;
  &#x27;content&#x27;: SubtitledHtmlBackendDict;
  &#x27;interaction&#x27;: InteractionBackendDict;
  &#x27;param_changes&#x27;: readonly ParamChangeBackendDict[];
  &#x27;recorded_voiceovers&#x27;: RecordedVoiceOverBackendDict;
  &#x27;solicit_answer_details&#x27;: boolean;
  &#x27;card_is_checkpoint&#x27;: boolean;
  &#x27;written_translations&#x27;: WrittenTranslationsBackendDict;
  &#x27;linked_skill_id&#x27;: string;
  &#x27;next_content_id_index&#x27;: number;
}

export class State {
  name: string;
  classifierModelId: string;
  linkedSkillId: string;
  content: SubtitledHtml;
  interaction: Interaction;
  paramChanges: ParamChange[];
  recordedVoiceovers: RecordedVoiceovers;
  solicitAnswerDetails: boolean;
  cardIsCheckpoint: boolean;
  writtenTranslations: WrittenTranslations;
  nextContentIdIndex: number;
  constructor(
      name: string, classifierModelId: string, linkedSkillId: string,
      content: SubtitledHtml, interaction: Interaction,
      paramChanges: ParamChange[], recordedVoiceovers: RecordedVoiceovers,
      solicitAnswerDetails: boolean, cardIsCheckpoint: boolean,
      writtenTranslations: WrittenTranslations, nextContentIdIndex: number) {
    this.name = name;
    this.classifierModelId = classifierModelId;
    this.linkedSkillId = linkedSkillId;
    this.content = content;
    this.interaction = interaction;
    this.paramChanges = paramChanges;
    this.recordedVoiceovers = recordedVoiceovers;
    this.solicitAnswerDetails = solicitAnswerDetails;
    this.cardIsCheckpoint = cardIsCheckpoint;
    this.writtenTranslations = writtenTranslations;
    this.nextContentIdIndex = nextContentIdIndex;
  }
  setName(newName: string): void {
    this.name = newName;
  }

  toBackendDict(): StateBackendDict {
    return {
      content: this.content.toBackendDict(),
      classifier_model_id: this.classifierModelId,
      linked_skill_id: this.linkedSkillId,
      interaction: this.interaction.toBackendDict(),
      param_changes: this.paramChanges.map((paramChange) =&gt; {
        return paramChange.toBackendDict();
      }),
      recorded_voiceovers: this.recordedVoiceovers.toBackendDict(),
      solicit_answer_details: this.solicitAnswerDetails,
      card_is_checkpoint: this.cardIsCheckpoint,
      written_translations: this.writtenTranslations.toBackendDict(),
      next_content_id_index: this.nextContentIdIndex
    };
  }

  copy(otherState: State): void {
    this.name = otherState.name;
    this.classifierModelId = otherState.classifierModelId;
    this.content = otherState.content;
    this.interaction.copy(otherState.interaction);
    this.paramChanges = otherState.paramChanges;
    this.recordedVoiceovers = otherState.recordedVoiceovers;
    this.solicitAnswerDetails = otherState.solicitAnswerDetails;
    this.cardIsCheckpoint = otherState.cardIsCheckpoint;
    this.writtenTranslations = otherState.writtenTranslations;
    this.nextContentIdIndex = otherState.nextContentIdIndex;
  }

  getRequiredWrittenTranslationContentIds(): Set&lt;string&gt; {
    let interactionId = this.interaction.id;

    let allContentIds = new Set(this.writtenTranslations.getAllContentIds());

    // As of now we do not delete interaction.hints when a user deletes
    // interaction, so these hints&#x27; written translations are not counted in
    // checking status of a state.
    if (!interactionId ||
      INTERACTION_SPECS[interactionId].is_linear ||
      INTERACTION_SPECS[interactionId].is_terminal) {
      allContentIds.forEach(contentId =&gt; {
        if (contentId.indexOf(AppConstants.COMPONENT_NAME_HINT) === 0) {
          allContentIds.delete(contentId);
        }
      });
      // Excluding default_outcome content status as default outcome&#x27;s
      // content is left empty so the translation or voiceover is not
      // required.
      allContentIds.delete(&#x27;default_outcome&#x27;);
    }

    return allContentIds;
  }
}

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class StateObjectFactory {
  constructor(
    private interactionObject: InteractionObjectFactory,
    private paramchangesObject: ParamChangesObjectFactory,
    private writtenTranslationsObject: WrittenTranslationsObjectFactory) {}

  get NEW_STATE_TEMPLATE(): StateBackendDict {
    return constants.NEW_STATE_TEMPLATE;
  }

  createDefaultState(newStateName: string): State {
    var newStateTemplate = this.NEW_STATE_TEMPLATE;
    var newState = this.createFromBackendDict(newStateName, {
      classifier_model_id: newStateTemplate.classifier_model_id,
      linked_skill_id: newStateTemplate.linked_skill_id,
      content: newStateTemplate.content,
      interaction: newStateTemplate.interaction,
      param_changes: newStateTemplate.param_changes,
      recorded_voiceovers: newStateTemplate.recorded_voiceovers,
      solicit_answer_details: newStateTemplate.solicit_answer_details,
      card_is_checkpoint: newStateTemplate.card_is_checkpoint,
      written_translations: newStateTemplate.written_translations,
      next_content_id_index: newStateTemplate.next_content_id_index
    });
    newState.interaction.defaultOutcome.dest = newStateName;
    return newState;
  }

  createFromBackendDict(
      stateName: string, stateDict: StateBackendDict): State {
    return new State(
      stateName,
      stateDict.classifier_model_id,
      stateDict.linked_skill_id,
      SubtitledHtml.createFromBackendDict(stateDict.content),
      this.interactionObject.createFromBackendDict(stateDict.interaction),
      this.paramchangesObject.createFromBackendList(
        stateDict.param_changes),
      RecordedVoiceovers.createFromBackendDict(
        stateDict.recorded_voiceovers),
      stateDict.solicit_answer_details,
      stateDict.card_is_checkpoint,
      this.writtenTranslationsObject.createFromBackendDict(
        stateDict.written_translations),
      stateDict.next_content_id_index);
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;StateObjectFactory&#x27;,
  downgradeInjectable(StateObjectFactory));
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:54 GMT</p>
    </body>
  </html>
  