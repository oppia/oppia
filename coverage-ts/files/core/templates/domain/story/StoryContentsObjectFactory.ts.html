
  <!DOCTYPE html>
  <html>
    <head>
      <title>StoryContentsObjectFactory.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="negative"><td class="">core/templates/domain/story/StoryContentsObjectFactory.ts</td><td class="">99.62%</td><td class="">100%</td><td class="">522</td><td class="">520</td><td class="">2</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Factory for creating and mutating instances of frontend
 * story contents domain objects.
 */

import { downgradeInjectable } from &#x27;@angular/upgrade/static&#x27;;
import { Injectable } from &#x27;@angular/core&#x27;;

import { StoryEditorPageConstants } from
  &#x27;pages/story-editor-page/story-editor-page.constants&#x27;;
import { StoryNodeBackendDict, StoryNode } from
  &#x27;domain/story/story-node.model&#x27;;

export interface StoryContentsBackendDict {
  &#x27;initial_node_id&#x27;: string;
  &#x27;next_node_id&#x27;: string;
  &#x27;nodes&#x27;: StoryNodeBackendDict[];
}

interface NodeTitles {
  [title: string]: string
}

export class StoryContents {
  // When the Story contains a single node and it needs to be deleted
  // then the value &#x27;_initialNodeId&#x27; needs to be changed to null.
  // See &#x27;deleteNode&#x27; function below in this file for more details.
  _initialNodeId: string | null;
  _nodes: StoryNode[];
  _nextNodeId: string;
  constructor(
      initialNodeId: string, nodes: StoryNode[], nextNodeId: string) {
    this._initialNodeId = initialNodeId;
    this._nodes = nodes;
    this._nextNodeId = nextNodeId;
  }

  getIncrementedNodeId(nodeId: string): string {
    var index = parseInt(
      nodeId.replace(StoryEditorPageConstants.NODE_ID_PREFIX, &#x27;&#x27;));
    ++index;
    return StoryEditorPageConstants.NODE_ID_PREFIX + index;
  }

  getInitialNodeId(): string | null {
    return this._initialNodeId;
  }

  getLinearNodesList(): StoryNode[] {
    return this._nodes.slice();
  }

  getNextNodeId(): string {
    return this._nextNodeId;
  }

  getNodes(): StoryNode[] {
    return this._nodes;
  }

  rearrangeNodeInStory(fromIndex: number, toIndex: number): void {
    const nodeToMove: StoryNode = this._nodes[fromIndex];
    this._nodes.splice(fromIndex, 1);
    this._nodes.splice(toIndex, 0, nodeToMove);
  }

  getNodeIdsToTitleMap(nodeIds: string[]): {} {
    var nodes = this._nodes;
    var nodeTitles: NodeTitles = {};
    for (var i = 0; i &lt; nodes.length; i++) {
      if (nodeIds.indexOf(nodes[i].getId()) !== -1) {
        nodeTitles[nodes[i].getId()] = nodes[i].getTitle();
      }
    }
    if (Object.keys(nodeTitles).length !== nodeIds.length) {
      for (var i = 0; i &lt; nodeIds.length; i++) {
        if (!nodeTitles.hasOwnProperty(nodeIds[i])) {
          throw new Error(&#x27;The node with id &#x27; + nodeIds[i] + &#x27; is invalid&#x27;);
        }
      }
    }
    return nodeTitles;
  }

  getNodeIds(): string[] {
    return this._nodes.map((node: StoryNode) =&gt; {
      return node.getId();
    });
  }

  getNodeIndex(nodeId: string): number {
    for (var i = 0; i &lt; this._nodes.length; i++) {
      if (this._nodes[i].getId() === nodeId) {
        return i;
      }
    }
    return -1;
  }

  validate(): string[] {
    var issues: string[] = [];
    var nodes = this._nodes;
    for (var i = 0; i &lt; nodes.length; i++) {
      var nodeIssues = nodes[i].validate();
      issues = issues.concat(nodeIssues);
    }
    if (issues.length &gt; 0) {
      return issues;
    }

    // Provided the nodes list is valid and each node in it is valid, the
    // preliminary checks are done to see if the story node graph obtained is
    // valid.
    var nodeIds = nodes.map((node: StoryNode) =&gt; {
      return node.getId();
    });
    for (var i = 0; i &lt; nodeIds.length; i++) {
      var nodeId = nodeIds[i];
      if (nodeIds.indexOf(nodeId) &lt; nodeIds.lastIndexOf(nodeId)) {
        throw new Error(
          &#x27;The node with id &#x27; + nodeId + &#x27; is duplicated in the story&#x27;);
      }
    }
    var nextNodeIdNumber = parseInt(
      this._nextNodeId.replace(StoryEditorPageConstants.NODE_ID_PREFIX, &#x27;&#x27;));
    var initialNodeIsPresent = false;
    for (var i = 0; i &lt; nodes.length; i++) {
      var nodeIdNumber = parseInt(
        nodes[i].getId().replace(StoryEditorPageConstants.NODE_ID_PREFIX, &#x27;&#x27;));
      if (nodes[i].getId() === this._initialNodeId) {
        initialNodeIsPresent = true;
      }
      if (nodeIdNumber &gt; nextNodeIdNumber) {
        throw new Error(
          &#x27;Node id out of bounds for node with id &#x27; + nodes[i].getId());
      }
      for (var j = 0; j &lt; nodes[i].getDestinationNodeIds().length; j++) {
        if (nodeIds.indexOf(nodes[i].getDestinationNodeIds()[j]) === -1) {
          issues.push(
            &#x27;The node with id &#x27; + nodes[i].getDestinationNodeIds()[j] +
            &#x27; doesn\&#x27;t exist&#x27;);
        }
      }
    }
    if (nodes.length &gt; 0) {
      if (!initialNodeIsPresent) {
        throw new Error(
          &#x27;Initial node - &#x27; + this._initialNodeId +
          &#x27; - is not present in the story&#x27;);
      }
    }
    return issues;
  }

  setInitialNodeId(nodeId: string): void {
    if (this.getNodeIndex(nodeId) === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._initialNodeId = nodeId;
  }

  addNode(title: string): void {
    this._nodes.push(
      StoryNode.createFromIdAndTitle(
        this._nextNodeId, title));
    if (this._initialNodeId === null) {
      this._initialNodeId = this._nextNodeId;
    }
    this._nextNodeId = this.getIncrementedNodeId(this._nextNodeId);
  }

  deleteNode(nodeId: string): void {
    if (this.getNodeIndex(nodeId) === -1) {
      throw new Error(&#x27;The node does not exist&#x27;);
    }
    if (nodeId === this._initialNodeId) {
      if (this._nodes.length === 1) {
        this._initialNodeId = null;
      } else {
        throw new Error(&#x27;Cannot delete initial story node&#x27;);
      }
    }
    for (var i = 0; i &lt; this._nodes.length; i++) {
      if (this._nodes[i].getDestinationNodeIds().indexOf(nodeId) !== -1) {
        this._nodes[i].removeDestinationNodeId(nodeId);
      }
    }
    this._nodes.splice(this.getNodeIndex(nodeId), 1);
  }

  setNodeOutline(nodeId: string, outline: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].setOutline(outline);
  }

  setNodeTitle(nodeId: string, title: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].setTitle(title);
  }

  setNodeDescription(nodeId: string, description: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].setDescription(description);
  }

  setNodeExplorationId(nodeId: string, explorationId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    } else {
      if (explorationId !== null) {
        for (var i = 0; i &lt; this._nodes.length; i++) {
          if ((this._nodes[i].getExplorationId() === explorationId) &amp;&amp; (
            i !== index)) {
            throw new Error(
              &#x27;The given exploration already exists in the story.&#x27;);
          }
        }
      }
      this._nodes[index].setExplorationId(explorationId);
    }
  }

  markNodeOutlineAsFinalized(nodeId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].markOutlineAsFinalized();
  }

  markNodeOutlineAsNotFinalized(nodeId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].markOutlineAsNotFinalized();
  }

  addPrerequisiteSkillIdToNode(nodeId: string, skillId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].addPrerequisiteSkillId(skillId);
  }

  removePrerequisiteSkillIdFromNode(nodeId: string, skillId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].removePrerequisiteSkillId(skillId);
  }

  addAcquiredSkillIdToNode(nodeId: string, skillId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].addAcquiredSkillId(skillId);
  }

  removeAcquiredSkillIdFromNode(nodeId: string, skillId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].removeAcquiredSkillId(skillId);
  }

  addDestinationNodeIdToNode(nodeId: string, destinationNodeId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    if (this.getNodeIndex(destinationNodeId) === -1) {
      throw new Error(&#x27;The destination node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].addDestinationNodeId(destinationNodeId);
  }

  removeDestinationNodeIdFromNode(
      nodeId: string, destinationNodeId: string): void {
    var index = this.getNodeIndex(nodeId);
    if (index === -1) {
      throw new Error(&#x27;The node with given id doesn\&#x27;t exist&#x27;);
    }
    this._nodes[index].removeDestinationNodeId(destinationNodeId);
  }
}

@Injectable({
  providedIn: &#x27;root&#x27;
})
export class StoryContentsObjectFactory {
  constructor() {}
  createFromBackendDict(
      storyContentsBackendObject: StoryContentsBackendDict): StoryContents {
    var nodes = [];
    for (var i = 0; i &lt; storyContentsBackendObject.nodes.length; i++) {
      nodes.push(
        StoryNode.createFromBackendDict(
          storyContentsBackendObject.nodes[i]));
    }
    return new StoryContents(
      storyContentsBackendObject.initial_node_id, nodes,
      storyContentsBackendObject.next_node_id);
  }
}

angular.module(&#x27;oppia&#x27;).factory(
  &#x27;StoryContentsObjectFactory&#x27;,
  downgradeInjectable(StoryContentsObjectFactory));
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;core/templates/domain/story/StoryContentsObjectFactory.ts&quot;,&quot;line&quot;:322,&quot;character&quot;:8,&quot;text&quot;:&quot;nodes&quot;,&quot;kind&quot;:2},{&quot;file&quot;:&quot;core/templates/domain/story/StoryContentsObjectFactory.ts&quot;,&quot;line&quot;:324,&quot;character&quot;:6,&quot;text&quot;:&quot;nodes&quot;,&quot;kind&quot;:2}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 17 Jun 2021 20:43:55 GMT</p>
    </body>
  </html>
  