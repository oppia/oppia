# coding: utf-8
#
# Copyright 2021 The Oppia Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utilities for running Apache Beam tests."""

from __future__ import absolute_import  # pylint: disable=import-only-modules
from __future__ import unicode_literals  # pylint: disable=import-only-modules

import ast
import datetime
import re

from core.tests import test_utils
from jobs import base_jobs
from jobs import job_options
from jobs.io import stub_io
import python_utils

from apache_beam import runners
from apache_beam.testing import test_pipeline
from apache_beam.testing import util as beam_testing_util
import contextlib2


class PipelinedTestBase(test_utils.TestBase):
    """Base class that runs tests within the context of a TestPipeline."""

    # Helpful constants used by tests to create models.
    NOW = datetime.datetime.utcnow()
    YEAR_AGO = NOW - datetime.timedelta(weeks=52)
    YEAR_LATER = NOW + datetime.timedelta(weeks=52)

    def __init__(self, *args, **kwargs):
        super(PipelinedTestBase, self).__init__(*args, **kwargs)
        self.pipeline = test_pipeline.TestPipeline(
            runner=runners.DirectRunner(),
            options=test_pipeline.PipelineOptions(runtime_type_check=True))

    def setUp(self):
        super(PipelinedTestBase, self).setUp()
        with contextlib2.ExitStack() as stack:
            stack.enter_context(decorate_beam_errors())
            stack.enter_context(self.pipeline)
            self._close_stack = stack.pop_all().close

    def tearDown(self):
        """Hook method for deconstructing the test fixture after testing it.

        Raises:
            AssertionError. The pipeline wrapping the test fixture has failed.
        """
        # NOTE: Important to call super().tearDown() first so that all classes
        # can clean up before trying to close the pipeline, which may raise.
        # Normally tearDown() should call super() after it has finished its job.
        super(PipelinedTestBase, self).tearDown()
        # Now it's safe to try and close the pipeline.
        self._close_stack()

    def assert_pcoll_equal(self, actual, expected):
        """Asserts that the given PCollections are equal.

        NOTE: This method doesn't raise the exception. It attaches a PTransform
        to the "actual" PCollection which raises when the pipeline closes.

        Args:
            actual: PCollection. The PCollection generated by the test.
            expected: PCollection. A PCollection with the expected values.
        """
        beam_testing_util.assert_that(
            actual, beam_testing_util.equal_to(expected))

    def assert_pcoll_empty(self, actual):
        """Asserts that the given PCollection is empty.

        NOTE: This method doesn't raise the exception. It attaches a PTransform
        to the "actual" PCollection which raises when the pipeline closes.

        Args:
            actual: PCollection. The PCollection generated by the test.
        """
        beam_testing_util.assert_that(
            actual, beam_testing_util.is_empty())

    def new_model(self, model_type, **properties):
        """Helper method for creating valid models with common default values.

        Args:
            model_type: type(*). Any subclass of BaseModel.
            **properties: dict(str: *). Properties to assign to the model. By
                default, this method will try to fill the required properties
                with default values.

        Returns:
            *. A new instance of the given model type.
        """
        property_values = {
            p._name: p._default for p in model_type._properties.values() # pylint: disable=protected-access
            if p._required # pylint: disable=protected-access
        }
        property_values['created_on'] = self.YEAR_AGO
        property_values['last_updated'] = self.YEAR_AGO
        property_values.update(properties)
        return model_type(**property_values)


class JobTestBase(PipelinedTestBase):
    """Base class with helpful methods for testing Oppia's jobs.

    Subclasses must add the class constant JOB_CLASS to use the helper methods.
    """

    JOB_CLASS = base_jobs.JobBase # NOTE: run() raises a NotImplementedError.

    def __init__(self, *args, **kwargs):
        super(JobTestBase, self).__init__(*args, **kwargs)
        self.model_io_stub = stub_io.ModelIoStub()
        self.pipeline.options.view_as(job_options.JobOptions).model_getter = (
            self.model_io_stub.get_models)

    def tearDown(self):
        self.model_io_stub.clear()
        super(JobTestBase, self).tearDown()

    def run_job(self):
        """Runs a new instance of self.JOB_CLASS and returns its output.

        Test authors should override this method if their jobs need arguments
        for their run() method, for example:

            class FooJob(JobBase):
                def run(self, model_kind):
                    pass

        Should override this method to provide a value for `model_kind`.

        Returns:
            PCollection. The output of the job.
        """
        return self.JOB_CLASS(self.pipeline).run()

    def assert_job_output_is(self, expected):
        """Asserts the output of self.JOB_CLASS matches the given PCollection.

        Args:
            expected: PCollection. A PCollection with the expected values.
        """
        self.assert_pcoll_equal(self.run_job(), expected)

    def assert_job_output_is_empty(self):
        """Asserts that the output of self.JOB_CLASS is an empty PCollection."""
        self.assert_pcoll_empty(self.run_job())


@contextlib2.contextmanager
def decorate_beam_errors():
    """Context manager to improve the readability of beam_testing_util errors.

    The beam_testing_util module raises exceptions with a single string of
    repr()'d lists as the message. The items end up appearing on one long line,
    making it difficult to read when the elements of the lists are very long
    (which they tend to be especially for Oppia's audit errors).

    This context manager tries to split the list elements into lines, so that
    it's easier to read which errors occurred and why. If it cannot parse the
    message successfully, it will raise the same message.

    Yields:
        None. Nothing.

    Raises:
        AssertionError. The decorated exception.
    """
    try:
        yield
    except beam_testing_util.BeamAssertException as exception:
        msg = python_utils.UNICODE(exception)
        match = (
            re.match(
                r'.*'
                r', unexpected elements (?P<unexpected>.*)'
                r', missing elements (?P<missing>.*)'
                r' \[(?P<context>while running .*)\]',
                msg)
            or re.match(
                r'.*'
                r', unexpected elements (?P<unexpected>.*)'
                r' \[(?P<context>while running .*)\]',
                msg)
            or re.match(
                r'.*'
                r', missing elements (?P<missing>.*)'
                r' \[(?P<context>while running .*)\]',
                msg)
            or re.match(
                r'.*'
                r'\[\] == (?P<unexpected>.*)'
                r' \[(?P<context>while running .*)\]',
                msg)
        )

        if match:
            groupdict = match.groupdict()
        else:
            raise AssertionError(msg)

        unexpected = groupdict.get('unexpected', None)
        try:
            unexpected = ast.literal_eval(unexpected) if unexpected else None
        except (SyntaxError, ValueError):
            raise AssertionError(msg)

        missing = groupdict.get('missing', None)
        try:
            missing = ast.literal_eval(missing) if missing else None
        except (SyntaxError, ValueError):
            raise AssertionError(msg)

        error_lines = [
            'failed %s' % match.group('context'),
            '',
        ]
        if unexpected:
            error_lines.append('Unexpected:')
            error_lines.extend('    %r' % item for item in unexpected)
        if unexpected and missing:
            error_lines.append('')
        if missing:
            error_lines.append('Missing:')
            error_lines.extend('    %r' % item for item in missing)
        error_lines.append('')
        raise AssertionError('\n'.join(error_lines))
